<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[OpenCV学习开发笔记(iOS9)]]></title>
      <url>%2F2016%2F12%2F29%2FOpenCVLearning%2F</url>
      <content type="text"><![CDATA[本文章采用的的开发环境为：1）Xcode 8.22）OpenCV for iOS 3.2 前言最近公司项目进入了较为稳定的维护周期，考虑到后面很可能会进行需要生物特征识别的项目，提前学习下OpenCV，也在此和大家分享一下。 OpenCV介绍OpenCV ，是一个开源的跨平台计算机视觉和机器学习库，通俗点的说，就是他给计算机提供了一双眼睛，一双可以从图片中获取信息的眼镜，从而完成人脸识别、去红眼、追踪移动物体等等的图像相关的功能。更多具体的说明可参见 OpenCV 官网。 导入工程首先下载从官网OpenCV官网下载的iOS支持库，我们新建一个工程。 导入 OpenCV 到 Xcode 的工程中还是比较简单的，从官网下载对应的 framework，直接丢到 Xcode 的工程中，从xcode7以后拖入的工程会自动添加到Building phase里面，检查一下。 然后在你想用 OpenCV 的地方引入 OpenCV 的头文件： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#import &lt;opencv2/opencv.hpp&gt;``` 或者直接在 PCH 文件中添加： ```objc#ifdef __cplusplus#import &lt;opencv2/opencv.hpp&gt;#endif``` &lt;!-- more --&gt;*关于这个宏下面会有解释说明*然后把使用到 OpenCV 中 C++方法的实现文件后缀名改成.mm，就可以开始使用 OpenCV 的方法了。看起来很简单，然而实际操作中还是有不少的问题。# 实际使用由于OpenCV代码是基于C++编写的，因此，要在项目中运行c++代码，需要将实现文件名后缀由`.m`改成`.mm`，如下图所示。![](http://oiu3ghos7.bkt.clouddn.com/14829787278230.jpg)再次强调一次使用opencv的类名一定要改成.mm!说了那么多先测试一下吧!```objc#import &lt;opencv2/opencv.hpp&gt;#import &lt;opencv2/imgproc/types_c.h&gt;#import &lt;opencv2/imgcodecs/ios.h&gt;#import "ViewController.h"@interface ViewController ()&#123; cv::Mat cvImage;&#125;@property (weak, nonatomic) IBOutlet UIImageView *imgView;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; UIImage *image = [UIImage imageNamed:@"learn.jpg"]; UIImageToMat(image, cvImage); if(!cvImage.empty())&#123; cv::Mat gray; // 将图像转换为灰度显示 cv::cvtColor(cvImage,gray,CV_RGB2GRAY); // 应用高斯滤波器去除小的边缘 cv::GaussianBlur(gray, gray, cv::Size(5,5), 1.2,1.2); // 计算与画布边缘 cv::Mat edges; cv::Canny(gray, edges, 0, 50); // 使用白色填充 cvImage.setTo(cv::Scalar::all(225)); // 修改边缘颜色 cvImage.setTo(cv::Scalar(0,128,255,255),edges); // 将Mat转换为Xcode的UIImageView显示 self.imgView.image = MatToUIImage(cvImage); &#125;&#125;@end 原图 运行在模拟器上的效果 遇到问题这是第一次导入C++的库进工程中，所以还是摸索了一段时间。 第一次编译的时候遇到一个问题，编译器报了个警告是123#if defined(NO)# warning Detected Apple &apos;NO&apos; macro definition, it can cause build conflicts. Please, include this header before any Apple headers.#endif 按照提示说明，OpenCV的头文件应该在所有APPLE的头文件之前导入，不然会抛出异常，把import调到最前面即可。 为何在 PCH 文件中引入 OpenCV 的头文件我们需要多加#ifdef __cpluseplus这一部分呢？这是因为 PCH 文件是一个会被所有的文件引入的头文件，而我们又希望 #import &lt;opencv2/opencv.hpp&gt;这部分只会被一些 C++实现文件编译，所以我们加上#ifdef __cpluseplus来表示这是 C++ 文件才会编译的，除了#ifdef __cpluseplus，还有#ifdef __OBJC__这样的宏来说明编译规则（按照 OC 文件编译），这样的宏多出现于一些会被多种类型的实现文件引用的头文件中。 另外注意另一个问题：如果一个头文件是C++类型的头文件，那么一定要保证所有直接或者间接引用这个头文件的实现文件都要为.mm或者.cpp，否则 Xcode 就不会把这个头文件当做 C++头文件来编译，就会出现最基本的#include &lt;iostream&gt;这种引用都会报出file not found这样的编译错误的问题。我在编译的过程中，某个C++头文件 A.h 被 B.h 引用，然后 B.h 又被 C.m 引用，虽然 B 的实现文件是 B.mm ，但是仍然报出了之前说的那个错误感谢 StackOberflow 让我找到了问题发生的原因。所以对于 C++ 头文件的引用一定要注意，但凡是引用了 A.h 的实现部分，都必须是.mm或者.cpp后缀名。（同时我们也可以知道，Xcode 是根据头文件被引用的情况来判定头文件的编译 类型的）。 转换UIImage和cv::Mat在 OpenCV 中同常用 cv::Mat 表示图片，而 iOS 中则是 UIImage 来表示图片，但openCV的官方教程已经给出了方法。 UIImage to cv::Mat12345678910111213141516171819202122 - (cv::Mat)cvMatFromUIImage:(UIImage *)image&#123; CGColorSpaceRef colorSpace = CGImageGetColorSpace(image.CGImage); CGFloat cols = image.size.width; CGFloat rows = image.size.height; cv::Mat cvMat(rows, cols, CV_8UC4); // 8 bits per component, 4 channels (color channels + alpha) CGContextRef contextRef = CGBitmapContextCreate(cvMat.data, // Pointer to data cols, // Width of bitmap rows, // Height of bitmap 8, // Bits per component cvMat.step[0], // Bytes per row colorSpace, // Colorspace kCGImageAlphaNoneSkipLast | kCGBitmapByteOrderDefault); // Bitmap info flags CGContextDrawImage(contextRef, CGRectMake(0, 0, cols, rows), image.CGImage); CGContextRelease(contextRef); return cvMat;&#125; cv::Mat to UIImage123456789101112131415161718192021222324252627282930313233343536-(UIImage *)UIImageFromCVMat:(cv::Mat)cvMat&#123; NSData *data = [NSData dataWithBytes:cvMat.data length:cvMat.elemSize()*cvMat.total()]; CGColorSpaceRef colorSpace; if (cvMat.elemSize() == 1) &#123;//可以根据这个决定使用哪种 colorSpace = CGColorSpaceCreateDeviceGray(); &#125; else &#123; colorSpace = CGColorSpaceCreateDeviceRGB(); &#125; CGDataProviderRef provider = CGDataProviderCreateWithCFData((__bridge CFDataRef)data); // Creating CGImage from cv::Mat CGImageRef imageRef = CGImageCreate(cvMat.cols, //width cvMat.rows, //height 8, //bits per component 8 * cvMat.elemSize(), //bits per pixel cvMat.step[0], //bytesPerRow colorSpace, //colorspace kCGImageAlphaNone|kCGBitmapByteOrderDefault,// bitmap info provider, //CGDataProviderRef NULL, //decode false, //should interpolate kCGRenderingIntentDefault //intent ); // Getting UIImage from CGImage UIImage *finalImage = [UIImage imageWithCGImage:imageRef]; CGImageRelease(imageRef); CGDataProviderRelease(provider); CGColorSpaceRelease(colorSpace); return finalImage; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS开发 之 运动GPS采样处理]]></title>
      <url>%2F2016%2F09%2F23%2Fioskai-fa-zhi-yun-dong-gpscai-yang-chu-li-2%2F</url>
      <content type="text"><![CDATA[iOS提供了获取位置信息的类，CLLocationManager。通过它，我们可以轻松得到包含位置信息的对象CLLocation。 但正常情况下在运动中，会不断得到CLLocation，而其中很多点都是无效的。如果不去掉，将导致里程，速度，配速等一系列数据误差非常大。 查询了一下资料，国内这一块的资料的确比较少，这里我针对常见的误差情况，用最简单明了的方法，教你判断无效的GPS点。 一、静止不动上一个GPS点的瞬时速度为零，当前点的瞬时速度也为0,那么当前点无效.瞬时速度就是CLLocation对象的属性speed。 二、GPS信号太差信号是CLLocation的属性horizontalAccuracy，表示水平方向的误差值。当这个值大于70，我们认为信号太差。 三、无效移动前后两个GPS点的距离，小于horizontalAccuracy * (0.5~0.66)，我们认为这个点是无效移动。 四、平均速度过大如果当前点到上一个点的距离 / 当前点到上一个点的时间速度大于某一个值，则认为当前点无效比如跑步，博尔特最快是10.44m/s 五、采样频率如果不想GPS点过于密集，可以用时间限制。如果当前点的时间到上一个点事件小于2s，则认为点无效。另外也可以用位置管理器的distanceFilter属性来设置。当distanceFilter = 30的时候，只有超过30m的移动，才会进入到位置更新的回调方法。这样做的好处是设备可以更加省电，CPU的占用更低，根据实际情况而定。 总结了几种常见gps点的过滤方法，希望对大家有帮助。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[响应者链条传递事件]]></title>
      <url>%2F2016%2F09%2F12%2Fxiang-ying-zhe-lian-tiao-chuan-di-shi-jian%2F</url>
      <content type="text"><![CDATA[开篇先说点废话吧，最近整个人都很烦躁，也许跟天气有关吧，也很久没有静下来写一些东西了，最近也一直忙着新项目，也很纠接新项目应该采用什么样的结构去写才好迭代、维护。最终按自己的一写想法采用了Controller View ViewHander的模式（有点类似MVVM），因为这个Demo按照这个想法来写的所以这里简单说下，就不过多的讨论这个了，回到主题上UIResponder来，没有说之前我们先看一个图我们开发中经常遇到的： 很简单就是在UITableViewCell 放了一个UIButton 那我们怎么样接收这个Button的点击事件? 你第一时间可能会想到Delegate,Block？的确它们都可以实现我们的需求，Delegate我们要多写点代码，Block 如果我们的事件逻辑复杂点就会再赋值时写很多代码，当然你可以用一个简单的Block把处理的业务代封装成方法，再这个调用这方法，也可以把代码弄的简洁点，最重要我一定要考虑循环引用的问题。那我们能不能用UIResponder 传递这个事件呢，在我们想要的地方捕获这个事件呢? 我们先来看看iOS 事件是怎么传递的我们看个图： 如上图，iOS中事件传递首先从App(UIApplication)开始，接着传递到Window(UIWindow)，在接着往下传递到View之前，Window会将事件交给GestureRecognizer，如果在此期间，GestureRecognizer识别了传递过来的事件，则该事件将不会继续传递到View去，而是像我们之前说的那样交给Target(ViewController)进行处理。（注：详细原理可以自己进行搜索学习）我们大致知道事件产生最先识别是的 AppDelegate，然后一层层往下找看事件发生那个view上，直到找个这个view,然后看个view 能不能响应这个事件。那我们现在再说说响应者链先看个张图： 我知道了当事触摸事件发生，通过一层层找到的这个View ,找到这个View 后先判断这个view能不能响应这个事件，如果不能那就继续找nextResponder我们看上面图可以看出如果一个View有SuperView 那么这个View的nextResponder 就是他的SuperView，如果没有SuperView 那么它的nextResponder 就是他所在ViewController 然后就这样一直找下去，直到找到或抛出异常。我们了解这机制后那我们怎么把这个UIButton Click 事件传递出来呢，我们先来给UIResponder 添加一个我们自定义的事件，我就让它传递我们这个事件出去。 12345678#import &quot;UIResponder+Router.h&quot;@implementation UIResponder (Router) // eventName 只是作个标记，当我们需要在一个页面传递个事件时我们可以进区分，userInfo 为了省劲就没有封装，你可以针对性再封装下- (void)routerEventWithName:(NSString *)eventName userInfo:(NSDictionary *)userInfo &#123; [[self nextResponder] routerEventWithName:eventName userInfo:userInfo]; &#125; @end 那我们怎么进行传递呢，那就是我们手动的去让响应者链传递这个事件我们先看下工程的代码文件：View 12345678910111213141516171819202122232425#import &quot;TestView.h&quot;#import &quot;TestViewTableDataSource.h&quot;@implementation TestView &#123; UITableView *_tableView;&#125; - (instancetype)initWithController:(SBBaseViewController *)controller &#123; self = [super initWithController:controller]; if (self) &#123; [self setup]; &#125; return self; &#125; - (void)setup &#123; _tableView = [[UITableView alloc] initWithFrame:CGRectZero style:UITableViewStylePlain]; _tableView.delegate = self; _tableView.rowHeight = 60; _tableView.translatesAutoresizingMaskIntoConstraints = NO; [_tableView registerClass:[TestViewTableCell class] forCellReuseIdentifier:@&quot;cell&quot;]; [self addSubview:_tableView]; [self addConstraints:[NSLayoutConstraint constraintsWithVisualFormat:@&quot;H:|-0-[_tableView]-0-|&quot; options:0 metrics:nil views:NSDictionaryOfVariableBindings(_tableView)]]; [self addConstraints:[NSLayoutConstraint constraintsWithVisualFormat:@&quot;V:|-0-[_tableView]-0-|&quot; options:0 metrics:nil views:NSDictionaryOfVariableBindings(_tableView)]]; } 123456789101112- (void)setHandler:(SBBaseHandler *)handler &#123; [super setHandler:handler]; // 把tableViewDataSource 分离出去 TestViewTableDataSource *tableViewDataSoure = [[TestViewTableDataSource alloc] initWithTableView:_tableView]; _tableView.dataSource = tableViewDataSoure; self.handler.tableDataSource = tableViewDataSoure;&#125;- (void)didLoad &#123; [self.handler loadData];&#125; Controller 1234567891011121314151617181920212223242526272829#import &quot;TestViewController.h&quot;#import &quot;TestView.h&quot;#import &quot;TestViewHandler.h&quot;@interface TestViewController ()@end@implementation TestViewController- (void)loadView &#123; [super loadView]; TestView *view = [[TestView alloc]initWithController:self]; TestViewHandler *handler = [[TestViewHandler alloc] init]; view.handler = handler; self.view = view;&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view. self.title = @&quot;UIResponderEx&quot;;&#125;- (void)didReceiveMemoryWarning &#123; [super didReceiveMemoryWarning]; // Dispose of any resources that can be recreated. &#125;@end Handler 12345678910111213#import &quot;TestViewHandler.h&quot;@implementation TestViewHandler- (void)loadData &#123; NSMutableArray *datasource = [NSMutableArray arrayWithCapacity:10]; for (int i = 0; i&lt; 10; ++i) &#123; [datasource addObject:[NSString stringWithFormat:@&quot;Row number is %d&quot;,i]]; &#125; self.tableDataSource.dataSouce = [datasource copy];&#125;@end TableDataSource 123456789#import &quot;SBBaseTableDataSource.h&quot;@interface TestViewTableDataSource : SBBaseTableDataSource@end// 这里为了省劲就没有用单独文件去写，最好还是建两个新文件去比较好@interface TestViewTableCell : UITableViewCell@end 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#import &quot;TestViewTableDataSource.h&quot;#import &quot;UIResponder+Router.h&quot;@implementation TestViewTableDataSource- (id)initWithTableView:(UITableView *)tableView &#123; self = [super initWithTableView:tableView]; if (self) &#123; &#125; return self;&#125; - (void)setDataSouce:(NSArray *)dataSouce &#123; [super setDataSouce:dataSouce]; [self.tableView reloadData];&#125;- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView &#123; return 1;&#125;- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section &#123; return self.dataSouce.count;&#125;- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123; TestViewTableCell *cell = [tableView dequeueReusableCellWithIdentifier:@&quot;cell&quot;]; cell.textLabel.text = self.dataSouce[indexPath.row]; return cell;&#125;@end@implementation TestViewTableCell- (instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier &#123; self = [super initWithStyle:style reuseIdentifier:reuseIdentifier]; if (self) &#123; [self setup]; &#125; return self;&#125;- (void)setup &#123; UIButton *showNumberButton = [UIButton buttonWithType:UIButtonTypeCustom]; [showNumberButton setTitle:@&quot;Show row number&quot; forState:UIControlStateNormal]; showNumberButton.backgroundColor = [UIColor purpleColor]; showNumberButton.layer.cornerRadius = 4; showNumberButton.layer.masksToBounds = YES; showNumberButton.translatesAutoresizingMaskIntoConstraints = NO; [showNumberButton addTarget:self action:@selector(showNumberButtonClick:) forControlEvents:UIControlEventTouchUpInside]; [self.contentView addSubview:showNumberButton]; [self.contentView addConstraints:[NSLayoutConstraint constraintsWithVisualFormat:@&quot;H:[showNumberButton(180)]-20-|&quot; options:0 metrics:nil views:NSDictionaryOfVariableBindings(showNumberButton)]]; [self.contentView addConstraint:[NSLayoutConstraint constraintWithItem:showNumberButton attribute:NSLayoutAttributeCenterY relatedBy:NSLayoutRelationEqual toItem:self.contentView attribute:NSLayoutAttributeCenterY multiplier:1.0 constant:0]];&#125; //关键代码就在这里, 我们在button click 事件中我再让传递一个事件给响应者链，让响应者链传出去- (void)showNumberButtonClick:(id)sender &#123; // 我们在这个Click事件中去手动让响应者传递一个事件 [self.nextResponder routerEventWithName:@&quot;showNumber&quot; userInfo:@&#123;@&quot;object&quot;:self.textLabel.text&#125;];&#125;@end 主要的代码差不多就是这些了，至于他们的基类都是自己封装好一部分，还不怎么完善都是一些自己的想法。就不贴代码稍后把这个Demo放出来。有兴趣的可以下下来看看，如果有我好的想法请联系我：lsb332@163.com我们先来看看在View 中捕获下事件，在.m 文件我们导入UIResponder+Router.h头文件 然后实现我们自定义的方法 123456#import &quot;UIResponder+Router.h&quot;#pragma UIResponder(Router)- (void)routerEventWithName:(NSString *)eventName userInfo:(NSDictionary *)userInfo &#123; UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:@&quot;View中捕获&quot; message:userInfo[@&quot;object&quot;] delegate:nil cancelButtonTitle:@&quot;OK&quot; otherButtonTitles: nil]; [alertView show];&#125; 手动传递事件的代码TableDataSource 已经贴出来过了这里就不贴了我们看下结果： 我们再来看看在UIViewController 捕获，代码就不贴了看下结果好了: 总结最重要的思想就是在响应事件方法我们再主动的传递给响应者链一个事件，然后我们合适的地方去响应这个事件这个也是抛砖引玉的，自己理解的还很肤浅的，现在写出来也算是自己学习的一个笔记吧，这个处理方法也是自己在集成环信中发现的，自己去摸索学习下。Demo地址 https://github.com/lsb332/UIResponderEX在这里再说一下自己项目结构，为了减轻UIViewController 重量实行真正的MVC 把View分出来了，从而使ViewController 只负责view 的显示 ，称除等。因为我们项目经常会用到TableView 为了不使View太重再次把这个分离去，使TableView的dataSource 在TableViewSource文件中去实现，然后又给View 建了一个Handler 用来处理业务逻辑，网络请求等，然后又把handler 继承一个网络求的类，这样可就可以处理的网络的请求了，如果handler 处理完数据后可以通过Block 回调给View 或者直接把数据传递给TableViewSource 就可以直接刷新数据，不用再回调给View。这里只是简单的说一下，有兴趣的可以工程里看看，还处在起步结段，如果觉得成熟了再写一篇文章说说吧。 文／lsb332（简书作者）原文链接：http://www.jianshu.com/p/8fef9171c322]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Git 分支 - 变基]]></title>
      <url>%2F2016%2F09%2F10%2Fgit-fen-zhi-bian-ji%2F</url>
      <content type="text"><![CDATA[变基在 Git 中整合来自不同分支的修改主要有两种方法：merge 以及 rebase。 在本节中我们将学习什么是“变基”，怎样使用“变基”，并将展示该操作的惊艳之处，以及指出在何种情况下你应避免使用它。 变基的基本操作请回顾之前在 分支的合并 中的一个例子，你会看到开发任务分叉到两个不同分支，又各自提交了更新。 Figure 3-27. 分叉的提交历史 之前介绍过，整合分支最容易的方法是 merge 命令。 它会把两个分支的最新快照（C3 和 C4）以及二者最近的共同祖先（C2）进行三方合并，合并的结果是生成一个新的快照（并提交）。 Figure 3-28. 通过合并操作来整合分叉了的历史 其实，还有一种方法：你可以提取在 C4 中引入的补丁和修改，然后在 C3 的基础上再应用一次。 在 Git 中，这种操作就叫做 变基。 你可以使用 rebase 命令将提交到某一分支上的所有修改都移至另一分支上，就好像“重新播放”一样。 在上面这个例子中，运行： 1234$ git checkout experiment$ git rebase masterFirst, rewinding head to replay your work on top of it...Applying: added staged command 它的原理是首先找到这两个分支（即当前分支 experiment、变基操作的目标基底分支 master）的最近共同祖先 C2，然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件，然后将当前分支指向目标基底 C3, 最后以此将之前另存为临时文件的修改依序应用。（译注：写明了 commit id，以便理解，下同） Figure 3-29. 将 C4 中的修改变基到 C3 上 现在回到 master 分支，进行一次快进合并。 12$ git checkout master$ git merge experiment Figure 3-30. master 分支的快进合并 此时，C4&#39; 指向的快照就和上面使用 merge 命令的例子中 C5 指向的快照一模一样了。 这两种整合方法的最终结果没有任何区别，但是变基使得提交历史更加整洁。 你在查看一个经过变基的分支的历史记录时会发现，尽管实际的开发工作是并行的，但它们看上去就像是先后串行的一样，提交历史是一条直线没有分叉。 一般我们这样做的目的是为了确保在向远程分支推送时能保持提交历史的整洁——例如向某个别人维护的项目贡献代码时。 在这种情况下，你首先在自己的分支里进行开发，当开发完成时你需要先将你的代码变基到 origin/master 上，然后再向主项目提交修改。 这样的话，该项目的维护者就不再需要进行整合工作，只需要快进合并便可。 请注意，无论是通过变基，还是通过三方合并，整合的最终结果所指向的快照始终是一样的，只不过提交历史不同罢了。 变基是将一系列提交按照原有次序依次应用到另一分支上，而合并是把最终结果合在一起。 更有趣的变基例子在对两个分支进行变基时，所生成的“重演”并不一定要在目标分支上应用，你也可以指定另外的一个分支进行应用。 就像 Figure 3-31 中的例子这样。 你创建了一个特性分支 server，为服务端添加了一些功能，提交了 C3 和 C4。 然后从 C3 上创建了特性分支 client，为客户端添加了一些功能，提交了 C8 和C9。 最后，你回到 server 分支，又提交了 C10。 Figure 3-31. 从一个特性分支里再分出一个特性分支的提交历史 假设你希望将 client 中的修改合并到主分支并发布，但暂时并不想合并 server 中的修改，因为它们还需要经过更全面的测试。 这时，你就可以使用 git rebase 命令的 --onto 选项，选中在 client 分支里但不在 server 分支里的修改（即 C8 和 C9），将它们在 master 分支上重演： 1$ git rebase --onto master server client 以上命令的意思是：“取出 client 分支，找出处于 client 分支和 server 分支的共同祖先之后的修改，然后把它们在 master 分支上重演一遍”。 这理解起来有一点复杂，不过效果非常酷。 Figure 3-32. 截取特性分支上的另一个特性分支，然后变基到其他分支 现在可以快进合并 master 分支了。（如图 Figure 3-33）： 12$ git checkout master$ git merge client Figure 3-33. 快进合并 master 分支，使之包含来自 client 分支的修改 接下来你决定将 server 分支中的修改也整合进来。 使用 git rebase [basebranch] [topicbranch] 命令可以直接将特性分支（即本例中的 server）变基到目标分支（即 master）上。这样做能省去你先切换到 server 分支，再对其执行变基命令的多个步骤。 1$ git rebase master server 如图 Figure 3-34 所示，server 中的代码被“续”到了 master 后面。 Figure 3-34. 将 server 中的修改变基到 master 上 然后就可以快进合并主分支 master 了： 12$ git checkout master$ git merge server 至此，client 和 server 分支中的修改都已经整合到主分支里去了，你可以删除这两个分支，最终提交历史会变成图 Figure 3-35 中的样子： 12$ git branch -d client$ git branch -d server Figure 3-35. 最终的提交历史 变基的风险呃，奇妙的变基也并非完美无缺，要用它得遵守一条准则： 不要对在你的仓库外有副本的分支执行变基。 如果你遵循这条金科玉律，就不会出差错。 否则，人民群众会仇恨你，你的朋友和家人也会嘲笑你，唾弃你。 变基操作的实质是丢弃一些现有的提交，然后相应地新建一些内容一样但实际上不同的提交。 如果你已经将提交推送至某个仓库，而其他人也已经从该仓库拉取提交并进行了后续工作，此时，如果你用 git rebase 命令重新整理了提交并再次推送，你的同伴因此将不得不再次将他们手头的工作与你的提交进行整合，如果接下来你还要拉取并整合他们修改过的提交，事情就会变得一团糟。 让我们来看一个在公开的仓库上执行变基操作所带来的问题。 假设你从一个中央服务器克隆然后在它的基础上进行了一些开发。 你的提交历史如图所示： Figure 3-36. 克隆一个仓库，然后在它的基础上进行了一些开发 然后，某人又向中央服务器提交了一些修改，其中还包括一次合并。 你抓取了这些在远程分支上的修改，并将其合并到你本地的开发分支，然后你的提交历史就会变成这样： Figure 3-37. 抓取别人的提交，合并到自己的开发分支 接下来，这个人又决定把合并操作回滚，改用变基；继而又用 git push --force 命令覆盖了服务器上的提交历史。 之后你从服务器抓取更新，会发现多出来一些新的提交。 Figure 3-38. 有人推送了经过变基的提交，并丢弃了你的本地开发所基于的一些提交 结果就是你们两人的处境都十分尴尬。 如果你执行 git pull 命令，你将合并来自两条提交历史的内容，生成一个新的合并提交，最终仓库会如图所示： Figure 3-39. 你将相同的内容又合并了一次，生成了一个新的提交 此时如果你执行 git log 命令，你会发现有两个提交的作者、日期、日志居然是一样的，这会令人感到混乱。 此外，如果你将这一堆又推送到服务器上，你实际上是将那些已经被变基抛弃的提交又找了回来，这会令人感到更加混乱。 很明显对方并不想在提交历史中看到 C4 和 C6，因为之前就是他们把这两个提交通过变基丢弃的。 用变基解决变基如果你 真的 遭遇了类似的处境，Git 还有一些高级魔法可以帮到你。 如果团队中的某人强制推送并覆盖了一些你所基于的提交，你需要做的就是检查你做了哪些修改，以及他们覆盖了哪些修改。 实际上，Git 除了对整个提交计算 SHA-1 校验和以外，也对本次提交所引入的修改计算了校验和—— 即 “patch-id”。 如果你拉取被覆盖过的更新并将你手头的工作基于此进行变基的话，一般情况下 Git 都能成功分辨出哪些是你的修改，并把它们应用到新分支上。 举个例子，如果遇到前面提到的 Figure 3-38 那种情境，如果我们不是执行合并，而是执行 git rebase teamone/master, Git 将会： 检查哪些提交是我们的分支上独有的（C2，C3，C4，C6，C7） 检查其中哪些提交不是合并操作的结果（C2，C3，C4） 检查哪些提交在对方覆盖更新时并没有被纳入目标分支（只有 C2 和 C3，因为 C4 其实就是 C4’） 把查到的这些提交应用在 teamone/master 上面 从而我们将得到与 Figure 3-39 中不同的结果，如图 Figure 3-40 所示。 Figure 3-40. 在一个被变基然后强制推送的分支上再次执行变基 要想上述方案有效，还需要对方在变基时确保 C4’ 和 C4 是几乎一样的。 否则变基操作将无法识别，并新建另一个类似 C4 的补丁（而这个补丁很可能无法整洁的整合入历史，因为补丁中的修改已经存在于某个地方了）。 在本例中另一种简单的方法是使用 git pull --rebase 命令而不是直接 git pull。 又或者你可以自己手动完成这个过程，先 git fetch，再 git rebase teamone/master。 如果你习惯使用 git pull ，同时又希望默认使用选项 --rebase，你可以执行这条语句 git config --global pull.rebase true 来更改 pull.rebase 的默认配置。 只要你把变基命令当作是在推送前清理提交使之整洁的工具，并且只在从未推送至共用仓库的提交上执行变基命令，你就不会有事。 假如你在那些已经被推送至共用仓库的提交上执行变基命令，并因此丢弃了一些别人的开发所基于的提交，那你就有大麻烦了，你的同事也会因此鄙视你。 如果你或你的同事在某些情形下决意要这么做，请一定要通知每个人执行 git pull --rebase 命令，这样尽管不能避免伤痛，但能有所缓解。 变基 vs. 合并至此，你已在实战中学习了变基和合并的用法，你一定会想问，到底哪种方式更好。 在回答这个问题之前，让我们退后一步，想讨论一下提交历史到底意味着什么。 有一种观点认为，仓库的提交历史即是 记录实际发生过什么。 它是针对历史的文档，本身就有价值，不能乱改。 从这个角度看来，改变提交历史是一种亵渎，你使用谎言掩盖了实际发生过的事情。 如果由合并产生的提交历史是一团糟怎么办？ 既然事实就是如此，那么这些痕迹就应该被保留下来，让后人能够查阅。 另一种观点则正好相反，他们认为提交历史是 项目过程中发生的故事。 没人会出版一本书的第一批草稿，软件维护手册也是需要反复修订才能方便使用。 持这一观点的人会使用 rebase 及 filter-branch 等工具来编写故事，怎么方便后来的读者就怎么写。 现在，让我们回到之前的问题上来，到底合并还是变基好？希望你能明白，并没有一个简单的答案。 Git 是一个非常强大的工具，它允许你对提交历史做许多事情，但每个团队、每个项目对此的需求并不相同。 既然你已经分别学习了两者的用法，相信你能够根据实际情况作出明智的选择。 总的原则是，只对尚未推送或分享给别人的本地修改执行变基操作清理历史，从不对已推送至别处的提交执行变基操作，这样，你才能享受到两种方式带来的便利。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[willMoveToSuperView导致观察者无法释放bug]]></title>
      <url>%2F2016%2F09%2F10%2Fwillmovetosuperviewdao-zhi-guan-cha-zhe-wu-fa-shi-fang-bug%2F</url>
      <content type="text"><![CDATA[(void)willMoveToSuperview 默认不做任何事情；当接收者父视图将要改变的时候回来到该方法，其中newSuperview是将要被添加的视图，该参数可以为new，子类可以重写这方法来作为特定的实现。最近在开发公司项目的过程中，遇到了一个比较棘手的bug。同事在构造一个modal出来的Controller中，用到了某个三方库其中有用到KVO去监听某个属性的值。而且也在dealloc里面对观察者进行了销毁。 但在点击关闭按钮销毁该界面的时候，程序先回到父控制器窗口，然后crash。查了许久原因未果。 通过断点调试和查看函数调用栈发现observeValueForKeyPath:这个方法一共来了两次进一步调试发现是- (void)willMoveToSuperview:(UIView *)newSuperview这个方法调用了两次，而增加观察者方法就写在其中。两次调用的时间分别是View视图将要显示前，和将要销毁前。 查阅资料得知newSuperview可以为nil，也就是modal视图销毁时这个方法会进行第二次调用，即把视图添加到为nill的View上。 进而在方法内部做了对参数的校验，解决问题。 不过把观察者写在view里面始终是野路子，把逻辑操作都写在controller中才是正途。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[比特币及区块链]]></title>
      <url>%2F2016%2F09%2F09%2Fbi-te-bi-ji-qu-kuai-lian%2F</url>
      <content type="text"><![CDATA[####Bitcoin是什么 ####一分钟了解比特币 ####NHK纪录片《比特币最前线》中英字幕版 ####Bitcoin是什么]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Xib加载的几种方法]]></title>
      <url>%2F2016%2F08%2F13%2Fxibjia-zai-de-ji-chong-fang-fa%2F</url>
      <content type="text"><![CDATA[一，本质 xib本质是XML代码（在编译时Xcode将xib中内容转换成代码） 注：如果一个view是从xib中加载出来的，默认width与height是xib中描述的尺寸，frame中(x,y)值默认为零 二、控制器中加载xib 加载方式一： 12NSArray *newsArr = [[NSBundle mainBundle] loadNibNamed:@&quot;news&quot; owner:nil options:nil];UIView *newsView = newsArr.firstObject; 注：“loadNibNamed:owner:options” 方法返回值是一个NSArray，因为一个xib中可以放多个view，但一般情况我们都只放一个在xib中 加载方式二： 12UINib *nib = [UINib nibWithNibName:@&quot;news&quot; bundle:[NSBundle mainBundle]];//[NSBundle mainBundle]作为参数时，可以传nil，切记[NSBundle mainBundle]调用其他方法时不可以为nil，用nil调用方法等于什么操作都没做UIView *news = [[nib instantiateWithOwner:nil options:nil] firstObject]; 三、使用xib加载view的注意事项 1，如果一个view是从xib加载出来的，那么xib绑定的View初始化过程中，不会执行init方法和initWithFrame方法，因此在页面中如果通过 alloc init 来初始化该view，界面会是空白2，如果多个页面中用到该view，最好在xib绑定的类中提供快速创建的类方法 1234+ (instancetype)viewForXib&#123; return [[[NSBundle mainBundle] loadNibNamed:NSStringFromClass(self) owner:nil options:nil] firstObject];&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS加密的基本介绍]]></title>
      <url>%2F2016%2F08%2F08%2Fiosjia-mi-de-ji-ben-jie-shao%2F</url>
      <content type="text"><![CDATA[安全隐患：在iOS开发过程中，尽管在发送数据的过程中，密码进行了“二进制”的转换，但实际上密码还是明文，可以通过一些拦截软件被拦截（青花瓷等等），不能保证我们数据的安全性。 加密选择：一般公司都会有一套自己的加密方案，按照公司接口文档的规定去加密 平常用到的解决办法： 1.Base64加密 Base64加密因其算法和充当密钥的索引表都是公开的，所以不属于加密算法，它的本质是将“二进制”数据转换成字符串，方便使用HTTP协议、用于公开的代码加密、URL加密，防止数据明文传输。 例如：有的网络请求上，会希望只传递字符串 1.URL中的参数，直接带上图片的传输 2.银联的网络接口，把整个消费凭据生成一个数据格式，然后进行Base64的编码，编码完成后传给服务器 特点：编码完成后的结果，只有64个字符。 转换方法： 1.将每三个字节分成一组，一共24个二进制位：3*8=24 2.将这24个二进制位分成4组，每组有6个二进制位：24/4=6 3.在每组前加两00，扩展成32个二进制位，即4个字节：4*(6+2)=32 4.根据Base64索引表就可得到对应的符号值。 Base64索引表 下面来看看它的具体转换过程： 加密的具体过程图 苹果在iOS7之后自带Base64加密，具体方法如下： 2.MD5加密 MD5即Message-Digest Algorithm 5（信息-摘要算法5），用于确保信息传输完整一致。是计算机广泛使用的杂凑算法之一（又译摘要算法、哈希算法），主流编程语言普遍已有MD5实现。作用是让大容量信息在用数字签名软件签署私人密钥前被”压缩”成一种保密的格式（就是把一个任意长度的字节串变换成一定长的十六进制数字串）。 MD5加密对输入信息生成唯一的128位散列值（32个字符），声称是不可逆的，但是目前可以通过以下网站解密MD5解密网站 ，主要运用在数字签名、文件完整性验证以及口令加密等方面。 先来看看基本的加密算法实现过程： 不过在平常的开发中我们一般都会用到第三方：例如 Security 的NSString+Hash.h 等等，主要原因稍后会介绍。 基本使用方法： 因为MD5生成的简单字符串会到目前会被轻易的破解，所以我们需要对其进行改进。 1.*加盐（Salt）*：在明文的固定位置插入随机串，然后再进行MD5 注：加的盐必须足够长，足够保密或者可以计入时间戳 如果还不行的话可以使用辅助手段 IP记录 手机短信记录 操作异常或者比较敏感的操作等手法。 2.*HMAC+MD5*：HMAC本来就是一种加密算法，再加上MD5，算得上双重保障 Security第三方有此方法 3.先加密，后乱序：先对明文进行MD5，然后对加密得到的MD5串的字符进行乱序，总之宗旨就是：黑客就算攻破了数据库，也无法解密出正确的明文 使用MD5的好处：快速校验 3. 对于重要数据，使用RSA进行数字签名，起到防篡改作用4 .对于比较敏感的数据，如用户信息（登陆、注册等），客户端发送使用RSA加密，服务器返回使用DES(AES)加密原因：客户端发送之所以使用RSA加密，是因为RSA解密需要知道服务器私钥，而服务器私钥一般盗取难度较大； 5.钥匙串（keychain）iOS 7.0.3版本后加入，使用256位AES加密 keychain Services：（iOS密钥链服务）提供了针对用户设备上的密码、密钥、证书、笔记和自定义数据的安全存储解决方案。保存的信息不会因App被删除而丢失，在用户重新安装App后依然有效，数据还在，是目前在设备中保存关键数据的唯一安全的地方。 那么，如何在应用里使用keychain呢？ 我们需要导入Security.framework ，keychain的操作接口声明在头文件SecItem.h里，直接使用SecItem.h里方法操作keychain，需要写的代码较为复杂，我们可以使用已经封装好了的工具类KeychainItemWrapper来对keychain进行操作。KeychainItemWrapper是apple官方例子“GenericKeychain”里一个访问keychain常用操作的封装类，在官网上下载了GenericKeychain项目后，只需要把“KeychainItemWrapper.h”和“KeychainItemWrapper.m”拷贝到我们项目，并导入Security.framework 。同时需要设置ARC（-fno-objc-arc）。 我们来看看使用方法： 保存数据 取出数据 其他具体的使用方法，自己看API。 第三方封装的有SSKeychain，使用方法更为简便。 6.Cookie（小甜饼）由服务器生成，发送给客户端，将cookie的key/value保存到某个目录的文本文件内。 最典型的应用是判定注册用户是否已经登录，另一个重要的应用场合是“购物车”。 简单使用方法： 原文链接：http://www.jianshu.com/p/2beffa24e889]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[升级Ruby配置CocoaPods安装]]></title>
      <url>%2F2016%2F08%2F07%2Fjie-jue-cocoapodan-zhuang-rubyban-ben-di-de-wen-ti%2F</url>
      <content type="text"><![CDATA[这两天全新安装了系统，安装cocoapods时出现： activesupport requires Ruby version &gt;= 2.2.2 检查下发现淘宝源的ruby版本是2.0.0，于是使用RVM更新了下Ruby。 1、安装 RVMRVM:Ruby Version Manager,Ruby版本管理器，包括Ruby的版本管理和Gem库管理(gemset) curl -L get.rvm.io | bash -s stable 等待一段时间后就可以成功安装好 RVM。 source ~/.bashrc source ~/.bash_profile 测试是否安装正常 rvm -v 2、用RVM升级Ruby12345678910查看当前ruby版本 ruby -v 列出已知的ruby版本 rvm list known &lt;!------MORE-------&gt;安装ruby 2.2.2 rvm install 2.2.2 安装完成之后ruby -v查看是否安装成功。终端输出123kidteaing-macmini:~ GeXiaodong$ ruby -vruby 2.2.2p95 (2015-04-13 revision 50295) [x86_64-darwin14] 到此已经完成ruby的升级]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PC端获取IPA包的方法]]></title>
      <url>%2F2016%2F08%2F07%2Fpcduan-huo-qu-ipabao-de-fang-fa%2F</url>
      <content type="text"><![CDATA[IPA包的下载流程 使用iTunes软件 登入自己的苹果账号 找到应用界面 选中AppStore 搜索要下载的应用 已购买应用显示下载，未购买应用显示购买 点击下载或购买后，会下载IPA包 下载完成后，会看到已下载标志 点击我的应用 已经下载的应用都列出来了 点中一个包，选择在Finder中显示 所有已下载的ipa包，都在文件夹中 补充 在iTunes的设置中，也可以直接查看缓存文件夹位置 用命令行即可打开文件夹 open /Users/mac/Music/iTunes/iTunes\ Media 应用的状态可能不止下载或购买，还可能有更新等，万变不离其宗，无论是什么状态，最终都可以下载IPA包 缓存的包如果被删除，需要重新下载。如果IPA包有更新版本，也可以在我的应用界面直接更新 如果想查看包内容，可以修改.ipa后缀名为.zip，然后解压即可]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift (?)可选类型和 (!)强制解包]]></title>
      <url>%2F2016%2F07%2F13%2Fswiftzhong-de-ke-xuan-lei-xing-he-qiang-zhi-jie-xi%2F</url>
      <content type="text"><![CDATA[很多Swift初学者在学习过程中对问号和感叹号比较迷惑，Swift中问号表示这是一个可选类型。翻译：某个常量或者变量可能是一个类型，也可能什么都没有，我不确定它是否真的会有值，也许会是nil。 比如： let number1 = “123” let number2 = number1.toInt() //number2是Int?类型 或者叫optional Int number2，可能包含Int值，也可能什么都没有（那就是nil） 当我们通过if语句判断，number2确实有值时，可以使用感叹号来表示。 翻译：我确定这个可选类型的值内有正确的内容，请使用它。 if number2 != nil { println(number2!) 感叹号，被称为可选值的强制解析（无论如何请一定要使用这个值，我保证这里面肯定有东西） 然而在使用强制解析的时候，一定要确保包中的内容确实不会为 nil，否则会报错。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS 开发路线]]></title>
      <url>%2F2016%2F07%2F12%2Fios-kai-fa-lu-xian%2F</url>
      <content type="text"><![CDATA[前言 学习iOS的人都想知道学习iOS需要学习哪些东西呢，本人搜集到github上有这么一个路径图，这里基本包含了开发中必须要掌握的一些技术知识。 查看路线详情 来源github地址iOS学习路线 此图片非本人所画，若原作者不允许使用此图，请及时告知，谢谢！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[基于 ijkplayer 的iOS视频直播推流仿写]]></title>
      <url>%2F2016%2F07%2F07%2Fosshi-pin-zhi-bo-fang%2F</url>
      <content type="text"><![CDATA[视频直播，可以分为 采集，前处理，编码，传输, 服务器处理，解码，渲染 采集: iOS系统因为软硬件种类不多, 硬件适配性比较好, 所以比较简单. 而Android端市面上机型众多, 要做些机型的适配工作.PC端是最麻烦的, 各种奇葩摄像头驱动.所以现在很多的中小型直播平台, 都放弃了PC的直播, 更有一些直播平台只做iOS端的视频直播. 前处理: 美颜算法,视频的模糊效果, 水印等都是在这个环节做. 目前iOS端最著名开源框架的毫无疑问就是GPUImage.其中内置了125种渲染效果, 还支持各种脚本自定义. 我高仿的喵播的美颜效果也是基于GPUImage的. 编码: 重难点在于要在分辨率，帧率，码率，GOP等参数设计上找到最佳平衡点。iOS8之后, Apple开放了VideoToolbox.framework, 可以直接进行硬编解码, 这也是为什么现在大多数直播平台最低只支持到iOS8的原因之一. iOS端硬件兼容性比较好, 可以直接采取硬编码. 而Android得硬编码又是一大坑. 传输: 这块一般都是交给CDN服务商. CDN只提供带宽和服务器之间的传输, 发送端和接收端的网络连接抖动缓存还是要自己实现的.目前国内最大的CDN服务商应该是网宿. 服务器处理: 需要在服务器做一些流处理工作, 让推送上来的流适配各个平台各种不同的协议, 比如:RTMP,HLS,FLV… 解码和渲染: 也就即音视频的播放. 解码毫无疑问也必须要硬解码. iOS端兼容较好, Android依然大坑.这块的难点在于音画同步, 目前很多直播平台这块是硬伤.国内比较好的开源项目应该是B站开源的ijkplayer . 斗鱼就是基于ijkplayer 的, 本项目也是基于ijkplayer 的. 技术坑 : 降噪, 音频解码器, 蓝牙适配, 回声消除, 信令控制, 登录, 鉴权, 权限管理, 状态管理, 应用消息, 消息推送, 礼物系统, 即时聊天, 支付系统, 统计系统, 数据库, 缓存, 分布式文件存储, 消息队列, 运维系统等等大小不一的坑等你来填!!! 资金坑 : 以带宽为例, 2万人同时在线, 手机码率在600KB, 每个月的带宽费用至少在30万左右. 根据欢聚时代(YY)15年四季度财务报, 他们的带宽成本为人民币1.611亿元, 折合每月5000万+. 人力成本+渠道支出和其他支出就不详谈了. 社会坑: 还得每时每刻与各种黑暗势力斗争, 包括色情, 广告, 刷小号, 刷充值, 告侵权, DDos… 前期准备项目主要是基于ijkplayer 的. 最好是打包成framework. 原本我准备写一个打包教程, 不过后来在简书上发现了一篇特别详细的打包blog, 分享给大家: http://www.jianshu.com/p/1f06b27b3ac0 Profile : 个人中心, 这里面只有一个ProfileController. 因为总写重复代码, 都写吐了, 这儿有兴趣的自己写一下吧, So easy… Network : 关于网络连接的工具类. 关于网络的实时监控, 网络状态的切换, 网络请求的工具类都在这里面. Other : 全局的常量. 当然你也可以在里面将文件结构更加细化. Home : 包含最新主播, 最热直播, 关注的直播, 礼物排行榜等模块. 还有最重要的视频直播也在这里面了. ShowTime :见名知意. 视频直播的前处理, 智能美颜和H264硬编码等都在这里面. Main : UITabBarController和UINavigationController的配置 Toos : 这儿命名有点不规范, 这里面放置的都是项目用到的分类 Login : 登录模块 Resource : 项目用到的资源文件 项目详解tip1: 判读网络类型. 在观看直播的时候, 我们通常都是用WiFi或者3/4G(土豪级别的), 一般用户在进行网络切换的时候, 我们都要给出友善的提示, 告诉TA: 您的网络状态切换到了XX状态. 假设用户从WiFi切换到4G, 你的应用也没个提醒, 导致TA的流量归零甚至欠了运营商一屁股的钱, 我想你的APP的用户体验也就归零或者为负了.我们可以使用苹果的Reachability结合下面的代码实时监听网络状态的改变123456789101112131415161718192021222324252627282930313233343536373839404142434445typedef NS_ENUM(NSUInteger, NetworkStates) &#123; NetworkStatesNone, // 没有网络 NetworkStates2G, // 2G NetworkStates3G, // 3G NetworkStates4G, // 4G NetworkStatesWIFI // WIFI&#125;;// 判断网络类型+ (NetworkStates)getNetworkStates &#123; NSArray *subviews = [[[[UIApplication sharedApplication] valueForKeyPath:@&quot;statusBar&quot;] valueForKeyPath:@&quot;foregroundView&quot;] subviews]; // 保存网络状态 NetworkStates states = NetworkStatesNone; for (id child in subviews) &#123; if ([child isKindOfClass:NSClassFromString(@&quot;UIStatusBarDataNetworkItemView&quot;)]) &#123; //获取到状态栏码 int networkType = [[child valueForKeyPath:@&quot;dataNetworkType&quot;] intValue]; switch (networkType) &#123; case 0: //无网模式 states = NetworkStatesNone; break; case 1: states = NetworkStates2G; break; case 2: states = NetworkStates3G; break; case 3: states = NetworkStates4G; break; case 5: &#123; states = NetworkStatesWIFI; &#125; break; default: break; &#125; &#125; &#125; //根据状态选择 return states; &#125; tip2: 登录模块 如果你多运行几次就会发现, 登录模块背景中播放的视频是2个视频每次随机播放一个的.并且是无限重复的, 也就是说只要你一直呆着登录界面, 就会单视频循环播放当前的视频. 这儿的登录只是几个按钮, 没有具体的登录逻辑, 随便点哪一个按钮都可以进入首页.我们需要监听视频, 是否播放完成.12345678910// 监听视频是否播放完成 [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(didFinish) name:IJKMPMoviePlayerPlaybackDidFinishNotification object:nil];如果播放完成了, 让IJKFFMoviePlayerController再次play即可- (void)didFinish &#123; // 播放完之后, 继续重播 [self.player play]; &#125; tip3: 首页 首页 这种效果相信很多人都看到过或者做过.我简单说一下我的做法(不一定是最佳的, 只是提供一个思路) 一个父控制器HomeViewController+三个子控制器(最热/最新/关注. 每个控制器各自管理自己的业务逻辑, 高内聚低耦合). 重写HomeViewController的loadView, 将self.view替换成UIScrollView. 将三个子控制器的view添加到UIScrollView上即可. 其他的效果实现, 请参照我的代码, 都有详细的中文注释.tip4: 直播(面向观众端)这个是整个项目的重点之一了.这种直播的布局, 应该是比较主流的了. 我下载的好多直播类APP都是这个项目布局, 包括YY也是这种界面布局.这个里面涉及的东西比较多了, 三言两语真说不清. 简单说一下已经实现的效果:A: 主播的直播B: 关联主播的视频直播, 默认是只有界面, 没有声音的. 点击该视图可以切换到此主播C: 下拉切换另一个主播, 这个功能是很常见的. 做法是直播控制器是一个UICollectionViewController, 只有一个cell, 且cell.frame就是self.collectionViewb.bounds. 我们进入直播控制器的时候, 其实是传进去一个关联主播数组, 每次下拉的时候, 就加载数组里面的主播D. 查看观众席的观众详情E. 查看主播详情F. 足迹: 粒子动画, 后面详解G. 弹幕: 点击最下方的工具栏第一个按钮可以开启/关闭弹幕, 后面详解…tip5: 粒子动画实现游客足迹粒子动画的layer是添加到播放器的view上面的. 下面代码有详细的注释123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172CAEmitterLayer *emitterLayer = [CAEmitterLayer layer];// 发射器在xy平面的中心位置emitterLayer.emitterPosition = CGPointMake(self.moviePlayer.view.frame.size.width-50,self.moviePlayer.view.frame.size.height-50);// 发射器的尺寸大小emitterLayer.emitterSize = CGSizeMake(20, 20);// 渲染模式emitterLayer.renderMode = kCAEmitterLayerUnordered;// 开启三维效果// _emitterLayer.preservesDepth = YES;NSMutableArray *array = [NSMutableArray array];// 创建粒子for (int i = 0; i&lt;10; i++) &#123; // 发射单元 CAEmitterCell *stepCell = [CAEmitterCell emitterCell]; // 粒子的创建速率，默认为1/s stepCell.birthRate = 1; // 粒子存活时间 stepCell.lifetime = arc4random_uniform(4) + 1; // 粒子的生存时间容差 stepCell.lifetimeRange = 1.5; // 颜色 // fire.color=[[UIColor colorWithRed:0.8 green:0.4 blue:0.2 alpha:0.1]CGColor]; UIImage *image = [UIImage imageNamed:[NSString stringWithFormat:@&quot;good%d_30x30&quot;, i]]; // 粒子显示的内容 stepCell.contents = (id)[image CGImage]; // 粒子的名字 // [fire setName:@&quot;step%d&quot;, i]; // 粒子的运动速度 stepCell.velocity = arc4random_uniform(100) + 100; // 粒子速度的容差 stepCell.velocityRange = 80; // 粒子在xy平面的发射角度 stepCell.emissionLongitude = M_PI+M_PI_2;; // 粒子发射角度的容差 stepCell.emissionRange = M_PI_2/6; // 缩放比例 stepCell.scale = 0.3; [array addObject:stepCell];&#125;emitterLayer.emitterCells = array;[self.moviePlayer.view.layer insertSublayer:emitterLayer below:self.catEarView.layer];tip6: 弹幕弹幕使用的也是一个第三方轮子BarrageRenderer . 这个开源项目的文档都是中文的, 用法也是很简单的.基本配置_renderer = [[BarrageRenderer alloc] init];// 设置弹幕的显示区域. 基于父控件的._renderer.canvasMargin = UIEdgeInsetsMake(ALinScreenHeight * 0.3, 10, 10, 10);[self.contentView addSubview:_renderer.view];弹幕配置#pragma mark - 弹幕描述符生产方法/// 生成精灵描述 - 过场文字弹幕- (BarrageDescriptor *)walkTextSpriteDescriptorWithDirection:(NSInteger)direction &#123; BarrageDescriptor * descriptor = [[BarrageDescriptor alloc]init]; descriptor.spriteName = NSStringFromClass([BarrageWalkTextSprite class]); descriptor.params[@&quot;text&quot;] = self.danMuText[arc4random_uniform((uint32_t)self.danMuText.count)]; descriptor.params[@&quot;textColor&quot;] = Color(arc4random_uniform(256), arc4random_uniform(256), arc4random_uniform(256)); descriptor.params[@&quot;speed&quot;] = @(100 * (double)random()/RAND_MAX+50); descriptor.params[@&quot;direction&quot;] = @(direction); descriptor.params[@&quot;clickAction&quot;] = ^&#123; UIAlertView *alertView = [[UIAlertView alloc]initWithTitle:@&quot;提示&quot; message:@&quot;弹幕被点击&quot; delegate:nil cancelButtonTitle:@&quot;取消&quot; otherButtonTitles:nil]; [alertView show]; &#125;; return descriptor; &#125; 最后一步, 千万要记得start[_renderer start]; tip7: 智能美颜效果现在的直播平台, 美颜是标配. 不然绝大多数的主播都是没法看的.美颜算法需要用到GPU编程, 需要懂图像处理的人. 图像处理这一块我不是很熟悉, 相关的文献也是看得云里雾里的. 所以, 依然使用开源的轮子: GPUImage . 这个开源框架有近1.3W+star(7月5日数据), 真不是盖的, 内置125种滤镜效果, 没有你想不到, 只有你不会用. 我的项目中都有详细的用法, 还是很简单的. 在这里摘抄一份其.h文件的注释. 一方面方便大家修改我项目中的美颜效果, 另一方面也是做个备份.(具体出处我真忘了, 如果有人找到了源地址链接, 可以联系我加上) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173#import &quot;GLProgram.h&quot;// Base classes#import &quot;GPUImageOpenGLESContext.h&quot;#import &quot;GPUImageOutput.h&quot;#import &quot;GPUImageView.h&quot;#import &quot;GPUImageVideoCamera.h&quot;#import &quot;GPUImageStillCamera.h&quot;#import &quot;GPUImageMovie.h&quot;#import &quot;GPUImagePicture.h&quot;#import &quot;GPUImageRawDataInput.h&quot;#import &quot;GPUImageRawDataOutput.h&quot;#import &quot;GPUImageMovieWriter.h&quot;#import &quot;GPUImageFilterPipeline.h&quot;#import &quot;GPUImageTextureOutput.h&quot;#import &quot;GPUImageFilterGroup.h&quot;#import &quot;GPUImageTextureInput.h&quot;#import &quot;GPUImageUIElement.h&quot;#import &quot;GPUImageBuffer.h&quot;// Filters#import &quot;GPUImageFilter.h&quot;#import &quot;GPUImageTwoInputFilter.h&quot;#pragma mark - 调整颜色 Handle Color#import &quot;GPUImageBrightnessFilter.h&quot; //亮度#import &quot;GPUImageExposureFilter.h&quot; //曝光#import &quot;GPUImageContrastFilter.h&quot; //对比度#import &quot;GPUImageSaturationFilter.h&quot; //饱和度#import &quot;GPUImageGammaFilter.h&quot; //伽马线#import &quot;GPUImageColorInvertFilter.h&quot; //反色#import &quot;GPUImageSepiaFilter.h&quot; //褐色（怀旧）#import &quot;GPUImageLevelsFilter.h&quot; //色阶#import &quot;GPUImageGrayscaleFilter.h&quot; //灰度#import &quot;GPUImageHistogramFilter.h&quot; //色彩直方图，显示在图片上#import &quot;GPUImageHistogramGenerator.h&quot; //色彩直方图#import &quot;GPUImageRGBFilter.h&quot; //RGB#import &quot;GPUImageToneCurveFilter.h&quot; //色调曲线#import &quot;GPUImageMonochromeFilter.h&quot; //单色#import &quot;GPUImageOpacityFilter.h&quot; //不透明度#import &quot;GPUImageHighlightShadowFilter.h&quot; //提亮阴影#import &quot;GPUImageFalseColorFilter.h&quot; //色彩替换（替换亮部和暗部色彩）#import &quot;GPUImageHueFilter.h&quot; //色度#import &quot;GPUImageChromaKeyFilter.h&quot; //色度键#import &quot;GPUImageWhiteBalanceFilter.h&quot; //白平横#import &quot;GPUImageAverageColor.h&quot; //像素平均色值#import &quot;GPUImageSolidColorGenerator.h&quot; //纯色#import &quot;GPUImageLuminosity.h&quot; //亮度平均#import &quot;GPUImageAverageLuminanceThresholdFilter.h&quot; //像素色值亮度平均，图像黑白（有类似漫画效果）#import &quot;GPUImageLookupFilter.h&quot; //lookup 色彩调整#import &quot;GPUImageAmatorkaFilter.h&quot; //Amatorka lookup#import &quot;GPUImageMissEtikateFilter.h&quot; //MissEtikate lookup#import &quot;GPUImageSoftEleganceFilter.h&quot; //SoftElegance lookup#pragma mark - 图像处理 Handle Image#import &quot;GPUImageCrosshairGenerator.h&quot; //十字#import &quot;GPUImageLineGenerator.h&quot; //线条#import &quot;GPUImageTransformFilter.h&quot; //形状变化#import &quot;GPUImageCropFilter.h&quot; //剪裁#import &quot;GPUImageSharpenFilter.h&quot; //锐化#import &quot;GPUImageUnsharpMaskFilter.h&quot; //反遮罩锐化#import &quot;GPUImageFastBlurFilter.h&quot; //模糊#import &quot;GPUImageGaussianBlurFilter.h&quot; //高斯模糊#import &quot;GPUImageGaussianSelectiveBlurFilter.h&quot; //高斯模糊，选择部分清晰#import &quot;GPUImageBoxBlurFilter.h&quot; //盒状模糊#import &quot;GPUImageTiltShiftFilter.h&quot; //条纹模糊，中间清晰，上下两端模糊#import &quot;GPUImageMedianFilter.h&quot; //中间值，有种稍微模糊边缘的效果#import &quot;GPUImageBilateralFilter.h&quot; //双边模糊#import &quot;GPUImageErosionFilter.h&quot; //侵蚀边缘模糊，变黑白#import &quot;GPUImageRGBErosionFilter.h&quot; //RGB侵蚀边缘模糊，有色彩#import &quot;GPUImageDilationFilter.h&quot; //扩展边缘模糊，变黑白#import &quot;GPUImageRGBDilationFilter.h&quot; //RGB扩展边缘模糊，有色彩#import &quot;GPUImageOpeningFilter.h&quot; //黑白色调模糊#import &quot;GPUImageRGBOpeningFilter.h&quot; //彩色模糊#import &quot;GPUImageClosingFilter.h&quot; //黑白色调模糊，暗色会被提亮#import &quot;GPUImageRGBClosingFilter.h&quot; //彩色模糊，暗色会被提亮#import &quot;GPUImageLanczosResamplingFilter.h&quot; //Lanczos重取样，模糊效果#import &quot;GPUImageNonMaximumSuppressionFilter.h&quot; //非最大抑制，只显示亮度最高的像素，其他为黑#import &quot;GPUImageThresholdedNonMaximumSuppressionFilter.h&quot; //与上相比，像素丢失更多#import &quot;GPUImageSobelEdgeDetectionFilter.h&quot; //Sobel边缘检测算法(白边，黑内容，有点漫画的反色效果)#import &quot;GPUImageCannyEdgeDetectionFilter.h&quot; //Canny边缘检测算法（比上更强烈的黑白对比度）#import &quot;GPUImageThresholdEdgeDetectionFilter.h&quot; //阈值边缘检测（效果与上差别不大）#import &quot;GPUImagePrewittEdgeDetectionFilter.h&quot; //普瑞维特(Prewitt)边缘检测(效果与Sobel差不多，貌似更平滑)#import &quot;GPUImageXYDerivativeFilter.h&quot; //XYDerivative边缘检测，画面以蓝色为主，绿色为边缘，带彩色#import &quot;GPUImageHarrisCornerDetectionFilter.h&quot; //Harris角点检测，会有绿色小十字显示在图片角点处#import &quot;GPUImageNobleCornerDetectionFilter.h&quot; //Noble角点检测，检测点更多#import &quot;GPUImageShiTomasiFeatureDetectionFilter.h&quot; //ShiTomasi角点检测，与上差别不大#import &quot;GPUImageMotionDetector.h&quot; //动作检测#import &quot;GPUImageHoughTransformLineDetector.h&quot; //线条检测#import &quot;GPUImageParallelCoordinateLineTransformFilter.h&quot; //平行线检测#import &quot;GPUImageLocalBinaryPatternFilter.h&quot; //图像黑白化，并有大量噪点#import &quot;GPUImageLowPassFilter.h&quot; //用于图像加亮#import &quot;GPUImageHighPassFilter.h&quot; //图像低于某值时显示为黑#pragma mark - 视觉效果 Visual Effect#import &quot;GPUImageSketchFilter.h&quot; //素描#import &quot;GPUImageThresholdSketchFilter.h&quot; //阀值素描，形成有噪点的素描#import &quot;GPUImageToonFilter.h&quot; //卡通效果（黑色粗线描边）#import &quot;GPUImageSmoothToonFilter.h&quot; //相比上面的效果更细腻，上面是粗旷的画风#import &quot;GPUImageKuwaharaFilter.h&quot; //桑原(Kuwahara)滤波,水粉画的模糊效果；处理时间比较长，慎用#import &quot;GPUImageMosaicFilter.h&quot; //黑白马赛克#import &quot;GPUImagePixellateFilter.h&quot; //像素化#import &quot;GPUImagePolarPixellateFilter.h&quot; //同心圆像素化#import &quot;GPUImageCrosshatchFilter.h&quot; //交叉线阴影，形成黑白网状画面#import &quot;GPUImageColorPackingFilter.h&quot; //色彩丢失，模糊（类似监控摄像效果）#import &quot;GPUImageVignetteFilter.h&quot; //晕影，形成黑色圆形边缘，突出中间图像的效果#import &quot;GPUImageSwirlFilter.h&quot; //漩涡，中间形成卷曲的画面#import &quot;GPUImageBulgeDistortionFilter.h&quot; //凸起失真，鱼眼效果#import &quot;GPUImagePinchDistortionFilter.h&quot; //收缩失真，凹面镜#import &quot;GPUImageStretchDistortionFilter.h&quot; //伸展失真，哈哈镜#import &quot;GPUImageGlassSphereFilter.h&quot; //水晶球效果#import &quot;GPUImageSphereRefractionFilter.h&quot; //球形折射，图形倒立#import &quot;GPUImagePosterizeFilter.h&quot; //色调分离，形成噪点效果#import &quot;GPUImageCGAColorspaceFilter.h&quot; //CGA色彩滤镜，形成黑、浅蓝、紫色块的画面#import &quot;GPUImagePerlinNoiseFilter.h&quot; //柏林噪点，花边噪点#import &quot;GPUImage3x3ConvolutionFilter.h&quot; //3x3卷积，高亮大色块变黑，加亮边缘、线条等#import &quot;GPUImageEmbossFilter.h&quot; //浮雕效果，带有点3d的感觉#import &quot;GPUImagePolkaDotFilter.h&quot; //像素圆点花样#import &quot;GPUImageHalftoneFilter.h&quot; //点染,图像黑白化，由黑点构成原图的大致图形#pragma mark - 混合模式 Blend#import &quot;GPUImageMultiplyBlendFilter.h&quot; //通常用于创建阴影和深度效果#import &quot;GPUImageNormalBlendFilter.h&quot; //正常#import &quot;GPUImageAlphaBlendFilter.h&quot; //透明混合,通常用于在背景上应用前景的透明度#import &quot;GPUImageDissolveBlendFilter.h&quot; //溶解#import &quot;GPUImageOverlayBlendFilter.h&quot; //叠加,通常用于创建阴影效果#import &quot;GPUImageDarkenBlendFilter.h&quot; //加深混合,通常用于重叠类型#import &quot;GPUImageLightenBlendFilter.h&quot; //减淡混合,通常用于重叠类型#import &quot;GPUImageSourceOverBlendFilter.h&quot; //源混合#import &quot;GPUImageColorBurnBlendFilter.h&quot; //色彩加深混合#import &quot;GPUImageColorDodgeBlendFilter.h&quot; //色彩减淡混合#import &quot;GPUImageScreenBlendFilter.h&quot; //屏幕包裹,通常用于创建亮点和镜头眩光#import &quot;GPUImageExclusionBlendFilter.h&quot; //排除混合#import &quot;GPUImageDifferenceBlendFilter.h&quot; //差异混合,通常用于创建更多变动的颜色#import &quot;GPUImageSubtractBlendFilter.h&quot; //差值混合,通常用于创建两个图像之间的动画变暗模糊效果#import &quot;GPUImageHardLightBlendFilter.h&quot; //强光混合,通常用于创建阴影效果#import &quot;GPUImageSoftLightBlendFilter.h&quot; //柔光混合#import &quot;GPUImageChromaKeyBlendFilter.h&quot; //色度键混合#import &quot;GPUImageMaskFilter.h&quot; //遮罩混合#import &quot;GPUImageHazeFilter.h&quot; //朦胧加暗#import &quot;GPUImageLuminanceThresholdFilter.h&quot; //亮度阈#import &quot;GPUImageAdaptiveThresholdFilter.h&quot; //自适应阈值#import &quot;GPUImageAddBlendFilter.h&quot; //通常用于创建两个图像之间的动画变亮模糊效果#import &quot;GPUImageDivideBlendFilter.h&quot; //通常用于创建两个图像之间的动画变暗模糊效果#pragma mark - 尚不清楚#import &quot;GPUImageJFAVoroniFilter.h&quot;#import &quot;GPUImageVoroniConsumerFilter.h&quot;tip8: H264硬编码如果使用ijkplayer 使用硬解码, 一句代码即可.// 开启硬解码[option setPlayerOptionValue:@&quot;1&quot; forKey:@&quot;videotoolbox&quot;]; 硬编码的应用场景: 我们要将主播的视频数据传送给服务器 通过摄像头来采集图像，然后将采集到的图像，通过硬编码的方式进行编码，最后编码后的数据将其组合成H264的码流通过网络传播。摄像头采集图像, iOS系统提供了AVCaptureSession来采集摄像头的图像数据. 项目中我是直接使用 GPUImage 中的GPUImageVideoCamera, 直接设置GPUImageVideoCamera的代理即可, 在其代理方法- (void)willOutputSampleBuffer:(CMSampleBufferRef)sampleBuffer;进行数据编码即可. 切记一点: 不管是系统自带的AVCaptureSession还是GPUImageVideoCamera采集到的数据都是未经过编码的CMSampleBuffer.然后将采集到的数据, 用iOS开放的VideoToolbox进行硬编码. 关于VideoToolbox硬编解码网上很多教程, 当然最好是看Apple的官方文档, 如果只是硬编码, 看我的项目即可. 关键的编码函数(来自YOLO直播负责人的开源项目 BeautifyFaceDemo ) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354void didCompressH264(void *outputCallbackRefCon, void *sourceFrameRefCon, OSStatus status, VTEncodeInfoFlags infoFlags, CMSampleBufferRef sampleBuffer )&#123; if (status != 0) return; // 采集的未编码数据是否准备好 if (!CMSampleBufferDataIsReady(sampleBuffer)) &#123; NSLog(@&quot;didCompressH264 data is not ready &quot;); return; &#125; ALinH264Encoder* encoder = (__bridge ALinH264Encoder*)outputCallbackRefCon; bool keyframe = !CFDictionaryContainsKey((CFArrayGetValueAtIndex(CMSampleBufferGetSampleAttachmentsArray(sampleBuffer, true), 0)), kCMSampleAttachmentKey_NotSync); if (keyframe) // 关键帧 &#123; CMFormatDescriptionRef format = CMSampleBufferGetFormatDescription(sampleBuffer); size_t sparameterSetSize, sparameterSetCount; const uint8_t *sparameterSet; OSStatus statusCode = CMVideoFormatDescriptionGetH264ParameterSetAtIndex(format, 0, &amp;sparameterSet, &amp;sparameterSetSize, &amp;sparameterSetCount, 0 ); if (statusCode == noErr) &#123; size_t pparameterSetSize, pparameterSetCount; const uint8_t *pparameterSet; OSStatus statusCode = CMVideoFormatDescriptionGetH264ParameterSetAtIndex(format, 1, &amp;pparameterSet, &amp;pparameterSetSize, &amp;pparameterSetCount, 0 ); if (statusCode == noErr) &#123; encoder-&gt;sps = [NSData dataWithBytes:sparameterSet length:sparameterSetSize]; encoder-&gt;pps = [NSData dataWithBytes:pparameterSet length:pparameterSetSize]; NSLog(@&quot;sps:%@ , pps:%@&quot;, encoder-&gt;sps, encoder-&gt;pps); &#125; &#125; &#125; CMBlockBufferRef dataBuffer = CMSampleBufferGetDataBuffer(sampleBuffer); size_t length, totalLength; char *dataPointer; OSStatus statusCodeRet = CMBlockBufferGetDataPointer(dataBuffer, 0, &amp;length, &amp;totalLength, &amp;dataPointer); if (statusCodeRet == noErr) &#123; size_t bufferOffset = 0; static const int AVCCHeaderLength = 4; while (bufferOffset &lt; totalLength - AVCCHeaderLength) &#123; uint32_t NALUnitLength = 0; memcpy(&amp;NALUnitLength, dataPointer + bufferOffset, AVCCHeaderLength); NALUnitLength = CFSwapInt32BigToHost(NALUnitLength); NSData *data = [[NSData alloc] initWithBytes:(dataPointer + bufferOffset + AVCCHeaderLength) length:NALUnitLength]; bufferOffset += AVCCHeaderLength + NALUnitLength; NSLog(@&quot;sendData--&gt;&gt; %@ %lu&quot;, data, bufferOffset); &#125; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[来自 Linkedin 的 Swift 编程风格指南]]></title>
      <url>%2F2016%2F07%2F03%2Flai-zi-linkedin-de-swift-bian-cheng-feng-ge-zhi-nan%2F</url>
      <content type="text"><![CDATA[##1. Code Formatting:代码格式化 1.1 使用4个空格来代替Tabs 1.2 避免过长的行，可以在XCode中进行设置单行最大长度：(Xcode-&gt;Preferences-&gt;Text Editing-&gt;Page guide at column: 160 is helpful for this) 1.3 保证每个文件结尾都存在一个新行 Ensure that there is a newline at the end of every file. 1.4 避免无意义的尾随空格: (Xcode-&gt;Preferences-&gt;Text Editing-&gt;Automatically trim trailing whitespace + Including whitespace-only lines). 1.5 避免将单独的左花括号放置到一行，我们参考了：1TBS style. 12345678910111213class SomeClass &#123; func someMethod() &#123; if x == y &#123; /* ... */ &#125; else if x == z &#123; /* ... */ &#125; else &#123; /* ... */ &#125; &#125; /* ... */&#125; 1.6 在写变量的类型声明、字典类型的键、函数参数、协议的声明或者父类的时候，不要在冒号前添加空格。 1234567891011121314151617181920212223242526// specifying typelet pirateViewController: PirateViewController// dictionary syntax (note that we left-align as opposed to aligning colons)let ninjaDictionary: [String: AnyObject] = [ &quot;fightLikeDairyFarmer&quot;: false, &quot;disgusting&quot;: true]// declaring a functionfunc myFunction&lt;T, U: SomeProtocol where T.RelatedType == U&gt;(firstArgument: U, secondArgument: T) &#123; /* ... */&#125;// calling a functionsomeFunction(someArgument: &quot;Kitten&quot;)// superclassesclass PirateViewController: UIViewController &#123; /* ... */&#125;// protocolsextension PirateViewController: UITableViewDataSource &#123; /* ... */&#125; 1.7 一般来说，逗号后面都要跟随一个空格。 1let myArray = [1, 2, 3, 4, 5] 1.8 在二元操作符譬如+, ==, 或者 -&gt;的前后需要加上空格，但是对于( 、`)的前后不需要加空格。 1.9 我们默认使用Xcode推荐的格式化风格(CTRL-I) ，在声明某个函数的时候会多行排布参数。 1.10 在调用多参数函数的时候，会把多个参数放置到单独的行中： 1.11 对于大型的数组或者字典类型，应该将其分割到多行内，[ 与 ]类比于花括号进行处理。对于闭包而言也应该同样适合于该规则。 1.12 尽可能地使用本地变量的方式来避免多行的判断语句。 ##2. Naming:命名 2.1 Swift中不需要再使用Objective-C那样的前缀，譬如使用 GuybrushThreepwood 而不是LIGuybrushThreepwood。 2.2 对于类型名即struct, enum, class, typedef, associatedtype等等使用 PascalCase 。 2.3 对于函数名、方法名、变量名、常量、参数名等使用camelCase。 2.4 在使用首字母缩写的时候尽可能地全部大写，并且注意保证全部代码中的统一。不过如果缩写被用于命名的起始，那么就全部小写。 12345678// &quot;HTML&quot; is at the start of a variable name, so we use lowercase &quot;html&quot;let htmlBodyContent: String = &quot;&lt;p&gt;Hello, World!&lt;/p&gt;&quot;// Prefer using ID to Idlet profileID: Int = 1// Prefer URLFinder to UrlFinderclass URLFinder &#123; /* ... */&#125; 2.5 对于静态常量使用 k 前缀 + PascalCase。 123456789101112class MyClassName &#123; // use `k` prefix for constant primitives static let kSomeConstantHeight: CGFloat = 80.0 // use `k` prefix for non-primitives as well static let kDeleteButtonColor = UIColor.redColor() // don&apos;t use `k` prefix for singletons static let sharedInstance = MyClassName() /* ... */&#125; 2.6 对于泛型或者关联类型，使用PascalCase描述泛型，如果泛型名与其他重复，那么可以添加一个Type后缀名到泛型名上。 12345678class SomeClass&lt;T&gt; &#123; /* ... */ &#125;class SomeClass&lt;Model&gt; &#123; /* ... */ &#125;protocol Modelable &#123; associatedtype Model&#125;protocol Sequence &#123; associatedtype IteratorType: Iterator&#125; 2.7 命名必须要是不模糊的并且方便表述的 12345// PREFERREDclass RoundAnimatingButton: UIButton &#123; /* ... */ &#125;// NOT PREFERREDclass CustomButton: UIButton &#123; /* ... */ &#125; 2.8 不要使用缩写，可以选择较为简短的单词。 123456789101112131415161718// PREFERREDclass RoundAnimatingButton: UIButton &#123; let animationDuration: NSTimeInterval func startAnimating() &#123; let firstSubview = subviews.first &#125;&#125;// NOT PREFERREDclass RoundAnimating: UIButton &#123; let aniDur: NSTimeInterval func srtAnmating() &#123; let v = subviews.first &#125;&#125; 2.9 对于不是很明显的类型需要将类型信息包含在属性名中。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// PREFERREDclass ConnectionTableViewCell: UITableViewCell &#123; let personImageView: UIImageView let animationDuration: NSTimeInterval // it is ok not to include string in the ivar name here because it&apos;s obvious // that it&apos;s a string from the property name let firstName: String // though not preferred, it is OK to use `Controller` instead of `ViewController` let popupController: UIViewController let popupViewController: UIViewController // when working with a subclass of `UIViewController` such as a table view // controller, collection view controller, split view controller, etc., // fully indicate the type in the name. let popupTableViewController: UITableViewController // when working with outlets, make sure to specify the outlet type in the // variable name. @IBOutlet weak var submitButton: UIButton! @IBOutlet weak var emailTextField: UITextField! @IBOutlet weak var nameLabel: UILabel!&#125;// NOT PREFERREDclass ConnectionTableViewCell: UITableViewCell &#123; // this isn&apos;t a `UIImage`, so shouldn&apos;t be called image // use personImageView instead let personImage: UIImageView // this isn&apos;t a `String`, so it should be `textLabel` let text: UILabel // `animation` is not clearly a time interval // use `animationDuration` or `animationTimeInterval` instead let animation: NSTimeInterval // this is not obviously a `String` // use `transitionText` or `transitionString` instead let transition: String // this is a view controller - not a view let popupView: UIViewController // as mentioned previously, we don&apos;t want to use abbreviations, so don&apos;t use // `VC` instead of `ViewController` let popupVC: UIViewController // even though this is still technically a `UIViewController`, this variable // should indicate that we are working with a *Table* View Controller let popupViewController: UITableViewController // for the sake of consistency, we should put the type name at the end of the // variable name and not at the start @IBOutlet weak var btnSubmit: UIButton! @IBOutlet weak var buttonSubmit: UIButton! // we should always have a type in the variable name when dealing with outlets // for example, here, we should have `firstNameLabel` instead @IBOutlet weak var firstName: UILabel!&#125; 2.10 在编写函数参数的时候，要保证每个参数都易于理解其功能。 2.11 根据 Apple’s API Design Guidelines, 对于protocol，如果其描述的是正在做的事情，譬如Collection，那么应该命名为名词。而如果是用于描述某种能力，譬如Equatable, ProgressReporting，那么应该添加 able, ible, 或者 ing 这样的后缀。如果你的协议并不符合上述两种情形，那么应该直接添加一个Protocol后缀，譬如： 123456789101112131415161718192021// here, the name is a noun that describes what the protocol doesprotocol TableViewSectionProvider &#123; func rowHeight(atRow row: Int) -&gt; CGFloat var numberOfRows: Int &#123; get &#125; /* ... */&#125;// here, the protocol is a capability, and we name it appropriatelyprotocol Loggable &#123; func logCurrentState() /* ... */&#125;// suppose we have an `InputTextView` class, but we also want a protocol// to generalize some of the functionality - it might be appropriate to// use the `Protocol` suffix hereprotocol InputTextViewProtocol &#123; func sendTrackingEvent() func inputText() -&gt; String /* ... */&#125; 3. Coding Style###3.1 General 3.1.1 尽可能地使用let来代替var。 3.1.2 尽可能地使用 map, filter, reduce的组合来进行集合的转换等操作，并且尽可能地避免使用带有副作用的闭包。 123456789101112131415161718192021// PREFERREDlet stringOfInts = [1, 2, 3].flatMap &#123; String($0) &#125;// [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]// NOT PREFERREDvar stringOfInts: [String] = []for integer in [1, 2, 3] &#123; stringOfInts.append(String(integer))&#125;// PREFERREDlet evenNumbers = [4, 8, 15, 16, 23, 42].filter &#123; $0 % 2 == 0 &#125;// [4, 8, 16, 42]// NOT PREFERREDvar evenNumbers: [Int] = []for integer in [4, 8, 15, 16, 23, 42] &#123; if integer % 2 == 0 &#123; evenNumbers(integer) &#125;&#125; 3.1.3 尽可能地显式声明不方便进行类型推测的变量或者常量的类型名。 3.1.4 如果你的函数需要返回多个参数，那么尽可能地使用Tuple来代替inout参数。如果你会多次使用某个元组，那么应该使用typealias设置别名。如果返回的参数超过三个，那么应该使用结构体或者类来替代。 1234567func pirateName() -&gt; (firstName: String, lastName: String) &#123; return (&quot;Guybrush&quot;, &quot;Threepwood&quot;)&#125;let name = pirateName()let firstName = name.firstNamelet lastName = name.lastName 3.1.5 在创建delegates/protocols的时候需要小心所谓的保留环(retain cycles)，这些属性需要被声明为weak。 3.1.6 在闭包中直接调用self可能会导致保留环，可以使用capture list 在这种情况下: 12345678910111213myFunctionWithClosure() &#123; [weak self] (error) -&gt; Void in // you can do this self?.doSomething() // or you can do this guard let strongSelf = self else &#123; return &#125; strongSelf.doSomething()&#125; 3.1.7 不要使用 labeled breaks。 3.1.8 不要在控制流逻辑判断的时候加上圆括号 123456789// PREFERREDif x == y &#123; /* ... */&#125;// NOT PREFERREDif (x == y) &#123; /* ... */&#125; 3.1.9 避免在使用enum的时候写出全名 12345// PREFERREDimageView.setImageWithURL(url, type: .person)// NOT PREFERREDimageView.setImageWithURL(url, type: AsyncImageView.Type.person) 3.1.10 在写类方法的时候不能用简短写法，应该使用类名.方法名，这样能够保证代码的可读性 12345// PREFERREDimageView.backgroundColor = UIColor.whiteColor()// NOT PREFERREDimageView.backgroundColor = .whiteColor() 3.1.11 在非必要的时候不要写self.。 3.1.12 在编写某个方法的时候注意考虑下这个方法是否有可能被复写，如果不可能被复写那么应该使用final修饰符。还要注意加上final之后也会导致无法在测试的时候进行复写，所以还是需要综合考虑。一般而言，加上final修饰符后会提高编译的效率，所以应该尽可能地使用该修饰符。 3.1.13 在使用譬如else, catch等等类似的语句的时候，将关键字与花括号放在一行，同样遵循1TBS style规范，这边列出了常见的if/else 以及 do/catch 示范代码。 1234567891011if someBoolean &#123; // do something&#125; else &#123; // do something else&#125;do &#123; let fileContents = try readFile(&quot;filename.txt&quot;)&#125; catch &#123; print(error)&#125; ###3.2 Access Modifiers 3.2.1 在需要的时候应该将访问修饰符放在关键字的第一位。 12345// PREFERREDprivate static let kMyPrivateNumber: Int// NOT PREFERREDstatic private let kMyPrivateNumber: Int 3.2.2 访问修饰符不应该单独放一行： 12345678910// PREFERREDpublic class Pirate &#123; /* ... */&#125;// NOT PREFERREDpublicclass Pirate &#123; /* ... */&#125; 3.2.3 一般来说，不要显式地写默认的 internal访问修饰符。 3.2.4 如果某个变量需要在测试的时候被使用到，那么应该标识为internal来保证@testable import ModuleName。这里需要注意的是，对于某些应该被声明为private的变量因为测试用途而声明为了internal，那么应该在注释里特别地注明。 12345/** This variable defines the pirate&apos;s name. - warning: Not `private` for `@testable`. */let pirateName = &quot;LeChuck&quot; 3.3 Custom Operators:自定义操作符尽可能地选用命名函数来代替自定义操作符。如果你打算引入一个自定义的操作符，那么一定要有非常充分的理由来说明为啥要讲一个新的操作符引入到全局作用域，而不是使用其他一些可替代的方式。你也可以选择去复写一些现有的操作符，譬如==来适应一些新的类型，不过要保证你添加的用法一定要与语义相符。譬如== 应该只能用于表示相等性测试并且返回一个布尔值。 ###3.4 Switch Statements and enums 3.4.1 在使用枚举类型作为switch的参数的时候，避免引入default关键字，而应该将没有使用的情形放到下面然后使用break关键字来避免被执行。 3.4.2 Swift中默认会在每个case的结尾进行break，因此没必要的时候不需要显式地声明break关键字。 3.4.3 The case statements should line up with the switch statement itself as per default Swift standards. 3.4.4 When defining a case that has an associated value, make sure that this value is appropriately labeled as opposed to just types (e.g. case Hunger(hungerLevel: Int) instead of case Hunger(Int)). 12345678910111213141516enum Problem &#123; case attitude case hair case hunger(hungerLevel: Int)&#125;func handleProblem(problem: Problem) &#123; switch problem &#123; case .attitude: print(&quot;At least I don&apos;t have a hair problem.&quot;) case .hair: print(&quot;Your barber didn&apos;t know when to stop.&quot;) case .hunger(let hungerLevel): print(&quot;The hunger level is \(hungerLevel).&quot;) &#125;&#125; 3.4.5 优先使用譬如case 1, 2, 3:这样的列表表达式而不是使用fallthrough关键字。 3.4.6 如果你添加了一个默认的case并且该case不应该被使用，那么应该在default情形下抛出异常。 123456func handleDigit(digit: Int) throws &#123; case 0, 1, 2, 3, 4, 5, 6, 7, 8, 9: print(&quot;Yes, \(digit) is a digit!&quot;) default: throw Error(message: &quot;The given number was not a digit.&quot;)&#125; ###3.5 Optionals 3.5.1 只应该在 @IBOutlet中使用隐式地未包裹的Options。否则其他情况下就应该使用Non-Optional或者正常的Optional的变量。虽然有时候你能保证某个变量肯定非nil，不过这样用的话还是比较安全并且能保证上下一致性。 The only time you should be using implicitly unwrapped optionals is withs. In every other case, it is better to use a non-optional or regular optional variable. Yes, there are cases in which you can probably “guarantee” that the variable will never be nil when used, but it is better to be safe and consistent. 3.5.2 不要使用 as! 或者 try!. 3.5.3 如果你只是打算判断存放在Optional中的值是否为空，那么你应该直接与nil进行判断而不是使用if let语句将值取出来。 123456789// PREFEREREDif someOptional != nil &#123; // do something&#125;// NOT PREFERREDif let _ = someOptional &#123; // do something&#125; 3.5.4 不要使用 unowned。你可以将unowned当做对于weak变量的隐式解包，虽然有时候unowned与weak相比有小小地性能提升，不过还是不建议进行使用。 123456// PREFERREDweak var parentViewController: UIViewController?// NOT PREFERREDweak var parentViewController: UIViewController!unowned var parentViewController: UIViewController 3.5.5 当对Optionals进行解包的时候，使用与Optionals变量一致的变量名 123guard let myVariable = myVariable else &#123; return&#125; 3.6 Protocols在实现协议的时候，大体上有两种代码组织方式： 使用 // MARK: 来注释你的专门用于实现协议中规定的方法 在你的类或者结构体实现之外使用一个扩展来存放实现代码，不过要保证在一个源文件中 不过需要注意的是，如果你是使用了Extension方式，那么定义在Extension中的方法是无法被子类复写的，这样可能会无法进行测试。 3.7 Properties 3.7.1 如果是定义一个只读的需要经过计算的属性，那么不需要声明 get {} 123456var computedProperty: String &#123; if someBool &#123; return &quot;I&apos;m a mighty pirate!&quot; &#125; return &quot;I&apos;m selling these fine leather jackets.&quot;&#125; 3.7.2 在使用 get {}, set {}, willSet, 以及 didSet, 注意块的缩进 3.7.3 尽管你可以在willSet/didSet以及 set方法中使用自定义的名称，不过建议还是使用默认的newValue/oldValue变量名 1234567891011121314151617var computedProperty: String &#123; get &#123; if someBool &#123; return &quot;I&apos;m a mighty pirate!&quot; &#125; return &quot;I&apos;m selling these fine leather jackets.&quot; &#125; set &#123; computedProperty = newValue &#125; willSet &#123; print(&quot;will set to \(newValue)&quot;) &#125; didSet &#123; print(&quot;did set from \(oldValue) to \(newValue)&quot;) &#125;&#125; 3.7.4 将任何类常量设置为static 1234class MyTableViewCell: UITableViewCell &#123; static let kReuseIdentifier = String(MyTableViewCell) static let kCellHeight: CGFloat = 80.0&#125; 3.7.5 可以使用如下方式便捷地声明一个单例变量： 12345class PirateManager &#123; static let sharedInstance = PirateManager() /* ... */&#125; 3.8 Closures:闭包 3.8.1 如果闭包中的某个参数的类型是显而易见的，那么可以避免声明类型。不过有时候为了保证可读性与一致性，还是会显示声明参数类型。 123456789101112// omitting the typedoSomethingWithClosure() &#123; response in print(response)&#125;// explicit typedoSomethingWithClosure() &#123; response: NSURLResponse in print(response)&#125;// using shorthand in a map statement[1, 2, 3].flatMap &#123; String($0) &#125; 3.8.2 在参数列表中，如果是使用了捕获变量或者声明了非Void的返回值，那么应该将参数列表写在一个圆括号里，其他情况下则可以省略圆括号。 123456789// parentheses due to capture listdoSomethingWithClosure() &#123; [weak self] (response: NSURLResponse) in self?.handleResponse(response)&#125;// parentheses due to return typedoSomethingWithClosure() &#123; (response: NSURLResponse) -&gt; String in return String(response)&#125; 3.8.3 如果你是将闭包声明为一个类型，那么除非该类型为Optional或者该闭包是另一个闭包的参数，否则不需要使用圆括号进行包裹。不过需要用圆括号来标注参数列表，并且使用Void来指明没有任何结果返回。 123456789let completionBlock: (success: Bool) -&gt; Void = &#123; print(&quot;Success? \(success)&quot;)&#125;let completionBlock: () -&gt; Void = &#123; print(&quot;Completed!&quot;)&#125;let completionBlock: (() -&gt; Void)? = nil 3.8.4 尽可能地将参数名与左括号放在一行，不过要避免打破每行最长160个字符的限制。 Keep parameter names on same line as the opening brace for closures when possible without too much horizontal overflow (i.e. ensure lines are less than 160 characters). 3.8.5 尽可能地使用 trailing closure表达式，除非需要显示地声明闭包参数的外部参数名。 1234567891011// trailing closuredoSomething(1.0) &#123; parameter1 in print(&quot;Parameter 1 is \(parameter1)&quot;)&#125;// no trailing closuredoSomething(1.0, success: &#123; parameter1 in print(&quot;Success with \(parameter1)&quot;)&#125;, failure: &#123; parameter1 in print(&quot;Failure with \(parameter1)&quot;)&#125;) ###3.9 Arrays 3.9.1 一般来说，避免使用下标直接访问某个数组，而应该使用类似于.first、.last这样的访问器进行访问。另外，应该优先使用for item in items语法来替代`for i in 0..。如果你打算用下标遍历数组，那么一定保证不能越界。 3.9.2 永远不要使用+= 或者 +运算符来增加或者连接数组，应该使用.append() 或者 .appendContentsOf() 方法。如果你想定义一个从其他数组生成的不可变数组，那么应该使用let关键字，即： let myNewArray = arr1 + arr2, 或者 let myNewArray = [arr1, arr2].flatten()。 3.10 Error Handling假设某个函数 myFunction 需要去返回一个String类型，不过有可能会在某个点抛出异常，一般来说会将该函数的返回值设置为String?： Example: 123456789101112131415161718func readFile(withFilename filename: String) -&gt; String? &#123; guard let file = openFile(filename) else &#123; return nil &#125; let fileContents = file.read() file.close() return fileContents&#125;func printSomeFile() &#123; let filename = &quot;somefile.txt&quot; guard let fileContents = readFile(filename) else &#123; print(&quot;Unable to open file \(filename).&quot;) return &#125; print(fileContents)&#125; 不过作为异常处理的角度，我们应该使用Swift的try-catch表达式，这样能显式地知道错误点： 12345678910111213struct Error: ErrorType &#123; public let file: StaticString public let function: StaticString public let line: UInt public let message: String public init(message: String, file: StaticString = #file, function: StaticString = #function, line: UInt = #line) &#123; self.file = file self.function = function self.line = line self.message = message &#125;&#125; Example usage: 123456789101112131415161718func readFile(withFilename filename: String) throws -&gt; String &#123; guard let file = openFile(filename) else &#123; throw Error(message: &quot;Unable to open file named \(filename).&quot;) &#125; let fileContents = file.read() file.close() return fileContents&#125;func printSomeFile() &#123; do &#123; let fileContents = try readFile(filename) print(fileContents) &#125; catch &#123; print(error) &#125;&#125; 总而言之，如果某个函数可能会出错，并且出错的原因不能显式地观测到，那么应该优先抛出异常而不是使用一个Optional作为返回值。 ###3.11 Using guard Statements 3.11.1 一般来说，我们会优先使用所谓的”early return”策略来避免if表达式中的多层嵌套的代码。在这种情况下使用guard语句能够有效地提升代码的可读性。 123456789101112131415161718// PREFERREDfunc eatDoughnut(atIndex index: Int) &#123; guard index &gt;= 0 &amp;&amp; index &lt; doughnuts else &#123; // return early because the index is out of bounds return &#125; let doughnut = doughnuts[index] eat(doughnut)&#125;// NOT PREFERREDfunc eatDoughnuts(atIndex index: Int) &#123; if index &gt;= 0 &amp;&amp; index &lt; donuts.count &#123; let doughnut = doughnuts[index] eat(doughnut) &#125;&#125; 3.11.2 在对Optional类型进行解包的时候，优先使用 guard 语句来避免if语句中较多的缩进。 12345678910111213141516171819// PREFERREDguard let monkeyIsland = monkeyIsland else &#123; return&#125;bookVacation(onIsland: monkeyIsland)bragAboutVacation(onIsland: monkeyIsland)// NOT PREFERREDif let monkeyIsland = monkeyIsland &#123; bookVacation(onIsland: monkeyIsland) bragAboutVacation(onIsland: monkeyIsland)&#125;// EVEN LESS PREFERREDif monkeyIsland == nil &#123; return&#125;bookVacation(onIsland: monkeyIsland!)bragAboutVacation(onIsland: monkeyIsland!) 3.11.3 在决定是要用if表达式还是guard表达式进行Optional类型解包的时候，最重要的点就是要保证代码的可读性。很多时候要注意因时而变，因地制宜： 1234567891011121314// an `if` statement is readable hereif operationFailed &#123; return&#125;// a `guard` statement is readable hereguard isSuccessful else &#123; return&#125;// double negative logic like this can get hard to read - i.e. don&apos;t do thisguard !operationFailed else &#123; return&#125; 3.11.4 当需要进行多可能性处理的时候，应该优先使用if表达式而不是guard表达式。 1234567891011121314// PREFERREDif isFriendly &#123; print(&quot;Hello, nice to meet you!&quot;)&#125; else &#123; print(&quot;You have the manners of a beggar.&quot;)&#125;// NOT PREFERREDguard isFriendly else &#123; print(&quot;You have the manners of a beggar.&quot;) return&#125;print(&quot;Hello, nice to meet you!&quot;) 3.11.5 一般来说，guard应该被用于需要直接退出当前上下文的情形。而对于下面这种两个条件互不干扰的情况，应该使用两个if而不是两个guard。 1234567if let monkeyIsland = monkeyIsland &#123; bookVacation(onIsland: monkeyIsland)&#125;if let woodchuck = woodchuck where canChuckWood(woodchuck) &#123; woodchuck.chuckWood()&#125; 3.11.6 有时候我们会碰到要用guard语句进行多个optionals解包的情况，一般而言，对于复杂的错误处理的Optional类型需要将其拆分到多个单个表达式中。 12345678910111213141516171819// combined because we just returnguard let thingOne = thingOne, let thingTwo = thingTwo, let thingThree = thingThree else &#123; return&#125;// separate statements because we handle a specific error in each caseguard let thingOne = thingOne else &#123; throw Error(message: &quot;Unwrapping thingOne failed.&quot;)&#125;guard let thingTwo = thingTwo else &#123; throw Error(message: &quot;Unwrapping thingTwo failed.&quot;)&#125;guard let thingThree = thingThree else &#123; throw Error(message: &quot;Unwrapping thingThree failed.&quot;)&#125; 3.11.7 不要将guard表达式强行缩写到一行内。 1234567// PREFERREDguard let thingOne = thingOne else &#123; return&#125;// NOT PREFERREDguard let thingOne = thingOne else &#123; return &#125; 4. Documentation/Comments4.1 Documentation如果某个函数不是简单地O(1)操作，那么最好就是为该函数添加一些注释文档，这样能有效地提高代码的可读性与可维护性。之前有个非常不错的文档工具VVDocumenter。推荐阅读Apple的官方指南中的描述：described in Apple’s Documentation. Guidelines: 4.1.1 每行不应超过160个字符 4.1.2 即使某些注释只有一行，也应该使用块注释符： (/** */). 4.1.3 不用给每行的开头都加上： *. 4.1.4 使用新的 - parameter 标识符来代替老的:param: syntax (注意这边是小写的 parameter 而不是Parameter). 4.1.5 如果你准备对参数/返回值/异常值来写注释，那么注意要一个不落的全局加上，尽管有时候会让文档显得重复冗余。有时候，如果只需要对单个参数进行注释，那么还不如直接放在描述里进行声明，而不需要专门的为参数写一个注释。 4.1.6 对于复杂的使用类，应该添加一些具体的使用用例来描述类的用法。注意Swift的注释文档中是支持MarkDown语法的，这是一个很好的特性。 12345678910111213141516171819202122232425262728/** ## Feature Support This class does some awesome things. It supports: - Feature 1 - Feature 2 - Feature 3 ## Examples Here is an example use case indented by four spaces because that indicates a code block: let myAwesomeThing = MyAwesomeClass() myAwesomeThing.makeMoney() ## Warnings:告警 There are some things you should be careful of: 1. Thing one 2. Thing two 3. Thing three */class MyAwesomeClass &#123; /* ... */&#125; 4.1.7 使用 - ` 在注释中著名引用的代码 1234567/** This does something with a `UIViewController`, perchance. - warning: Make sure that `someValue` is `true` before running this function. */func myFunction() &#123; /* ... */&#125; 4.1.8 保证文档的注释尽可能的简洁 4.2 Other Commenting Guidelines:其他的注释规则 4.2.1 //后面总是要跟上一个空格 4.2.2 注释永远要放在单独的行中 4.2.3 在使用// MARK: - whatever的时候，注意MARK与代码之间保留一个空行 12345678910111213class Pirate &#123; // MARK: - instance properties private let pirateName: String // MARK: - initialization init() &#123; /* ... */ &#125;&#125; 原文链接:github:Swift Style Guide]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift中的问号?和感叹号!]]></title>
      <url>%2F2016%2F06%2F28%2Fswiftzhong-de-wen-hao-he-gan-tan-hao%2F</url>
      <content type="text"><![CDATA[本文转载自：代码手工艺人的博客，原文名称：Swift之 ? 和 ! Swift语言使用var定义变量，但和别的语言不同，Swift里不会自动给变量赋初始值，也就是说变量不会有默认值，所以要求使用变量之前必须要对其初始化。如果在使用变量之前不进行初始化就会报错： 12345var stringValue : String //error: variable &apos;stringValue&apos; used before being initialized//let hashValue = stringValue.hashValue// ^let hashValue = stringValue.hashValue 上面了解到的是普通值，接下来Optional值要上场了。经喵神提醒，Optional其实是个enum，里面有None和Some两种类型。其实所谓的nil就是Optional.None, 非nil就是Optional.Some, 然后会通过Some(T)包装（wrap）原始值，这也是为什么在使用Optional的时候要拆包（从enum里取出来原始值）的原因, 也是PlayGround会把Optional值显示为类似{Some &quot;hello world&quot;}的原因，这里是enum Optional的定义： 12345678910111213enum Optional&lt;T&gt; : LogicValue, Reflectable &#123; case None case Some(T) init() init(_ some: T) /// Allow use in a Boolean context. func getLogicValue() -&gt; Bool /// Haskell&apos;s fmap, which was mis-named func map&lt;U&gt;(f: (T) -&gt; U) -&gt; U? func getMirror() -&gt; Mirror&#125; 声明为Optional只需要在类型后面紧跟一个?即可。如: 12var strValue: String? //?相当于下面这种写法的语法糖var strValue: Optional&lt;Int&gt; 一旦声明为Optional的，如果不显式的赋值就会有个默认值nil。判断一个Optional的值是否有值，可以用if来判断： 123if strValue &#123; //do sth with strValue&#125; 然后怎么使用Optional值呢？文档中也有提到说，在使用Optional值的时候需要在具体的操作，比如调用方法、属性、下标索引等前面需要加上一个?，经喵神指正，”Optional Chaining的问号的意思是询问是否响应后面这个方法，和原来的isResponseToSelector有些类似”，如果是nil值，也就是Optional.None，固然不能响应后面的方法，所以就会跳过，如果有值，就是Optional.Some，可能就会拆包(unwrap)，然后对拆包后的值执行后面的操作，比如： 1let hashValue = strValue?.hashValue strValue是Optional的字符串，如果strValue是nil，则hashValue也为nil，如果strValue不为nil，hashValue就是strValue字符串的哈希值 到这里我们看到了?的两种使用场景:1.声明Optional值变量2.用在对Optional值操作中，用来判断是否能响应后面的操作 另外，对于Optional值，不能直接进行操作，否则会报错： 12345//error: &apos;String?&apos; does not have a member named &apos;hashValue&apos;//let hashValue = strValue.hashValue// ^ ~~~~~~~~~let hashValue = strValue.hashValue 上面提到Optional值需要拆包(unwrap)后才能得到原来值，然后才能对其操作，那怎么来拆包呢？拆包提到了几种方法，一种是Optional Binding， 比如： 123if let str = strValue &#123; let hashValue = str.hashValue&#125; 还有一种是在具体的操作前添加!符号，好吧，这又是什么诡异的语法?! 直接上例子，strValue是Optional的String： 1let hashValue = strValue!.hashValue 这里的!表示“我确定这里的的strValue一定是非nil的，尽情调用吧” ，比如这种情况: 123if strValue &#123; let hashValue = strValue!.hashValue&#125; {}里的strValue一定是非nil的，所以就能直接加上!，强制拆包(unwrap)并执行后面的操作。 当然如果不加判断，strValue不小心为nil的话，就会出错，crash掉。 考虑下这一种情况，我们有一个自定义的MyViewController类，类中有一个属性是myLabel，myLabel是在viewDidLoad中进行初始化。因为是在viewDidLoad中初始化，所以不能直接声明为普通值：var myLabel : UILabel，因为非Optional的变量必须在声明时或者构造器中进行初始化，但我们是想在viewDidLoad中初始化，所以就只能声明为Optional：var myLabel: UILabel?, 虽然我们确定在viewDidLoad中会初始化，并且在ViewController的生命周期内不会置为nil，但是在对myLabel操作时，每次依然要加上!来强制拆包(在读取值的时候，也可以用?，谢谢iPresent在回复中提醒)，比如: 123myLabel!.text = &quot;text&quot;myLabel!.frame = CGRectMake(0, 0, 10, 10)... 对于这种类型的值，我们可以直接这么声明：var myLabel: UILabel!, 果然是高(hao)大(gui)上(yi)的语法!, 这种是特殊的Optional，称为Implicitly Unwrapped Optionals, 直译就是隐式拆包的Optional，就等于说你每次对这种类型的值操作时，都会自动在操作前补上一个!进行拆包，然后在执行后面的操作，当然如果该值是nil，也一样会报错crash掉。 12var myLabel: UILabel! //!相当于下面这种写法的语法糖var myLabel: ImplicitlyUnwrappedOptional&lt;UILabel&gt; Swift是门新生的语言，我们有幸见证了它的诞生，激动之余也在佩服苹果大刀阔斧的推出一个新的语言替代一个已经比较成熟语言的魄力，今天在知乎日报上看到一个回答是说Swift是一门玩具语言，正当想去吐槽，发现回答已经被删除了。个人认为苹果是很认真的推出Swift的，从Swift的各种细微的设计也能看的出来。 另外这两个小符号就花费了我不少的时间来理解，可能依然会有错误和不妥之处，欢迎大家指正，本文旨在抛砖引玉。除此之外，Swift还有很多很棒的特性，WWDC 2014 会有四五个和Swift语言相关的Video，大家也可以去关注一下。 最后要感谢喵神的纠正了多处有问题的地方，thx, have fun! 主要参考自苹果的官方文档《The Swift Programming Language》，可以在这里下载到]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift 中的异常抛出和错误处理]]></title>
      <url>%2F2016%2F06%2F28%2Fswift-zhong-de-yi-chang-pao-chu-he-cuo-wu-chu-li%2F</url>
      <content type="text"><![CDATA[前言Swift语言对其错误处理进行了新的设计，当然了，重新设计后的结果使得该错误处理系统用起来更爽。今天的主题就是系统的搞一下Swift中的错误处理，以及看一下Swift中是如何抛出异常的。在编译型语言中，错误一般分为编译错误和运行时错误。我们平时在代码中处理的错误为运行时错误，我们对异常进行处理的操作的目的是为了防止程序出现错误而导致其他的副作用，比如用户数据未保存等等。 在今天的文章中，先给出主动产生异常的几种情况，然后再给出如何处理被动异常。 问题总结一、主动退出程序的几种情况 在Objective-C中，在单元测试时我们会使用断言，断言中条件满足时会产生异常，并打印出相应的断言错误，在Swift中也有几种产生异常的语法。在本篇博客的第一部分就给出这几种方法。 1.Fatal Errors（致命的错误） 使用fatalError()函数可以立即终止你的应用程序，在fatalError()中可以给出终止信息。使用fatalError()函数，会毫无条件的终止你的应用程序，用起来也是比较简单的，就是一个函数的调用。下方这个Demo一目了然呢，在此就不做过多赘述了。 2. Assertions（断言） 在单元测试中是少不了断言的，Swift中的断言和Objective-C的区别不是太大，使用方法也是大同小异。下方就是断言的两种方法，由代码提示可知，在断言中的提示条件是可选的。断言会在Debug模式下起作用，但是在Release版本中就会被忽略。 在assert()函数中, 第一个参数是Bool类型，第二个参数是输出的信息。当条件为true时，断言不执行，相应的断言信息不打印。当条件为false时，断言执行，并且打印相应的断言信息。 assertionFailure()函数只有一个Message参数，并且该参数也是可以省略的，assertionFailure()没有条件。如下所示： 3. 先决条件（Preconditions） Preconditions的用法和断言一样，不过有一点需要主要，Preconditions在debug和release模式下都会被执行，除非使用–Ounchecked进行编译。下方截图是代码提示给出的Preconditions函数的提示，如下所示： 关于Preconditions的具体用法请参照断言，和断言用法一样，在此就不做过多的赘述了。 二.Swift中的错误处理 在Objective-C中，如果你处理过错误的话，那么你将会对NSError很熟悉。在Swift中，如果你要定义你自己的错误类型，你只需要实现ErrorType协议即可。声明完错误类型后，就可以在处理错误抛出异常时使用自定义的错误类型了。下方将会一步步带你走完Swift中的错误处理的路程。 1.使用枚举创建错误类型 （1）.遵循ErrorType协议，自定义错误类型。下方定义了一个错误类型枚举，该枚举遵循了ErrorType协议，在接下来的代码中我们将会使用这个MyCustomErrorType枚举，错误枚举的实现如下所示： 123456//定义错误类型enum MyCustomErrorType: ErrorType &#123;case ErrorReasoncase ErrorReasoncase ErrorReason&#125; （2）.在我们的函数定义时可以使用throws关键字，以及在函数中使用throw关键字对错误进行抛出，抛出的错误类型就可以使用上面我们自己定义的错误类型。下方函数就是一个可以抛出错误的函数，抛出的错误就是我们在上面枚举中所定义的类型。具体代码如下所示： 123456func myThrowFunc() throws &#123;let test:Int? = nilguard test != nil else &#123;throw MyCustomErrorType.ErrorReason&#125;&#125; （3）.上面函数的功能是对错误进行抛出，接下来就该使用do-catch来处理抛出的错误。使用try对错误进行捕捉，使用do-catch对错误进行处理。具体处理方式如下所示。在下方错误处理中类似于switch-case语句，catch后边可以枚举匹配错误类型，具体如下所示： （4）在枚举实现错误类型中我们可以通过值绑定的形式为错误添加错误代码和错误原因。在声明枚举时，我们使用了枚举元素值绑定的特性（关于枚举使用的更多细节请参考之前的博客《窥探Swift之别样的枚举类型》）。在声明枚举成员ErrorState时，我们为其绑定了两个变量，一个是错误代码errorCode, 另一个是错误原因errorReason。这两者可以在抛出错误时为其传入相应的值，如下方代码片段中的throwError函数所示，在抛出错误是为errorCode指定的错误代码为404，为errorReason指定的错误原因是“not found”。 最后就是使用do-catch处理异常了，在catch中对绑定的错误代码和错误原因进行了获取，并且通过where子句进行了错误代码的筛选。此处catch的用法与switch-case中获取枚举绑定值的用法是一样的，所以在此就不做过多的赘述。具体实现方式如下代码所示： 2.使用结构体为错误处理添加Reason 在上面的内容中，使用枚举遵循ErrorType协议的方式定义了特定的错误类型。接下来我们将使用结构体来遵循ErrorType协议，为错误类型添加错误原因。也就是说，我们可以在抛出错误时，给自定义错误类型提供错误原因。该功能在开发中是非常常用的，而且用起来也是非常爽的。接下来就看一下如何为我们的错误类型添加错误原因。 （1）使用结构体创建错误类型，下方名为MyErrorType的结构体遵循了ErrorType协议，并且在MyErrorType结构体中，声明了一个reason常量，该reason常量中存储的就是错误原因，具体实现方式如下： 123struct MyErrorType: ErrorType &#123;let reason : String&#125; （2）上面定义完错误类型结构体后，在错误抛出中就可以使用了。在错误抛出时，可以传入一个错误原因，具体代码如下所示： 123456func myThrowFunc() throws &#123;let test:Int? = nilguard test != nil else &#123;throw MyErrorType(reason: &quot;我是详细的错误原因，存储在error中&quot;)&#125;&#125; （3）最后要对抛出的错误进行do-catch处理，在处理时，可以对错误原因进行打印，错误原因存储在error中，具体操作和打印结果如下所示： 由上面的输出结果可知，error是我们自定义的MyErrorType类型，我们可以使用下面的代码来代替catch中的print语句，如下所示： 上面的做法似乎有些麻烦，还有一种简化输出的方法，就是在上述结构体中实现CustomDebugStringConvertible协议，对描述信息进行一个重写，就可以在打印error时，只打印错误信息，下方是重写后的结构体。 123456struct MyErrorType: ErrorType,CustomDebugStringConvertible &#123;let reason : Stringvar debugDescription: String &#123;return &quot;错误类型-----\(self.dynamicType): \(reason)&quot;&#125;&#125; 修改后，输出结果如下，直接打印error输出的就是错误信息，而不是MyErrorType类型。 3.使String类型遵循ErrorType协议，直接使用String提供错误原因 在“2”中，我们使用了结构体遵循ErrorType协议的形式，来为错误提供错误信息的。在接下来的部分，我们将通过更为简单的方式为抛出的错误提供错误信息。这种方式更为简单，也易于理解，具体方式如下方代码所示： 三、在错误处理中使用内置关键字 1.初探这些内置关键字 在Swift中提供了一些内置关键字（FILE, FUNCTION, LINE等）来获取上下文信息，在本篇博客的第三部分，将会给出如何在我们的错误处理中使用这些内置关键字。下方就是这些内置关键字的作用，如下所示： 上面说是内置关键字，其实就是存储代码上下文的宏定义，上方代码段简单的给出了这些内置关键字的作用与用法，在接下来将在ErrorType中使用这些内置关键字，让我们的错误信息更加丰富多彩。 2.在ErrorType中使用上述内置关键字 如果想在ErrorType中使用这些上下文内置关键字，我们只需要对ErrorType进行扩展，使其在ErrorType提供错误信息时给出出错的上下文信息。当然，这实现起来比较简单，就是在ErrorType中添加了一个扩展方法contextString()。该方法的作用就是提供错误的上下文信息，也就是在出错的地方，调用contextString()方法生成上下文描述信息即可。对ErrorType协议的具体延展实现如下代码段所示. 在下方代码片段中，我们对ErrorType进行了扩展，为ErrorType添加了contextString的函数实现。contextString()函数有三个默认参数，分别是file–当前文件名，function–当前出错的函数名，line–当前抛出异常的行数。上述三个参数都有参数默认值，分别对应着FILE, FUNCTION, LINE。该扩展函数的返回值为这三个参数组成从字符串信息。具体实现如下所示： 3.使用扩展的contextString方法 上面我们使用结构体实现ErrorType协议的形式，为错误类型添加错误原因。接下来我们将在添加reason的同时，使用contextString()函数添加描述信息。下方CustomErrorType结构体遵循了ErrorType协议，其中添加了一个reason常量来存储错误原因，一个context常量来存储上下文信息，并且为该结构体添加了一个构造函数，在构造函数中初始化和reason常量。具体实现如下所示： 4. 抛出并捕获异常 在下方代码中函数throwError()抛出了异常，该抛出的错误类型是CustomErrorType。在创建CustomErrorType类型实例，也就是err变量时，我们指定了错误原因，也就是为reason赋了一个值。在创建完err实例后，我们又调用延展contextString()函数获取异常的上下文信息，并把返回的内容存储在err实例的context属性中。最后使用throw关键字抛出err实例，如下方第一部分代码所示。 在创建抛出异常的函数后，我们需要对抛出的异常进行捕获。也就是使用try对异常进行捕获，使用do-catch对异常进行处理，具体操作如下方第二段代码所示。 5. 分析打印结果 经过上述步骤如果你在Playground中进行试验的，那么在控制台上你将会看到如下信息。从打印出的信息我们可以看到，信息包括reason：错误原因，和context：异常上下文。在下方的输出结果中，文件名我们可以看到是这并不是确切的文件名，因为我们是在Playground中使用的，并且不是确切的Swift源文件，所以获取不到确切的文件名。 为了观察确切的文件名，我们需要在确切的Swift源文件中抛出上述异常。在特定Swift源文件中，我们会看到下方的输出结果。从下方的输出日志中，我们可以清楚的看到文件名是一个详细的文件路径。如下所示：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[React-Native学习笔记]]></title>
      <url>%2F2016%2F06%2F28%2Freact-nativexue-xi-bi-ji%2F</url>
      <content type="text"><![CDATA[自己在学习React-Native过程中整理的一份学习指南，包含 教程、开源app和资源网站等，还在不断更新中。欢迎pull requests！ React-Native学习指南 本指南汇集React-Native各类学习资源，给大家提供便利。指南正在不断的更新，大家有好的资源欢迎Pull Requests！ 同时还有Awesome React-Native系列 https://github.com/jondot/awesome-react-native 教程react-native 官方api文档 http://facebook.github.io/react-native/docs/getting-started.html react-native 中文api文档 (翻译中) https://github.com/ecomfe/react-native-cn react.js中文文档 http://reactjs.cn/ react.js入门教程(gitbook) http://hulufei.gitbooks.io/react-tutorial/content/introduction.html react.js快速入门教程 - 阮一峰 http://www.ruanyifeng.com/blog/2015/03/react.html react.js视频教程 http://react.nodejs-china.org/t/reactjszhong-wen-shi-pin-jiao-cheng-bai-du-wang-pan/584 react-native第一课 http://html-js.com/article/2783 深入浅出 React Native：使用 JavaScript 构建原生应用 http://zhuanlan.zhihu.com/FrontendMagazine/19996445 React Native通信机制详解 http://blog.cnbang.net/tech/2698/ React Native布局篇 http://segmentfault.com/a/1190000002658374 React Native 基础练习指北（一） http://segmentfault.com/a/1190000002645929 React Native 基础练习指北（二） http://segmentfault.com/a/1190000002647733 构建一个简单的列表页和2页导航 http://www.xn--cnq920ntha.cn/archives/235#6838470-tsina-1-17436-6a377b1a66595f9ede646cf5c012734c Diary of Building an iOS App with React Native http://herman.asia/building-a-flashcard-app-with-react-native Use React Native in Existing iOS App http://blog-en.leapoahead.com/post/use-react-native-in-existing-ios-app tcomb-form-native使用视频教程(需翻墙) http://react.rocks/example/tcomb-form-native 开源APP研究源码也是一个很好的学习方式 官方演示App https://github.com/facebook/react-native/tree/master/Examples ReactNativeRubyChina https://github.com/henter/ReactNativeRubyChina HackerNews-React-Native https://github.com/iSimar/HackerNews-React-Native React-Native新闻客户端 https://github.com/tabalt/ReactNativeNews newswatch(新闻客户端) https://github.com/bradoyler/newswatch-react-native buyscreen(购买页面) https://github.com/appintheair/react-native-buyscreen V2EX客户端 https://github.com/samuel1112/v2er react-native-todo https://github.com/joemaddalone/react-native-todo react-native-beer https://github.com/muratsu/react-native-beer react-native-stars https://github.com/86/react-native-stars 模仿天猫首页的app https://github.com/baofen14787/react-native-demo ReactNativeChess https://github.com/csarsam/ReactNativeChess react native 编写的音乐软件 https://github.com/Johnqing/miumiu react-native-pokedex https://github.com/ababol/react-native-pokedex CNode-React-Native https://github.com/SFantasy/CNode-React-Native 8tracks电台客户端 https://github.com/voronianski/EightTracksReactNative React-Native实现的计算器 https://github.com/yoxisem544/Calculator-using-React-Native 房产搜索app https://github.com/jawee/react-native-PropertyFinder 知乎专栏app https://github.com/LeezQ/react-native-zhihu-app ForeignExchangeApp https://github.com/peralmq/ForeignExchangeApp 工具react-native-snippets(代码提示) https://github.com/Shrugs/react-native-snippets react-native-babel(使用ES6+) https://github.com/roman01la/react-native-babel 资源网站 React-native官网 http://facebook.github.io/react-native/ React-China社区 http://react-china.org/ React-native组件库（比较全的组件库） http://react.parts/ React Native Modules http://reactnativemodules.com/ 11款React Native开源移动 UI 组件 http://www.oschina.net/news/61214/11-react-native-ui-components 业界讨论谈谈 React Native - 唐巧 http://blog.devtang.com/blog/2015/02/01/talk-about-react-native/ 如何评价React-Native? http://www.zhihu.com/question/27852694/answer/43990708 React Native概述：背景、规划和风险 http://div.io/topic/938 官方指南： https://github.com/ele828/react-native-guide]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mac OS X 进程UserEventAgent 占用CPU 100%的解决办法]]></title>
      <url>%2F2016%2F06%2F26%2Fmac-os-x-jin-cheng-usereventagent-zhan-yong-cpu-100-de-jie-jue-ban-fa%2F</url>
      <content type="text"><![CDATA[前几天电脑无故发热特别厉害，达到了70+度，一查进程居然有一个UserEventAgent占了100%的CPU，虽未影响系统流畅度，还是受不了这么高的温度，我也不记得对系统和硬件做过什么大的改动，上网查了一下似乎和USB设备有关，后来一忙又把这事放了几天，今天干脆直接申请了Apple支持，电话连线近一小时仍无果（服务还是不错的），只能提供了一些后续的解决方案。闲不住自己试了几遍，发现只有连接鼠标的时候才会有这个问题（不过这鼠标以前用着一切正常..），点开UserEventAgent进程发现打开的文件里很多在/system/Library/下，没看到和鼠标有关的，直接Finder定位到/System/Library/搜索mouse，出来两个目测和鼠标有关的文件：AppleHIDMouse.kextAppleHIDMouseAgent.plugin 本想直接把这文件移动到其他路径，为求保险再搜了一下上面自己猜测的信息，在Apple的技术支持论坛找到一个和上述一样解决方法的帖子，原来只需要删除下面这一个文件即可：/System/Library/UserEventPlugins/AppleHIDMouseAgent.plugin/Contents/MacOS/AppleH IDMouseAgent 删除之，重启，终于恢复正常。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Bitcode 理解]]></title>
      <url>%2F2016%2F06%2F26%2Fbitcode-li-jie%2F</url>
      <content type="text"><![CDATA[今天试着用Xcode 7 beta 3在真机(iOS 8.3)上运行一下我们的工程，结果发现工程编译不过。看了下问题，得到的信息是我们引入的一个第三方库不包含bitcode。嗯，不知道bitcode是啥，所以就得先看看这货是啥了。 Bitcode是什么？找东西嘛，最先想到的当然是先看官方文档了。在App Distribution Guide – App Thinning (iOS, watchOS)一节中，找到了下面这样一个定义： Bitcode is an intermediate representation of a compiled program. Apps you upload to iTunes Connect that contain bitcode will be compiled and linked on the App Store. Including bitcode will allow Apple to re-optimize your app binary in the future without the need to submit a new version of your app to the store. 说的是bitcode是被编译程序的一种中间形式的代码。包含bitcode配置的程序将会在App store上被编译和链接。bitcode允许苹果在后期重新优化我们程序的二进制文件，而不需要我们重新提交一个新的版本到App store上。 嗯，看着挺高级的啊。 继续看，在What’s New in Xcode-New Features in Xcode 7中，还有一段如下的描述 Bitcode. When you archive for submission to the App Store, Xcode will compile your app into an intermediate representation. The App Store will then compile the bitcode down into the 64 or 32 bit executables as necessary. 当我们提交程序到App store上时，Xcode会将程序编译为一个中间表现形式(bitcode)。然后App store会再将这个botcode编译为可执行的64位或32位程序。 再看看这两段描述都是放在App Thinning(App瘦身)一节中，可以看出其与包的优化有关了。喵大(@onevcat)在其博客开发者所需要知道的 iOS 9 SDK 新特性中也描述了iOS 9中苹果在App瘦身中所做的一些改进，大家可以转场到那去研读一下。 Bitcode配置在上面的错误提示中，提到了如何处理我们遇到的问题： You must rebuild it with bitcode enabled (Xcode setting ENABLE_BITCODE), obtain an updated library from the vendor, or disable bitcode for this target. for architecture arm64 要么让第三方库支持，要么关闭target的bitcode选项。 实际上在Xcode 7中，我们新建一个iOS程序时，bitcode选项默认是设置为YES的。我们可以在”Build Settings”-&gt;”Enable Bitcode”选项中看到这个设置。 不过，我们现在需要考虑的是三个平台：iOS，Mac OS，watchOS。 对应iOS，bitcode是可选的。 对于watchOS，bitcode是必须的。 Mac OS不支持bitcode。 如果我们开启了bitcode，在提交包时，下面这个界面也会有个bitcode选项： 盗图，我的应用没办法在这个界面显示bitcode，因为依赖于第三方的库，而这个库不支持bitcode，暂时只能设置ENABLE_BITCODE为NO。 所以，如果我们的工程需要支持bitcode，则必要要求所有的引入的第三方库都支持bitcode。我就只能等着公司那些大哥大姐们啥时候提供一个新包给我们了。 题外话如上面所说，bitcode是一种中间代码。LLVM官方文档有介绍这种文件的格式，有兴趣的可以移步LLVM Bitcode File Format。 参考 App Distribution Guide – App Thinning (iOS, watchOS) What’s New in Xcode-New Features in Xcode 7 开发者所需要知道的 iOS 9 SDK 新特性 LLVM Bitcode File Format]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Bilibili开源框架ijkplayer]]></title>
      <url>%2F2016%2F06%2F26%2Fbilibilikai-yuan-kuang-jia-ijkplayer%2F</url>
      <content type="text"><![CDATA[ijkplayer 是一款做视频直播的框架, 基于ffmpeg, 支持 Android 和 iOS, 网上也有很多集成说明, 但是个人觉得还是不够详细, 在这里详细的讲一下在 iOS 中如何集成ijkplayer, 即便以前从没有接触过, 按着下面做也可以集成成功! 一. 下载ijkplayerijkplayer下载地址:https://github.com/Bilibili/ijkplayer ijkplayer下载地址:https://github.com/Bilibili/ijkplayer下载完成后解压 二. 编译 ijkplayer说是编译 ijkplayer, 其实是编译 ffmpeg, 在这里我们已经下载好了ijkplayer, 所以 github 上README.md中的Build iOS那一步中有一些步骤是不需要的. 说是编译 ijkplayer, 其实是编译 ffmpeg, 在这里我们已经下载好了ijkplayer, 所以 github 上README.md中的Build iOS那一步中有一些步骤是不需要的.下面开始一步一步编译: 说是编译 ijkplayer, 其实是编译 ffmpeg, 在这里我们已经下载好了ijkplayer, 所以 github 上README.md中的Build iOS那一步中有一些步骤是不需要的.下面开始一步一步编译:1.打开终端, cd 到jkplayer-master文件夹中, 也就是下载完解压后的文件夹 2.执行命令行./init-ios.sh, 这一步是去下载 ffmpeg 的, 时间会久一点, 耐心等一下.如下图: 3.在第2步中下载完成后, 执行cd ios, 也就是进入到 ios目录中 4.进入 ios 文件夹后, 在终端依次执行./compile-ffmpeg.sh clean和./compile-ffmpeg.sh all命令, 编译 ffmpeg, 也就是README.md中这两步编译时间较久, 耐心等待一下. 三. 打包IJKMediaFramework.framework框架集成 ijkplayer 有两种方法: 集成 ijkplayer 有两种方法:一种方法是按照IJKMediaDemo工程中那样, 直接导入工程IJKMediaPlayer.xcodeproj, 在这里不做介绍 第二种集成方法是把 ijkplayer 打包成framework导入工程中使用. 下面开始介绍如何打包IJKMediaFramework.framework 首先打开工程IJKMediaPlayer.xcodeproj, 位置如下图: 2.工程打开后设置工程的 scheme 3.设置好 scheme 后, 分别选择真机和模拟器进行编译, 编译完成后, 进入 Finder, 如下图: 进入 Finder 后, 可以看到有真机和模拟器两个版本的编译结果 下面开始合并真机和模拟器版本的 framework, 注意不要合并错了打开终端, 进行合并, 命令行具体格式为: 1lipo -create &quot;真机版本路径&quot; &quot;模拟器版本路径&quot; -output &quot;合并后的文件路径&quot; 下面很重要, 需要用合并后的IJKMediaFramework把原来的IJKMediaFramework替换掉上图中的1、2两步完成后, 绿色框住的那个IJKMediaFramework.framework文件就是我们需要的框架了, 可以复制出来, 稍后我们需要导入工程使用. 四. iOS工程中集成ijkplayer新建工程, 导入合并后的IJKMediaFramework.framework以及相关依赖框架以及相关依赖框架导入框架后, 在ViewController.m进行测试, 首先导入IJKMediaFramework.h头文件, 编译看有没有错, 如果没有错说明集成成功. 导入框架后, 在ViewController.m进行测试, 首先导入IJKMediaFramework.h头文件, 编译看有没有错, 如果没有错说明集成成功.接着开始在ViewController.m文件中使用IJKMediaFramework框架进行测试使用, 写一个简单的直播视频进行测试, 在这里看一下运行后的结果, 后面会放上 Demo 供下载.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[逆向工程 - Reveal、IDA、Hopper、https抓包]]></title>
      <url>%2F2016%2F06%2F23%2Fni-xiang-gong-cheng-reveal-ida-hopper-httpszhua-bao%2F</url>
      <content type="text"><![CDATA[iOS应用的安全性 常常被大家忽视 ##一、iOS 如何做才安全: 详见《iOS如何做才安全》 ##二、ipa文件 1、AppStore里的ipa包 可以通过 iTunes 下载到电脑。iOS8.3以下系统的非越狱的手机上，可以用MAC上的PP助手等软件，直接把手机上的ipa文件(包含沙盒里的存储文件)拷贝到电脑。 如果是越狱手机，都可以用PP助手、itools直接把ipa导出到电脑，并且可以用PP助手、iExplorer、itools这些工具 查看 iOS的系统目录。 MAC上安装 iExplorer软件，用iExplorer 可以看到 手机（非越狱也可以） 在 iTunes上备份的内容。 如果你在帮测试美女的手机 调试问题的时候， 在 iTunes上设置 “连接次iPhone时自动同步”(或者点击 备份到本地电脑),默认该手机上的照片、短信等内容都会备份到你的电脑上，用 iExplorer 就可以看到 这位 美女的隐私。 曾经有次不小心看到同事的隐私信息，所以现在都比较注意这块，避免引发误会。 2、拿到ipa文件后，解压缩，得到.app文件，右键显示包内容，可以看到里面的app中的图片、js、plist、静态H5页 等资源。 比如 你要 用微信里的默认表情包，解压微信的ipa包就可以获取到。 3、iOS的系统目录和MAC上的都类似（类unix系统）。iOS系统的目录图： ##三、沙盒 中的数据 iPhone上 计算器的沙盒： .app文件:应用程序本身的数据，打包时候的一些资源文件（如：图片、plist等文件）、可执行文件。这个目录不会被iTunes同步。 Documents ：存储不可再生 的关键数据。不会被iTunes同步 Library：保存配置文件和其他一些文件。NSUserDefault 会存储到 Library下的Preferences中 的 plist文件中。可以直接打开，所以 也不要在 NSUserDefault 中存一些 关键数据，或者 存储的时候 进行 AES等方式的加密。 Library/Caches可以用来保存可再生的数据，比如网络请求，用户需要负责删除对应文件。 这个目录（除了Library/Caches外）会被iTunes同步 tmp：临时文件。不需要的时候，手动将其内文件删除。（当应用不再运行的时候，系统可能会将此目录清空。） tmp：临时文件。不需要的时候，手动将其内文件删除。（当应用不再运行的时候，系统可能会将此目录清空。）这个目录不会被iTunes同步 存到沙盒的数据都是不安全的，关键数据一定 要做加密存储。 ##四、Reveal 工具：查看 任何APP 的UI结构 1、不越狱的手机 可以用 Reveal 来查看自己APP的UI结构。不能查看其他APP的UI结构。这里就不再描述了。 2、越狱手机 上可以查看 任何APP的UI结构。 在越狱的手机上，在 Cydia 搜索并安装 Reveal Loader，如果搜索不到。就 点下面的“软件源”，选择“BigBoss”,选择“全部软件包”，点右边R的字母，去一个个找到 Reveal Loader，放心吧，你一定能找到的，我用的iOS7.1的系统测试的，没问题。 安装完成后，打开“设置”页面，下拉到最底部，点击“Reveal” 3、点击 Enabled Applictions 。然后选中 你想分析的APP。 4、确保iOS和OSX在同一个IP网段内。打开想分析的 APP，如果该APP已经启动，则关闭后再次启动 5、打开MAC上的 Reveal，选中 左上方列表里的 APP，比如QQ： 6、如果 Reveal 左上方 一直显示：No Connection。说明iPhone上的 Reveal Loader 没安装成功，需要配置一下。 首先从MAC上 用PP助手或 iTools 查看“文件系统（系统）”–》Library文件夹，看 Library文件夹下面有没有 RHRevealLoader 文件夹，如果没有，就 右键 新建文件夹，并修改名字为：RHRevealLoader。 在Mac 下打开已经安装的Reveal，选择标题栏Help下的Show Reveal Library in Finder 下的 iOS library 选项，将会显示如下界面： 将libReveal.dylib 文件通过PP助手拷贝到刚才创建的RHRevealLoader文件夹下，就可以了。 然后 从手机上打开APP， 再 打开 MAC上的 Reveal 软件，左上方 就会出来 相关APP的选项。 再发个 淘宝中的天猫模块吧： ##五、反编译工具：IDA 从AppStore下载的ipa都是加壳的(苹果 把开发者上传的ipa进行了加壳再放到AppStore中)，加壳的ipa要先去壳，可以用clutch、dumpdecrypted、使用gdb调试 等解密去壳工具，这个我们后面再说。 如果你有越狱手机，可以直接 从 PP助手上下载ipa包，这个就是 脱壳后的。。 现在 我们先反编译 自己的APP，通过Xcode打包的APP 都是没加壳的，可以直接用来反编译。 新建一个项目，在 ViewController 的 viewDidLoad 方法里 加 几句代码。 ;) 12345678- (void)viewDidLoad &#123; [super viewDidLoad]; UILabel *label = [[UILabel alloc] initWithFrame:CGRectMake(50, 70, 200, 100)]; label.text = @&quot;CeShiLabel007&quot;; label.backgroundColor = [UIColor redColor]; [self.view addSubview:label];&#125; ;) 将项目 打包，生成 ipa文件，下面我们就用IDA分析一下 ipa。 将ipa文件 解压后 得到.app文件： 下载IDA，并打开： 点击“New”按钮，选择刚才 解压的 .app文件。一路 点击“OK”或者“YES” 就可以了。 打开界面后，双击左侧的 viewDidLoad： 可以看出：代码中的 “CeShiLabel007” 字符串 完全可以反编译出来。所以尽量不要在代码里放一些 关键 的数据。可以通过接口来获取。或者 把 数据进行加密。 从上面的界面中 ，按下键盘的F5，可以 把汇编转成C语言代码。可读性很高。。 你如果试了 就发现你的F5不管用啊，那是因为 F5是一个插件Hex-Rays.Decompiler 的快捷键，这个插件是收费的、收费的。 ##六、反编译工具：Hopper Disassembler 下载 Hopper Disassembler软件。打开ipa解压的.app。 或者直接 把.app拖进去。 双击“viewDidLoad”： 可以看到 汇编代码， “CeShiLabel007” 字符串、setText方法 等。 点击右上角的 if(a) f(x)图标： 会弹出 类似源代码的 伪编码： 代码中可以清楚的看到 处理的逻辑。简单易懂，和看源代码没太大区别。。 下面 是我从越狱手机的PP助手上下载的 微信 的ipa 进行反编译,看下里面的 QQContactInfoViewController 页面 的 viewDidLoad方法里的代码 怎么写的， 截图： 如果 你把从 AppStore下载的 ipa包直接拖到 IDA或Hopper里，看到的就是乱码，刚才已经说过了。AppStore的ipa是加过壳的 。如图： ##七、抓包-https Charles 老版本和 新版本 抓取https 的配置 不一样。。 先看HTTP抓包： 打开Charles程序 查看Mac电脑的IP地址，如192.168.1.7 打开iOS设置，进入当前wifi连接，设置HTTP代理Group，将服务器填为上一步中获得的IP，即192.168.1.7，端口填8888 iOS设备打开你要抓包的app进行网络操作 Charles弹出确认框，点击Allow按钮即可 HTTPS 老版本抓包： 下载Charles证书http://www.charlesproxy.com/ssl.zip，解压后导入到iOS设备中（将crt文件作为邮件附件发给自己，再在iOS设备中点击附件即可安装；也可上传至dropbox之类的网盘，通过safari下载安装） 在Charles的工具栏上点击设置按钮，选择Proxy Settings… 切换到SSL选项卡，选中Enable SSL Proxying 这一步跟Fiddler不同，Fiddler安装证书后就可以抓HTTPS网址的包了，Charles 还 需要在上一步的SSL选项卡的Locations表单填写要抓包的域名和端口，点击Add按钮，在弹出的表单中Host填写域名，比如填api.instagram.com，Port填443 HTTPS 新版本抓包： Charles新版本 的 Proxy Settings 选项里是没有 SSL选项卡的。在左侧的域名上点右键：Enable SSL Proxying，就可以用了。 然后 点击APP，会看到HTTPS解密的json数据。如果接口返回的数据 本身进行了加密，那你看到的还是乱码。 ##七、https - iOS 的代码如何写 2015年4月末，网爆流行IOS网络通信库AFNetworking SSL漏洞，影响银联、中国银行、交通银行在内的2.5万个IOS应用，我来看下 各种网络写法对应的问题。 1、信任任何证书。在 AFNetworking 中 定义 allowInvalidCertificates 为true，表示 忽略所有证书。 123AFHTTPRequestOperationManager * manager = [AFHTTPRequestOperationManager manager];manager.securityPolicy.allowInvalidCertificates = YES; 这种情况下 用我们上面讲的方法，用Charles很容易 破解HTTPS加密的数据。 这种情况，一般是 因为 测试环境 用的不是 CA发的证书，需要忽略掉证书，所以把 allowInvalidCertificates 设为了 true。这个可以用 #ifdef DEBUG 来进行设置。 123#ifdef DEBUGmanager.securityPolicy.allowInvalidCertificates = YES;#endif 2、信任证书管理机构（CA）颁发的证书。 CA颁发的证书，据说这类的证书只需50美元就能买到。此类问题出在AFNetworking 2.5.2及之前的版本，是AF的漏洞（详见新闻）。如果某IOS APP使用了此版本的开源通信库，在不安全Wifi网络中的，黑客 只要使用CA颁发的证书就可以对该APP的HTTPS加密数据进行监听或者篡改。 这个需要升级到 AFNetworking 最新版本，正好最新版本也声明兼容IPv6。 3、信任合法的证书、服务器和客户端双向认证。 这两种也都有办法破解，详见：Bypassing OpenSSL Certificate Pinning in iOS Apps、http://drops.wooyun.org/tips/7838 要正确的使用HTTPS才不会出现上面的问题。接口也一定要用自己的方式进行加密 才真正的放心，把小命完全放到对方(HTTPS)手里，命运就只能靠别人来摆布。。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[WWDC2016 随想]]></title>
      <url>%2F2016%2F06%2F15%2Fwwdc2016-sui-xiang%2F</url>
      <content type="text"><![CDATA[凌晨 1 点钟，熬夜看了今年的 WWDC，一些随想分享给大家。 ###时光 因为刚刚说的原因，结果我到 12 点都还没有睡着，我在迷迷糊糊中躺到了快一点钟，watch 震动了，于是我翻身走到客厅，打开电脑，连上直播地址。对了，还有一些朋友不知道直播地址，大家可以记一下，每年直播地址都是固定的：wwdc.apple.com 。 由于英语不是特别过硬，还是选择了有同声中文字幕的优酷直播。这里要吐槽下优酷的直播分发真的做的挺差的，一起看直播的群友都表示看标清都卡。 ###内容 这次的 WWDC keynote 主要分成 4 个部分，其实就是四个平台：watchOS, tvOS，macOS（原来叫 OS X）, iOS。整个分享中规中矩，分别给大家介绍一下我觉得值得关注的改进吧。 ###watchOS 有些人觉得 watchOS离自己比较遥远,但是对于拥有apple watch 并且饱受启动应用缓慢之苦的我来说简直是天大的福音。 watchOS 推出了 watchOS 3，启动速度快了7倍，基本上是秒开，但是不知道耗电是不是也是更多了。关于这个，后续有一个 session 主题分享《Architecting for Performance on watchOS 3》https://developer.apple.com/videos/play/wwdc2016/227/，感兴趣的朋友可以关注。 增加了 scribbles 功能，其实就是一种手写输入，手写居然还支持中文，我当时就在想：手表这么小的地方，你倒是写一个复杂一点的字试试看呢？我对此功能不太看好。 别的改进都很小，比如增加了滑动更换主题，快速报警，现场还花大力气介绍一款叫 breathe 的应用，而这个应用就是指导你深呼吸的。不知道大家喜不喜欢，反正我是不会用的。 ###tvOS 这部分直接跳过吧，原因你懂的。 ###macOS OS X 更名为了 macOS，可以支持通过 apple watch 解锁电脑了。哦耶，我的手表终于不再只是用来看时间了 ! 剪切版支持从手机上复制，在电脑上粘贴，这个还是挺有用的，我平常都是用 QQ 或微信的文件传输助手做类似的事情。 optimize storage 功能可以把老文件自动存在云端，据说可以节省大概 100G 的空间。不过我猜想，iCloud 的免费空间应该不够用吧？是不是得花钱买些容量才行。 apple pay 可以在 PC 的浏览器上直接支付，点击支付时，需要在手机上确认授权。整个体验类似于拿微信或支付宝扫二维码付款。 siri 可以在 mac 上使用了，并且 siri 的结果可以 pin 在一个列表中，并可以拖动到别的地方。我有一阵子很喜欢用 iPhone 上的 siri，不过还是不太稳定。mac 上一般办公室是不太方便用 siri 的，家里的话要是没有培养出习惯，估计也不太会使用。所以这个功能到底实用性有多大还不确定。 增加了一个名为 picture in picture 的功能，其实就是看视频的时候可以固定住视频。 ###iOS 介绍了 10 个特性，我选一些有意思的介绍吧。 Siri 可以和微信整合，这个很赞，你可以直接用 siri 控制发信息给微信中的好友。 系统的 Map 整合了大量的应用，比如可以在上面看大众点评的评价，可以直接叫滴滴打车。如果做得好，Map 很可能成为一个重要的打车入口，想到这儿就能明白为什么苹果投了滴滴 10 亿美金了。 不过就苹果系统 Map 的那个糟糕体验，我不确定我是否能够接受它。反正我已经喜欢上了高德地图里面的郭德纲和林志玲的声音，离线的地图和导航也很适合中国这种按流量计费的移动网络环境。相比而言，系统自带的 Map 有些不接地气。 homekit 与智能家居的整合，整体的效果非常酷，但整个还需要依赖生态产业的配合。当前来看，国内的小米在这方面做得比苹果还是要快一些。 电话功能终于支持恶意电话提醒了，现场提到用的是腾讯的解决方案。嗯，360 估计是没有翻身的可能了（可能和小周在库克面前炫耀360手机多好用有关）。另外，phone extension 似乎可以做更多的事情。 iMessage 可以发更多的内容，tap to replace to emoji 功能的交互设计还是挺有意思的，省却了选择 emoji 的时间。不过现场演示出现了 Bug，还是挺尴尬的。另外，大家都已经习惯了微信，而且 iMessage 只能和 iPhone 用户发，我觉得这些功能做得再有意思，也没有多大用。大家的直觉还是用微信来社交。 中国元素 这次 WWDC 中多次提到了中国，以及中国的互联网产品，包括微信，大众点评，滴滴。中国为苹果的赢收增长做出了巨大的贡献，我们也能看到苹果越来越重视中国区的需求了。比如恶意来电提醒，就是一个特别针对中国区用户的设计。 ###Developer 这次 Tim Cook 专门介绍了针对开发者做的 iPad 版的 Swift Playground，其实这哪是一个 Playground 啊，这就是一个学习编程的 3D 游戏！整个 App 设计得非常用心，效果看起来也非常棒。 不过 Tim Cook 毕竟是做销售出身的，他不明白，其实我们真正关心的是，Swift 3 什么时候推出啊！结果他在 keynote 上啥都没说，让我们以为 Swift 3 没戏了，结果，我们事后又发现 Swift 3 的内容安静地躺在苹果的官方网站上：https://developer.apple.com/swift/ 。所以说，Tim Cook 还是不了解我们， iPad 版的 Swift Playground 太酷，那也就是给小孩学编程入门用的，大量的程序员还是关心的是 Swift 啥时候稳定，Xcode 有啥有意思的功能不，这些都被 Cook 给忽视了。 还算我眼睛尖，我在他的一页大量的 feature list 中，看到了下面的一行字： 这意味着，Xcode 终于官方支持插件了！妈妈再也不用担心升级 Xcode 的时候插件失效了！我今天翻了一下日程，WWDC 中专门有一个 session 做相关的介绍，是：《Using and Extending the Xcode Source Editor》https://developer.apple.com/videos/play/wwdc2016/414/ ###结语 最后看完 WWDC，已经是零辰 3 点钟了，有一点点失落。今年的内容惊喜不多，但是，我终归是又一次熬夜观看了直播。希望自己能保持这样对技术的激情，也希望苹果明年的 WWDC 能有一些惊喜。 哦，我整理了一个后续值得观注的 session 列表，分享给大家： Improving Existing Apps with Modern Best Practiceshttps://developer.apple.com/videos/play/wwdc2016/213/ What’s New in Cocoa Touchhttps://developer.apple.com/videos/play/wwdc2016/205/ What’s New in Foundation for Swifthttps://developer.apple.com/videos/play/wwdc2016/207/ What’s New in UICollectionView in iOS 10https://developer.apple.com/videos/play/wwdc2016/219/ Typography and Fontshttps://developer.apple.com/videos/play/wwdc2016/803/ Advanced Testing and Continuous Integrationhttps://developer.apple.com/videos/play/wwdc2016/409/ Debugging Tips and Trickshttps://developer.apple.com/videos/play/wwdc2016/417/ Getting Started with Swift ( 有最新 Swift 3 的内容）https://developer.apple.com/videos/play/wwdc2016/404/ Going Server-side with Swift Open Sourcehttps://developer.apple.com/videos/play/wwdc2016/415/ Introduction to Xcode ( 看看 Xcode 8 的新功能有啥）https://developer.apple.com/videos/play/wwdc2016/413/ Swift API Design Guidelineshttps://developer.apple.com/videos/play/wwdc2016/403/ Understanding Swift Performancehttps://developer.apple.com/videos/play/wwdc2016/416/ Using and Extending the Xcode Source Editor（了解 Xcode 编辑器的插件功能）https://developer.apple.com/videos/play/wwdc2016/414/ What’s New in LLVMhttps://developer.apple.com/videos/play/wwdc2016/405/ What’s New in Swifthttps://developer.apple.com/videos/play/wwdc2016/402/ What’s New in Xcode App Signinghttps://developer.apple.com/videos/play/wwdc2016/401/ Concurrent Programming With GCD in Swift 3https://developer.apple.com/videos/play/wwdc2016/720/ NSURLSession: New Features and Best Practiceshttps://developer.apple.com/videos/play/wwdc2016/711/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JSPatch – 动态更新iOS APP]]></title>
      <url>%2F2016%2F06%2F12%2Fjspatch-dong-tai-geng-xin-ios-app%2F</url>
      <content type="text"><![CDATA[只需在项目中引入极小的引擎，就可以使用JavaScript调用任何Objective-C的原生接口，获得脚本语言的能力：动态更新APP，替换项目原生代码修复bug。 用途是否有过这样的经历：新版本上线后发现有个严重的bug，可能会导致crash率激增，可能会使网络请求无法发出，这时能做的只是赶紧修复bug然后提交等待漫长的AppStore审核，再盼望用户快点升级，付出巨大的人力和时间成本，才能完成此次bug的修复。 使用JSPatch可以解决这样的问题，只需在项目中引入JSPatch，就可以在发现bug时下发JS脚本补丁，替换原生方法，无需更新APP即时修复bug。 例子上述代码中取数组元素处可能会超出数组范围导致crash。如果在项目里引用了JSPatch，就可以下发JS脚本修复这个bug： 这样 JPTableViewController 里的 -tableView:didSelectRowAtIndexPath: 就替换成了这个JS脚本里的实现，在用户无感知的情况下修复了这个bug。 更多的使用文档和demo请参考github项目主页。 原理JSPatch用iOS内置的JavaScriptCore.framework作为JS引擎，但没有用它JSExport的特性进行JS-OC函数互调，而是通过Objective-C Runtime，从JS传递要调用的类名函数名到Objective-C，再使用NSInvocation动态调用对应的OC方法。详细的实现原理以及实现过程中遇到的各种坑和hack方法会另有文章介绍。 方案对比目前已经有一些方案可以实现动态打补丁，例如WaxPatch，可以用Lua调用OC方法，相对于WaxPatch，JSPatch的优势是： 1.JS语言 1.JS语言 JS比Lua在应用开发领域有更广泛的应用，目前前端开发和终端开发有融合的趋势，作为扩展的脚本语言，JS是不二之选。 2.符合Apple规则 2.符合Apple规则 JSPatch更符合Apple的规则。iOS Developer Program License Agreement里3.3.2提到不可动态下发可执行代码，但通过苹果JavaScriptCore.framework或WebKit执行的代码除外，JS正是通过JavaScriptCore.framework执行的。 3.小巧 3.小巧 使用系统内置的JavaScriptCore.framework，无需内嵌脚本引擎，体积小巧。 4.支持block 4.支持block wax在几年前就停止了开发和维护，不支持Objective-C里block跟Lua程序的互传，虽然一些第三方已经实现block，但使用时参数上也有比较多的限制。 相对于WaxPatch，JSPatch劣势在于不支持iOS6，因为需要引入JavaScriptCore.framework。另外目前内存的使用上会高于wax，持续改进中。 风险JSPatch让脚本语言获得调用所有原生OC方法的能力，不像web前端把能力局限在浏览器，使用上会有一些安全风险： 1.若在网络传输过程中下发明文JS，可能会被中间人篡改JS脚本，执行任意方法，盗取APP里的相关信息。可以对传输过程进行加密，或用直接使用https解决。 2.若下载完后的JS保存在本地没有加密，在未越狱的机器上用户也可以手动替换或篡改脚本。这点危害没有第一点大，因为操作者是手机拥有者，不存在APP内相关信息被盗用的风险。若要避免用户修改代码影响APP运行，可以选择简单的加密存储。 其他用途 JSPatch可以动态打补丁，自由修改APP里的代码，理论上还可以完全用JSPatch实现一个业务模块，甚至整个APP，跟wax一样，但不推荐这么做，因为： JSPatch和wax一样都是通过Objective-C Runtime的接口通过字符串反射找到对应的类和方法进行调用，这中间的字符串处理会损耗一定的性能，另外两种语言间的类型转换也有性能损耗，若用来做一个完整的业务模块，大量的频繁来回互调，可能有性能问题。 开发过程中需要用OC的思维写JS/Lua，丧失了脚本语言自己的特性。 JSPatch和wax都没有IDE支持，开发效率低。 若想动态为APP添加模块，目前React Native给出了很好的方案，解决了上述三个问题： JS/OC不会频繁通信，会在事件触发时批量传递，提高效率。（详见React Native通信机制详解） 开发过程无需考虑OC的感受，遵从React框架的思想进行纯JS开发就行，剩下的事情React Native帮你处理好了。 React Native连IDE都准备好了。 所以动态添加业务模块目前还是推荐尝试React Native，但React Native并不会提供原生OC接口的反射调用和方法替换，无法做到修改原生代码，JSPatch以小巧的引擎补足这个缺口，配合React Native用统一的JS语言让一个原生APP时刻处于可扩展可修改的状态。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[xcode nib but the view outlet was not set 错误]]></title>
      <url>%2F2016%2F06%2F11%2Fxcode-nib-but-the-view-outlet-was-not-set-cuo-wu%2F</url>
      <content type="text"><![CDATA[xib 中, 没有对File’s Owner 的Outlets view 进行绑定, 导致在父视图中插入子视图时出错, 在IB中拖拽Files’ Owner到view, 添加绑定后, 运行成功!总结一下创建视图和绑定的步骤: 创建控制器. File-&gt;New File-&gt;Iphone OS-&gt;Cocoa Touch Class-&gt;UIViewController subclass; 创建xib. File-&gt;New File-&gt;Iphone OS-&gt;User Interface-&gt;View XIB 绑定controller和view. 用Interface Builder打开xxx.xib, 点击Files’ Owner, 在Identity Inspector里面的Class Identity, 选择Step 1创建的控制器类, 接着拖拽File’s Owner到View中, 选择Outlets-&gt;view.先选中file’s owner(这个很重要)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[UIWindow 和 UIWindowLevel详解]]></title>
      <url>%2F2016%2F06%2F11%2Fuiwindow-he-uiwindowlevelxiang-jie%2F</url>
      <content type="text"><![CDATA[一、UIWindow是一种特殊的UIView，通常在一个程序中只会有一个UIWindow，但可以手动创建多个UIWindow，同时加到程序里面。UIWindow在程序中主要起到三个作用： 1、作为容器，包含app所要显示的所有视图 2、传递触摸消息到程序中view和其他对象 3、与UIViewController协同工作，方便完成设备方向旋转的支持 二、通常我们可以采取两种方法将view添加到UIWindow中： 1、addSubview 直接将view通过addSubview方式添加到window中，程序负责维护view的生命周期以及刷新，但是并不会为去理会view对应的ViewController，因此采用这种方法将view添加到window以后，我们还要保持view对应的ViewController的有效性，不能过早释放。 2、rootViewController rootViewController时UIWindow的一个遍历方法，通过设置该属性为要添加view对应的ViewController，UIWindow将会自动将其view添加到当前window中，同时负责ViewController和view的生命周期的维护，防止其过早释放 三、WindowLevel UIWindow在显示的时候会根据UIWindowLevel进行排序的，即Level高的将排在所有Level比他低的层级的前面。下面我们来看UIWindowLevel的定义： 1234 const UIWindowLevel UIWindowLevelNormal; const UIWindowLevel UIWindowLevelAlert; const UIWindowLevel UIWindowLevelStatusBar; typedef CGFloat UIWindowLevel; iOS系统中定义了三个window层级，其中每一个层级又可以分好多子层级(从UIWindow的头文件中可以看到成员变量CGFloat _windowSublevel;)，不过系统并没有把则个属性开出来。UIWindow的默认级别是UIWindowLevelNormal，我们打印输出这三个level的值分别如下： 2012-03-27 22:46:08.752 UIViewSample[395:f803] Normal window level: 0.000000 2012-03-27 22:46:08.754 UIViewSample[395:f803] Normal window level: 2000.000000 2012-03-27 22:46:08.755 UIViewSample[395:f803] Normal window level: 1000.000000 这样印证了他们级别的高低顺序从小到大为Normal &lt; StatusBar &lt; Alert，下面请看小的测试代码： 运行结果如下图： 我们可以注意到两点： 1）我们生成的normalWindow虽然是在第一个默认的window之后调用makeKeyAndVisible，但是仍然没有显示出来。这说明当Level层级相同的时候，只有第一个设置为KeyWindow的显示出来，后面同级的再设置KeyWindow也不会显示。 2）statusLevelWindow在alertLevelWindow之后调用makeKeyAndVisible，淡仍然只是显示在alertLevelWindow的下方。这说明UIWindow在显示的时候是不管KeyWindow是谁，都是Level优先的，即Level最高的始终显示在最前面。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS 离屏渲染的研究]]></title>
      <url>%2F2016%2F06%2F08%2Fios-liping-xuanran%2F</url>
      <content type="text"><![CDATA[GPU渲染机制：CPU 计算好显示内容提交到 GPU，GPU 渲染完成后将渲染结果放入帧缓冲区，随后视频控制器会按照 VSync 信号逐行读取帧缓冲区的数据，经过可能的数模转换传递给显示器显示。 GPU屏幕渲染有以下两种方式： On-Screen Rendering 意为当前屏幕渲染，指的是GPU的渲染操作是在当前用于显示的屏幕缓冲区中进行。 Off-Screen Rendering意为离屏渲染，指的是GPU在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作。特殊的离屏渲染：如果将不在GPU的当前屏幕缓冲区中进行的渲染都称为离屏渲染，那么就还有另一种特殊的“离屏渲染”方式： CPU渲染。如果我们重写了drawRect方法，并且使用任何Core Graphics的技术进行了绘制操作，就涉及到了CPU渲染。整个渲染过程由CPU在App内 同步地完成，渲染得到的bitmap最后再交由GPU用于显示。备注：CoreGraphic通常是线程安全的，所以可以进行异步绘制，显示的时候再放回主线程，一个简单的异步绘制过程大致如下1234567891011- (void)display &#123; dispatch_async(backgroundQueue, ^&#123; CGContextRef ctx = CGBitmapContextCreate(...); // draw in context... CGImageRef img = CGBitmapContextCreateImage(ctx); CFRelease(ctx); dispatch_async(mainQueue, ^&#123; layer.contents = img; &#125;); &#125;);&#125; 离屏渲染的触发方式设置了以下属性时，都会触发离屏绘制： shouldRasterize（光栅化） masks（遮罩） shadows（阴影） edge antialiasing（抗锯齿） group opacity（不透明） 复杂形状设置圆角等 渐变 其中shouldRasterize（光栅化）是比较特别的一种：光栅化概念：将图转化为一个个栅格组成的图象。光栅化特点：每个元素对应帧缓冲区中的一像素。 shouldRasterize = YES在其他属性触发离屏渲染的同时，会将光栅化后的内容缓存起来，如果对应的layer及其sublayers没有发生改变，在下一帧的时候可以直接复用。shouldRasterize = YES，这将隐式的创建一个位图，各种阴影遮罩等效果也会保存到位图中并缓存起来，从而减少渲染的频度（不是矢量图）。 相当于光栅化是把GPU的操作转到CPU上了，生成位图缓存，直接读取复用。 当你使用光栅化时，你可以开启“Color Hits Green and Misses Red”来检查该场景下光栅化操作是否是一个好的选择。绿色表示缓存被复用，红色表示缓存在被重复创建。 如果光栅化的层变红得太频繁那么光栅化对优化可能没有多少用处。位图缓存从内存中删除又重新创建得太过频繁，红色表明缓存重建得太迟。可以针对性的选择某个较小而较深的层结构进行光栅化，来尝试减少渲染时间。 注意：对于经常变动的内容,这个时候不要开启,否则会造成性能的浪费 例如我们日程经常打交道的TableViewCell,因为TableViewCell的重绘是很频繁的（因为Cell的复用）,如果Cell的内容不断变化,则Cell需要不断重绘,如果此时设置了cell.layer可光栅化。则会造成大量的离屏渲染,降低图形性能。 为什么会使用离屏渲染 当使用圆角，阴影，遮罩的时候，图层属性的混合体被指定为在未预合成之前不能直接在屏幕中绘制，所以就需要屏幕外渲染被唤起。 屏幕外渲染并不意味着软件绘制，但是它意味着图层必须在被显示之前在一个屏幕外上下文中被渲染（不论CPU还是GPU）。 所以当使用离屏渲染的时候会很容易造成性能消耗，因为在OPENGL里离屏渲染会单独在内存中创建一个屏幕外缓冲区并进行渲染，而屏幕外缓冲区跟当前屏幕缓冲区上下文切换是很耗性能的。 Instruments监测离屏渲染 Instruments的Core Animation工具中有几个和离屏渲染相关的检查选项： Color Offscreen-Rendered Yellow开启后会把那些需要离屏渲染的图层高亮成黄色，这就意味着黄色图层可能存在性能问题。 Color Hits Green and Misses Red如果shouldRasterize被设置成YES，对应的渲染结果会被缓存，如果图层是绿色，就表示这些缓存被复用；如果是红色就表示缓存会被重复创建，这就表示该处存在性能问题了。 iOS版本上的优化iOS 9.0 之前UIimageView跟UIButton设置圆角都会触发离屏渲染 iOS 9.0 之后UIButton设置圆角会触发离屏渲染，而UIImageView里png图片设置圆角不会触发离屏渲染了，如果设置其他阴影效果之类的还是会触发离屏渲染的。 这可能是苹果也意识到离屏渲染会产生性能问题，所以能不产生离屏渲染的地方苹果也就不用离屏渲染了。 引用出处:iOS离屏渲染]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS控制器总结]]></title>
      <url>%2F2016%2F06%2F07%2Fioskong-zhi-qi-tiao-zhuan-zong-jie%2F</url>
      <content type="text"><![CDATA[以FirstViewController(FVC)的按钮button点击后跳转到SecondViewController(SVC)为例说明: 方式一：Storyboard的segues方式鼠标点击按钮button然后按住control键拖拽到SVC页面，在弹出的segue页面中选择跳转模式即可 segues方式优点:操作方便,无代码生成,在storyboard中展示逻辑清晰 缺点:页面较多时不方便查看,团队合作时可维护性差, 多人合作时不建议使用这种方式。 方式二：选项卡UITabBarController控制器通过调用UITabBarController的addChildViewController方法添加子控制器，代码实例如下： UITabBarController *tabbarVC = [[ UITabBarController alloc ] init ]; FirstViewController *FVC = [[FirstViewController ] init ]; FVC.tabBarItem.title = @”控制器1”; FVC.tabBarItem.image = [ UIImage imageNamed : @”first.png”]; SecondViewController *SVC = [[SecondViewController ] init ]; SVC.tabBarItem.title = @”控制器2”; SVC. tabBarItem.image = [UIImage imageNamed : @”new.png”]; // 添加子控制器（这些子控制器会自动添加到UITabBarController的 viewControllers 数组中） [tabbarVC addChildViewController :FVC]; [tabbarVC addChildViewController :SVC]; 优点:代码量较少 缺点:tabbar的ios原生样式不太好看,(不常用,目前不建议使用),如果要使用,建议自定义tabbar 方式三：导航控制器UINavigationController// 在FVC的button的监听方法中调用: [self.navigationController pushViewController:newC animated:YES];//跳转到下一页面 // 在SVC的方法中调用: [self.navigationController popViewControllerAnimated:YES];//返回上一页面 //当有多次跳转发生并希望返回根控制器时,调用: [self .navigationController popToRootViewControllerAnimated: YES ];//返回根控制器,即最开始的页面 方式四：利用 Modal 形式展示控制器// 在FVC中调用: [ self presentViewController:SVC animated: YES completion:nil]; // 在SVC中调用: [ self dismissViewControllerAnimated: YES completion: nil ]; 方式五：直接更改 UIWindow 的 rootViewController总结：Storyboard方式适合个人开发小程序时使用,有团队合作或者项目较大时不建议使用 UITabBarController因为目前系统的原生样式不太美观,不建议使用 推荐使用UINavigationController和Modal,无明显缺点,而且目前大部分程序都使用这两种方式,只是看是否需要导航控制器而确定使用哪种方案]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[基于Google I/O 大会，寻求人工智能的意义]]></title>
      <url>%2F2016%2F05%2F26%2Fce-shi%2F</url>
      <content type="text"><![CDATA[如今科技圈都在谈人工智能。好像突然之间有一股莫名的力量，从图像识别，到虚拟助手聊天机器人。最近，在 Google 的 I/O 大会上，AI 成为了讨论的前沿科技和中心，参会的 7,000 名开发者和媒体都期望 Google 成为未来的巅峰。Google CEO Sundar Pichai 没有打消人们的热情，最后在 AI 部分结束时，他直接引用了《星际迷航》中的台词：“以前以为不可能的事情，事实上会变为可能。” AI 在我们日常生活中发挥的作用越来越重要，但是关于 AI 的发展最有趣的方面是我们对它是干什么的知之甚少。如果 AI 真的能够改变世界，我们首先要做的是看一下它的定义，Google I/O 大会之外，我们还能从哪里了更好地了解它呢？ 当我采访别人 “你会如何定义 AI” 时，他们这样回答： “这个问题，你最好去采访一下别人吧。” “我不太确定，我还没有使用 AI 处理过事情。” “不好意思，你去采访下别人吧，祝你好运。” “对不起，我在打电话。” “我对 AI 不太了解。” “它是机器学习。” “我不清楚，你问别人吧。” “我在雅虎工作……” 但是，并不是所有人对 AI 都一无所知。票务大师的一名领导 Dan Cernoch 说到，他认为真正的 AI 就像电脑复制了人类大脑中的功能，但是距离实现这一目标还有很远的距离。Cernoch 说人们称之为 AI 的产品实质上是 “机器学习”。很多人把机器学习类的产品统称为 AI。我们稍后再做详细解释。 另一个人这样说：“AI 是指机器开始变得比他们预设的程序更加智能。” 除了可以反馈人们之前给它灌输的知识外，AI 还可以有个人的见解。它可以自己了解事情，不仅仅是被告知如何去做。 我们发现很难找到关于 AI 的定义，于是找到了 Google 的高级研究研究员 Greg Corrado，寻求专家的建议。Greg Corrado 解释道：“人工智能是让机器更加智能的艺术和科学。” 但是这个定义太宽泛了，他很快就聚焦到机器学习上，他认为机器学习是 AI 最大的增长领域。Corrado 说：“我们不是直接编写程序让计算机变得更加聪明，我们编写程序，让计算机自己学习。” 解释机器学习这个抽象概念最好的方法是通过具体的案例，Corrado 从图像识别开始介绍。你可以向计算机提供大量已经识别出的图像，然后教计算机识别特定事物的图像。举例来说，向计算机提供很多猫的照片，计算机可以学习如何识别含有猫的新图像。 计算机通过所谓的 “神经网络” 识别图像，Corrado 说 “神经网络” 是仿照人类的大脑设计的，大脑中数十亿的神经都会根据信息作出决策，但是所有的神经一起工作的话可以处理高级的思维任务。“智能是指这些数十亿个单个神经出现了协同一致的行为。” 人工智能也有神经。在介绍神经网络时，Corrado 说：“我们在每个功能之上创建新的功能，然后他们会学会共同协作处理任务。” 我们再回到刚才提到的图像识别案例，Corrado 解释道，这些人工神经会扫描每个图像的小像素块，并对此进行判断。“它都是白色的吗? 它都是黑色的吗？它有边界吗？哪里边界点？” 大量的人工神经可以扫描图像，并且将他们的结论传递给另外的神经，机器会根据已有的数据做出自己的决策。最终，神经网络可以决定图像是一张面孔、一辆汽车或者是一辆卡车。 机器学习和图像识别的工作原理相似。这种原理同样适用于语言翻译，它们使用相同的方法通过分析语音推断出文字。当它识别出文字之后，它就可以通过翻译程序进行翻译。Corrado 说 “它会在音频流里寻求信号，然后进行猜测，翻译这个词时该输出什么？” 当谈到使用机器学习预定电影票时，Corrado 解释道其中的部分工作不是 AI 做的。“当你创建整个产品时，有各种各样的子系统，例如，当你在当地电影院查看电影播放时间时，你想要获得的是对新的直接的、完美的检索。你可以写一个程序帮你做到这一点，但是没有必要试着学习如何以一种更软的方式进行处理。机器学习最适合用在这种有很多直观步骤的地方。” Google 基于 AI 的产品不会进行自我创造，至少现在不会。]]></content>
    </entry>

    
  
  
</search>
