<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Xiaodong&#39;s Blog</title>
  <subtitle>Talk is cheap, show me the code.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://godknow.cn/"/>
  <updated>2016-12-29T06:50:43.000Z</updated>
  <id>http://godknow.cn/</id>
  
  <author>
    <name>晓东儿</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>fragment 不重叠</title>
    <link href="http://godknow.cn/2016/12/29/2016-12-29/"/>
    <id>http://godknow.cn/2016/12/29/2016-12-29/</id>
    <published>2016-12-29T06:38:10.000Z</published>
    <updated>2016-12-29T06:50:43.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="fragment-不重叠"><a href="#fragment-不重叠" class="headerlink" title="fragment 不重叠"></a>fragment 不重叠</h1><p>写过类似微博这种tab结构的人都知道，使用的是fragment实现，但是fragment有个问题，就是官方其实没有说明白这个东西到底应该怎么用。比如如果简单的使用rplace来切换tab切换fragment会导致每次都会刷新的问题<br>使用hide和show显示fragment会带来重叠的问题。</p>
<p>###为什么会出现重叠的现象?<br>因为Activity在内存不足的时候被回收了，再次打开的时候恢复了Activity，之前的Fragment还在Activity中，但是你又重新创建了Fragment,并且Add回去了，所以就重叠了。</p>
<a id="more"></a>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;fragment-不重叠&quot;&gt;&lt;a href=&quot;#fragment-不重叠&quot; class=&quot;headerlink&quot; title=&quot;fragment 不重叠&quot;&gt;&lt;/a&gt;fragment 不重叠&lt;/h1&gt;&lt;p&gt;写过类似微博这种tab结构的人都知道，使用的是fragment实现，但是fragment有个问题，就是官方其实没有说明白这个东西到底应该怎么用。比如如果简单的使用rplace来切换tab切换fragment会导致每次都会刷新的问题&lt;br&gt;使用hide和show显示fragment会带来重叠的问题。&lt;/p&gt;
&lt;p&gt;###为什么会出现重叠的现象?&lt;br&gt;因为Activity在内存不足的时候被回收了，再次打开的时候恢复了Activity，之前的Fragment还在Activity中，但是你又重新创建了Fragment,并且Add回去了，所以就重叠了。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>OpenCV学习开发笔记(iOS9)</title>
    <link href="http://godknow.cn/2016/12/29/OpenCVLearning/"/>
    <id>http://godknow.cn/2016/12/29/OpenCVLearning/</id>
    <published>2016-12-29T01:52:38.000Z</published>
    <updated>2016-12-29T06:40:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文章采用的的开发环境为：<br>1）Xcode 8.2<br>2）OpenCV for iOS 3.2 </p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近公司项目进入了较为稳定的维护周期，考虑到后面很可能会进行需要生物特征识别的项目，提前学习下OpenCV，也在此和大家分享一下。</p>
<h1 id="OpenCV介绍"><a href="#OpenCV介绍" class="headerlink" title="OpenCV介绍"></a>OpenCV介绍</h1><p>OpenCV ，是一个开源的跨平台计算机视觉和机器学习库，通俗点的说，就是他给计算机提供了一双眼睛，一双可以从图片中获取信息的眼镜，从而完成人脸识别、去红眼、追踪移动物体等等的图像相关的功能。更多具体的说明可参见 OpenCV 官网。</p>
<h1 id="导入工程"><a href="#导入工程" class="headerlink" title="导入工程"></a>导入工程</h1><p>首先下载从官网<a href="http://opencv.org/" target="_blank" rel="external">OpenCV官网</a>下载的iOS支持库，我们新建一个工程。</p>
<p><img src="http://oiu3ghos7.bkt.clouddn.com/14829768918916.jpg" alt="搭建环境"></p>
<p>导入 OpenCV 到 Xcode 的工程中还是比较简单的，从官网下载对应的 framework，直接丢到 Xcode 的工程中，从xcode7以后拖入的工程会自动添加到Building phase里面，检查一下。<br><img src="http://oiu3ghos7.bkt.clouddn.com/14829783173349.jpg" alt=""></p>
<p>然后在你想用 OpenCV 的地方引入 OpenCV 的头文件：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></div><div class="line"></div><div class="line">```    </div><div class="line"></div><div class="line">或者直接在 PCH 文件中添加：  </div><div class="line">  </div><div class="line">```objc</div><div class="line"><span class="meta">#ifdef __cplusplus</span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></div><div class="line"><span class="meta">#endif</span></div><div class="line"></div><div class="line">```    </div><div class="line">&lt;!-- more --&gt;</div><div class="line"></div><div class="line">*关于这个宏下面会有解释说明*</div><div class="line"></div><div class="line">然后把使用到 OpenCV 中 C++方法的实现文件后缀名改成.mm，就可以开始使用 OpenCV 的方法了。</div><div class="line"></div><div class="line">看起来很简单，然而实际操作中还是有不少的问题。</div><div class="line"></div><div class="line"><span class="meta"># 实际使用</span></div><div class="line"></div><div class="line">由于OpenCV代码是基于C++编写的，因此，要在项目中运行c++代码，需要将实现文件名后缀由`.m`改成`.mm`，如下图所示。</div><div class="line">![](http:<span class="comment">//oiu3ghos7.bkt.clouddn.com/14829787278230.jpg)</span></div><div class="line"></div><div class="line">再次强调一次使用opencv的类名一定要改成.mm!</div><div class="line"></div><div class="line"></div><div class="line">说了那么多先测试一下吧!</div><div class="line"></div><div class="line"></div><div class="line">```objc</div><div class="line"><span class="meta">#import <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;opencv2/imgproc/types_c.h&gt;</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;opencv2/imgcodecs/ios.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#import <span class="meta-string">"ViewController.h"</span></span></div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></div><div class="line">&#123;</div><div class="line">     cv::Mat cvImage;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIImageView</span> *imgView;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    </div><div class="line">    <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"learn.jpg"</span>];</div><div class="line">    </div><div class="line">    <span class="built_in">UIImageToMat</span>(image, cvImage);</div><div class="line">    </div><div class="line">    <span class="keyword">if</span>(!cvImage.empty())&#123;</div><div class="line">        cv::Mat gray;</div><div class="line">        <span class="comment">// 将图像转换为灰度显示</span></div><div class="line">        cv::cvtColor(cvImage,gray,CV_RGB2GRAY);</div><div class="line">        <span class="comment">// 应用高斯滤波器去除小的边缘</span></div><div class="line">        cv::GaussianBlur(gray, gray, cv::Size(<span class="number">5</span>,<span class="number">5</span>), <span class="number">1.2</span>,<span class="number">1.2</span>);</div><div class="line">        <span class="comment">// 计算与画布边缘</span></div><div class="line">        cv::Mat edges;</div><div class="line">        cv::Canny(gray, edges, <span class="number">0</span>, <span class="number">50</span>);</div><div class="line">        <span class="comment">// 使用白色填充</span></div><div class="line">        cvImage.setTo(cv::Scalar::all(<span class="number">225</span>));</div><div class="line">        <span class="comment">// 修改边缘颜色</span></div><div class="line">        cvImage.setTo(cv::Scalar(<span class="number">0</span>,<span class="number">128</span>,<span class="number">255</span>,<span class="number">255</span>),edges);</div><div class="line">        <span class="comment">// 将Mat转换为Xcode的UIImageView显示</span></div><div class="line">        <span class="keyword">self</span>.imgView.image = MatToUIImage(cvImage);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>原图<br><img src="http://oiu3ghos7.bkt.clouddn.com/finn.jpg" alt="finn-w290"></p>
<p>运行在模拟器上的效果<br><img src="http://oiu3ghos7.bkt.clouddn.com/14829830035512.jpg" alt="运行效果"></p>
<h1 id="遇到问题"><a href="#遇到问题" class="headerlink" title="遇到问题"></a>遇到问题</h1><p>这是第一次导入C++的库进工程中，所以还是摸索了一段时间。</p>
<ol>
<li>第一次编译的时候遇到一个问题，编译器报了个警告是<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#if defined(NO)</div><div class="line">#  warning Detected Apple &apos;NO&apos; macro definition, it can cause build conflicts. Please, include this header before any Apple headers.</div><div class="line">#endif</div></pre></td></tr></table></figure>
</li>
</ol>
<p>按照提示说明，OpenCV的头文件应该在所有APPLE的头文件之前导入，不然会抛出异常，把import调到最前面即可。</p>
<ol>
<li><p>为何在 PCH 文件中引入 OpenCV 的头文件我们需要多加<code>#ifdef __cpluseplus</code>这一部分呢？这是因为 PCH 文件是一个会被<strong>所有的文件</strong>引入的头文件，而我们又希望 <code>#import &lt;opencv2/opencv.hpp&gt;</code>这部分只会被一些 C++实现文件编译，所以我们加上<code>#ifdef __cpluseplus</code>来表示这是 <code>C++</code> 文件才会编译的，除了<code>#ifdef __cpluseplus</code>，还有<code>#ifdef __OBJC__</code>这样的宏来说明编译规则（按照 OC 文件编译），这样的宏多出现于一些会被多种类型的实现文件引用的头文件中。</p>
</li>
<li><p>另外注意另一个问题：如果一个头文件是C++类型的头文件，那么一定要保证所有<code>直接</code>或者<code>间接</code>引用这个头文件的实现文件都要为.mm或者.cpp，否则 Xcode 就不会把这个头文件当做 C++头文件来编译，就会出现最基本的<code>#include &lt;iostream&gt;</code>这种引用都会报出<code>file not found</code>这样的编译错误的问题。我在编译的过程中，某个C++头文件 A.h 被 B.h 引用，然后 B.h 又被 C.m 引用，虽然 B 的实现文件是 B.mm ，但是仍然报出了之前说的那个错误<br>感谢 StackOberflow 让我找到了问题发生的原因。所以对于 C++ 头文件的引用一定要注意，但凡是引用了 A.h 的实现部分，都必须是.mm或者.cpp后缀名。（同时我们也可以知道，Xcode 是根据头文件被引用的情况来判定头文件的编译 类型的）。</p>
</li>
</ol>
<h1 id="转换UIImage和cv-Mat"><a href="#转换UIImage和cv-Mat" class="headerlink" title="转换UIImage和cv::Mat"></a>转换UIImage和cv::Mat</h1><p>在 OpenCV 中同常用 cv::Mat 表示图片，而 iOS 中则是 UIImage 来表示图片，但openCV的<a href="http://docs.opencv.org/2.4/doc/tutorials/ios/image_manipulation/image_manipulation.html#opencviosimagemanipulation" target="_blank" rel="external">官方教程</a>已经给出了方法。</p>
<h2 id="UIImage-to-cv-Mat"><a href="#UIImage-to-cv-Mat" class="headerlink" title="UIImage to cv::Mat"></a>UIImage to cv::Mat</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">    - (cv::Mat)cvMatFromUIImage:(<span class="built_in">UIImage</span> *)image</div><div class="line">&#123;</div><div class="line">  <span class="built_in">CGColorSpaceRef</span> colorSpace = <span class="built_in">CGImageGetColorSpace</span>(image.CGImage);</div><div class="line">  <span class="built_in">CGFloat</span> cols = image.size.width;</div><div class="line">  <span class="built_in">CGFloat</span> rows = image.size.height;</div><div class="line"></div><div class="line">  cv::Mat cvMat(rows, cols, CV_8UC4); <span class="comment">// 8 bits per component, 4 channels (color channels + alpha)</span></div><div class="line"></div><div class="line">  <span class="built_in">CGContextRef</span> contextRef = <span class="built_in">CGBitmapContextCreate</span>(cvMat.data,                 <span class="comment">// Pointer to  data</span></div><div class="line">                                                 cols,                       <span class="comment">// Width of bitmap</span></div><div class="line">                                                 rows,                       <span class="comment">// Height of bitmap</span></div><div class="line">                                                 <span class="number">8</span>,                          <span class="comment">// Bits per component</span></div><div class="line">                                                 cvMat.step[<span class="number">0</span>],              <span class="comment">// Bytes per row</span></div><div class="line">                                                 colorSpace,                 <span class="comment">// Colorspace</span></div><div class="line">                                                 kCGImageAlphaNoneSkipLast |</div><div class="line">                                                 kCGBitmapByteOrderDefault); <span class="comment">// Bitmap info flags</span></div><div class="line"></div><div class="line">  <span class="built_in">CGContextDrawImage</span>(contextRef, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, cols, rows), image.CGImage);</div><div class="line">  <span class="built_in">CGContextRelease</span>(contextRef);</div><div class="line"></div><div class="line">  <span class="keyword">return</span> cvMat;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="cv-Mat-to-UIImage"><a href="#cv-Mat-to-UIImage" class="headerlink" title="cv::Mat to UIImage"></a>cv::Mat to UIImage</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">-(<span class="built_in">UIImage</span> *)<span class="built_in">UIImageFromCVMat</span>:(cv::Mat)cvMat</div><div class="line">&#123;</div><div class="line">  <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithBytes:cvMat.data length:cvMat.elemSize()*cvMat.total()];</div><div class="line">  <span class="built_in">CGColorSpaceRef</span> colorSpace;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (cvMat.elemSize() == <span class="number">1</span>) &#123;<span class="comment">//可以根据这个决定使用哪种</span></div><div class="line">      colorSpace = <span class="built_in">CGColorSpaceCreateDeviceGray</span>();</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">      colorSpace = <span class="built_in">CGColorSpaceCreateDeviceRGB</span>();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="built_in">CGDataProviderRef</span> provider = <span class="built_in">CGDataProviderCreateWithCFData</span>((__bridge <span class="built_in">CFDataRef</span>)data);</div><div class="line"></div><div class="line">  <span class="comment">// Creating CGImage from cv::Mat</span></div><div class="line">  <span class="built_in">CGImageRef</span> imageRef = <span class="built_in">CGImageCreate</span>(cvMat.cols,                                 <span class="comment">//width</span></div><div class="line">                                     cvMat.rows,                                 <span class="comment">//height</span></div><div class="line">                                     <span class="number">8</span>,                                          <span class="comment">//bits per component</span></div><div class="line">                                     <span class="number">8</span> * cvMat.elemSize(),                       <span class="comment">//bits per pixel</span></div><div class="line">                                     cvMat.step[<span class="number">0</span>],                            <span class="comment">//bytesPerRow</span></div><div class="line">                                     colorSpace,                                 <span class="comment">//colorspace</span></div><div class="line">                                     kCGImageAlphaNone|kCGBitmapByteOrderDefault,<span class="comment">// bitmap info</span></div><div class="line">                                     provider,                                   <span class="comment">//CGDataProviderRef</span></div><div class="line">                                     <span class="literal">NULL</span>,                                       <span class="comment">//decode</span></div><div class="line">                                     <span class="literal">false</span>,                                      <span class="comment">//should interpolate</span></div><div class="line">                                     kCGRenderingIntentDefault                   <span class="comment">//intent</span></div><div class="line">                                     );</div><div class="line"></div><div class="line"></div><div class="line">  <span class="comment">// Getting UIImage from CGImage</span></div><div class="line">  <span class="built_in">UIImage</span> *finalImage = [<span class="built_in">UIImage</span> imageWithCGImage:imageRef];</div><div class="line">  <span class="built_in">CGImageRelease</span>(imageRef);</div><div class="line">  <span class="built_in">CGDataProviderRelease</span>(provider);</div><div class="line">  <span class="built_in">CGColorSpaceRelease</span>(colorSpace);</div><div class="line"></div><div class="line">  <span class="keyword">return</span> finalImage;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文章采用的的开发环境为：&lt;br&gt;1）Xcode 8.2&lt;br&gt;2）OpenCV for iOS 3.2 &lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近公司项目进入了
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://godknow.cn/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="人脸识别" scheme="http://godknow.cn/tags/%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/"/>
    
  </entry>
  
  <entry>
    <title>iOS开发 之 运动GPS采样处理</title>
    <link href="http://godknow.cn/2016/09/23/ioskai-fa-zhi-yun-dong-gpscai-yang-chu-li-2/"/>
    <id>http://godknow.cn/2016/09/23/ioskai-fa-zhi-yun-dong-gpscai-yang-chu-li-2/</id>
    <published>2016-09-23T05:29:52.000Z</published>
    <updated>2016-09-28T06:28:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>iOS提供了获取位置信息的类，CLLocationManager。<br>通过它，我们可以轻松得到包含位置信息的对象CLLocation。</p>
<p>但正常情况下在运动中，会不断得到CLLocation，而其中很多点都是无效的。<br>如果不去掉，将导致里程，速度，配速等一系列数据误差非常大。</p>
<p>查询了一下资料，国内这一块的资料的确比较少，<br>这里我针对常见的误差情况，用最简单明了的方法，教你判断无效的GPS点。</p>
<p><strong>一、静止不动</strong><br>上一个GPS点的瞬时速度为零，当前点的瞬时速度也为0,那么当前点无效.<br>瞬时速度就是CLLocation对象的属性speed。</p>
<p><strong>二、GPS信号太差</strong><br>信号是CLLocation的属性horizontalAccuracy，表示水平方向的误差值。<br>当这个值大于70，我们认为信号太差。</p>
<p><strong>三、无效移动</strong><br>前后两个GPS点的距离，小于horizontalAccuracy * (0.5~0.66)，我们认为这个点是无效移动。</p>
<p><strong>四、平均速度过大</strong><br>如果当前点到上一个点的距离 / 当前点到上一个点的时间<br>速度大于某一个值，则认为当前点无效<br>比如跑步，博尔特最快是10.44m/s</p>
<p><strong>五、采样频率</strong><br>如果不想GPS点过于密集，可以用时间限制。<br>如果当前点的时间到上一个点事件小于2s，则认为点无效。<br>另外也可以用位置管理器的distanceFilter属性来设置。<br>当distanceFilter = 30的时候，只有超过30m的移动，才会进入到位置更新的回调方法。<br>这样做的好处是设备可以更加省电，CPU的占用更低，根据实际情况而定。</p>
<p>总结了几种常见gps点的过滤方法，希望对大家有帮助。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;iOS提供了获取位置信息的类，CLLocationManager。&lt;br&gt;通过它，我们可以轻松得到包含位置信息的对象CLLocation。&lt;/p&gt;
&lt;p&gt;但正常情况下在运动中，会不断得到CLLocation，而其中很多点都是无效的。&lt;br&gt;如果不去掉，将导致里程，速度，配速
    
    </summary>
    
    
      <category term="GPS" scheme="http://godknow.cn/tags/GPS/"/>
    
  </entry>
  
  <entry>
    <title>响应者链条传递事件</title>
    <link href="http://godknow.cn/2016/09/12/xiang-ying-zhe-lian-tiao-chuan-di-shi-jian/"/>
    <id>http://godknow.cn/2016/09/12/xiang-ying-zhe-lian-tiao-chuan-di-shi-jian/</id>
    <published>2016-09-12T05:15:11.000Z</published>
    <updated>2016-09-12T05:16:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>开篇先说点废话吧，最近整个人都很烦躁，也许跟天气有关吧，也很久没有静下来写一些东西了，最近也一直忙着新项目，也很纠接新项目应该采用什么样的结构去写才好迭代、维护。最终按自己的一写想法采用了Controller View ViewHander的模式（有点类似MVVM），因为这个Demo按照这个想法来写的所以这里简单说下，就不过多的讨论这个了，回到主题上UIResponder来，没有说之前我们先看一个图我们开发中经常遇到的：</p>
<p><img src="http://ww2.sinaimg.cn/large/65e4f1e6gw1f7qq6xkecej20af0ik75x.jpg" alt=""></p>
<p>很简单就是在UITableViewCell 放了一个UIButton 那我们怎么样接收这个Button的点击事件? 你第一时间可能会想到Delegate,Block？的确它们都可以实现我们的需求，Delegate我们要多写点代码，Block 如果我们的事件逻辑复杂点就会再赋值时写很多代码，当然你可以用一个简单的Block把处理的业务代封装成方法，再这个调用这方法，也可以把代码弄的简洁点，最重要我一定要考虑<strong>循环引用</strong>的问题。那我们能不能用UIResponder 传递这个事件呢，在我们想要的地方捕获这个事件呢? 我们先来看看iOS 事件是怎么传递的我们看个图：</p>
<a id="more"></a>
<p><img src="http://ww4.sinaimg.cn/large/65e4f1e6gw1f7qq6j34v9j20eu04g0st.jpg" alt=""></p>
<p>如上图，iOS中事件传递首先从App(UIApplication)开始，接着传递到Window(UIWindow)，在接着往下传递到View之前，Window会将事件交给GestureRecognizer，如果在此期间，GestureRecognizer识别了传递过来的事件，则该事件将不会继续传递到View去，而是像我们之前说的那样交给Target(ViewController)进行处理。（注：详细原理可以自己进行搜索学习）我们大致知道事件产生最先识别是的 AppDelegate，然后一层层往下找看事件发生那个view上，直到找个这个view,然后看个view 能不能响应这个事件。那我们现在再说说响应者链先看个张图：</p>
<p><img src="http://ww1.sinaimg.cn/large/65e4f1e6gw1f7qq6ipf1hj20jy09t75c.jpg" alt=""></p>
<p>我知道了当事触摸事件发生，通过一层层找到的这个View ,找到这个View 后先判断这个view能不能响应这个事件，如果不能那就继续找nextResponder我们看上面图可以看出如果一个View有SuperView 那么这个View的nextResponder 就是他的SuperView，如果没有SuperView 那么它的nextResponder 就是他所在ViewController 然后就这样一直找下去，直到找到或抛出异常。<br>我们了解这机制后那我们怎么把这个UIButton Click 事件传递出来呢，我们先来给UIResponder 添加一个我们自定义的事件，我就让它传递我们这个事件出去。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#import &quot;UIResponder+Router.h&quot;</div><div class="line"></div><div class="line">@implementation UIResponder (Router)</div><div class="line"> // eventName 只是作个标记，当我们需要在一个页面传递个事件时我们可以进区分，userInfo 为了省劲就没有封装，你可以针对性再封装下</div><div class="line">- (void)routerEventWithName:(NSString *)eventName userInfo:(NSDictionary *)userInfo &#123;</div><div class="line">      [[self nextResponder] routerEventWithName:eventName userInfo:userInfo];</div><div class="line"> &#125;</div><div class="line"> @end</div></pre></td></tr></table></figure>
<p>那我们怎么进行传递呢，那就是我们手动的去让响应者链传递这个事件<br>我们先看下工程的代码文件：<br><strong>View</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">#import &quot;TestView.h&quot;</div><div class="line">#import &quot;TestViewTableDataSource.h&quot;</div><div class="line"></div><div class="line">@implementation TestView &#123;</div><div class="line">    UITableView *_tableView;</div><div class="line">&#125;</div><div class="line"></div><div class="line"> - (instancetype)initWithController:(SBBaseViewController *)controller &#123;</div><div class="line">   self = [super initWithController:controller];</div><div class="line">   if (self) &#123;</div><div class="line">    [self setup];</div><div class="line">    &#125;</div><div class="line">     return self;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> - (void)setup &#123;</div><div class="line"></div><div class="line">    _tableView = [[UITableView alloc] initWithFrame:CGRectZero style:UITableViewStylePlain];</div><div class="line">    _tableView.delegate = self;</div><div class="line">    _tableView.rowHeight = 60;</div><div class="line">    _tableView.translatesAutoresizingMaskIntoConstraints = NO;</div><div class="line">    [_tableView registerClass:[TestViewTableCell class] forCellReuseIdentifier:@&quot;cell&quot;];</div><div class="line">    [self addSubview:_tableView];</div><div class="line">    [self addConstraints:[NSLayoutConstraint constraintsWithVisualFormat:@&quot;H:|-0-[_tableView]-0-|&quot; options:0 metrics:nil views:NSDictionaryOfVariableBindings(_tableView)]];</div><div class="line">    [self addConstraints:[NSLayoutConstraint constraintsWithVisualFormat:@&quot;V:|-0-[_tableView]-0-|&quot; options:0 metrics:nil views:NSDictionaryOfVariableBindings(_tableView)]];</div></pre></td></tr></table></figure>
<p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (void)setHandler:(SBBaseHandler *)handler &#123;</div><div class="line">    [super setHandler:handler];</div><div class="line">    // 把tableViewDataSource 分离出去</div><div class="line">    TestViewTableDataSource *tableViewDataSoure = [[TestViewTableDataSource alloc] initWithTableView:_tableView];</div><div class="line"></div><div class="line">    _tableView.dataSource = tableViewDataSoure;</div><div class="line">    self.handler.tableDataSource = tableViewDataSoure;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)didLoad &#123;</div><div class="line">    [self.handler loadData];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>Controller</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">#import &quot;TestViewController.h&quot;</div><div class="line">#import &quot;TestView.h&quot;</div><div class="line">#import &quot;TestViewHandler.h&quot;</div><div class="line"></div><div class="line">@interface TestViewController ()</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation TestViewController</div><div class="line"></div><div class="line">- (void)loadView &#123;</div><div class="line">    [super loadView];</div><div class="line">    TestView *view = [[TestView alloc]initWithController:self];</div><div class="line">    TestViewHandler *handler = [[TestViewHandler alloc] init];</div><div class="line">    view.handler = handler;</div><div class="line">    self.view = view;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    // Do any additional setup after loading the view.</div><div class="line">    self.title = @&quot;UIResponderEx&quot;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)didReceiveMemoryWarning &#123;</div><div class="line">    [super didReceiveMemoryWarning];</div><div class="line">    // Dispose of any resources that can be recreated.</div><div class="line"> &#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p><strong>Handler</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">#import &quot;TestViewHandler.h&quot;</div><div class="line"></div><div class="line">@implementation TestViewHandler</div><div class="line"></div><div class="line">- (void)loadData &#123;</div><div class="line">    NSMutableArray *datasource = [NSMutableArray arrayWithCapacity:10];</div><div class="line">    for (int i = 0; i&lt; 10; ++i) &#123;</div><div class="line">        [datasource addObject:[NSString stringWithFormat:@&quot;Row number is %d&quot;,i]];</div><div class="line">    &#125;</div><div class="line">    self.tableDataSource.dataSouce = [datasource copy];</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p><strong>TableDataSource</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#import &quot;SBBaseTableDataSource.h&quot;</div><div class="line"></div><div class="line">@interface TestViewTableDataSource : SBBaseTableDataSource</div><div class="line"></div><div class="line">@end</div><div class="line">// 这里为了省劲就没有用单独文件去写，最好还是建两个新文件去比较好</div><div class="line">@interface TestViewTableCell : UITableViewCell</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line">#import &quot;TestViewTableDataSource.h&quot;</div><div class="line">#import &quot;UIResponder+Router.h&quot;</div><div class="line"></div><div class="line">@implementation TestViewTableDataSource</div><div class="line"></div><div class="line">- (id)initWithTableView:(UITableView *)tableView &#123;</div><div class="line">    self = [super initWithTableView:tableView];</div><div class="line">    if (self) &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">  - (void)setDataSouce:(NSArray *)dataSouce &#123;</div><div class="line">    [super setDataSouce:dataSouce];</div><div class="line">    [self.tableView reloadData];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView &#123;</div><div class="line"></div><div class="line">    return 1;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section &#123;</div><div class="line"></div><div class="line">    return self.dataSouce.count;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123;</div><div class="line">    TestViewTableCell *cell = [tableView dequeueReusableCellWithIdentifier:@&quot;cell&quot;];</div><div class="line">    cell.textLabel.text = self.dataSouce[indexPath.row];</div><div class="line"></div><div class="line">    return cell;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation TestViewTableCell</div><div class="line"></div><div class="line">- (instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier &#123;</div><div class="line">    self = [super initWithStyle:style reuseIdentifier:reuseIdentifier];</div><div class="line">    if (self) &#123;</div><div class="line">       [self setup];</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)setup &#123;</div><div class="line">    UIButton *showNumberButton = [UIButton buttonWithType:UIButtonTypeCustom];</div><div class="line">    [showNumberButton setTitle:@&quot;Show row number&quot; forState:UIControlStateNormal];</div><div class="line">    showNumberButton.backgroundColor = [UIColor purpleColor];</div><div class="line">    showNumberButton.layer.cornerRadius = 4;</div><div class="line">    showNumberButton.layer.masksToBounds = YES;</div><div class="line">    showNumberButton.translatesAutoresizingMaskIntoConstraints = NO;</div><div class="line">   [showNumberButton addTarget:self action:@selector(showNumberButtonClick:) forControlEvents:UIControlEventTouchUpInside];</div><div class="line">    [self.contentView addSubview:showNumberButton];</div><div class="line"></div><div class="line">    [self.contentView addConstraints:[NSLayoutConstraint constraintsWithVisualFormat:@&quot;H:[showNumberButton(180)]-20-|&quot; options:0 metrics:nil views:NSDictionaryOfVariableBindings(showNumberButton)]];</div><div class="line">    [self.contentView addConstraint:[NSLayoutConstraint constraintWithItem:showNumberButton attribute:NSLayoutAttributeCenterY relatedBy:NSLayoutRelationEqual toItem:self.contentView attribute:NSLayoutAttributeCenterY multiplier:1.0 constant:0]];</div><div class="line">&#125;</div><div class="line">   //关键代码就在这里, 我们在button click 事件中我再让传递一个事件给响应者链，让响应者链传出去</div><div class="line">- (void)showNumberButtonClick:(id)sender &#123;</div><div class="line">    // 我们在这个Click事件中去手动让响应者传递一个事件</div><div class="line">    [self.nextResponder routerEventWithName:@&quot;showNumber&quot; userInfo:@&#123;@&quot;object&quot;:self.textLabel.text&#125;];</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>主要的代码差不多就是这些了，至于他们的基类都是自己封装好一部分，还不怎么完善都是一些自己的想法。就不贴代码稍后把这个Demo放出来。有兴趣的可以下下来看看，如果有我好的想法请联系我：<a href="mailto:lsb332@163.com" target="_blank" rel="external">lsb332@163.com</a><br>我们先来看看在View 中捕获下事件，在.m 文件我们导入UIResponder+Router.h头文件 然后实现我们自定义的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#import &quot;UIResponder+Router.h&quot;</div><div class="line">#pragma UIResponder(Router)</div><div class="line">- (void)routerEventWithName:(NSString *)eventName userInfo:(NSDictionary *)userInfo &#123;</div><div class="line">   UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:@&quot;View中捕获&quot; message:userInfo[@&quot;object&quot;] delegate:nil cancelButtonTitle:@&quot;OK&quot; otherButtonTitles: nil];</div><div class="line">   [alertView show];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong> 手动传递事件的代码TableDataSource 已经贴出来过了这里就不贴了</strong><br>我们看下结果：</p>
<p><img src="http://ww2.sinaimg.cn/large/65e4f1e6gw1f7qq7f1kxyj20af0ih3zq.jpg" alt=""></p>
<p>我们再来看看在UIViewController 捕获，代码就不贴了看下结果好了:</p>
<p><img src="http://ww1.sinaimg.cn/large/65e4f1e6gw1f7qq7rh5foj20af0ij75k.jpg" alt=""></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>最重要的思想就是在响应事件方法我们再主动的传递给响应者链一个事件，然后我们合适的地方去响应这个事件</strong><br>这个也是抛砖引玉的，自己理解的还很肤浅的，现在写出来也算是自己学习的一个笔记吧，这个处理方法也是自己在集成环信中发现的，自己去摸索学习下。<br>Demo地址 <a href="https://github.com/lsb332/UIResponderEX" target="_blank" rel="external">https://github.com/lsb332/UIResponderEX</a><br>在这里再说一下自己项目结构，为了减轻UIViewController 重量实行真正的MVC 把View分出来了，从而使ViewController 只负责view 的显示 ，称除等。因为我们项目经常会用到TableView 为了不使View太重再次把这个分离去，使TableView的dataSource 在TableViewSource文件中去实现，然后又给View 建了一个Handler  用来处理业务逻辑，网络请求等，然后又把handler 继承一个网络求的类，这样可就可以处理的网络的请求了，如果handler 处理完数据后可以通过Block 回调给View 或者直接把数据传递给TableViewSource 就可以直接刷新数据，不用再回调给View。这里只是简单的说一下，有兴趣的可以工程里看看，还处在起步结段，如果觉得成熟了再写一篇文章说说吧。</p>
<p>文／lsb332（简书作者）<br>原文链接：<a href="http://www.jianshu.com/p/8fef9171c322" target="_blank" rel="external">http://www.jianshu.com/p/8fef9171c322</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开篇先说点废话吧，最近整个人都很烦躁，也许跟天气有关吧，也很久没有静下来写一些东西了，最近也一直忙着新项目，也很纠接新项目应该采用什么样的结构去写才好迭代、维护。最终按自己的一写想法采用了Controller View ViewHander的模式（有点类似MVVM），因为这个Demo按照这个想法来写的所以这里简单说下，就不过多的讨论这个了，回到主题上UIResponder来，没有说之前我们先看一个图我们开发中经常遇到的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/large/65e4f1e6gw1f7qq6xkecej20af0ik75x.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;很简单就是在UITableViewCell 放了一个UIButton 那我们怎么样接收这个Button的点击事件? 你第一时间可能会想到Delegate,Block？的确它们都可以实现我们的需求，Delegate我们要多写点代码，Block 如果我们的事件逻辑复杂点就会再赋值时写很多代码，当然你可以用一个简单的Block把处理的业务代封装成方法，再这个调用这方法，也可以把代码弄的简洁点，最重要我一定要考虑&lt;strong&gt;循环引用&lt;/strong&gt;的问题。那我们能不能用UIResponder 传递这个事件呢，在我们想要的地方捕获这个事件呢? 我们先来看看iOS 事件是怎么传递的我们看个图：&lt;/p&gt;
    
    </summary>
    
    
      <category term=" - 转载" scheme="http://godknow.cn/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>Git 分支 - 变基</title>
    <link href="http://godknow.cn/2016/09/10/git-fen-zhi-bian-ji/"/>
    <id>http://godknow.cn/2016/09/10/git-fen-zhi-bian-ji/</id>
    <published>2016-09-10T06:08:57.000Z</published>
    <updated>2016-09-10T06:27:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="变基"><a href="#变基" class="headerlink" title="变基"></a>变基</h2><p>在 Git 中整合来自不同分支的修改主要有两种方法：<code>merge</code> 以及 <code>rebase</code>。 在本节中我们将学习什么是“变基”，怎样使用“变基”，并将展示该操作的惊艳之处，以及指出在何种情况下你应避免使用它。</p>
<h3 id="变基的基本操作"><a href="#变基的基本操作" class="headerlink" title="变基的基本操作"></a><a href="https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA#变基的基本操作" target="_blank" rel="external">变基的基本操作</a></h3><p>请回顾之前在 <a href="https://git-scm.com/book/zh/v2/ch00/_basic_merging" target="_blank" rel="external">分支的合并</a> 中的一个例子，你会看到开发任务分叉到两个不同分支，又各自提交了更新。</p>
<a id="more"></a>
<p><img src="https://git-scm.com/book/en/v2/book/03-git-branching/images/basic-rebase-1.png" alt="分叉的提交历史">Figure 3-27. 分叉的提交历史</p>
<p>之前介绍过，整合分支最容易的方法是 <code>merge</code> 命令。 它会把两个分支的最新快照（<code>C3</code> 和 <code>C4</code>）以及二者最近的共同祖先（<code>C2</code>）进行三方合并，合并的结果是生成一个新的快照（并提交）。</p>
<p><img src="https://git-scm.com/book/en/v2/book/03-git-branching/images/basic-rebase-2.png" alt="通过合并操作来整合分叉了的历史">Figure 3-28. 通过合并操作来整合分叉了的历史</p>
<p>其实，还有一种方法：你可以提取在 <code>C4</code> 中引入的补丁和修改，然后在 <code>C3</code> 的基础上再应用一次。 在 Git 中，这种操作就叫做 <em>变基</em>。 你可以使用 <code>rebase</code> 命令将提交到某一分支上的所有修改都移至另一分支上，就好像“重新播放”一样。</p>
<p>在上面这个例子中，运行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git checkout experiment</div><div class="line">$ git rebase master</div><div class="line">First, rewinding head to replay your work on top of it...</div><div class="line">Applying: added staged command</div></pre></td></tr></table></figure>
<p>它的原理是首先找到这两个分支（即当前分支 <code>experiment</code>、变基操作的目标基底分支 <code>master</code>）的最近共同祖先 <code>C2</code>，然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件，然后将当前分支指向目标基底 <code>C3</code>, 最后以此将之前另存为临时文件的修改依序应用。（译注：写明了 commit id，以便理解，下同）</p>
<p><img src="https://git-scm.com/book/en/v2/book/03-git-branching/images/basic-rebase-3.png" alt="将 `C4` 中的修改变基到 `C3` 上">Figure 3-29. 将 <code>C4</code> 中的修改变基到 <code>C3</code> 上</p>
<p>现在回到 <code>master</code> 分支，进行一次快进合并。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git checkout master</div><div class="line">$ git merge experiment</div></pre></td></tr></table></figure>
<p><img src="https://git-scm.com/book/en/v2/book/03-git-branching/images/basic-rebase-4.png" alt="master 分支的快进合并">Figure 3-30. master 分支的快进合并</p>
<p>此时，<code>C4&#39;</code> 指向的快照就和上面使用 <code>merge</code> 命令的例子中 <code>C5</code> 指向的快照一模一样了。 这两种整合方法的最终结果没有任何区别，但是变基使得提交历史更加整洁。 你在查看一个经过变基的分支的历史记录时会发现，尽管实际的开发工作是并行的，但它们看上去就像是先后串行的一样，提交历史是一条直线没有分叉。</p>
<p>一般我们这样做的目的是为了确保在向远程分支推送时能保持提交历史的整洁——例如向某个别人维护的项目贡献代码时。 在这种情况下，你首先在自己的分支里进行开发，当开发完成时你需要先将你的代码变基到 <code>origin/master</code> 上，然后再向主项目提交修改。 这样的话，该项目的维护者就不再需要进行整合工作，只需要快进合并便可。</p>
<p>请注意，无论是通过变基，还是通过三方合并，整合的最终结果所指向的快照始终是一样的，只不过提交历史不同罢了。 变基是将一系列提交按照原有次序依次应用到另一分支上，而合并是把最终结果合在一起。</p>
<h3 id="更有趣的变基例子"><a href="#更有趣的变基例子" class="headerlink" title="更有趣的变基例子"></a><a href="https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA#更有趣的变基例子" target="_blank" rel="external">更有趣的变基例子</a></h3><p>在对两个分支进行变基时，所生成的“重演”并不一定要在目标分支上应用，你也可以指定另外的一个分支进行应用。 就像 <a href="https://git-scm.com/book/zh/v2/ch00/rbdiag_e" target="_blank" rel="external">Figure 3-31</a> 中的例子这样。 你创建了一个特性分支 <code>server</code>，为服务端添加了一些功能，提交了 <code>C3</code> 和 <code>C4</code>。 然后从 <code>C3</code> 上创建了特性分支 <code>client</code>，为客户端添加了一些功能，提交了 <code>C8</code> 和<code>C9</code>。 最后，你回到 <code>server</code> 分支，又提交了 <code>C10</code>。</p>
<p><img src="https://git-scm.com/book/en/v2/book/03-git-branching/images/interesting-rebase-1.png" alt="从一个特性分支里再分出一个特性分支的提交历史">Figure 3-31. 从一个特性分支里再分出一个特性分支的提交历史</p>
<p>假设你希望将 <code>client</code> 中的修改合并到主分支并发布，但暂时并不想合并 <code>server</code> 中的修改，因为它们还需要经过更全面的测试。 这时，你就可以使用 <code>git rebase</code> 命令的 <code>--onto</code> 选项，选中在 <code>client</code> 分支里但不在 <code>server</code> 分支里的修改（即 <code>C8</code> 和 <code>C9</code>），将它们在 <code>master</code> 分支上重演：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git rebase --onto master server client</div></pre></td></tr></table></figure>
<p>以上命令的意思是：“取出 <code>client</code> 分支，找出处于 <code>client</code> 分支和 <code>server</code> 分支的共同祖先之后的修改，然后把它们在 <code>master</code> 分支上重演一遍”。 这理解起来有一点复杂，不过效果非常酷。</p>
<p><img src="https://git-scm.com/book/en/v2/book/03-git-branching/images/interesting-rebase-2.png" alt="截取特性分支上的另一个特性分支，然后变基到其他分支">Figure 3-32. 截取特性分支上的另一个特性分支，然后变基到其他分支</p>
<p>现在可以快进合并 <code>master</code> 分支了。（如图 <a href="https://git-scm.com/book/zh/v2/ch00/rbdiag_g" target="_blank" rel="external">Figure 3-33</a>）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git checkout master</div><div class="line">$ git merge client</div></pre></td></tr></table></figure>
<p><img src="https://git-scm.com/book/en/v2/book/03-git-branching/images/interesting-rebase-3.png" alt="快进合并 master 分支，使之包含来自 client 分支的修改">Figure 3-33. 快进合并 master 分支，使之包含来自 client 分支的修改</p>
<p>接下来你决定将 <code>server</code> 分支中的修改也整合进来。 使用 <code>git rebase [basebranch] [topicbranch]</code> 命令可以直接将特性分支（即本例中的 <code>server</code>）变基到目标分支（即 <code>master</code>）上。这样做能省去你先切换到 <code>server</code> 分支，再对其执行变基命令的多个步骤。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git rebase master server</div></pre></td></tr></table></figure>
<p>如图 <a href="https://git-scm.com/book/zh/v2/ch00/rbdiag_h" target="_blank" rel="external">Figure 3-34</a> 所示，<code>server</code> 中的代码被“续”到了 <code>master</code> 后面。</p>
<p><img src="https://git-scm.com/book/en/v2/book/03-git-branching/images/interesting-rebase-4.png" alt="将 server 中的修改变基到 master 上">Figure 3-34. 将 server 中的修改变基到 master 上</p>
<p>然后就可以快进合并主分支 master 了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git checkout master</div><div class="line">$ git merge server</div></pre></td></tr></table></figure>
<p>至此，<code>client</code> 和 <code>server</code> 分支中的修改都已经整合到主分支里去了，你可以删除这两个分支，最终提交历史会变成图 <a href="https://git-scm.com/book/zh/v2/ch00/rbdiag_i" target="_blank" rel="external">Figure 3-35</a> 中的样子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git branch -d client</div><div class="line">$ git branch -d server</div></pre></td></tr></table></figure>
<p><img src="https://git-scm.com/book/en/v2/book/03-git-branching/images/interesting-rebase-5.png" alt="最终的提交历史">Figure 3-35. 最终的提交历史</p>
<h3 id="变基的风险"><a href="#变基的风险" class="headerlink" title="变基的风险"></a><a href="https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA#变基的风险" target="_blank" rel="external">变基的风险</a></h3><p>呃，奇妙的变基也并非完美无缺，要用它得遵守一条准则：</p>
<p><strong>不要对在你的仓库外有副本的分支执行变基。</strong></p>
<p>如果你遵循这条金科玉律，就不会出差错。 否则，人民群众会仇恨你，你的朋友和家人也会嘲笑你，唾弃你。</p>
<p>变基操作的实质是丢弃一些现有的提交，然后相应地新建一些内容一样但实际上不同的提交。 如果你已经将提交推送至某个仓库，而其他人也已经从该仓库拉取提交并进行了后续工作，此时，如果你用 <code>git rebase</code> 命令重新整理了提交并再次推送，你的同伴因此将不得不再次将他们手头的工作与你的提交进行整合，如果接下来你还要拉取并整合他们修改过的提交，事情就会变得一团糟。</p>
<p>让我们来看一个在公开的仓库上执行变基操作所带来的问题。 假设你从一个中央服务器克隆然后在它的基础上进行了一些开发。 你的提交历史如图所示：</p>
<p><img src="https://git-scm.com/book/en/v2/book/03-git-branching/images/perils-of-rebasing-1.png" alt="克隆一个仓库，然后在它的基础上进行了一些开发">Figure 3-36. 克隆一个仓库，然后在它的基础上进行了一些开发</p>
<p>然后，某人又向中央服务器提交了一些修改，其中还包括一次合并。 你抓取了这些在远程分支上的修改，并将其合并到你本地的开发分支，然后你的提交历史就会变成这样：</p>
<p><img src="https://git-scm.com/book/en/v2/book/03-git-branching/images/perils-of-rebasing-2.png" alt="抓取别人的提交，合并到自己的开发分支">Figure 3-37. 抓取别人的提交，合并到自己的开发分支</p>
<p>接下来，这个人又决定把合并操作回滚，改用变基；继而又用 <code>git push --force</code> 命令覆盖了服务器上的提交历史。 之后你从服务器抓取更新，会发现多出来一些新的提交。</p>
<p><img src="https://git-scm.com/book/en/v2/book/03-git-branching/images/perils-of-rebasing-3.png" alt="有人推送了经过变基的提交，并丢弃了你的本地开发所基于的一些提交">Figure 3-38. 有人推送了经过变基的提交，并丢弃了你的本地开发所基于的一些提交</p>
<p>结果就是你们两人的处境都十分尴尬。 如果你执行 <code>git pull</code> 命令，你将合并来自两条提交历史的内容，生成一个新的合并提交，最终仓库会如图所示：</p>
<p><img src="https://git-scm.com/book/en/v2/book/03-git-branching/images/perils-of-rebasing-4.png" alt="你将相同的内容又合并了一次，生成了一个新的提交">Figure 3-39. 你将相同的内容又合并了一次，生成了一个新的提交</p>
<p>此时如果你执行 <code>git log</code> 命令，你会发现有两个提交的作者、日期、日志居然是一样的，这会令人感到混乱。 此外，如果你将这一堆又推送到服务器上，你实际上是将那些已经被变基抛弃的提交又找了回来，这会令人感到更加混乱。 很明显对方并不想在提交历史中看到 <code>C4</code> 和 <code>C6</code>，因为之前就是他们把这两个提交通过变基丢弃的。</p>
<h3 id="用变基解决变基"><a href="#用变基解决变基" class="headerlink" title="用变基解决变基"></a><a href="https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA#用变基解决变基" target="_blank" rel="external">用变基解决变基</a></h3><p>如果你 <strong>真的</strong> 遭遇了类似的处境，Git 还有一些高级魔法可以帮到你。 如果团队中的某人强制推送并覆盖了一些你所基于的提交，你需要做的就是检查你做了哪些修改，以及他们覆盖了哪些修改。</p>
<p>实际上，Git 除了对整个提交计算 SHA-1 校验和以外，也对本次提交所引入的修改计算了校验和—— 即 “patch-id”。</p>
<p>如果你拉取被覆盖过的更新并将你手头的工作基于此进行变基的话，一般情况下 Git 都能成功分辨出哪些是你的修改，并把它们应用到新分支上。</p>
<p>举个例子，如果遇到前面提到的 <a href="https://git-scm.com/book/zh/v2/ch00/_pre_merge_rebase_work" target="_blank" rel="external">Figure 3-38</a> 那种情境，如果我们不是执行合并，而是执行 <code>git rebase teamone/master</code>, Git 将会：</p>
<ul>
<li>检查哪些提交是我们的分支上独有的（C2，C3，C4，C6，C7）</li>
<li>检查其中哪些提交不是合并操作的结果（C2，C3，C4）</li>
<li>检查哪些提交在对方覆盖更新时并没有被纳入目标分支（只有 C2 和 C3，因为 C4 其实就是 C4’）</li>
<li>把查到的这些提交应用在 <code>teamone/master</code> 上面</li>
</ul>
<p>从而我们将得到与 <a href="https://git-scm.com/book/zh/v2/ch00/_merge_rebase_work" target="_blank" rel="external">Figure 3-39</a> 中不同的结果，如图 <a href="https://git-scm.com/book/zh/v2/ch00/_rebase_rebase_work" target="_blank" rel="external">Figure 3-40</a> 所示。</p>
<p><img src="https://git-scm.com/book/en/v2/book/03-git-branching/images/perils-of-rebasing-5.png" alt="在一个被变基然后强制推送的分支上再次执行变基">Figure 3-40. 在一个被变基然后强制推送的分支上再次执行变基</p>
<p>要想上述方案有效，还需要对方在变基时确保 C4’ 和 C4 是几乎一样的。 否则变基操作将无法识别，并新建另一个类似 C4 的补丁（而这个补丁很可能无法整洁的整合入历史，因为补丁中的修改已经存在于某个地方了）。</p>
<p>在本例中另一种简单的方法是使用 <code>git pull --rebase</code> 命令而不是直接 <code>git pull</code>。 又或者你可以自己手动完成这个过程，先 <code>git fetch</code>，再 <code>git rebase teamone/master</code>。</p>
<p>如果你习惯使用 <code>git pull</code> ，同时又希望默认使用选项 <code>--rebase</code>，你可以执行这条语句 <code>git config --global pull.rebase true</code> 来更改 <code>pull.rebase</code> 的默认配置。</p>
<p>只要你把变基命令当作是在推送前清理提交使之整洁的工具，并且只在从未推送至共用仓库的提交上执行变基命令，你就不会有事。 假如你在那些已经被推送至共用仓库的提交上执行变基命令，并因此丢弃了一些别人的开发所基于的提交，那你就有大麻烦了，你的同事也会因此鄙视你。</p>
<p>如果你或你的同事在某些情形下决意要这么做，请一定要通知每个人执行 <code>git pull --rebase</code> 命令，这样尽管不能避免伤痛，但能有所缓解。</p>
<h3 id="变基-vs-合并"><a href="#变基-vs-合并" class="headerlink" title="变基 vs. 合并"></a><a href="https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA#变基-vs.-合并" target="_blank" rel="external">变基 vs. 合并</a></h3><p>至此，你已在实战中学习了变基和合并的用法，你一定会想问，到底哪种方式更好。 在回答这个问题之前，让我们退后一步，想讨论一下提交历史到底意味着什么。</p>
<p>有一种观点认为，仓库的提交历史即是 <strong>记录实际发生过什么</strong>。 它是针对历史的文档，本身就有价值，不能乱改。 从这个角度看来，改变提交历史是一种亵渎，你使用<em>谎言</em>掩盖了实际发生过的事情。 如果由合并产生的提交历史是一团糟怎么办？ 既然事实就是如此，那么这些痕迹就应该被保留下来，让后人能够查阅。</p>
<p>另一种观点则正好相反，他们认为提交历史是 <strong>项目过程中发生的故事</strong>。 没人会出版一本书的第一批草稿，软件维护手册也是需要反复修订才能方便使用。 持这一观点的人会使用 rebase 及 filter-branch 等工具来编写故事，怎么方便后来的读者就怎么写。</p>
<p>现在，让我们回到之前的问题上来，到底合并还是变基好？希望你能明白，并没有一个简单的答案。 Git 是一个非常强大的工具，它允许你对提交历史做许多事情，但每个团队、每个项目对此的需求并不相同。 既然你已经分别学习了两者的用法，相信你能够根据实际情况作出明智的选择。</p>
<p>总的原则是，只对尚未推送或分享给别人的本地修改执行变基操作清理历史，从不对已推送至别处的提交执行变基操作，这样，你才能享受到两种方式带来的便利。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;变基&quot;&gt;&lt;a href=&quot;#变基&quot; class=&quot;headerlink&quot; title=&quot;变基&quot;&gt;&lt;/a&gt;变基&lt;/h2&gt;&lt;p&gt;在 Git 中整合来自不同分支的修改主要有两种方法：&lt;code&gt;merge&lt;/code&gt; 以及 &lt;code&gt;rebase&lt;/code&gt;。 在本节中我们将学习什么是“变基”，怎样使用“变基”，并将展示该操作的惊艳之处，以及指出在何种情况下你应避免使用它。&lt;/p&gt;
&lt;h3 id=&quot;变基的基本操作&quot;&gt;&lt;a href=&quot;#变基的基本操作&quot; class=&quot;headerlink&quot; title=&quot;变基的基本操作&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA#变基的基本操作&quot;&gt;变基的基本操作&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;请回顾之前在 &lt;a href=&quot;https://git-scm.com/book/zh/v2/ch00/_basic_merging&quot;&gt;分支的合并&lt;/a&gt; 中的一个例子，你会看到开发任务分叉到两个不同分支，又各自提交了更新。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>willMoveToSuperView导致观察者无法释放bug</title>
    <link href="http://godknow.cn/2016/09/10/willmovetosuperviewdao-zhi-guan-cha-zhe-wu-fa-shi-fang-bug/"/>
    <id>http://godknow.cn/2016/09/10/willmovetosuperviewdao-zhi-guan-cha-zhe-wu-fa-shi-fang-bug/</id>
    <published>2016-09-10T02:33:17.000Z</published>
    <updated>2016-09-10T02:39:20.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/801b780agw1f7oaf0t13bj20rt0hp44z.jpg" alt="obeserve无法释放"></p>
<p>(void)willMoveToSuperview 默认不做任何事情；当接收者父视图将要改变的时候回来到该方法，其中newSuperview是将要被添加的视图，该参数可以为new，子类可以重写这方法来作为特定的实现。<br>最近在开发公司项目的过程中，遇到了一个比较棘手的bug。<br>同事在构造一个modal出来的Controller中，用到了某个三方库<br>其中有用到KVO去监听某个属性的值。<br>而且也在dealloc里面对观察者进行了销毁。</p>
<p>但在点击关闭按钮销毁该界面的时候，程序先回到父控制器窗口，然后crash。<br>查了许久原因未果。</p>
<p>通过断点调试和查看函数调用栈发现<br>observeValueForKeyPath:这个方法一共来了两次<br>进一步调试发现<br>是- (void)willMoveToSuperview:(UIView *)newSuperview这个方法调用了两次，而增加观察者方法就写在其中。<br>两次调用的时间分别是View视图将要显示前，和将要销毁前。</p>
<p>查阅资料得知newSuperview可以为nil，也就是modal视图销毁时这个方法会进行第二次调用，即把视图添加到为nill的View上。</p>
<p>进而在方法内部做了对参数的校验，解决问题。</p>
<p>不过把观察者写在view里面始终是野路子，把逻辑操作都写在controller中才是正途。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/801b780agw1f7oaf0t13bj20rt0hp44z.jpg&quot; alt=&quot;obeserve无法释放&quot;&gt;&lt;/p&gt;
&lt;p&gt;(void)willMoveToSuperview 默认不做任何事情
    
    </summary>
    
    
      <category term=" - bug归档" scheme="http://godknow.cn/tags/bug%E5%BD%92%E6%A1%A3/"/>
    
  </entry>
  
  <entry>
    <title>比特币及区块链</title>
    <link href="http://godknow.cn/2016/09/09/bi-te-bi-ji-qu-kuai-lian/"/>
    <id>http://godknow.cn/2016/09/09/bi-te-bi-ji-qu-kuai-lian/</id>
    <published>2016-09-09T03:13:43.000Z</published>
    <updated>2016-09-10T03:46:54.000Z</updated>
    
    <content type="html"><![CDATA[<hr>
<p>####<a href="http://http://v.youku.com/v_show/id_XMjY4MTA3NDky.html" target="_blank" rel="external">Bitcoin是什么</a></p>
<p>####<a href="http://v.youku.com/v_show/id_XNjY1NTQzMDYw.html?beta&amp;from=s1.8-1-1.2&amp;spm=0.0.0.0.Xy0KUn" target="_blank" rel="external">一分钟了解比特币</a></p>
<p>####<a href="http://v.youku.com/v_show/id_XNzk0MzgwNTU2.html?beta&amp;from=s1.8-1-1.2&amp;spm=0.0.0.0.nfpGov" target="_blank" rel="external">NHK纪录片《比特币最前线》中英字幕版</a></p>
<hr>
<p>####<a href="http://v.youku.com/v_show/id_XMTYyNTc1OTAwNA==.html?beta&amp;from=s1.8-1-1.2&amp;spm=0.0.0.0.vDyGgJ" target="_blank" rel="external">Bitcoin是什么</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;####&lt;a href=&quot;http://http://v.youku.com/v_show/id_XMjY4MTA3NDky.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Bitcoin是什么&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;####&lt;a hre
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Xib加载的几种方法</title>
    <link href="http://godknow.cn/2016/08/13/xibjia-zai-de-ji-chong-fang-fa/"/>
    <id>http://godknow.cn/2016/08/13/xibjia-zai-de-ji-chong-fang-fa/</id>
    <published>2016-08-13T07:00:33.000Z</published>
    <updated>2016-08-25T04:50:56.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>一，本质</p>
</blockquote>
<p> xib本质是<code>XML</code>代码（在编译时<code>Xcode</code>将<code>xib</code>中内容转换成代码）</p>
<p>注：如果一个<code>view</code>是从<code>xib</code>中加载出来的，默认<code>width</code>与<code>height</code>是<code>xib</code>中描述的尺寸，frame中(x,y)值默认为零</p>
<blockquote>
<p>二、控制器中加载xib</p>
</blockquote>
<p>加载方式一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NSArray *newsArr = [[NSBundle mainBundle] loadNibNamed:@&quot;news&quot; owner:nil options:nil];</div><div class="line">UIView *newsView = newsArr.firstObject;</div></pre></td></tr></table></figure>
<p>注：<br>“<code>loadNibNamed:owner:options</code>” 方法返回值是一个<code>NSArray</code>，因为一个xib中可以放多个<code>view</code>，但一般情况我们都只放一个在<code>xib</code>中</p>
<p>加载方式二：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">UINib *nib = [UINib nibWithNibName:@&quot;news&quot; bundle:[NSBundle mainBundle]];//[NSBundle mainBundle]作为参数时，可以传nil，切记[NSBundle mainBundle]调用其他方法时不可以为nil，用nil调用方法等于什么操作都没做</div><div class="line">UIView *news = [[nib instantiateWithOwner:nil options:nil] firstObject];</div></pre></td></tr></table></figure>
<blockquote>
<p>三、使用xib加载view的注意事项</p>
</blockquote>
<p>1，如果一个<code>view</code>是从<code>xib</code>加载出来的，那么<code>xib</code>绑定的<code>View</code>初始化过程中，不会执行<code>init</code>方法和<code>initWithFrame</code>方法，因此在页面中如果通过 <code>alloc init</code> 来初始化该<code>view</code>，界面会是空白<br>2，如果多个页面中用到该<code>view</code>，最好在<code>xib</code>绑定的类中提供快速创建的类方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">+ (instancetype)viewForXib</div><div class="line">&#123;</div><div class="line">    return [[[NSBundle mainBundle] loadNibNamed:NSStringFromClass(self) owner:nil options:nil] firstObject];</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;一，本质&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; xib本质是&lt;code&gt;XML&lt;/code&gt;代码（在编译时&lt;code&gt;Xcode&lt;/code&gt;将&lt;code&gt;xib&lt;/code&gt;中内容转换成代码）&lt;/p&gt;
&lt;p&gt;注：如果一个&lt;code&gt;view
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS加密的基本介绍</title>
    <link href="http://godknow.cn/2016/08/08/iosjia-mi-de-ji-ben-jie-shao/"/>
    <id>http://godknow.cn/2016/08/08/iosjia-mi-de-ji-ben-jie-shao/</id>
    <published>2016-08-08T05:52:13.000Z</published>
    <updated>2016-08-14T09:59:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>安全隐患：在iOS开发过程中，尽管在发送数据的过程中，密码进行了“二进制”的转换，但实际上密码还是明文，可以通过一些拦截软件被拦截（青花瓷等等），不能保证我们数据的安全性。</p>
<p>加密选择：一般公司都会有一套自己的加密方案，按照公司接口文档的规定去加密</p>
<p>平常用到的解决办法：</p>
<h1 id="1-Base64加密"><a href="#1-Base64加密" class="headerlink" title="1.Base64加密"></a>1.Base64加密</h1><blockquote>
<p>Base64加密因其算法和充当密钥的索引表都是公开的，所以不属于加密算法，它的本质是将“二进制”数据转换成字符串，方便使用HTTP协议、用于公开的代码加密、URL加密，防止数据明文传输。</p>
</blockquote>
<p>例如：有的网络请求上，会希望只传递字符串</p>
<p>1.URL中的参数，直接带上图片的传输</p>
<p>2.银联的网络接口，把整个消费凭据生成一个数据格式，然后进行Base64的编码，编码完成后传给服务器</p>
<p>特点：编码完成后的结果，只有64个字符。</p>
<p>转换方法：</p>
<blockquote>
<p>1.将每三个字节分成一组，一共24个二进制位：3*8=24</p>
<p>2.将这24个二进制位分成4组，每组有6个二进制位：24/4=6</p>
<p>3.在每组前加两00，扩展成32个二进制位，即4个字节：4*(6+2)=32</p>
<p>4.根据Base64索引表就可得到对应的符号值。</p>
</blockquote>
<p>Base64索引表</p>
<p>下面来看看它的具体转换过程：</p>
<p>加密的具体过程图</p>
<p>苹果在iOS7之后自带Base64加密，具体方法如下：</p>
<a id="more"></a>
<h1 id="2-MD5加密"><a href="#2-MD5加密" class="headerlink" title="2.MD5加密"></a>2.MD5加密</h1><blockquote>
<p>MD5即Message-Digest Algorithm 5（信息-摘要算法5），用于确保信息传输完整一致。是计算机广泛使用的杂凑算法之一（又译摘要算法、哈希算法），主流编程语言普遍已有MD5实现。作用是让大容量信息在用数字签名软件签署私人密钥前被”压缩”成一种保密的格式（就是把一个任意长度的字节串变换成一定长的十六进制数字串）。</p>
<p>MD5加密对输入信息生成唯一的128位散列值（32个字符），声称是不可逆的，但是目前可以通过以下网站解密<a href="http://www.cmd5.com" target="_blank" rel="external">MD5解密网站</a> ，主要运用在数字签名、文件完整性验证以及口令加密等方面。</p>
</blockquote>
<p>先来看看基本的加密算法实现过程：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/974583-36ecd58f885b2b01.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<p>不过在平常的开发中我们一般都会用到第三方：例如 <strong> Security 的NSString+Hash.h</strong> 等等，主要原因稍后会介绍。</p>
<p>基本使用方法：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/974583-2d1695260849a0e8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<p>因为MD5生成的简单字符串会到目前会被轻易的破解，所以我们需要对其进行改进。</p>
<p>1.<strong>*加盐（Salt）*</strong>：在明文的固定位置插入随机串，然后再进行MD5</p>
<p><img src="http://upload-images.jianshu.io/upload_images/974583-54897bb397997310.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<p>注：加的盐必须足够长，足够保密或者可以计入时间戳</p>
<p>如果还不行的话可以使用辅助手段 IP记录   手机短信记录   操作异常或者比较敏感的操作等手法。</p>
<p>2.<strong>*HMAC+MD5*</strong>：HMAC本来就是一种加密算法，再加上MD5，算得上双重保障</p>
<p>Security第三方有此方法</p>
<p>3.<strong>先加密，后乱序</strong>：先对明文进行MD5，然后对加密得到的MD5串的字符进行乱序，总之宗旨就是：黑客就算攻破了数据库，也无法解密出正确的明文</p>
<blockquote>
<p>使用MD5的好处：快速校验</p>
</blockquote>
<h1 id="3-对于重要数据，使用RSA进行数字签名，起到防篡改作用"><a href="#3-对于重要数据，使用RSA进行数字签名，起到防篡改作用" class="headerlink" title="3. 对于重要数据，使用RSA进行数字签名，起到防篡改作用"></a>3. 对于重要数据，使用RSA进行数字签名，起到防篡改作用</h1><h1 id="4-对于比较敏感的数据，如用户信息（登陆、注册等），客户端发送使用RSA加密，服务器返回使用DES-AES-加密"><a href="#4-对于比较敏感的数据，如用户信息（登陆、注册等），客户端发送使用RSA加密，服务器返回使用DES-AES-加密" class="headerlink" title="4 .对于比较敏感的数据，如用户信息（登陆、注册等），客户端发送使用RSA加密，服务器返回使用DES(AES)加密"></a>4 .对于比较敏感的数据，如用户信息（登陆、注册等），客户端发送使用RSA加密，服务器返回使用DES(AES)加密</h1><p>原因：客户端发送之所以使用RSA加密，是因为RSA解密需要知道服务器私钥，而服务器私钥一般盗取难度较大；</p>
<h1 id="5-钥匙串（keychain）"><a href="#5-钥匙串（keychain）" class="headerlink" title="5.钥匙串（keychain）"></a>5.钥匙串（keychain）</h1><p>iOS 7.0.3版本后加入，使用256位AES加密</p>
<blockquote>
<p>keychain Services：（iOS密钥链服务）提供了针对用户设备上的密码、密钥、证书、笔记和自定义数据的安全存储解决方案。保存的信息不会因App被删除而丢失，在用户重新安装App后依然有效，数据还在，是目前在设备中保存关键数据的唯一安全的地方。</p>
</blockquote>
<p>那么，如何在应用里使用keychain呢？</p>
<p>我们需要导入Security.framework ，keychain的操作接口声明在头文件SecItem.h里，直接使用SecItem.h里方法操作keychain，需要写的代码较为复杂，我们可以使用已经封装好了的工具类KeychainItemWrapper来对keychain进行操作。KeychainItemWrapper是apple官方例子“GenericKeychain”里一个访问keychain常用操作的封装类，在官网上下载了GenericKeychain项目后，<strong>只需要把“KeychainItemWrapper.h”和“KeychainItemWrapper.m”拷贝到我们项目，并导入Security.framework 。同时需要设置ARC（-fno-objc-arc）。</strong></p>
<p>我们来看看使用方法：</p>
<p>保存数据</p>
<p>取出数据</p>
<p>其他具体的使用方法，自己看API。</p>
<p>第三方封装的有<strong>SSKeychain</strong>，使用方法更为简便。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/974583-6949590f265968a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/974583-a16cfe95dc2702ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<h1 id="6-Cookie（小甜饼）"><a href="#6-Cookie（小甜饼）" class="headerlink" title="6.Cookie（小甜饼）"></a>6.Cookie（小甜饼）</h1><p>由服务器生成，发送给客户端，将cookie的key/value保存到某个目录的文本文件内。</p>
<p>最典型的应用是判定注册用户是否已经登录，另一个重要的应用场合是“购物车”。</p>
<p>简单使用方法：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/974583-ff4a1b563a0f2ddb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<p>原文链接：<a href="http://www.jianshu.com/p/2beffa24e889" target="_blank" rel="external">http://www.jianshu.com/p/2beffa24e889</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;安全隐患：在iOS开发过程中，尽管在发送数据的过程中，密码进行了“二进制”的转换，但实际上密码还是明文，可以通过一些拦截软件被拦截（青花瓷等等），不能保证我们数据的安全性。&lt;/p&gt;
&lt;p&gt;加密选择：一般公司都会有一套自己的加密方案，按照公司接口文档的规定去加密&lt;/p&gt;
&lt;p&gt;平常用到的解决办法：&lt;/p&gt;
&lt;h1 id=&quot;1-Base64加密&quot;&gt;&lt;a href=&quot;#1-Base64加密&quot; class=&quot;headerlink&quot; title=&quot;1.Base64加密&quot;&gt;&lt;/a&gt;1.Base64加密&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Base64加密因其算法和充当密钥的索引表都是公开的，所以不属于加密算法，它的本质是将“二进制”数据转换成字符串，方便使用HTTP协议、用于公开的代码加密、URL加密，防止数据明文传输。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;例如：有的网络请求上，会希望只传递字符串&lt;/p&gt;
&lt;p&gt;1.URL中的参数，直接带上图片的传输&lt;/p&gt;
&lt;p&gt;2.银联的网络接口，把整个消费凭据生成一个数据格式，然后进行Base64的编码，编码完成后传给服务器&lt;/p&gt;
&lt;p&gt;特点：编码完成后的结果，只有64个字符。&lt;/p&gt;
&lt;p&gt;转换方法：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1.将每三个字节分成一组，一共24个二进制位：3*8=24&lt;/p&gt;
&lt;p&gt;2.将这24个二进制位分成4组，每组有6个二进制位：24/4=6&lt;/p&gt;
&lt;p&gt;3.在每组前加两00，扩展成32个二进制位，即4个字节：4*(6+2)=32&lt;/p&gt;
&lt;p&gt;4.根据Base64索引表就可得到对应的符号值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Base64索引表&lt;/p&gt;
&lt;p&gt;下面来看看它的具体转换过程：&lt;/p&gt;
&lt;p&gt;加密的具体过程图&lt;/p&gt;
&lt;p&gt;苹果在iOS7之后自带Base64加密，具体方法如下：&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>升级Ruby配置CocoaPods安装</title>
    <link href="http://godknow.cn/2016/08/07/jie-jue-cocoapodan-zhuang-rubyban-ben-di-de-wen-ti/"/>
    <id>http://godknow.cn/2016/08/07/jie-jue-cocoapodan-zhuang-rubyban-ben-di-de-wen-ti/</id>
    <published>2016-08-07T05:05:29.000Z</published>
    <updated>2016-08-07T05:25:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>这两天全新安装了系统，安装cocoapods时出现：</p>
<blockquote>
<p>activesupport requires Ruby version &gt;= 2.2.2</p>
</blockquote>
<p>检查下发现淘宝源的ruby版本是2.0.0，于是使用RVM更新了下Ruby。</p>
<h2 id="1、安装-RVM"><a href="#1、安装-RVM" class="headerlink" title="1、安装 RVM"></a>1、安装 RVM</h2><p>RVM:Ruby Version Manager,Ruby版本管理器，包括Ruby的版本管理和Gem库管理(gemset)</p>
<blockquote>
<p>curl -L get.rvm.io | bash -s stable </p>
</blockquote>
<p>等待一段时间后就可以成功安装好 RVM。</p>
<blockquote>
<p>source ~/.bashrc  </p>
<p>source ~/.bash_profile  </p>
</blockquote>
<p>测试是否安装正常</p>
<blockquote>
<p>rvm -v </p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/1727086-68742171c589c6ad.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="13:03:18.jpg"></p>
<h2 id="2、用RVM升级Ruby"><a href="#2、用RVM升级Ruby" class="headerlink" title="2、用RVM升级Ruby"></a>2、用RVM升级Ruby</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">查看当前ruby版本  </div><div class="line">ruby -v  </div><div class="line">列出已知的ruby版本  </div><div class="line">rvm list known  </div><div class="line"></div><div class="line">&lt;!------MORE-------&gt;</div><div class="line"></div><div class="line"></div><div class="line">安装ruby 2.2.2  </div><div class="line">rvm install 2.2.2</div></pre></td></tr></table></figure>
<p>安装完成之后ruby -v查看是否安装成功。<br>终端输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">kidteaing-macmini:~ GeXiaodong$ ruby -v</div><div class="line">ruby 2.2.2p95 (2015-04-13 revision 50295) [x86_64-darwin14]</div></pre></td></tr></table></figure></p>
<p>到此已经完成ruby的升级</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这两天全新安装了系统，安装cocoapods时出现：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;activesupport requires Ruby version &amp;gt;= 2.2.2&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;检查下发现淘宝源的ruby版本是2.0.0
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>PC端获取IPA包的方法</title>
    <link href="http://godknow.cn/2016/08/07/pcduan-huo-qu-ipabao-de-fang-fa/"/>
    <id>http://godknow.cn/2016/08/07/pcduan-huo-qu-ipabao-de-fang-fa/</id>
    <published>2016-08-07T04:29:16.000Z</published>
    <updated>2016-08-07T04:30:15.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IPA包的下载流程"><a href="#IPA包的下载流程" class="headerlink" title="IPA包的下载流程"></a>IPA包的下载流程</h1><ol>
<li><p>使用iTunes软件</p>
</li>
<li><p>登入自己的苹果账号</p>
</li>
<li><p>找到应用界面</p>
</li>
<li><p>选中AppStore</p>
</li>
<li><p>搜索要下载的应用</p>
</li>
<li><p>已购买应用显示下载，未购买应用显示购买</p>
</li>
<li><p>点击下载或购买后，会下载IPA包</p>
</li>
<li><p>下载完成后，会看到已下载标志</p>
</li>
<li><p>点击我的应用</p>
</li>
<li><p>已经下载的应用都列出来了</p>
</li>
<li><p>点中一个包，选择在Finder中显示</p>
</li>
<li><p>所有已下载的ipa包，都在文件夹中</p>
</li>
</ol>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><ol>
<li>在iTunes的设置中，也可以直接查看缓存文件夹位置</li>
</ol>
<p>   用命令行即可打开文件夹<br>       open /Users/mac/Music/iTunes/iTunes\ Media</p>
<ol>
<li><p>应用的状态可能不止下载或购买，还可能有更新等，万变不离其宗，无论是什么状态，最终都可以下载IPA包</p>
</li>
<li><p>缓存的包如果被删除，需要重新下载。如果IPA包有更新版本，也可以在我的应用界面直接更新</p>
</li>
<li><p>如果想查看包内容，可以修改.ipa后缀名为.zip，然后解压即可</p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;IPA包的下载流程&quot;&gt;&lt;a href=&quot;#IPA包的下载流程&quot; class=&quot;headerlink&quot; title=&quot;IPA包的下载流程&quot;&gt;&lt;/a&gt;IPA包的下载流程&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;使用iTunes软件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;登入自己的
    
    </summary>
    
    
      <category term="iOS" scheme="http://godknow.cn/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Swift (?)可选类型和 (!)强制解包</title>
    <link href="http://godknow.cn/2016/07/13/swiftzhong-de-ke-xuan-lei-xing-he-qiang-zhi-jie-xi/"/>
    <id>http://godknow.cn/2016/07/13/swiftzhong-de-ke-xuan-lei-xing-he-qiang-zhi-jie-xi/</id>
    <published>2016-07-13T07:00:33.000Z</published>
    <updated>2016-07-20T19:05:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>很多Swift初学者在学习过程中对问号和感叹号比较迷惑，<br>Swift中<strong>问号</strong>表示这是一个可选类型。<br>翻译：某个常量或者变量可能是一个类型，也可能什么都没有，<strong>我不确定它是否真的会有值，也许会是nil</strong>。</p>
<p>比如：</p>
<blockquote>
<p>let number1 = “123”</p>
<p>let number2 = number1.toInt()</p>
<p>//number2是Int?类型 或者叫optional Int</p>
</blockquote>
<p>number2，可能包含Int值，也可能什么都没有（那就是nil）</p>
<p>当我们通过if语句判断，number2确实有值时，可以使用<strong>感叹号</strong>来表示。</p>
<p>翻译：<strong>我确定这个可选类型的值内有正确的内容，请使用它</strong>。</p>
<blockquote>
<p>if number2 != nil {</p>
<pre><code>println(number2!)
</code></pre></blockquote>
<p>感叹号，被称为可选值的强制解析（无论如何请一定要使用这个值，我保证这里面肯定有东西）</p>
<p>然而在使用强制解析的时候，一定要确保包中的内容确实不会为 nil，<strong>否则会报错</strong>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很多Swift初学者在学习过程中对问号和感叹号比较迷惑，&lt;br&gt;Swift中&lt;strong&gt;问号&lt;/strong&gt;表示这是一个可选类型。&lt;br&gt;翻译：某个常量或者变量可能是一个类型，也可能什么都没有，&lt;strong&gt;我不确定它是否真的会有值，也许会是nil&lt;/strong&gt;
    
    </summary>
    
    
      <category term="swift" scheme="http://godknow.cn/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>iOS 开发路线</title>
    <link href="http://godknow.cn/2016/07/12/ios-kai-fa-lu-xian/"/>
    <id>http://godknow.cn/2016/07/12/ios-kai-fa-lu-xian/</id>
    <published>2016-07-12T11:59:43.000Z</published>
    <updated>2016-07-13T06:56:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>前言</p>
<p>学习iOS的人都想知道学习iOS需要学习哪些东西呢，本人搜集到github上有这么一个路径图，这里基本包含了开发中必须要掌握的一些技术知识。</p>
<p><img src="https://raw.githubusercontent.com/shaojiankui/iOS-Route/master/look.jpg" alt="预览图"></p>
<p><a href="http://ios.skyfox.org/route.html" target="_blank" rel="external">查看路线详情</a></p>
<p>来源<br><a href="https://github.com/shaojiankui/iOS-Route" target="_blank" rel="external">github地址iOS学习路线</a></p>
<p>此图片非本人所画，若原作者不允许使用此图，请及时告知，谢谢！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前言&lt;/p&gt;
&lt;p&gt;学习iOS的人都想知道学习iOS需要学习哪些东西呢，本人搜集到github上有这么一个路径图，这里基本包含了开发中必须要掌握的一些技术知识。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/shaoj
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>基于 ijkplayer 的iOS视频直播推流仿写</title>
    <link href="http://godknow.cn/2016/07/07/osshi-pin-zhi-bo-fang/"/>
    <id>http://godknow.cn/2016/07/07/osshi-pin-zhi-bo-fang/</id>
    <published>2016-07-07T03:39:36.000Z</published>
    <updated>2016-08-10T16:05:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>视频直播，可以分为 采集，前处理，编码，传输, 服务器处理，解码，渲染</p>
<p>采集: iOS系统因为软硬件种类不多, 硬件适配性比较好, 所以比较简单. 而Android端市面上机型众多, 要做些机型的适配工作.PC端是最麻烦的, 各种奇葩摄像头驱动.所以现在很多的中小型直播平台, 都放弃了PC的直播, 更有一些直播平台只做iOS端的视频直播.</p>
<p>前处理: 美颜算法,视频的模糊效果, 水印等都是在这个环节做. 目前iOS端最著名开源框架的毫无疑问就是GPUImage.其中内置了125种渲染效果, 还支持各种脚本自定义. 我高仿的喵播的美颜效果也是基于GPUImage的.</p>
<p>编码: 重难点在于要在分辨率，帧率，码率，GOP等参数设计上找到最佳平衡点。iOS8之后, Apple开放了VideoToolbox.framework, 可以直接进行硬编解码, 这也是为什么现在大多数直播平台最低只支持到iOS8的原因之一. iOS端硬件兼容性比较好, 可以直接采取硬编码. 而Android得硬编码又是一大坑.</p>
<p>传输: 这块一般都是交给CDN服务商. CDN只提供带宽和服务器之间的传输, 发送端和接收端的网络连接抖动缓存还是要自己实现的.目前国内最大的CDN服务商应该是网宿.</p>
<p>服务器处理: 需要在服务器做一些流处理工作, 让推送上来的流适配各个平台各种不同的协议, 比如:RTMP,HLS,FLV…</p>
<p>解码和渲染: 也就即音视频的播放. 解码毫无疑问也必须要硬解码. iOS端兼容较好, Android依然大坑.这块的难点在于音画同步, 目前很多直播平台这块是硬伤.国内比较好的开源项目应该是B站开源的ijkplayer . 斗鱼就是基于ijkplayer 的, 本项目也是基于ijkplayer 的.</p>
<p>技术坑 : 降噪, 音频解码器, 蓝牙适配, 回声消除, 信令控制, 登录, 鉴权, 权限管理, 状态管理, 应用消息, 消息推送, 礼物系统, 即时聊天, 支付系统, 统计系统, 数据库, 缓存, 分布式文件存储, 消息队列, 运维系统等等大小不一的坑等你来填!!!</p>
<a id="more"></a>
<p>资金坑 : 以带宽为例, 2万人同时在线, 手机码率在600KB, 每个月的带宽费用至少在30万左右. 根据欢聚时代(YY)15年四季度财务报, 他们的带宽成本为人民币1.611亿元, 折合每月5000万+. 人力成本+渠道支出和其他支出就不详谈了.</p>
<p>社会坑: 还得每时每刻与各种黑暗势力斗争, 包括色情, 广告, 刷小号, 刷充值, 告侵权, DDos…</p>
<p>前期准备<br>项目主要是基于ijkplayer 的. 最好是打包成framework. 原本我准备写一个打包教程, 不过后来在简书上发现了一篇特别详细的打包blog, 分享给大家: <a href="http://" target="_blank" rel="external">http://www.jianshu.com/p/1f06b27b3ac0</a></p>
<p>Profile : 个人中心, 这里面只有一个ProfileController. 因为总写重复代码, 都写吐了, 这儿有兴趣的自己写一下吧, So easy…</p>
<p>Network : 关于网络连接的工具类. 关于网络的实时监控, 网络状态的切换, 网络请求的工具类都在这里面.</p>
<p>Other : 全局的常量. 当然你也可以在里面将文件结构更加细化.</p>
<p>Home : 包含最新主播, 最热直播, 关注的直播, 礼物排行榜等模块. 还有最重要的视频直播也在这里面了.</p>
<p>ShowTime :见名知意. 视频直播的前处理, 智能美颜和H264硬编码等都在这里面.</p>
<p>Main : UITabBarController和UINavigationController的配置</p>
<p>Toos : 这儿命名有点不规范, 这里面放置的都是项目用到的分类</p>
<p>Login : 登录模块</p>
<p>Resource : 项目用到的资源文件</p>
<p>项目详解<br>tip1: 判读网络类型.</p>
<p>在观看直播的时候, 我们通常都是用WiFi或者3/4G(土豪级别的), 一般用户在进行网络切换的时候, 我们都要给出友善的提示, 告诉TA: 您的网络状态切换到了XX状态. 假设用户从WiFi切换到4G, 你的应用也没个提醒, 导致TA的流量归零甚至欠了运营商一屁股的钱, 我想你的APP的用户体验也就归零或者为负了.<br>我们可以使用苹果的Reachability结合下面的代码实时监听网络状态的改变<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">typedef NS_ENUM(NSUInteger, NetworkStates) &#123;</div><div class="line">    NetworkStatesNone, // 没有网络</div><div class="line">    NetworkStates2G, // 2G</div><div class="line">    NetworkStates3G, // 3G</div><div class="line">    NetworkStates4G, // 4G</div><div class="line">    NetworkStatesWIFI // WIFI</div><div class="line">&#125;;</div><div class="line">// 判断网络类型</div><div class="line">+ (NetworkStates)getNetworkStates</div><div class="line">  &#123;</div><div class="line">    NSArray *subviews = [[[[UIApplication sharedApplication] valueForKeyPath:@&quot;statusBar&quot;] valueForKeyPath:@&quot;foregroundView&quot;] subviews];</div><div class="line">    // 保存网络状态</div><div class="line">    NetworkStates states = NetworkStatesNone;</div><div class="line">    for (id child in subviews) &#123;</div><div class="line">        if ([child isKindOfClass:NSClassFromString(@&quot;UIStatusBarDataNetworkItemView&quot;)]) &#123;</div><div class="line">            //获取到状态栏码</div><div class="line">            int networkType = [[child valueForKeyPath:@&quot;dataNetworkType&quot;] intValue];</div><div class="line">            switch (networkType) &#123;</div><div class="line">                case 0:</div><div class="line">                   //无网模式</div><div class="line">                    states = NetworkStatesNone;</div><div class="line">                    break;</div><div class="line">                case 1:</div><div class="line">                    states = NetworkStates2G;</div><div class="line">                    break;</div><div class="line">                case 2:</div><div class="line">                    states = NetworkStates3G;</div><div class="line">                    break;</div><div class="line">                case 3:</div><div class="line">                    states = NetworkStates4G;</div><div class="line">                    break;</div><div class="line">                case 5:</div><div class="line">                &#123;</div><div class="line">                    states = NetworkStatesWIFI;</div><div class="line">                &#125;</div><div class="line">                    break;</div><div class="line">                default:</div><div class="line">                    break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    //根据状态选择</div><div class="line">    return states;</div><div class="line">  &#125;</div><div class="line">  tip2: 登录模块</div></pre></td></tr></table></figure></p>
<p>如果你多运行几次就会发现, 登录模块背景中播放的视频是2个视频每次随机播放一个的.并且是无限重复的, 也就是说只要你一直呆着登录界面, 就会单视频循环播放当前的视频. 这儿的登录只是几个按钮, 没有具体的登录逻辑, 随便点哪一个按钮都可以进入首页.<br>我们需要监听视频, 是否播放完成.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// 监听视频是否播放完成</div><div class="line">  [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(didFinish) name:IJKMPMoviePlayerPlaybackDidFinishNotification object:nil];</div><div class="line">如果播放完成了, 让IJKFFMoviePlayerController再次play即可</div><div class="line"></div><div class="line">- (void)didFinish</div><div class="line">  &#123;</div><div class="line">    // 播放完之后, 继续重播</div><div class="line">    [self.player play];</div><div class="line">  &#125;</div><div class="line">  tip3: 首页</div></pre></td></tr></table></figure></p>
<p>首页</p>
<p>这种效果相信很多人都看到过或者做过.我简单说一下我的做法(不一定是最佳的, 只是提供一个思路)</p>
<p>一个父控制器HomeViewController+三个子控制器(最热/最新/关注. 每个控制器各自管理自己的业务逻辑, 高内聚低耦合). 重写HomeViewController的loadView, 将self.view替换成UIScrollView. 将三个子控制器的view添加到UIScrollView上即可. 其他的效果实现, 请参照我的代码, 都有详细的中文注释.<br>tip4: 直播(面向观众端)<br>这个是整个项目的重点之一了.这种直播的布局, 应该是比较主流的了. 我下载的好多直播类APP都是这个项目布局, 包括YY也是这种界面布局.这个里面涉及的东西比较多了, 三言两语真说不清.</p>
<p>简单说一下已经实现的效果:<br>A: 主播的直播<br>B: 关联主播的视频直播, 默认是只有界面, 没有声音的. 点击该视图可以切换到此主播<br>C: 下拉切换另一个主播, 这个功能是很常见的. 做法是直播控制器是一个UICollectionViewController, 只有一个cell, 且cell.frame就是self.collectionViewb.bounds. 我们进入直播控制器的时候, 其实是传进去一个关联主播数组, 每次下拉的时候, 就加载数组里面的主播<br>D. 查看观众席的观众详情<br>E. 查看主播详情<br>F. 足迹: 粒子动画, 后面详解<br>G. 弹幕: 点击最下方的工具栏第一个按钮可以开启/关闭弹幕, 后面详解<br>…<br>tip5: 粒子动画实现游客足迹<br>粒子动画的layer是添加到播放器的view上面的. 下面代码有详细的注释<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line">CAEmitterLayer *emitterLayer = [CAEmitterLayer layer];</div><div class="line">// 发射器在xy平面的中心位置</div><div class="line">emitterLayer.emitterPosition = CGPointMake(self.moviePlayer.view.frame.size.width-50,self.moviePlayer.view.frame.size.height-50);</div><div class="line">// 发射器的尺寸大小</div><div class="line">emitterLayer.emitterSize = CGSizeMake(20, 20);</div><div class="line">// 渲染模式</div><div class="line">emitterLayer.renderMode = kCAEmitterLayerUnordered;</div><div class="line">// 开启三维效果</div><div class="line">//    _emitterLayer.preservesDepth = YES;</div><div class="line">NSMutableArray *array = [NSMutableArray array];</div><div class="line">// 创建粒子</div><div class="line">for (int i = 0; i&lt;10; i++) &#123;</div><div class="line">    // 发射单元</div><div class="line">    CAEmitterCell *stepCell = [CAEmitterCell emitterCell];</div><div class="line">    // 粒子的创建速率，默认为1/s</div><div class="line">    stepCell.birthRate = 1;</div><div class="line">    // 粒子存活时间</div><div class="line">    stepCell.lifetime = arc4random_uniform(4) + 1;</div><div class="line">    // 粒子的生存时间容差</div><div class="line">    stepCell.lifetimeRange = 1.5;</div><div class="line">    // 颜色</div><div class="line">    // fire.color=[[UIColor colorWithRed:0.8 green:0.4 blue:0.2 alpha:0.1]CGColor];</div><div class="line">    UIImage *image = [UIImage imageNamed:[NSString stringWithFormat:@&quot;good%d_30x30&quot;, i]];</div><div class="line">    // 粒子显示的内容</div><div class="line">    stepCell.contents = (id)[image CGImage];</div><div class="line">    // 粒子的名字</div><div class="line">    //            [fire setName:@&quot;step%d&quot;, i];</div><div class="line">    // 粒子的运动速度</div><div class="line">    stepCell.velocity = arc4random_uniform(100) + 100;</div><div class="line">    // 粒子速度的容差</div><div class="line">    stepCell.velocityRange = 80;</div><div class="line">    // 粒子在xy平面的发射角度</div><div class="line">    stepCell.emissionLongitude = M_PI+M_PI_2;;</div><div class="line">    // 粒子发射角度的容差</div><div class="line">    stepCell.emissionRange = M_PI_2/6;</div><div class="line">    // 缩放比例</div><div class="line">    stepCell.scale = 0.3;</div><div class="line">    [array addObject:stepCell];</div><div class="line">&#125;</div><div class="line"></div><div class="line">emitterLayer.emitterCells = array;</div><div class="line">[self.moviePlayer.view.layer insertSublayer:emitterLayer below:self.catEarView.layer];</div><div class="line">tip6: 弹幕</div><div class="line">弹幕使用的也是一个第三方轮子BarrageRenderer . 这个开源项目的文档都是中文的, 用法也是很简单的.</div><div class="line"></div><div class="line">基本配置</div><div class="line"></div><div class="line">_renderer = [[BarrageRenderer alloc] init];</div><div class="line">// 设置弹幕的显示区域. 基于父控件的.</div><div class="line">_renderer.canvasMargin = UIEdgeInsetsMake(ALinScreenHeight * 0.3, 10, 10, 10);</div><div class="line">[self.contentView addSubview:_renderer.view];</div><div class="line">弹幕配置</div><div class="line"></div><div class="line">#pragma mark - 弹幕描述符生产方法</div><div class="line">/// 生成精灵描述 - 过场文字弹幕</div><div class="line">- (BarrageDescriptor *)walkTextSpriteDescriptorWithDirection:(NSInteger)direction</div><div class="line">  &#123;</div><div class="line">    BarrageDescriptor * descriptor = [[BarrageDescriptor alloc]init];</div><div class="line">    descriptor.spriteName = NSStringFromClass([BarrageWalkTextSprite class]);</div><div class="line">    descriptor.params[@&quot;text&quot;] = self.danMuText[arc4random_uniform((uint32_t)self.danMuText.count)];</div><div class="line">    descriptor.params[@&quot;textColor&quot;] = Color(arc4random_uniform(256), arc4random_uniform(256), arc4random_uniform(256));</div><div class="line">    descriptor.params[@&quot;speed&quot;] = @(100 * (double)random()/RAND_MAX+50);</div><div class="line">    descriptor.params[@&quot;direction&quot;] = @(direction);</div><div class="line">    descriptor.params[@&quot;clickAction&quot;] = ^&#123;</div><div class="line">        UIAlertView *alertView = [[UIAlertView alloc]initWithTitle:@&quot;提示&quot; message:@&quot;弹幕被点击&quot; delegate:nil cancelButtonTitle:@&quot;取消&quot; otherButtonTitles:nil];</div><div class="line">        [alertView show];</div><div class="line">    &#125;;</div><div class="line">    return descriptor;</div><div class="line">  &#125;</div><div class="line">  最后一步, 千万要记得start</div><div class="line"></div><div class="line">[_renderer start];</div></pre></td></tr></table></figure></p>
<p>tip7: 智能美颜效果<br>现在的直播平台, 美颜是标配. 不然绝大多数的主播都是没法看的.美颜算法需要用到GPU编程, 需要懂图像处理的人. 图像处理这一块我不是很熟悉, 相关的文献也是看得云里雾里的. 所以, 依然使用开源的轮子: GPUImage . 这个开源框架有近1.3W+star(7月5日数据), 真不是盖的, 内置125种滤镜效果, 没有你想不到, 只有你不会用. 我的项目中都有详细的用法, 还是很简单的. 在这里摘抄一份其.h文件的注释. 一方面方便大家修改我项目中的美颜效果, 另一方面也是做个备份.(具体出处我真忘了, 如果有人找到了源地址链接, 可以联系我加上)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div></pre></td><td class="code"><pre><div class="line">#import &quot;GLProgram.h&quot;</div><div class="line"></div><div class="line">// Base classes</div><div class="line">#import &quot;GPUImageOpenGLESContext.h&quot;</div><div class="line">#import &quot;GPUImageOutput.h&quot;</div><div class="line">#import &quot;GPUImageView.h&quot;</div><div class="line">#import &quot;GPUImageVideoCamera.h&quot;</div><div class="line">#import &quot;GPUImageStillCamera.h&quot;</div><div class="line">#import &quot;GPUImageMovie.h&quot;</div><div class="line">#import &quot;GPUImagePicture.h&quot;</div><div class="line">#import &quot;GPUImageRawDataInput.h&quot;</div><div class="line">#import &quot;GPUImageRawDataOutput.h&quot;</div><div class="line">#import &quot;GPUImageMovieWriter.h&quot;</div><div class="line">#import &quot;GPUImageFilterPipeline.h&quot;</div><div class="line">#import &quot;GPUImageTextureOutput.h&quot;</div><div class="line">#import &quot;GPUImageFilterGroup.h&quot;</div><div class="line">#import &quot;GPUImageTextureInput.h&quot;</div><div class="line">#import &quot;GPUImageUIElement.h&quot;</div><div class="line">#import &quot;GPUImageBuffer.h&quot;</div><div class="line"></div><div class="line">// Filters</div><div class="line">#import &quot;GPUImageFilter.h&quot;</div><div class="line">#import &quot;GPUImageTwoInputFilter.h&quot;</div><div class="line"></div><div class="line"></div><div class="line">#pragma mark - 调整颜色 Handle Color</div><div class="line"></div><div class="line">#import &quot;GPUImageBrightnessFilter.h&quot;                //亮度</div><div class="line">#import &quot;GPUImageExposureFilter.h&quot;                  //曝光</div><div class="line">#import &quot;GPUImageContrastFilter.h&quot;                  //对比度</div><div class="line">#import &quot;GPUImageSaturationFilter.h&quot;                //饱和度</div><div class="line">#import &quot;GPUImageGammaFilter.h&quot;                     //伽马线</div><div class="line">#import &quot;GPUImageColorInvertFilter.h&quot;               //反色</div><div class="line">#import &quot;GPUImageSepiaFilter.h&quot;                     //褐色（怀旧）</div><div class="line">#import &quot;GPUImageLevelsFilter.h&quot;                    //色阶</div><div class="line">#import &quot;GPUImageGrayscaleFilter.h&quot;                 //灰度</div><div class="line">#import &quot;GPUImageHistogramFilter.h&quot;                 //色彩直方图，显示在图片上</div><div class="line">#import &quot;GPUImageHistogramGenerator.h&quot;              //色彩直方图</div><div class="line">#import &quot;GPUImageRGBFilter.h&quot;                       //RGB</div><div class="line">#import &quot;GPUImageToneCurveFilter.h&quot;                 //色调曲线</div><div class="line">#import &quot;GPUImageMonochromeFilter.h&quot;                //单色</div><div class="line">#import &quot;GPUImageOpacityFilter.h&quot;                   //不透明度</div><div class="line">#import &quot;GPUImageHighlightShadowFilter.h&quot;           //提亮阴影</div><div class="line">#import &quot;GPUImageFalseColorFilter.h&quot;                //色彩替换（替换亮部和暗部色彩）</div><div class="line">#import &quot;GPUImageHueFilter.h&quot;                       //色度</div><div class="line">#import &quot;GPUImageChromaKeyFilter.h&quot;                 //色度键</div><div class="line">#import &quot;GPUImageWhiteBalanceFilter.h&quot;              //白平横</div><div class="line">#import &quot;GPUImageAverageColor.h&quot;                    //像素平均色值</div><div class="line">#import &quot;GPUImageSolidColorGenerator.h&quot;             //纯色</div><div class="line">#import &quot;GPUImageLuminosity.h&quot;                      //亮度平均</div><div class="line">#import &quot;GPUImageAverageLuminanceThresholdFilter.h&quot; //像素色值亮度平均，图像黑白（有类似漫画效果）</div><div class="line"></div><div class="line">#import &quot;GPUImageLookupFilter.h&quot;                    //lookup 色彩调整</div><div class="line">#import &quot;GPUImageAmatorkaFilter.h&quot;                  //Amatorka lookup</div><div class="line">#import &quot;GPUImageMissEtikateFilter.h&quot;               //MissEtikate lookup</div><div class="line">#import &quot;GPUImageSoftEleganceFilter.h&quot;              //SoftElegance lookup</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">#pragma mark - 图像处理 Handle Image</div><div class="line"></div><div class="line">#import &quot;GPUImageCrosshairGenerator.h&quot;              //十字</div><div class="line">#import &quot;GPUImageLineGenerator.h&quot;                   //线条</div><div class="line"></div><div class="line">#import &quot;GPUImageTransformFilter.h&quot;                 //形状变化</div><div class="line">#import &quot;GPUImageCropFilter.h&quot;                      //剪裁</div><div class="line">#import &quot;GPUImageSharpenFilter.h&quot;                   //锐化</div><div class="line">#import &quot;GPUImageUnsharpMaskFilter.h&quot;               //反遮罩锐化</div><div class="line"></div><div class="line">#import &quot;GPUImageFastBlurFilter.h&quot;                  //模糊</div><div class="line">#import &quot;GPUImageGaussianBlurFilter.h&quot;              //高斯模糊</div><div class="line">#import &quot;GPUImageGaussianSelectiveBlurFilter.h&quot;     //高斯模糊，选择部分清晰</div><div class="line">#import &quot;GPUImageBoxBlurFilter.h&quot;                   //盒状模糊</div><div class="line">#import &quot;GPUImageTiltShiftFilter.h&quot;                 //条纹模糊，中间清晰，上下两端模糊</div><div class="line">#import &quot;GPUImageMedianFilter.h&quot;                    //中间值，有种稍微模糊边缘的效果</div><div class="line">#import &quot;GPUImageBilateralFilter.h&quot;                 //双边模糊</div><div class="line">#import &quot;GPUImageErosionFilter.h&quot;                   //侵蚀边缘模糊，变黑白</div><div class="line">#import &quot;GPUImageRGBErosionFilter.h&quot;                //RGB侵蚀边缘模糊，有色彩</div><div class="line">#import &quot;GPUImageDilationFilter.h&quot;                  //扩展边缘模糊，变黑白</div><div class="line">#import &quot;GPUImageRGBDilationFilter.h&quot;               //RGB扩展边缘模糊，有色彩</div><div class="line">#import &quot;GPUImageOpeningFilter.h&quot;                   //黑白色调模糊</div><div class="line">#import &quot;GPUImageRGBOpeningFilter.h&quot;                //彩色模糊</div><div class="line">#import &quot;GPUImageClosingFilter.h&quot;                   //黑白色调模糊，暗色会被提亮</div><div class="line">#import &quot;GPUImageRGBClosingFilter.h&quot;                //彩色模糊，暗色会被提亮</div><div class="line">#import &quot;GPUImageLanczosResamplingFilter.h&quot;         //Lanczos重取样，模糊效果</div><div class="line">#import &quot;GPUImageNonMaximumSuppressionFilter.h&quot;     //非最大抑制，只显示亮度最高的像素，其他为黑</div><div class="line">#import &quot;GPUImageThresholdedNonMaximumSuppressionFilter.h&quot; //与上相比，像素丢失更多</div><div class="line"></div><div class="line">#import &quot;GPUImageSobelEdgeDetectionFilter.h&quot;        //Sobel边缘检测算法(白边，黑内容，有点漫画的反色效果)</div><div class="line">#import &quot;GPUImageCannyEdgeDetectionFilter.h&quot;        //Canny边缘检测算法（比上更强烈的黑白对比度）</div><div class="line">#import &quot;GPUImageThresholdEdgeDetectionFilter.h&quot;    //阈值边缘检测（效果与上差别不大）</div><div class="line">#import &quot;GPUImagePrewittEdgeDetectionFilter.h&quot;      //普瑞维特(Prewitt)边缘检测(效果与Sobel差不多，貌似更平滑)</div><div class="line">#import &quot;GPUImageXYDerivativeFilter.h&quot;              //XYDerivative边缘检测，画面以蓝色为主，绿色为边缘，带彩色</div><div class="line">#import &quot;GPUImageHarrisCornerDetectionFilter.h&quot;     //Harris角点检测，会有绿色小十字显示在图片角点处</div><div class="line">#import &quot;GPUImageNobleCornerDetectionFilter.h&quot;      //Noble角点检测，检测点更多</div><div class="line">#import &quot;GPUImageShiTomasiFeatureDetectionFilter.h&quot; //ShiTomasi角点检测，与上差别不大</div><div class="line">#import &quot;GPUImageMotionDetector.h&quot;                  //动作检测</div><div class="line">#import &quot;GPUImageHoughTransformLineDetector.h&quot;      //线条检测</div><div class="line">#import &quot;GPUImageParallelCoordinateLineTransformFilter.h&quot; //平行线检测</div><div class="line"></div><div class="line">#import &quot;GPUImageLocalBinaryPatternFilter.h&quot;        //图像黑白化，并有大量噪点</div><div class="line"></div><div class="line">#import &quot;GPUImageLowPassFilter.h&quot;                   //用于图像加亮</div><div class="line">#import &quot;GPUImageHighPassFilter.h&quot;                  //图像低于某值时显示为黑</div><div class="line"></div><div class="line"></div><div class="line">#pragma mark - 视觉效果 Visual Effect</div><div class="line"></div><div class="line">#import &quot;GPUImageSketchFilter.h&quot;                    //素描</div><div class="line">#import &quot;GPUImageThresholdSketchFilter.h&quot;           //阀值素描，形成有噪点的素描</div><div class="line">#import &quot;GPUImageToonFilter.h&quot;                      //卡通效果（黑色粗线描边）</div><div class="line">#import &quot;GPUImageSmoothToonFilter.h&quot;                //相比上面的效果更细腻，上面是粗旷的画风</div><div class="line">#import &quot;GPUImageKuwaharaFilter.h&quot;                  //桑原(Kuwahara)滤波,水粉画的模糊效果；处理时间比较长，慎用</div><div class="line"></div><div class="line">#import &quot;GPUImageMosaicFilter.h&quot;                    //黑白马赛克</div><div class="line">#import &quot;GPUImagePixellateFilter.h&quot;                 //像素化</div><div class="line">#import &quot;GPUImagePolarPixellateFilter.h&quot;            //同心圆像素化</div><div class="line">#import &quot;GPUImageCrosshatchFilter.h&quot;                //交叉线阴影，形成黑白网状画面</div><div class="line">#import &quot;GPUImageColorPackingFilter.h&quot;              //色彩丢失，模糊（类似监控摄像效果）</div><div class="line"></div><div class="line">#import &quot;GPUImageVignetteFilter.h&quot;                  //晕影，形成黑色圆形边缘，突出中间图像的效果</div><div class="line">#import &quot;GPUImageSwirlFilter.h&quot;                     //漩涡，中间形成卷曲的画面</div><div class="line">#import &quot;GPUImageBulgeDistortionFilter.h&quot;           //凸起失真，鱼眼效果</div><div class="line">#import &quot;GPUImagePinchDistortionFilter.h&quot;           //收缩失真，凹面镜</div><div class="line">#import &quot;GPUImageStretchDistortionFilter.h&quot;         //伸展失真，哈哈镜</div><div class="line">#import &quot;GPUImageGlassSphereFilter.h&quot;               //水晶球效果</div><div class="line">#import &quot;GPUImageSphereRefractionFilter.h&quot;          //球形折射，图形倒立</div><div class="line"></div><div class="line">#import &quot;GPUImagePosterizeFilter.h&quot;                 //色调分离，形成噪点效果</div><div class="line">#import &quot;GPUImageCGAColorspaceFilter.h&quot;             //CGA色彩滤镜，形成黑、浅蓝、紫色块的画面</div><div class="line">#import &quot;GPUImagePerlinNoiseFilter.h&quot;               //柏林噪点，花边噪点</div><div class="line">#import &quot;GPUImage3x3ConvolutionFilter.h&quot;            //3x3卷积，高亮大色块变黑，加亮边缘、线条等</div><div class="line">#import &quot;GPUImageEmbossFilter.h&quot;                    //浮雕效果，带有点3d的感觉</div><div class="line">#import &quot;GPUImagePolkaDotFilter.h&quot;                  //像素圆点花样</div><div class="line">#import &quot;GPUImageHalftoneFilter.h&quot;                  //点染,图像黑白化，由黑点构成原图的大致图形</div><div class="line"></div><div class="line"></div><div class="line">#pragma mark - 混合模式 Blend</div><div class="line"></div><div class="line">#import &quot;GPUImageMultiplyBlendFilter.h&quot;             //通常用于创建阴影和深度效果</div><div class="line">#import &quot;GPUImageNormalBlendFilter.h&quot;               //正常</div><div class="line">#import &quot;GPUImageAlphaBlendFilter.h&quot;                //透明混合,通常用于在背景上应用前景的透明度</div><div class="line">#import &quot;GPUImageDissolveBlendFilter.h&quot;             //溶解</div><div class="line">#import &quot;GPUImageOverlayBlendFilter.h&quot;              //叠加,通常用于创建阴影效果</div><div class="line">#import &quot;GPUImageDarkenBlendFilter.h&quot;               //加深混合,通常用于重叠类型</div><div class="line">#import &quot;GPUImageLightenBlendFilter.h&quot;              //减淡混合,通常用于重叠类型</div><div class="line">#import &quot;GPUImageSourceOverBlendFilter.h&quot;           //源混合</div><div class="line">#import &quot;GPUImageColorBurnBlendFilter.h&quot;            //色彩加深混合</div><div class="line">#import &quot;GPUImageColorDodgeBlendFilter.h&quot;           //色彩减淡混合</div><div class="line">#import &quot;GPUImageScreenBlendFilter.h&quot;               //屏幕包裹,通常用于创建亮点和镜头眩光</div><div class="line">#import &quot;GPUImageExclusionBlendFilter.h&quot;            //排除混合</div><div class="line">#import &quot;GPUImageDifferenceBlendFilter.h&quot;           //差异混合,通常用于创建更多变动的颜色</div><div class="line">#import &quot;GPUImageSubtractBlendFilter.h&quot;             //差值混合,通常用于创建两个图像之间的动画变暗模糊效果</div><div class="line">#import &quot;GPUImageHardLightBlendFilter.h&quot;            //强光混合,通常用于创建阴影效果</div><div class="line">#import &quot;GPUImageSoftLightBlendFilter.h&quot;            //柔光混合</div><div class="line">#import &quot;GPUImageChromaKeyBlendFilter.h&quot;            //色度键混合</div><div class="line">#import &quot;GPUImageMaskFilter.h&quot;                      //遮罩混合</div><div class="line">#import &quot;GPUImageHazeFilter.h&quot;                      //朦胧加暗</div><div class="line">#import &quot;GPUImageLuminanceThresholdFilter.h&quot;        //亮度阈</div><div class="line">#import &quot;GPUImageAdaptiveThresholdFilter.h&quot;         //自适应阈值</div><div class="line">#import &quot;GPUImageAddBlendFilter.h&quot;                  //通常用于创建两个图像之间的动画变亮模糊效果</div><div class="line">#import &quot;GPUImageDivideBlendFilter.h&quot;               //通常用于创建两个图像之间的动画变暗模糊效果</div><div class="line"></div><div class="line"></div><div class="line">#pragma mark - 尚不清楚</div><div class="line">#import &quot;GPUImageJFAVoroniFilter.h&quot;</div><div class="line">#import &quot;GPUImageVoroniConsumerFilter.h&quot;</div><div class="line">tip8: H264硬编码</div><div class="line">如果使用ijkplayer 使用硬解码, 一句代码即可.</div><div class="line"></div><div class="line">// 开启硬解码</div><div class="line">[option setPlayerOptionValue:@&quot;1&quot; forKey:@&quot;videotoolbox&quot;];</div></pre></td></tr></table></figure>
<p>硬编码的应用场景: 我们要将主播的视频数据传送给服务器</p>
<p>通过摄像头来采集图像，然后将采集到的图像，通过硬编码的方式进行编码，最后编码后的数据将其组合成H264的码流通过网络传播。<br>摄像头采集图像, iOS系统提供了AVCaptureSession来采集摄像头的图像数据. 项目中我是直接使用 GPUImage 中的GPUImageVideoCamera, 直接设置GPUImageVideoCamera的代理即可, 在其代理方法- (void)willOutputSampleBuffer:(CMSampleBufferRef)sampleBuffer;进行数据编码即可.</p>
<p>切记一点: 不管是系统自带的AVCaptureSession还是GPUImageVideoCamera采集到的数据都是未经过编码的CMSampleBuffer.<br>然后将采集到的数据, 用iOS开放的VideoToolbox进行硬编码. 关于VideoToolbox硬编解码网上很多教程, 当然最好是看Apple的官方文档, 如果只是硬编码, 看我的项目即可.</p>
<p>关键的编码函数(来自YOLO直播负责人的开源项目 BeautifyFaceDemo )</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">void didCompressH264(void *outputCallbackRefCon, void *sourceFrameRefCon, OSStatus status, VTEncodeInfoFlags infoFlags,</div><div class="line">                     CMSampleBufferRef sampleBuffer )</div><div class="line">&#123;</div><div class="line">    if (status != 0) return;</div><div class="line">    // 采集的未编码数据是否准备好</div><div class="line">    if (!CMSampleBufferDataIsReady(sampleBuffer))</div><div class="line">    &#123;</div><div class="line">        NSLog(@&quot;didCompressH264 data is not ready &quot;);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    ALinH264Encoder* encoder = (__bridge ALinH264Encoder*)outputCallbackRefCon;</div><div class="line">    </div><div class="line">    bool keyframe = !CFDictionaryContainsKey((CFArrayGetValueAtIndex(CMSampleBufferGetSampleAttachmentsArray(sampleBuffer, true), 0)), kCMSampleAttachmentKey_NotSync);</div><div class="line">    </div><div class="line">    if (keyframe) // 关键帧</div><div class="line">    &#123;</div><div class="line">        CMFormatDescriptionRef format = CMSampleBufferGetFormatDescription(sampleBuffer);</div><div class="line">        size_t sparameterSetSize, sparameterSetCount;</div><div class="line">        const uint8_t *sparameterSet;</div><div class="line">        OSStatus statusCode = CMVideoFormatDescriptionGetH264ParameterSetAtIndex(format, 0, &amp;sparameterSet, &amp;sparameterSetSize, &amp;sparameterSetCount, 0 );</div><div class="line">        if (statusCode == noErr)</div><div class="line">        &#123;</div><div class="line">            size_t pparameterSetSize, pparameterSetCount;</div><div class="line">            const uint8_t *pparameterSet;</div><div class="line">            OSStatus statusCode = CMVideoFormatDescriptionGetH264ParameterSetAtIndex(format, 1, &amp;pparameterSet, &amp;pparameterSetSize, &amp;pparameterSetCount, 0 );</div><div class="line">            if (statusCode == noErr)</div><div class="line">            &#123;</div><div class="line">                encoder-&gt;sps = [NSData dataWithBytes:sparameterSet length:sparameterSetSize];</div><div class="line">                encoder-&gt;pps = [NSData dataWithBytes:pparameterSet length:pparameterSetSize];</div><div class="line">                NSLog(@&quot;sps:%@ , pps:%@&quot;, encoder-&gt;sps, encoder-&gt;pps);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    CMBlockBufferRef dataBuffer = CMSampleBufferGetDataBuffer(sampleBuffer);</div><div class="line">    size_t length, totalLength;</div><div class="line">    char *dataPointer;</div><div class="line">    OSStatus statusCodeRet = CMBlockBufferGetDataPointer(dataBuffer, 0, &amp;length, &amp;totalLength, &amp;dataPointer);</div><div class="line">    if (statusCodeRet == noErr) &#123;</div><div class="line">    </div><div class="line">        size_t bufferOffset = 0;</div><div class="line">        static const int AVCCHeaderLength = 4;</div><div class="line">        while (bufferOffset &lt; totalLength - AVCCHeaderLength)</div><div class="line">        &#123;</div><div class="line">            uint32_t NALUnitLength = 0;</div><div class="line">            memcpy(&amp;NALUnitLength, dataPointer + bufferOffset, AVCCHeaderLength);</div><div class="line">            NALUnitLength = CFSwapInt32BigToHost(NALUnitLength);</div><div class="line">            NSData *data = [[NSData alloc] initWithBytes:(dataPointer + bufferOffset + AVCCHeaderLength) length:NALUnitLength];</div><div class="line">            bufferOffset += AVCCHeaderLength + NALUnitLength;</div><div class="line">            NSLog(@&quot;sendData--&gt;&gt; %@ %lu&quot;, data, bufferOffset);</div><div class="line">        &#125;</div><div class="line">    </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;视频直播，可以分为 采集，前处理，编码，传输, 服务器处理，解码，渲染&lt;/p&gt;
&lt;p&gt;采集: iOS系统因为软硬件种类不多, 硬件适配性比较好, 所以比较简单. 而Android端市面上机型众多, 要做些机型的适配工作.PC端是最麻烦的, 各种奇葩摄像头驱动.所以现在很多的中小型直播平台, 都放弃了PC的直播, 更有一些直播平台只做iOS端的视频直播.&lt;/p&gt;
&lt;p&gt;前处理: 美颜算法,视频的模糊效果, 水印等都是在这个环节做. 目前iOS端最著名开源框架的毫无疑问就是GPUImage.其中内置了125种渲染效果, 还支持各种脚本自定义. 我高仿的喵播的美颜效果也是基于GPUImage的.&lt;/p&gt;
&lt;p&gt;编码: 重难点在于要在分辨率，帧率，码率，GOP等参数设计上找到最佳平衡点。iOS8之后, Apple开放了VideoToolbox.framework, 可以直接进行硬编解码, 这也是为什么现在大多数直播平台最低只支持到iOS8的原因之一. iOS端硬件兼容性比较好, 可以直接采取硬编码. 而Android得硬编码又是一大坑.&lt;/p&gt;
&lt;p&gt;传输: 这块一般都是交给CDN服务商. CDN只提供带宽和服务器之间的传输, 发送端和接收端的网络连接抖动缓存还是要自己实现的.目前国内最大的CDN服务商应该是网宿.&lt;/p&gt;
&lt;p&gt;服务器处理: 需要在服务器做一些流处理工作, 让推送上来的流适配各个平台各种不同的协议, 比如:RTMP,HLS,FLV…&lt;/p&gt;
&lt;p&gt;解码和渲染: 也就即音视频的播放. 解码毫无疑问也必须要硬解码. iOS端兼容较好, Android依然大坑.这块的难点在于音画同步, 目前很多直播平台这块是硬伤.国内比较好的开源项目应该是B站开源的ijkplayer . 斗鱼就是基于ijkplayer 的, 本项目也是基于ijkplayer 的.&lt;/p&gt;
&lt;p&gt;技术坑 : 降噪, 音频解码器, 蓝牙适配, 回声消除, 信令控制, 登录, 鉴权, 权限管理, 状态管理, 应用消息, 消息推送, 礼物系统, 即时聊天, 支付系统, 统计系统, 数据库, 缓存, 分布式文件存储, 消息队列, 运维系统等等大小不一的坑等你来填!!!&lt;/p&gt;
    
    </summary>
    
    
      <category term=" - 转载" scheme="http://godknow.cn/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>来自 Linkedin 的 Swift 编程风格指南</title>
    <link href="http://godknow.cn/2016/07/03/lai-zi-linkedin-de-swift-bian-cheng-feng-ge-zhi-nan/"/>
    <id>http://godknow.cn/2016/07/03/lai-zi-linkedin-de-swift-bian-cheng-feng-ge-zhi-nan/</id>
    <published>2016-07-03T01:37:29.000Z</published>
    <updated>2016-07-03T09:36:24.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ooo.0o0.ooo/2016/07/03/5778dc0ab45a1.jpg" alt=""></p>
<p>##1. Code Formatting:代码格式化</p>
<ul>
<li><strong>1.1</strong> 使用4个空格来代替Tabs</li>
<li><strong>1.2</strong> 避免过长的行，可以在XCode中进行设置单行最大长度：(Xcode-&gt;Preferences-&gt;Text Editing-&gt;Page guide at column: 160 is helpful for this)</li>
<li><strong>1.3</strong> 保证每个文件结尾都存在一个新行 Ensure that there is a newline at the end of every file.</li>
<li><strong>1.4</strong> 避免无意义的尾随空格: (Xcode-&gt;Preferences-&gt;Text Editing-&gt;Automatically trim trailing whitespace + Including whitespace-only lines).</li>
<li><strong>1.5</strong> 避免将单独的左花括号放置到一行，我们参考了：<a href="https://en.m.wikipedia.org/wiki/Indent_style#Variant:_1TBS" target="_blank" rel="external">1TBS style</a>.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class SomeClass &#123;</div><div class="line">    func someMethod() &#123;</div><div class="line">        if x == y &#123;</div><div class="line">            /* ... */</div><div class="line">        &#125; else if x == z &#123;</div><div class="line">            /* ... */</div><div class="line">        &#125; else &#123;</div><div class="line">            /* ... */</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* ... */</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>1.6</strong> 在写变量的类型声明、字典类型的键、函数参数、协议的声明或者父类的时候，不要在冒号前添加空格。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">// specifying type</div><div class="line">let pirateViewController: PirateViewController</div><div class="line"></div><div class="line">// dictionary syntax (note that we left-align as opposed to aligning colons)</div><div class="line">let ninjaDictionary: [String: AnyObject] = [</div><div class="line">    &quot;fightLikeDairyFarmer&quot;: false,</div><div class="line">    &quot;disgusting&quot;: true</div><div class="line">]</div><div class="line"></div><div class="line">// declaring a function</div><div class="line">func myFunction&lt;T, U: SomeProtocol where T.RelatedType == U&gt;(firstArgument: U, secondArgument: T) &#123;</div><div class="line">    /* ... */</div><div class="line">&#125;</div><div class="line"></div><div class="line">// calling a function</div><div class="line">someFunction(someArgument: &quot;Kitten&quot;)</div><div class="line"></div><div class="line">// superclasses</div><div class="line">class PirateViewController: UIViewController &#123;</div><div class="line">    /* ... */</div><div class="line">&#125;</div><div class="line"></div><div class="line">// protocols</div><div class="line">extension PirateViewController: UITableViewDataSource &#123;</div><div class="line">    /* ... */</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>1.7</strong> 一般来说，逗号后面都要跟随一个空格。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let myArray = [1, 2, 3, 4, 5]</div></pre></td></tr></table></figure>
<ul>
<li><strong>1.8</strong> 在二元操作符譬如<code>+</code>, <code>==</code>, 或者 <code>-&gt;</code>的前后需要加上空格，但是对于<code>(</code> 、`)的前后不需要加空格。</li>
</ul>
<ul>
<li><strong>1.9</strong> 我们默认使用Xcode推荐的格式化风格(CTRL-I) ，在声明某个函数的时候会多行排布参数。</li>
</ul>
<ul>
<li><strong>1.10</strong> 在调用多参数函数的时候，会把多个参数放置到单独的行中：</li>
</ul>
<ul>
<li><strong>1.11</strong> 对于大型的数组或者字典类型，应该将其分割到多行内，<code>[</code> 与 <code>]</code>类比于花括号进行处理。对于闭包而言也应该同样适合于该规则。</li>
</ul>
<ul>
<li><strong>1.12</strong> 尽可能地使用本地变量的方式来避免多行的判断语句。</li>
</ul>
<p>##2. Naming:命名</p>
<ul>
<li><strong>2.1</strong> Swift中不需要再使用Objective-C那样的前缀，譬如使用 <code>GuybrushThreepwood</code> 而不是<code>LIGuybrushThreepwood</code>。</li>
<li><strong>2.2</strong> 对于类型名即<code>struct</code>, <code>enum</code>, <code>class</code>, <code>typedef</code>, <code>associatedtype</code>等等使用 <code>PascalCase</code> 。</li>
<li><strong>2.3</strong> 对于函数名、方法名、变量名、常量、参数名等使用<code>camelCase</code>。</li>
<li><strong>2.4</strong> 在使用首字母缩写的时候尽可能地全部大写，并且注意保证全部代码中的统一。不过如果缩写被用于命名的起始，那么就全部小写。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// &quot;HTML&quot; is at the start of a variable name, so we use lowercase &quot;html&quot;</div><div class="line">let htmlBodyContent: String = &quot;&lt;p&gt;Hello, World!&lt;/p&gt;&quot;</div><div class="line">// Prefer using ID to Id</div><div class="line">let profileID: Int = 1</div><div class="line">// Prefer URLFinder to UrlFinder</div><div class="line">class URLFinder &#123;</div><div class="line">    /* ... */</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>2.5</strong> 对于静态常量使用 <code>k</code> 前缀 + PascalCase。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class MyClassName &#123;</div><div class="line">    // use `k` prefix for constant primitives</div><div class="line">    static let kSomeConstantHeight: CGFloat = 80.0</div><div class="line"></div><div class="line">    // use `k` prefix for non-primitives as well</div><div class="line">    static let kDeleteButtonColor = UIColor.redColor()</div><div class="line"></div><div class="line">    // don&apos;t use `k` prefix for singletons</div><div class="line">    static let sharedInstance = MyClassName()</div><div class="line"></div><div class="line">    /* ... */</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>2.6</strong> 对于泛型或者关联类型，使用<code>PascalCase</code>描述泛型，如果泛型名与其他重复，那么可以添加一个<code>Type</code>后缀名到泛型名上。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class SomeClass&lt;T&gt; &#123; /* ... */ &#125;</div><div class="line">class SomeClass&lt;Model&gt; &#123; /* ... */ &#125;</div><div class="line">protocol Modelable &#123;</div><div class="line">    associatedtype Model</div><div class="line">&#125;</div><div class="line">protocol Sequence &#123;</div><div class="line">    associatedtype IteratorType: Iterator</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>2.7</strong> 命名必须要是不模糊的并且方便表述的</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// PREFERRED</div><div class="line">class RoundAnimatingButton: UIButton &#123; /* ... */ &#125;</div><div class="line"></div><div class="line">// NOT PREFERRED</div><div class="line">class CustomButton: UIButton &#123; /* ... */ &#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>2.8</strong> 不要使用缩写，可以选择较为简短的单词。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">// PREFERRED</div><div class="line">class RoundAnimatingButton: UIButton &#123;</div><div class="line">    let animationDuration: NSTimeInterval</div><div class="line"></div><div class="line">    func startAnimating() &#123;</div><div class="line">        let firstSubview = subviews.first</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">// NOT PREFERRED</div><div class="line">class RoundAnimating: UIButton &#123;</div><div class="line">    let aniDur: NSTimeInterval</div><div class="line"></div><div class="line">    func srtAnmating() &#123;</div><div class="line">        let v = subviews.first</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>2.9</strong> 对于不是很明显的类型需要将类型信息包含在属性名中。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">// PREFERRED</div><div class="line">class ConnectionTableViewCell: UITableViewCell &#123;</div><div class="line">    let personImageView: UIImageView</div><div class="line"></div><div class="line">    let animationDuration: NSTimeInterval</div><div class="line"></div><div class="line">    // it is ok not to include string in the ivar name here because it&apos;s obvious</div><div class="line">    // that it&apos;s a string from the property name</div><div class="line">    let firstName: String</div><div class="line"></div><div class="line">    // though not preferred, it is OK to use `Controller` instead of `ViewController`</div><div class="line">    let popupController: UIViewController</div><div class="line">    let popupViewController: UIViewController</div><div class="line"></div><div class="line">    // when working with a subclass of `UIViewController` such as a table view</div><div class="line">    // controller, collection view controller, split view controller, etc.,</div><div class="line">    // fully indicate the type in the name.</div><div class="line">    let popupTableViewController: UITableViewController</div><div class="line"></div><div class="line">    // when working with outlets, make sure to specify the outlet type in the</div><div class="line">    // variable name.</div><div class="line">    @IBOutlet weak var submitButton: UIButton!</div><div class="line">    @IBOutlet weak var emailTextField: UITextField!</div><div class="line">    @IBOutlet weak var nameLabel: UILabel!</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">// NOT PREFERRED</div><div class="line">class ConnectionTableViewCell: UITableViewCell &#123;</div><div class="line">    // this isn&apos;t a `UIImage`, so shouldn&apos;t be called image</div><div class="line">    // use personImageView instead</div><div class="line">    let personImage: UIImageView</div><div class="line"></div><div class="line">    // this isn&apos;t a `String`, so it should be `textLabel`</div><div class="line">    let text: UILabel</div><div class="line"></div><div class="line">    // `animation` is not clearly a time interval</div><div class="line">    // use `animationDuration` or `animationTimeInterval` instead</div><div class="line">    let animation: NSTimeInterval</div><div class="line"></div><div class="line">    // this is not obviously a `String`</div><div class="line">    // use `transitionText` or `transitionString` instead</div><div class="line">    let transition: String</div><div class="line"></div><div class="line">    // this is a view controller - not a view</div><div class="line">    let popupView: UIViewController</div><div class="line"></div><div class="line">    // as mentioned previously, we don&apos;t want to use abbreviations, so don&apos;t use</div><div class="line">    // `VC` instead of `ViewController`</div><div class="line">    let popupVC: UIViewController</div><div class="line"></div><div class="line">    // even though this is still technically a `UIViewController`, this variable</div><div class="line">    // should indicate that we are working with a *Table* View Controller</div><div class="line">    let popupViewController: UITableViewController</div><div class="line"></div><div class="line">    // for the sake of consistency, we should put the type name at the end of the</div><div class="line">    // variable name and not at the start</div><div class="line">    @IBOutlet weak var btnSubmit: UIButton!</div><div class="line">    @IBOutlet weak var buttonSubmit: UIButton!</div><div class="line"></div><div class="line">    // we should always have a type in the variable name when dealing with outlets</div><div class="line">    // for example, here, we should have `firstNameLabel` instead</div><div class="line">    @IBOutlet weak var firstName: UILabel!</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>2.10</strong> 在编写函数参数的时候，要保证每个参数都易于理解其功能。</li>
<li><strong>2.11</strong> 根据 <a href="https://swift.org/documentation/api-design-guidelines/" target="_blank" rel="external">Apple’s API Design Guidelines</a>, 对于<code>protocol</code>，如果其描述的是正在做的事情，譬如<code>Collection</code>，那么应该命名为名词。而如果是用于描述某种能力，譬如<code>Equatable</code>, <code>ProgressReporting</code>，那么应该添加 <code>able</code>, <code>ible</code>, 或者 <code>ing</code> 这样的后缀。如果你的协议并不符合上述两种情形，那么应该直接添加一个<code>Protocol</code>后缀，譬如：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">// here, the name is a noun that describes what the protocol does</div><div class="line">protocol TableViewSectionProvider &#123;</div><div class="line">    func rowHeight(atRow row: Int) -&gt; CGFloat</div><div class="line">    var numberOfRows: Int &#123; get &#125;</div><div class="line">    /* ... */</div><div class="line">&#125;</div><div class="line"></div><div class="line">// here, the protocol is a capability, and we name it appropriately</div><div class="line">protocol Loggable &#123;</div><div class="line">    func logCurrentState()</div><div class="line">    /* ... */</div><div class="line">&#125;</div><div class="line"></div><div class="line">// suppose we have an `InputTextView` class, but we also want a protocol</div><div class="line">// to generalize some of the functionality - it might be appropriate to</div><div class="line">// use the `Protocol` suffix here</div><div class="line">protocol InputTextViewProtocol &#123;</div><div class="line">    func sendTrackingEvent()</div><div class="line">    func inputText() -&gt; String</div><div class="line">    /* ... */</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="3-Coding-Style"><a href="#3-Coding-Style" class="headerlink" title="3. Coding Style"></a>3. Coding Style</h2><p>###3.1 General</p>
<ul>
<li><strong>3.1.1</strong> 尽可能地使用<code>let</code>来代替<code>var</code>。</li>
<li><strong>3.1.2</strong> 尽可能地使用 <code>map</code>, <code>filter</code>, <code>reduce</code>的组合来进行集合的转换等操作，并且尽可能地避免使用带有副作用的闭包。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">// PREFERRED</div><div class="line">let stringOfInts = [1, 2, 3].flatMap &#123; String($0) &#125;</div><div class="line">// [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]</div><div class="line"></div><div class="line">// NOT PREFERRED</div><div class="line">var stringOfInts: [String] = []</div><div class="line">for integer in [1, 2, 3] &#123;</div><div class="line">    stringOfInts.append(String(integer))</div><div class="line">&#125;</div><div class="line"></div><div class="line">// PREFERRED</div><div class="line">let evenNumbers = [4, 8, 15, 16, 23, 42].filter &#123; $0 % 2 == 0 &#125;</div><div class="line">// [4, 8, 16, 42]</div><div class="line"></div><div class="line">// NOT PREFERRED</div><div class="line">var evenNumbers: [Int] = []</div><div class="line">for integer in [4, 8, 15, 16, 23, 42] &#123;</div><div class="line">    if integer % 2 == 0 &#123;</div><div class="line">        evenNumbers(integer)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>3.1.3</strong> 尽可能地显式声明不方便进行类型推测的变量或者常量的类型名。</li>
<li><strong>3.1.4</strong> 如果你的函数需要返回多个参数，那么尽可能地使用<code>Tuple</code>来代替<code>inout</code>参数。如果你会多次使用某个元组，那么应该使用<code>typealias</code>设置别名。如果返回的参数超过三个，那么应该使用结构体或者类来替代。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">func pirateName() -&gt; (firstName: String, lastName: String) &#123;</div><div class="line">    return (&quot;Guybrush&quot;, &quot;Threepwood&quot;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">let name = pirateName()</div><div class="line">let firstName = name.firstName</div><div class="line">let lastName = name.lastName</div></pre></td></tr></table></figure>
<ul>
<li><strong>3.1.5</strong> 在创建delegates/protocols的时候需要小心所谓的保留环(retain cycles)，这些属性需要被声明为<code>weak</code>。</li>
<li><strong>3.1.6</strong> 在闭包中直接调用<code>self</code>可能会导致保留环，可以使用<a href="https://developer.apple.com/library/ios/documentation/swift/conceptual/Swift_Programming_Language/Closures.html#//apple_ref/doc/uid/TP40014097-CH11-XID_163" target="_blank" rel="external">capture list</a> 在这种情况下:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">myFunctionWithClosure() &#123; [weak self] (error) -&gt; Void in</div><div class="line">    // you can do this</div><div class="line"></div><div class="line">    self?.doSomething()</div><div class="line"></div><div class="line">    // or you can do this</div><div class="line"></div><div class="line">    guard let strongSelf = self else &#123;</div><div class="line">        return</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    strongSelf.doSomething()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>3.1.7</strong> 不要使用 labeled breaks。</li>
<li><strong>3.1.8</strong> 不要在控制流逻辑判断的时候加上圆括号</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// PREFERRED</div><div class="line">if x == y &#123;</div><div class="line">    /* ... */</div><div class="line">&#125;</div><div class="line"></div><div class="line">// NOT PREFERRED</div><div class="line">if (x == y) &#123;</div><div class="line">    /* ... */</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>3.1.9</strong> 避免在使用enum的时候写出全名</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// PREFERRED</div><div class="line">imageView.setImageWithURL(url, type: .person)</div><div class="line"></div><div class="line">// NOT PREFERRED</div><div class="line">imageView.setImageWithURL(url, type: AsyncImageView.Type.person)</div></pre></td></tr></table></figure>
<ul>
<li><strong>3.1.10</strong> 在写类方法的时候不能用简短写法，应该使用类名.方法名，这样能够保证代码的可读性</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// PREFERRED</div><div class="line">imageView.backgroundColor = UIColor.whiteColor()</div><div class="line"></div><div class="line">// NOT PREFERRED</div><div class="line">imageView.backgroundColor = .whiteColor()</div></pre></td></tr></table></figure>
<ul>
<li><strong>3.1.11</strong> 在非必要的时候不要写<code>self.</code>。</li>
<li><strong>3.1.12</strong> 在编写某个方法的时候注意考虑下这个方法是否有可能被复写，如果不可能被复写那么应该使用<code>final</code>修饰符。还要注意加上final之后也会导致无法在测试的时候进行复写，所以还是需要综合考虑。一般而言，加上<code>final</code>修饰符后会提高编译的效率，所以应该尽可能地使用该修饰符。</li>
<li><strong>3.1.13</strong> 在使用譬如<code>else</code>, <code>catch</code>等等类似的语句的时候，将关键字与花括号放在一行，同样遵循<a href="https://en.m.wikipedia.org/wiki/Indent_style#Variant:_1TBS" target="_blank" rel="external">1TBS style</a>规范，这边列出了常见的<code>if</code>/<code>else</code> 以及 <code>do</code>/<code>catch</code> 示范代码。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">if someBoolean &#123;</div><div class="line">    // do something</div><div class="line">&#125; else &#123;</div><div class="line">    // do something else</div><div class="line">&#125;</div><div class="line"></div><div class="line">do &#123;</div><div class="line">    let fileContents = try readFile(&quot;filename.txt&quot;)</div><div class="line">&#125; catch &#123;</div><div class="line">    print(error)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>###3.2 Access Modifiers</p>
<ul>
<li><strong>3.2.1</strong> 在需要的时候应该将访问修饰符放在关键字的第一位。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// PREFERRED</div><div class="line">private static let kMyPrivateNumber: Int</div><div class="line"></div><div class="line">// NOT PREFERRED</div><div class="line">static private let kMyPrivateNumber: Int</div></pre></td></tr></table></figure>
<ul>
<li><strong>3.2.2</strong> 访问修饰符不应该单独放一行：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// PREFERRED</div><div class="line">public class Pirate &#123;</div><div class="line">    /* ... */</div><div class="line">&#125;</div><div class="line"></div><div class="line">// NOT PREFERRED</div><div class="line">public</div><div class="line">class Pirate &#123;</div><div class="line">    /* ... */</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>3.2.3</strong> 一般来说，不要显式地写默认的 <code>internal</code>访问修饰符。</li>
<li><strong>3.2.4</strong> 如果某个变量需要在测试的时候被使用到，那么应该标识为<code>internal</code>来保证<code>@testable import ModuleName</code>。这里需要注意的是，对于某些应该被声明为<code>private</code>的变量因为测试用途而声明为了<code>internal</code>，那么应该在注释里特别地注明。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> This variable defines the pirate&apos;s name.</div><div class="line"> - warning: Not `private` for `@testable`.</div><div class="line"> */</div><div class="line">let pirateName = &quot;LeChuck&quot;</div></pre></td></tr></table></figure>
<h3 id="3-3-Custom-Operators-自定义操作符"><a href="#3-3-Custom-Operators-自定义操作符" class="headerlink" title="3.3 Custom Operators:自定义操作符"></a><a href="https://github.com/wxyyxc1992/iOS-Boilerplate/blob/master/Doc/language/swift/advanced/bestpractices/styleguide/linkedin-swift-style-guide.md#33-custom-operators自定义操作符" target="_blank" rel="external"></a>3.3 Custom Operators:自定义操作符</h3><p>尽可能地选用命名函数来代替自定义操作符。如果你打算引入一个自定义的操作符，那么一定要有非常充分的理由来说明为啥要讲一个新的操作符引入到全局作用域，而不是使用其他一些可替代的方式。你也可以选择去复写一些现有的操作符，譬如<code>==</code>来适应一些新的类型，不过要保证你添加的用法一定要与语义相符。譬如<code>==</code> 应该只能用于表示相等性测试并且返回一个布尔值。</p>
<p>###3.4 Switch Statements and <code>enum</code>s</p>
<ul>
<li><strong>3.4.1</strong> 在使用枚举类型作为switch的参数的时候，避免引入<code>default</code>关键字，而应该将没有使用的情形放到下面然后使用break关键字来避免被执行。</li>
<li><strong>3.4.2</strong> Swift中默认会在每个case的结尾进行break，因此没必要的时候不需要显式地声明<code>break</code>关键字。</li>
<li><strong>3.4.3</strong> The <code>case</code> statements should line up with the <code>switch</code> statement itself as per default Swift standards.</li>
<li><strong>3.4.4</strong> When defining a case that has an associated value, make sure that this value is appropriately labeled as opposed to just types (e.g. <code>case Hunger(hungerLevel: Int)</code> instead of <code>case Hunger(Int)</code>).</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">enum Problem &#123;</div><div class="line">    case attitude</div><div class="line">    case hair</div><div class="line">    case hunger(hungerLevel: Int)</div><div class="line">&#125;</div><div class="line"></div><div class="line">func handleProblem(problem: Problem) &#123;</div><div class="line">    switch problem &#123;</div><div class="line">    case .attitude:</div><div class="line">        print(&quot;At least I don&apos;t have a hair problem.&quot;)</div><div class="line">    case .hair:</div><div class="line">        print(&quot;Your barber didn&apos;t know when to stop.&quot;)</div><div class="line">    case .hunger(let hungerLevel):</div><div class="line">        print(&quot;The hunger level is \(hungerLevel).&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>3.4.5</strong> 优先使用譬如<code>case 1, 2, 3:</code>这样的列表表达式而不是使用<code>fallthrough</code>关键字。</li>
<li><strong>3.4.6</strong> 如果你添加了一个默认的case并且该case不应该被使用，那么应该在default情形下抛出异常。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">func handleDigit(digit: Int) throws &#123;</div><div class="line">    case 0, 1, 2, 3, 4, 5, 6, 7, 8, 9:</div><div class="line">        print(&quot;Yes, \(digit) is a digit!&quot;)</div><div class="line">    default:</div><div class="line">        throw Error(message: &quot;The given number was not a digit.&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>###3.5 Optionals</p>
<ul>
<li><strong>3.5.1</strong> 只应该在 <code>@IBOutlet</code>中使用隐式地未包裹的Options。否则其他情况下就应该使用Non-Optional或者正常的Optional的变量。虽然有时候你能保证某个变量肯定非<code>nil</code>，不过这样用的话还是比较安全并且能保证上下一致性。</li>
</ul>
<p>The only time you should be using implicitly unwrapped optionals is withs. In every other case, it is better to use a non-optional or regular optional variable. Yes, there are cases in which you can probably “guarantee” that the variable will never be <code>nil</code> when used, but it is better to be safe and consistent.</p>
<ul>
<li><strong>3.5.2</strong> 不要使用 <code>as!</code> 或者 <code>try!</code>.</li>
<li><strong>3.5.3</strong> 如果你只是打算判断存放在Optional中的值是否为空，那么你应该直接与<code>nil</code>进行判断而不是使用<code>if let</code>语句将值取出来。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// PREFERERED</div><div class="line">if someOptional != nil &#123;</div><div class="line">    // do something</div><div class="line">&#125;</div><div class="line"></div><div class="line">// NOT PREFERRED</div><div class="line">if let _ = someOptional &#123;</div><div class="line">    // do something</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>3.5.4</strong> 不要使用 <code>unowned</code>。你可以将<code>unowned</code>当做对于<code>weak</code>变量的隐式解包，虽然有时候<code>unowned</code>与<code>weak</code>相比有小小地性能提升，不过还是不建议进行使用。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// PREFERRED</div><div class="line">weak var parentViewController: UIViewController?</div><div class="line"></div><div class="line">// NOT PREFERRED</div><div class="line">weak var parentViewController: UIViewController!</div><div class="line">unowned var parentViewController: UIViewController</div></pre></td></tr></table></figure>
<ul>
<li><strong>3.5.5</strong> 当对Optionals进行解包的时候，使用与Optionals变量一致的变量名</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">guard let myVariable = myVariable else &#123;</div><div class="line">    return</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-6-Protocols"><a href="#3-6-Protocols" class="headerlink" title="3.6 Protocols"></a>3.6 Protocols</h3><p>在实现协议的时候，大体上有两种代码组织方式：</p>
<ol>
<li>使用 <code>// MARK:</code> 来注释你的专门用于实现协议中规定的方法</li>
<li>在你的类或者结构体实现之外使用一个扩展来存放实现代码，不过要保证在一个源文件中</li>
</ol>
<p>不过需要注意的是，如果你是使用了Extension方式，那么定义在Extension中的方法是无法被子类复写的，这样可能会无法进行测试。</p>
<h3 id="3-7-Properties"><a href="#3-7-Properties" class="headerlink" title="3.7 Properties"></a><a href="https://github.com/wxyyxc1992/iOS-Boilerplate/blob/master/Doc/language/swift/advanced/bestpractices/styleguide/linkedin-swift-style-guide.md#37-properties" target="_blank" rel="external"></a>3.7 Properties</h3><ul>
<li><strong>3.7.1</strong> 如果是定义一个只读的需要经过计算的属性，那么不需要声明 <code>get {}</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var computedProperty: String &#123;</div><div class="line">    if someBool &#123;</div><div class="line">        return &quot;I&apos;m a mighty pirate!&quot;</div><div class="line">    &#125;</div><div class="line">    return &quot;I&apos;m selling these fine leather jackets.&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>3.7.2</strong> 在使用 <code>get {}</code>, <code>set {}</code>, <code>willSet</code>, 以及 <code>didSet</code>, 注意块的缩进</li>
<li><strong>3.7.3</strong> 尽管你可以在<code>willSet</code>/<code>didSet</code>以及 <code>set</code>方法中使用自定义的名称，不过建议还是使用默认的<code>newValue</code>/<code>oldValue</code>变量名</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">var computedProperty: String &#123;</div><div class="line">    get &#123;</div><div class="line">        if someBool &#123;</div><div class="line">            return &quot;I&apos;m a mighty pirate!&quot;</div><div class="line">        &#125;</div><div class="line">        return &quot;I&apos;m selling these fine leather jackets.&quot;</div><div class="line">    &#125;</div><div class="line">    set &#123;</div><div class="line">        computedProperty = newValue</div><div class="line">    &#125;</div><div class="line">    willSet &#123;</div><div class="line">        print(&quot;will set to \(newValue)&quot;)</div><div class="line">    &#125;</div><div class="line">    didSet &#123;</div><div class="line">        print(&quot;did set from \(oldValue) to \(newValue)&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>3.7.4</strong> 将任何类常量设置为<code>static</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">class MyTableViewCell: UITableViewCell &#123;</div><div class="line">    static let kReuseIdentifier = String(MyTableViewCell)</div><div class="line">    static let kCellHeight: CGFloat = 80.0</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>3.7.5</strong> 可以使用如下方式便捷地声明一个单例变量：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class PirateManager &#123;</div><div class="line">    static let sharedInstance = PirateManager()</div><div class="line"></div><div class="line">    /* ... */</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-8-Closures-闭包"><a href="#3-8-Closures-闭包" class="headerlink" title="3.8 Closures:闭包"></a>3.8 Closures:闭包</h3><ul>
<li><strong>3.8.1</strong> 如果闭包中的某个参数的类型是显而易见的，那么可以避免声明类型。不过有时候为了保证可读性与一致性，还是会显示声明参数类型。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// omitting the type</div><div class="line">doSomethingWithClosure() &#123; response in</div><div class="line">    print(response)</div><div class="line">&#125;</div><div class="line"></div><div class="line">// explicit type</div><div class="line">doSomethingWithClosure() &#123; response: NSURLResponse in</div><div class="line">    print(response)</div><div class="line">&#125;</div><div class="line"></div><div class="line">// using shorthand in a map statement</div><div class="line">[1, 2, 3].flatMap &#123; String($0) &#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>3.8.2</strong> 在参数列表中，如果是使用了捕获变量或者声明了非Void的返回值，那么应该将参数列表写在一个圆括号里，其他情况下则可以省略圆括号。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// parentheses due to capture list</div><div class="line">doSomethingWithClosure() &#123; [weak self] (response: NSURLResponse) in</div><div class="line">    self?.handleResponse(response)</div><div class="line">&#125;</div><div class="line"></div><div class="line">// parentheses due to return type</div><div class="line">doSomethingWithClosure() &#123; (response: NSURLResponse) -&gt; String in</div><div class="line">    return String(response)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>3.8.3</strong> 如果你是将闭包声明为一个类型，那么除非该类型为Optional或者该闭包是另一个闭包的参数，否则不需要使用圆括号进行包裹。不过需要用圆括号来标注参数列表，并且使用<code>Void</code>来指明没有任何结果返回。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">let completionBlock: (success: Bool) -&gt; Void = &#123;</div><div class="line">    print(&quot;Success? \(success)&quot;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">let completionBlock: () -&gt; Void = &#123;</div><div class="line">    print(&quot;Completed!&quot;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">let completionBlock: (() -&gt; Void)? = nil</div></pre></td></tr></table></figure>
<ul>
<li><strong>3.8.4</strong> 尽可能地将参数名与左括号放在一行，不过要避免打破每行最长160个字符的限制。</li>
</ul>
<p>Keep parameter names on same line as the opening brace for closures when possible without too much horizontal overflow (i.e. ensure lines are less than 160 characters).</p>
<ul>
<li><strong>3.8.5</strong> 尽可能地使用 trailing closure表达式，除非需要显示地声明闭包参数的外部参数名。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// trailing closure</div><div class="line">doSomething(1.0) &#123; parameter1 in</div><div class="line">    print(&quot;Parameter 1 is \(parameter1)&quot;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">// no trailing closure</div><div class="line">doSomething(1.0, success: &#123; parameter1 in</div><div class="line">    print(&quot;Success with \(parameter1)&quot;)</div><div class="line">&#125;, failure: &#123; parameter1 in</div><div class="line">    print(&quot;Failure with \(parameter1)&quot;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>###3.9 Arrays</p>
<ul>
<li><strong>3.9.1</strong> 一般来说，避免使用下标直接访问某个数组，而应该使用类似于<code>.first</code>、<code>.last</code>这样的访问器进行访问。另外，应该优先使用<code>for item in items</code>语法来替代`for i in 0..。如果你打算用下标遍历数组，那么一定保证不能越界。</li>
<li><strong>3.9.2</strong> 永远不要使用<code>+=</code> 或者 <code>+</code>运算符来增加或者连接数组，应该使用<code>.append()</code> 或者 <code>.appendContentsOf()</code> 方法。如果你想定义一个从其他数组生成的不可变数组，那么应该使用<code>let</code>关键字，即： <code>let myNewArray = arr1 + arr2</code>, 或者 <code>let myNewArray = [arr1, arr2].flatten()</code>。</li>
</ul>
<h3 id="3-10-Error-Handling"><a href="#3-10-Error-Handling" class="headerlink" title="3.10 Error Handling"></a><a href="https://github.com/wxyyxc1992/iOS-Boilerplate/blob/master/Doc/language/swift/advanced/bestpractices/styleguide/linkedin-swift-style-guide.md#310-error-handling" target="_blank" rel="external"></a>3.10 Error Handling</h3><p>假设某个函数 <code>myFunction</code> 需要去返回一个<code>String</code>类型，不过有可能会在某个点抛出异常，一般来说会将该函数的返回值设置为<code>String?</code>：</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">func readFile(withFilename filename: String) -&gt; String? &#123;</div><div class="line">    guard let file = openFile(filename) else &#123;</div><div class="line">        return nil</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    let fileContents = file.read()</div><div class="line">    file.close()</div><div class="line">    return fileContents</div><div class="line">&#125;</div><div class="line"></div><div class="line">func printSomeFile() &#123;</div><div class="line">    let filename = &quot;somefile.txt&quot;</div><div class="line">    guard let fileContents = readFile(filename) else &#123;</div><div class="line">        print(&quot;Unable to open file \(filename).&quot;)</div><div class="line">        return</div><div class="line">    &#125;</div><div class="line">    print(fileContents)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不过作为异常处理的角度，我们应该使用Swift的<code>try-catch</code>表达式，这样能显式地知道错误点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">struct Error: ErrorType &#123;</div><div class="line">    public let file: StaticString</div><div class="line">    public let function: StaticString</div><div class="line">    public let line: UInt</div><div class="line">    public let message: String</div><div class="line"></div><div class="line">    public init(message: String, file: StaticString = #file, function: StaticString = #function, line: UInt = #line) &#123;</div><div class="line">        self.file = file</div><div class="line">        self.function = function</div><div class="line">        self.line = line</div><div class="line">        self.message = message</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Example usage:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">func readFile(withFilename filename: String) throws -&gt; String &#123;</div><div class="line">    guard let file = openFile(filename) else &#123;</div><div class="line">        throw Error(message: &quot;Unable to open file named \(filename).&quot;)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    let fileContents = file.read()</div><div class="line">    file.close()</div><div class="line">    return fileContents</div><div class="line">&#125;</div><div class="line"></div><div class="line">func printSomeFile() &#123;</div><div class="line">    do &#123;</div><div class="line">        let fileContents = try readFile(filename)</div><div class="line">        print(fileContents)</div><div class="line">    &#125; catch &#123;</div><div class="line">        print(error)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>总而言之，如果某个函数可能会出错，并且出错的原因不能显式地观测到，那么应该优先抛出异常而不是使用一个Optional作为返回值。</p>
<p>###3.11 Using <code>guard</code> Statements</p>
<ul>
<li><strong>3.11.1</strong> 一般来说，我们会优先使用所谓的”early return”策略来避免<code>if</code>表达式中的多层嵌套的代码。在这种情况下使用<code>guard</code>语句能够有效地提升代码的可读性。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">// PREFERRED</div><div class="line">func eatDoughnut(atIndex index: Int) &#123;</div><div class="line">    guard index &gt;= 0 &amp;&amp; index &lt; doughnuts else &#123;</div><div class="line">        // return early because the index is out of bounds</div><div class="line">        return</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    let doughnut = doughnuts[index]</div><div class="line">    eat(doughnut)</div><div class="line">&#125;</div><div class="line"></div><div class="line">// NOT PREFERRED</div><div class="line">func eatDoughnuts(atIndex index: Int) &#123;</div><div class="line">    if index &gt;= 0 &amp;&amp; index &lt; donuts.count &#123;</div><div class="line">        let doughnut = doughnuts[index]</div><div class="line">        eat(doughnut)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>3.11.2</strong> 在对Optional类型进行解包的时候，优先使用 <code>guard</code> 语句来避免<code>if</code>语句中较多的缩进。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">// PREFERRED</div><div class="line">guard let monkeyIsland = monkeyIsland else &#123;</div><div class="line">    return</div><div class="line">&#125;</div><div class="line">bookVacation(onIsland: monkeyIsland)</div><div class="line">bragAboutVacation(onIsland: monkeyIsland)</div><div class="line"></div><div class="line">// NOT PREFERRED</div><div class="line">if let monkeyIsland = monkeyIsland &#123;</div><div class="line">    bookVacation(onIsland: monkeyIsland)</div><div class="line">    bragAboutVacation(onIsland: monkeyIsland)</div><div class="line">&#125;</div><div class="line"></div><div class="line">// EVEN LESS PREFERRED</div><div class="line">if monkeyIsland == nil &#123;</div><div class="line">    return</div><div class="line">&#125;</div><div class="line">bookVacation(onIsland: monkeyIsland!)</div><div class="line">bragAboutVacation(onIsland: monkeyIsland!)</div></pre></td></tr></table></figure>
<ul>
<li><strong>3.11.3</strong> 在决定是要用<code>if</code>表达式还是<code>guard</code>表达式进行Optional类型解包的时候，最重要的点就是要保证代码的可读性。很多时候要注意因时而变，因地制宜：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// an `if` statement is readable here</div><div class="line">if operationFailed &#123;</div><div class="line">    return</div><div class="line">&#125;</div><div class="line"></div><div class="line">// a `guard` statement is readable here</div><div class="line">guard isSuccessful else &#123;</div><div class="line">    return</div><div class="line">&#125;</div><div class="line"></div><div class="line">// double negative logic like this can get hard to read - i.e. don&apos;t do this</div><div class="line">guard !operationFailed else &#123;</div><div class="line">    return</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>3.11.4</strong> 当需要进行多可能性处理的时候，应该优先使用<code>if</code>表达式而不是<code>guard</code>表达式。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// PREFERRED</div><div class="line">if isFriendly &#123;</div><div class="line">    print(&quot;Hello, nice to meet you!&quot;)</div><div class="line">&#125; else &#123;</div><div class="line">    print(&quot;You have the manners of a beggar.&quot;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">// NOT PREFERRED</div><div class="line">guard isFriendly else &#123;</div><div class="line">    print(&quot;You have the manners of a beggar.&quot;)</div><div class="line">    return</div><div class="line">&#125;</div><div class="line"></div><div class="line">print(&quot;Hello, nice to meet you!&quot;)</div></pre></td></tr></table></figure>
<ul>
<li><strong>3.11.5</strong> 一般来说，<code>guard</code>应该被用于需要直接退出当前上下文的情形。而对于下面这种两个条件互不干扰的情况，应该使用两个<code>if</code>而不是两个<code>guard</code>。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">if let monkeyIsland = monkeyIsland &#123;</div><div class="line">    bookVacation(onIsland: monkeyIsland)</div><div class="line">&#125;</div><div class="line"></div><div class="line">if let woodchuck = woodchuck where canChuckWood(woodchuck) &#123;</div><div class="line">    woodchuck.chuckWood()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>3.11.6</strong> 有时候我们会碰到要用<code>guard</code>语句进行多个optionals解包的情况，一般而言，对于复杂的错误处理的Optional类型需要将其拆分到多个单个表达式中。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">// combined because we just return</div><div class="line">guard let thingOne = thingOne,</div><div class="line">    let thingTwo = thingTwo,</div><div class="line">    let thingThree = thingThree else &#123;</div><div class="line">    return</div><div class="line">&#125;</div><div class="line"></div><div class="line">// separate statements because we handle a specific error in each case</div><div class="line">guard let thingOne = thingOne else &#123;</div><div class="line">    throw Error(message: &quot;Unwrapping thingOne failed.&quot;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">guard let thingTwo = thingTwo else &#123;</div><div class="line">    throw Error(message: &quot;Unwrapping thingTwo failed.&quot;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">guard let thingThree = thingThree else &#123;</div><div class="line">    throw Error(message: &quot;Unwrapping thingThree failed.&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>3.11.7</strong> 不要将<code>guard</code>表达式强行缩写到一行内。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// PREFERRED</div><div class="line">guard let thingOne = thingOne else &#123;</div><div class="line">    return</div><div class="line">&#125;</div><div class="line"></div><div class="line">// NOT PREFERRED</div><div class="line">guard let thingOne = thingOne else &#123; return &#125;</div></pre></td></tr></table></figure>
<h2 id="4-Documentation-Comments"><a href="#4-Documentation-Comments" class="headerlink" title="4. Documentation/Comments"></a>4. Documentation/Comments</h2><h3 id="4-1-Documentation"><a href="#4-1-Documentation" class="headerlink" title="4.1 Documentation"></a><a href="https://github.com/wxyyxc1992/iOS-Boilerplate/blob/master/Doc/language/swift/advanced/bestpractices/styleguide/linkedin-swift-style-guide.md#41-documentation" target="_blank" rel="external"></a>4.1 Documentation</h3><p>如果某个函数不是简单地<code>O(1)</code>操作，那么最好就是为该函数添加一些注释文档，这样能有效地提高代码的可读性与可维护性。之前有个非常不错的文档工具<a href="https://github.com/onevcat/VVDocumenter-Xcode" target="_blank" rel="external">VVDocumenter</a>。推荐阅读Apple的官方指南中的描述：<a href="https://developer.apple.com/library/tvos/documentation/Xcode/Reference/xcode_markup_formatting_ref/Attention.html#//apple_ref/doc/uid/TP40016497-CH29-SW1" target="_blank" rel="external">described in Apple’s Documentation</a>.</p>
<p>Guidelines:</p>
<ul>
<li><strong>4.1.1</strong> 每行不应超过160个字符</li>
<li><strong>4.1.2</strong> 即使某些注释只有一行，也应该使用块注释符： (<code>/** */</code>).</li>
<li><strong>4.1.3</strong> 不用给每行的开头都加上： <code>*</code>.</li>
<li><strong>4.1.4</strong> 使用新的 <code>- parameter</code> 标识符来代替老的<code>:param:</code> syntax (注意这边是小写的 <code>parameter</code> 而不是<code>Parameter</code>).</li>
<li><strong>4.1.5</strong> 如果你准备对参数/返回值/异常值来写注释，那么注意要一个不落的全局加上，尽管有时候会让文档显得重复冗余。有时候，如果只需要对单个参数进行注释，那么还不如直接放在描述里进行声明，而不需要专门的为参数写一个注释。</li>
<li><strong>4.1.6</strong> 对于复杂的使用类，应该添加一些具体的使用用例来描述类的用法。注意Swift的注释文档中是支持MarkDown语法的，这是一个很好的特性。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> ## Feature Support</div><div class="line"></div><div class="line"> This class does some awesome things. It supports:</div><div class="line"></div><div class="line"> - Feature 1</div><div class="line"> - Feature 2</div><div class="line"> - Feature 3</div><div class="line"></div><div class="line"> ## Examples</div><div class="line"></div><div class="line"> Here is an example use case indented by four spaces because that indicates a</div><div class="line"> code block:</div><div class="line"></div><div class="line">     let myAwesomeThing = MyAwesomeClass()</div><div class="line">     myAwesomeThing.makeMoney()</div><div class="line"></div><div class="line"> ## Warnings:告警</div><div class="line"></div><div class="line"> There are some things you should be careful of:</div><div class="line"></div><div class="line"> 1. Thing one</div><div class="line"> 2. Thing two</div><div class="line"> 3. Thing three</div><div class="line"> */</div><div class="line">class MyAwesomeClass &#123;</div><div class="line">    /* ... */</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>4.1.7</strong> 使用 - ` 在注释中著名引用的代码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> This does something with a `UIViewController`, perchance.</div><div class="line"> - warning: Make sure that `someValue` is `true` before running this function.</div><div class="line"> */</div><div class="line">func myFunction() &#123;</div><div class="line">    /* ... */</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>4.1.8</strong> 保证文档的注释尽可能的简洁</li>
</ul>
<h3 id="4-2-Other-Commenting-Guidelines-其他的注释规则"><a href="#4-2-Other-Commenting-Guidelines-其他的注释规则" class="headerlink" title="4.2 Other Commenting Guidelines:其他的注释规则"></a>4.2 Other Commenting Guidelines:其他的注释规则</h3><ul>
<li><strong>4.2.1</strong> <code>//</code>后面总是要跟上一个空格</li>
<li><strong>4.2.2</strong> 注释永远要放在单独的行中</li>
<li><strong>4.2.3</strong> 在使用<code>// MARK: - whatever</code>的时候，注意MARK与代码之间保留一个空行</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class Pirate &#123;</div><div class="line"></div><div class="line">    // MARK: - instance properties</div><div class="line"></div><div class="line">    private let pirateName: String</div><div class="line"></div><div class="line">    // MARK: - initialization</div><div class="line"></div><div class="line">    init() &#123;</div><div class="line">        /* ... */</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>原文链接:<a href="https://github.com/wxyyxc1992/iOS-Boilerplate/blob/master/Doc/language/swift/advanced/bestpractices/styleguide/linkedin-swift-style-guide.md#1-code-formatting" target="_blank" rel="external">github:Swift Style Guide</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ooo.0o0.ooo/2016/07/03/5778dc0ab45a1.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;##1. Code Formatting:代码格式化&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;1.1&lt;/strong&gt; 使
    
    </summary>
    
    
      <category term=" - 转载" scheme="http://godknow.cn/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>Swift中的问号?和感叹号!</title>
    <link href="http://godknow.cn/2016/06/28/swiftzhong-de-wen-hao-he-gan-tan-hao/"/>
    <id>http://godknow.cn/2016/06/28/swiftzhong-de-wen-hao-he-gan-tan-hao/</id>
    <published>2016-06-28T08:50:22.000Z</published>
    <updated>2016-06-28T08:53:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文转载自：<a href="http://joeyio.com/ios/2014/06/04/swift---/" target="_blank" rel="external">代码手工艺人</a>的博客，原文名称：Swift之 ? 和 !</p>
<p>Swift语言使用var定义变量，但和别的语言不同，Swift里不会自动给变量赋初始值，也就是说变量不会有默认值，所以要求使用变量之前必须要对其初始化。如果在使用变量之前不进行初始化就会报错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var stringValue : String </div><div class="line">//error: variable &apos;stringValue&apos; used before being initialized</div><div class="line">//let hashValue = stringValue.hashValue</div><div class="line">//                            ^</div><div class="line">let hashValue = stringValue.hashValue</div></pre></td></tr></table></figure>
<p>上面了解到的是普通值，接下来Optional值要上场了。经<a href="http://onevcat.com/" target="_blank" rel="external">喵神</a>提醒，Optional其实是个<code>enum</code>，里面有<code>None</code>和<code>Some</code>两种类型。其实所谓的nil就是<code>Optional.None</code>, 非nil就是<code>Optional.Some</code>, 然后会通过<code>Some(T)</code>包装（wrap）原始值，这也是为什么在使用Optional的时候要拆包（从enum里取出来原始值）的原因, 也是PlayGround会把Optional值显示为类似<code>{Some &quot;hello world&quot;}</code>的原因，这里是enum Optional的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">enum Optional&lt;T&gt; : LogicValue, Reflectable &#123;</div><div class="line">    case None</div><div class="line">    case Some(T)</div><div class="line">    init()</div><div class="line">    init(_ some: T)</div><div class="line"></div><div class="line">    /// Allow use in a Boolean context.</div><div class="line">    func getLogicValue() -&gt; Bool</div><div class="line"></div><div class="line">    /// Haskell&apos;s fmap, which was mis-named</div><div class="line">    func map&lt;U&gt;(f: (T) -&gt; U) -&gt; U?</div><div class="line">    func getMirror() -&gt; Mirror</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>声明为Optional只需要在类型后面<strong>紧跟</strong>一个<code>?</code>即可。如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var strValue: String?   //?相当于下面这种写法的语法糖</div><div class="line">var strValue: Optional&lt;Int&gt;</div></pre></td></tr></table></figure>
<p>一旦声明为Optional的，如果不显式的赋值就会有个默认值nil。判断一个Optional的值是否有值，可以用if来判断：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if strValue &#123;</div><div class="line">    //do sth with strValue</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后怎么使用Optional值呢？文档中也有提到说，在使用Optional值的时候需要在具体的操作，比如调用方法、属性、下标索引等前面需要加上一个<code>?</code>，经<a href="http://onevcat.com/" target="_blank" rel="external">喵神</a>指正，”Optional Chaining的问号的意思是询问是否响应后面这个方法，和原来的<code>isResponseToSelector</code>有些类似”，如果是nil值，也就是<code>Optional.None</code>，固然不能响应后面的方法，所以就会跳过，如果有值，就是<code>Optional.Some</code>，可能就会拆包(unwrap)，然后对拆包后的值执行后面的操作，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let hashValue = strValue?.hashValue</div></pre></td></tr></table></figure>
<p>strValue是Optional的字符串，如果strValue是nil，则hashValue也为nil，如果strValue不为nil，hashValue就是strValue字符串的哈希值</p>
<p>到这里我们看到了<code>?</code>的两种使用场景:1.声明Optional值变量<br>2.用在对Optional值操作中，用来判断是否能响应后面的操作</p>
<p>另外，对于Optional值，不能直接进行操作，否则会报错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//error: &apos;String?&apos; does not have a member named &apos;hashValue&apos;</div><div class="line">//let hashValue = strValue.hashValue</div><div class="line">//                ^        ~~~~~~~~~</div><div class="line"></div><div class="line">let hashValue = strValue.hashValue</div></pre></td></tr></table></figure>
<p>上面提到Optional值需要拆包(unwrap)后才能得到原来值，然后才能对其操作，那怎么来拆包呢？拆包提到了几种方法，一种是<code>Optional Binding</code>， 比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if let str = strValue &#123;</div><div class="line">    let hashValue = str.hashValue</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>还有一种是在具体的操作前添加<code>!</code>符号，好吧，这又是什么诡异的语法?!</p>
<p>直接上例子，strValue是Optional的String：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let hashValue = strValue!.hashValue</div></pre></td></tr></table></figure>
<p>这里的<code>!</code>表示“我确定这里的的strValue一定是非nil的，尽情调用吧” ，比如这种情况:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if strValue &#123;</div><div class="line">    let hashValue = strValue!.hashValue</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>{}里的strValue一定是非nil的，所以就能直接加上!，强制拆包(unwrap)并执行后面的操作。 当然如果不加判断，strValue不小心为nil的话，就会出错，crash掉。</p>
<p>考虑下这一种情况，我们有一个自定义的<code>MyViewController</code>类，类中有一个属性是<code>myLabel</code>，myLabel是在viewDidLoad中进行初始化。因为是在viewDidLoad中初始化，所以不能直接声明为普通值：<code>var myLabel : UILabel</code>，因为非Optional的变量必须在声明时或者构造器中进行初始化，但我们是想在viewDidLoad中初始化，所以就只能声明为Optional：<code>var myLabel: UILabel?</code>, 虽然我们确定在viewDidLoad中会初始化，并且在ViewController的生命周期内不会置为nil，但是在对myLabel操作时，每次依然要加上<code>!</code>来强制拆包(在读取值的时候，也可以用<code>?</code>，谢谢iPresent在回复中提醒)，比如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">myLabel!.text = &quot;text&quot;</div><div class="line">myLabel!.frame = CGRectMake(0, 0, 10, 10)</div><div class="line">...</div></pre></td></tr></table></figure>
<p>对于这种类型的值，我们可以直接这么声明：<code>var myLabel: UILabel!</code>, 果然是高(hao)大(gui)上(yi)的语法!, 这种是特殊的Optional，称为<code>Implicitly Unwrapped Optionals</code>, 直译就是隐式拆包的Optional，就等于说你每次对这种类型的值操作时，都会自动在操作前补上一个<code>!</code>进行拆包，然后在执行后面的操作，当然如果该值是nil，也一样会报错crash掉。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var myLabel: UILabel!  //!相当于下面这种写法的语法糖</div><div class="line">var myLabel: ImplicitlyUnwrappedOptional&lt;UILabel&gt;</div></pre></td></tr></table></figure>
<p>Swift是门新生的语言，我们有幸见证了它的诞生，激动之余也在佩服苹果大刀阔斧的推出一个新的语言替代一个已经比较成熟语言的魄力，今天在知乎日报上看到一个回答是说Swift是一门玩具语言，正当想去吐槽，发现回答已经被删除了。个人认为苹果是很认真的推出Swift的，从Swift的各种细微的设计也能看的出来。</p>
<p>另外这两个小符号就花费了我不少的时间来理解，可能依然会有错误和不妥之处，欢迎大家指正，本文旨在抛砖引玉。除此之外，Swift还有很多很棒的特性，WWDC 2014 会有四五个和Swift语言相关的Video，大家也可以去关注一下。</p>
<p>最后要感谢<a href="http://onevcat.com/" target="_blank" rel="external">喵神</a>的纠正了多处有问题的地方，thx, have fun!</p>
<p>主要参考自苹果的官方文档《The Swift Programming Language》，可以在<a href="https://developer.apple.com/swift/" target="_blank" rel="external">这里</a>下载到</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文转载自：&lt;a href=&quot;http://joeyio.com/ios/2014/06/04/swift---/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;代码手工艺人&lt;/a&gt;的博客，原文名称：Swift之 ? 和 !&lt;/p&gt;
&lt;p&gt;Swift语言使
    
    </summary>
    
    
      <category term="转载" scheme="http://godknow.cn/tags/%E8%BD%AC%E8%BD%BD/"/>
    
      <category term="swift" scheme="http://godknow.cn/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift 中的异常抛出和错误处理</title>
    <link href="http://godknow.cn/2016/06/28/swift-zhong-de-yi-chang-pao-chu-he-cuo-wu-chu-li/"/>
    <id>http://godknow.cn/2016/06/28/swift-zhong-de-yi-chang-pao-chu-he-cuo-wu-chu-li/</id>
    <published>2016-06-28T04:19:24.000Z</published>
    <updated>2016-06-28T04:20:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Swift语言对其错误处理进行了新的设计，当然了，重新设计后的结果使得该错误处理系统用起来更爽。今天的主题就是系统的搞一下Swift中的错误处理，以及看一下Swift中是如何抛出异常的。在编译型语言中，错误一般分为编译错误和运行时错误。我们平时在代码中处理的错误为运行时错误，我们对异常进行处理的操作的目的是为了防止程序出现错误而导致其他的副作用，比如用户数据未保存等等。</p>
<p>在今天的文章中，先给出主动产生异常的几种情况，然后再给出如何处理被动异常。</p>
<h1 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h1><p><strong>一、主动退出程序的几种情况</strong></p>
<p>在Objective-C中，在单元测试时我们会使用断言，断言中条件满足时会产生异常，并打印出相应的断言错误，在Swift中也有几种产生异常的语法。在本篇博客的第一部分就给出这几种方法。</p>
<p><strong>1.Fatal Errors（致命的错误）</strong></p>
<p>使用fatalError()函数可以立即终止你的应用程序，在fatalError()中可以给出终止信息。使用fatalError()函数，会毫无条件的终止你的应用程序，用起来也是比较简单的，就是一个函数的调用。下方这个Demo一目了然呢，在此就不做过多赘述了。</p>
<p><img src="http://files.jb51.net/file_images/article/201602/201602261147512.png" alt="img"></p>
<p><strong>2. Assertions（断言）</strong></p>
<p>在单元测试中是少不了断言的，Swift中的断言和Objective-C的区别不是太大，使用方法也是大同小异。下方就是断言的两种方法，由代码提示可知，在断言中的提示条件是可选的。断言会在Debug模式下起作用，但是在Release版本中就会被忽略。</p>
<p><img src="http://files.jb51.net/file_images/article/201602/201602261147513.png" alt="img"></p>
<p>在assert()函数中, 第一个参数是Bool类型，第二个参数是输出的信息。当条件为true时，断言不执行，相应的断言信息不打印。当条件为false时，断言执行，并且打印相应的断言信息。</p>
<p><img src="http://files.jb51.net/file_images/article/201602/201602261147514.png" alt="img"></p>
<p>assertionFailure()函数只有一个Message参数，并且该参数也是可以省略的，assertionFailure()没有条件。如下所示：</p>
<p><img src="http://files.jb51.net/file_images/article/201602/201602261147515.png" alt="img"></p>
<p><strong>3. 先决条件（Preconditions）</strong></p>
<p>Preconditions的用法和断言一样，不过有一点需要主要，Preconditions在debug和release模式下都会被执行，除非使用–Ounchecked进行编译。下方截图是代码提示给出的Preconditions函数的提示，如下所示：</p>
<p><img src="http://files.jb51.net/file_images/article/201602/201602261147516.png" alt="img"></p>
<p>关于Preconditions的具体用法请参照断言，和断言用法一样，在此就不做过多的赘述了。</p>
<p><strong>二.Swift中的错误处理</strong></p>
<p>在Objective-C中，如果你处理过错误的话，那么你将会对NSError很熟悉。在Swift中，如果你要定义你自己的错误类型，你只需要实现ErrorType协议即可。声明完错误类型后，就可以在处理错误抛出异常时使用自定义的错误类型了。下方将会一步步带你走完Swift中的错误处理的路程。</p>
<p><strong>1.使用枚举创建错误类型</strong></p>
<p>（1）.遵循ErrorType协议，自定义错误类型。下方定义了一个错误类型枚举，该枚举遵循了ErrorType协议，在接下来的代码中我们将会使用这个MyCustomErrorType枚举，错误枚举的实现如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//定义错误类型</div><div class="line">enum MyCustomErrorType: ErrorType &#123;</div><div class="line">case ErrorReason</div><div class="line">case ErrorReason</div><div class="line">case ErrorReason</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>（2）.在我们的函数定义时可以使用throws关键字，以及在函数中使用throw关键字对错误进行抛出，抛出的错误类型就可以使用上面我们自己定义的错误类型。下方函数就是一个可以抛出错误的函数，抛出的错误就是我们在上面枚举中所定义的类型。具体代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">func myThrowFunc() throws &#123;</div><div class="line">let test:Int? = nil</div><div class="line">guard test != nil else &#123;</div><div class="line">throw MyCustomErrorType.ErrorReason</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>（3）.上面函数的功能是对错误进行抛出，接下来就该使用do-catch来处理抛出的错误。使用try对错误进行捕捉，使用do-catch对错误进行处理。具体处理方式如下所示。在下方错误处理中类似于switch-case语句，catch后边可以枚举匹配错误类型，具体如下所示：　　　　</p>
<p><img src="http://files.jb51.net/file_images/article/201602/201602261147517.png" alt="img"></p>
<p>（4）在枚举实现错误类型中我们可以通过值绑定的形式为错误添加错误代码和错误原因。在声明枚举时，我们使用了枚举元素值绑定的特性（关于枚举使用的更多细节请参考之前的博客《窥探Swift之别样的枚举类型》）。在声明枚举成员ErrorState时，我们为其绑定了两个变量，一个是错误代码errorCode, 另一个是错误原因errorReason。这两者可以在抛出错误时为其传入相应的值，如下方代码片段中的throwError函数所示，在抛出错误是为errorCode指定的错误代码为404，为errorReason指定的错误原因是“not found”。</p>
<p>　　最后就是使用do-catch处理异常了，在catch中对绑定的错误代码和错误原因进行了获取，并且通过where子句进行了错误代码的筛选。此处catch的用法与switch-case中获取枚举绑定值的用法是一样的，所以在此就不做过多的赘述。具体实现方式如下代码所示：</p>
<p><img src="http://files.jb51.net/file_images/article/201602/201602261147518.png" alt="img"></p>
<p><strong>2.使用结构体为错误处理添加Reason</strong></p>
<p>在上面的内容中，使用枚举遵循ErrorType协议的方式定义了特定的错误类型。接下来我们将使用结构体来遵循ErrorType协议，为错误类型添加错误原因。也就是说，我们可以在抛出错误时，给自定义错误类型提供错误原因。该功能在开发中是非常常用的，而且用起来也是非常爽的。接下来就看一下如何为我们的错误类型添加错误原因。</p>
<p>（1）使用结构体创建错误类型，下方名为MyErrorType的结构体遵循了ErrorType协议，并且在MyErrorType结构体中，声明了一个reason常量，该reason常量中存储的就是错误原因，具体实现方式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">struct MyErrorType: ErrorType &#123;</div><div class="line">let reason : String</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>（2）上面定义完错误类型结构体后，在错误抛出中就可以使用了。在错误抛出时，可以传入一个错误原因，具体代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">func myThrowFunc() throws &#123;</div><div class="line">let test:Int? = nil</div><div class="line">guard test != nil else &#123;</div><div class="line">throw MyErrorType(reason: &quot;我是详细的错误原因，存储在error中&quot;)</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>（3）最后要对抛出的错误进行do-catch处理，在处理时，可以对错误原因进行打印，错误原因存储在error中，具体操作和打印结果如下所示：　　　　　　</p>
<p><img src="http://files.jb51.net/file_images/article/201602/201602261147519.png" alt="img"></p>
<p>由上面的输出结果可知，error是我们自定义的MyErrorType类型，我们可以使用下面的代码来代替catch中的print语句，如下所示：　　　　</p>
<p><img src="http://files.jb51.net/file_images/article/201602/2016022611475110.png" alt="img"></p>
<p>上面的做法似乎有些麻烦，还有一种简化输出的方法，就是在上述结构体中实现CustomDebugStringConvertible协议，对描述信息进行一个重写，就可以在打印error时，只打印错误信息，下方是重写后的结构体。　　　</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">struct MyErrorType: ErrorType,CustomDebugStringConvertible &#123;</div><div class="line">let reason : String</div><div class="line">var debugDescription: String &#123;</div><div class="line">return &quot;错误类型-----\(self.dynamicType): \(reason)&quot;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>修改后，输出结果如下，直接打印error输出的就是错误信息，而不是MyErrorType类型。</p>
<p><img src="http://files.jb51.net/file_images/article/201602/2016022611475111.png" alt="img"></p>
<p><strong>3.使String类型遵循ErrorType协议，直接使用String提供错误原因</strong></p>
<p>在“2”中，我们使用了结构体遵循ErrorType协议的形式，来为错误提供错误信息的。在接下来的部分，我们将通过更为简单的方式为抛出的错误提供错误信息。这种方式更为简单，也易于理解，具体方式如下方代码所示：　　　　</p>
<p><img src="http://files.jb51.net/file_images/article/201602/2016022611475112.png" alt="img"></p>
<p><strong>三、在错误处理中使用内置关键字</strong></p>
<p><strong>1.初探这些内置关键字</strong></p>
<p>在Swift中提供了一些内置关键字（<strong>FILE</strong>, <strong>FUNCTION</strong>, <strong>LINE</strong>等）来获取上下文信息，在本篇博客的第三部分，将会给出如何在我们的错误处理中使用这些内置关键字。下方就是这些内置关键字的作用，如下所示：</p>
<p><img src="http://files.jb51.net/file_images/article/201602/2016022611475113.png" alt="img"></p>
<p>上面说是内置关键字，其实就是存储代码上下文的宏定义，上方代码段简单的给出了这些内置关键字的作用与用法，在接下来将在ErrorType中使用这些内置关键字，让我们的错误信息更加丰富多彩。　</p>
<p><strong>2.在ErrorType中使用上述内置关键字</strong></p>
<p>如果想在ErrorType中使用这些上下文内置关键字，我们只需要对ErrorType进行扩展，使其在ErrorType提供错误信息时给出出错的上下文信息。当然，这实现起来比较简单，就是在ErrorType中添加了一个扩展方法contextString()。该方法的作用就是提供错误的上下文信息，也就是在出错的地方，调用contextString()方法生成上下文描述信息即可。对ErrorType协议的具体延展实现如下代码段所示.</p>
<p>在下方代码片段中，我们对ErrorType进行了扩展，为ErrorType添加了contextString的函数实现。contextString()函数有三个默认参数，分别是file–当前文件名，function–当前出错的函数名，line–当前抛出异常的行数。上述三个参数都有参数默认值，分别对应着<strong>FILE</strong>, <strong>FUNCTION</strong>, <strong>LINE</strong>。该扩展函数的返回值为这三个参数组成从字符串信息。具体实现如下所示：</p>
<p><img src="http://files.jb51.net/file_images/article/201602/2016022611475214.png" alt="img"></p>
<p><strong>3.使用扩展的contextString方法</strong></p>
<p>上面我们使用结构体实现ErrorType协议的形式，为错误类型添加错误原因。接下来我们将在添加reason的同时，使用contextString()函数添加描述信息。下方CustomErrorType结构体遵循了ErrorType协议，其中添加了一个reason常量来存储错误原因，一个context常量来存储上下文信息，并且为该结构体添加了一个构造函数，在构造函数中初始化和reason常量。具体实现如下所示：　　</p>
<p><img src="http://files.jb51.net/file_images/article/201602/2016022611475215.png" alt="img"></p>
<p><strong>4. 抛出并捕获异常</strong></p>
<p>在下方代码中函数throwError()抛出了异常，该抛出的错误类型是CustomErrorType。在创建CustomErrorType类型实例，也就是err变量时，我们指定了错误原因，也就是为reason赋了一个值。在创建完err实例后，我们又调用延展contextString()函数获取异常的上下文信息，并把返回的内容存储在err实例的context属性中。最后使用throw关键字抛出err实例，如下方第一部分代码所示。</p>
<p>在创建抛出异常的函数后，我们需要对抛出的异常进行捕获。也就是使用try对异常进行捕获，使用do-catch对异常进行处理，具体操作如下方第二段代码所示。</p>
<p>　　　<img src="http://files.jb51.net/file_images/article/201602/2016022611475216.png" alt="img">　</p>
<p><strong>5. 分析打印结果</strong></p>
<p>经过上述步骤如果你在Playground中进行试验的，那么在控制台上你将会看到如下信息。从打印出的信息我们可以看到，信息包括reason：错误原因，和context：异常上下文。在下方的输出结果中，文件名我们可以看到是<expr>这并不是确切的文件名，因为我们是在Playground中使用的，并且不是确切的Swift源文件，所以获取不到确切的文件名。</expr></p>
<p><img src="http://files.jb51.net/file_images/article/201602/2016022611475217.png" alt="img"></p>
<p>为了观察确切的文件名，我们需要在确切的Swift源文件中抛出上述异常。在特定Swift源文件中，我们会看到下方的输出结果。从下方的输出日志中，我们可以清楚的看到文件名是一个详细的文件路径。如下所示：　　　　</p>
<p><img src="http://files.jb51.net/file_images/article/201602/2016022611475218.png" alt="img"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Swift语言对其错误处理进行了新的设计，当然了，重新设计后的结果使得该错误处理系统用起来更爽。今天的主题就是系统的搞一下Swift中的错误
    
    </summary>
    
    
      <category term=" - swift" scheme="http://godknow.cn/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>React-Native学习笔记</title>
    <link href="http://godknow.cn/2016/06/28/react-nativexue-xi-bi-ji/"/>
    <id>http://godknow.cn/2016/06/28/react-nativexue-xi-bi-ji/</id>
    <published>2016-06-27T16:47:14.000Z</published>
    <updated>2016-07-13T07:01:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>自己在学习React-Native过程中整理的一份学习指南，包含 教程、开源app和资源网站等，还在不断更新中。欢迎pull requests！</p>
<p>React-Native学习指南</p>
<p>本指南汇集React-Native各类学习资源，给大家提供便利。指南正在不断的更新，大家有好的资源欢迎Pull Requests！</p>
<p>同时还有Awesome React-Native系列</p>
<p><a href="https://github.com/jondot/awesome-react-native" target="_blank" rel="external">https://github.com/jondot/awesome-react-native</a></p>
<h1 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h1><p>react-native 官方api文档 <a href="http://facebook.github.io/react-native/docs/getting-started.html" target="_blank" rel="external">http://facebook.github.io/react-native/docs/getting-started.html</a></p>
<p>react-native 中文api文档 (翻译中) <a href="https://github.com/ecomfe/react-native-cn" target="_blank" rel="external">https://github.com/ecomfe/react-native-cn</a></p>
<p>react.js中文文档 <a href="http://reactjs.cn/" target="_blank" rel="external">http://reactjs.cn/</a></p>
<p>react.js入门教程(gitbook) <a href="http://hulufei.gitbooks.io/react-tutorial/content/introduction.html" target="_blank" rel="external">http://hulufei.gitbooks.io/react-tutorial/content/introduction.html</a></p>
<p>react.js快速入门教程 - 阮一峰 <a href="http://www.ruanyifeng.com/blog/2015/03/react.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2015/03/react.html</a></p>
<p>react.js视频教程 <a href="http://react.nodejs-china.org/t/reactjszhong-wen-shi-pin-jiao-cheng-bai-du-wang-pan/584" target="_blank" rel="external">http://react.nodejs-china.org/t/reactjszhong-wen-shi-pin-jiao-cheng-bai-du-wang-pan/584</a></p>
<p>react-native第一课 <a href="http://html-js.com/article/2783" target="_blank" rel="external">http://html-js.com/article/2783</a></p>
<p>深入浅出 React Native：使用 JavaScript 构建原生应用 <a href="http://zhuanlan.zhihu.com/FrontendMagazine/19996445" target="_blank" rel="external">http://zhuanlan.zhihu.com/FrontendMagazine/19996445</a></p>
<p>React Native通信机制详解 <a href="http://blog.cnbang.net/tech/2698/" target="_blank" rel="external">http://blog.cnbang.net/tech/2698/</a></p>
<p>React Native布局篇 <a href="http://segmentfault.com/a/1190000002658374" target="_blank" rel="external">http://segmentfault.com/a/1190000002658374</a></p>
<p>React Native 基础练习指北（一） <a href="http://segmentfault.com/a/1190000002645929" target="_blank" rel="external">http://segmentfault.com/a/1190000002645929</a></p>
<p>React Native 基础练习指北（二） <a href="http://segmentfault.com/a/1190000002647733" target="_blank" rel="external">http://segmentfault.com/a/1190000002647733</a></p>
<p>构建一个简单的列表页和2页导航 <a href="http://www.xn--cnq920ntha.cn/archives/235#6838470-tsina-1-17436-6a377b1a66595f9ede646cf5c012734c" target="_blank" rel="external">http://www.xn--cnq920ntha.cn/archives/235#6838470-tsina-1-17436-6a377b1a66595f9ede646cf5c012734c</a></p>
<p>Diary of Building an iOS App with React Native <a href="http://herman.asia/building-a-flashcard-app-with-react-native" target="_blank" rel="external">http://herman.asia/building-a-flashcard-app-with-react-native</a></p>
<p>Use React Native in Existing iOS App <a href="http://blog-en.leapoahead.com/post/use-react-native-in-existing-ios-app" target="_blank" rel="external">http://blog-en.leapoahead.com/post/use-react-native-in-existing-ios-app</a></p>
<p>tcomb-form-native使用视频教程(需翻墙) <a href="http://react.rocks/example/tcomb-form-native" target="_blank" rel="external">http://react.rocks/example/tcomb-form-native</a></p>
<h1 id="开源APP"><a href="#开源APP" class="headerlink" title="开源APP"></a>开源APP</h1><p>研究源码也是一个很好的学习方式</p>
<p>官方演示App <a href="https://github.com/facebook/react-native/tree/master/Examples" target="_blank" rel="external">https://github.com/facebook/react-native/tree/master/Examples</a></p>
<p>ReactNativeRubyChina <a href="https://github.com/henter/ReactNativeRubyChina" target="_blank" rel="external">https://github.com/henter/ReactNativeRubyChina</a></p>
<p>HackerNews-React-Native <a href="https://github.com/iSimar/HackerNews-React-Native" target="_blank" rel="external">https://github.com/iSimar/HackerNews-React-Native</a></p>
<p>React-Native新闻客户端 <a href="https://github.com/tabalt/ReactNativeNews" target="_blank" rel="external">https://github.com/tabalt/ReactNativeNews</a></p>
<p>newswatch(新闻客户端) <a href="https://github.com/bradoyler/newswatch-react-native" target="_blank" rel="external">https://github.com/bradoyler/newswatch-react-native</a></p>
<p>buyscreen(购买页面) <a href="https://github.com/appintheair/react-native-buyscreen" target="_blank" rel="external">https://github.com/appintheair/react-native-buyscreen</a></p>
<p>V2EX客户端 <a href="https://github.com/samuel1112/v2er" target="_blank" rel="external">https://github.com/samuel1112/v2er</a></p>
<p>react-native-todo <a href="https://github.com/joemaddalone/react-native-todo" target="_blank" rel="external">https://github.com/joemaddalone/react-native-todo</a></p>
<p>react-native-beer <a href="https://github.com/muratsu/react-native-beer" target="_blank" rel="external">https://github.com/muratsu/react-native-beer</a></p>
<p>react-native-stars <a href="https://github.com/86/react-native-stars" target="_blank" rel="external">https://github.com/86/react-native-stars</a></p>
<p>模仿天猫首页的app <a href="https://github.com/baofen14787/react-native-demo" target="_blank" rel="external">https://github.com/baofen14787/react-native-demo</a></p>
<p>ReactNativeChess <a href="https://github.com/csarsam/ReactNativeChess" target="_blank" rel="external">https://github.com/csarsam/ReactNativeChess</a></p>
<p>react native 编写的音乐软件 <a href="https://github.com/Johnqing/miumiu" target="_blank" rel="external">https://github.com/Johnqing/miumiu</a></p>
<p>react-native-pokedex <a href="https://github.com/ababol/react-native-pokedex" target="_blank" rel="external">https://github.com/ababol/react-native-pokedex</a></p>
<p>CNode-React-Native <a href="https://github.com/SFantasy/CNode-React-Native" target="_blank" rel="external">https://github.com/SFantasy/CNode-React-Native</a></p>
<p>8tracks电台客户端 <a href="https://github.com/voronianski/EightTracksReactNative" target="_blank" rel="external">https://github.com/voronianski/EightTracksReactNative</a></p>
<p>React-Native实现的计算器 <a href="https://github.com/yoxisem544/Calculator-using-React-Native" target="_blank" rel="external">https://github.com/yoxisem544/Calculator-using-React-Native</a></p>
<p>房产搜索app <a href="https://github.com/jawee/react-native-PropertyFinder" target="_blank" rel="external">https://github.com/jawee/react-native-PropertyFinder</a></p>
<p>知乎专栏app <a href="https://github.com/LeezQ/react-native-zhihu-app" target="_blank" rel="external">https://github.com/LeezQ/react-native-zhihu-app</a></p>
<p>ForeignExchangeApp <a href="https://github.com/peralmq/ForeignExchangeApp" target="_blank" rel="external">https://github.com/peralmq/ForeignExchangeApp</a></p>
<h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><p>react-native-snippets(代码提示) <a href="https://github.com/Shrugs/react-native-snippets" target="_blank" rel="external">https://github.com/Shrugs/react-native-snippets</a></p>
<p>react-native-babel(使用ES6+) <a href="https://github.com/roman01la/react-native-babel" target="_blank" rel="external">https://github.com/roman01la/react-native-babel</a></p>
<p>资源网站</p>
<p>React-native官网 <a href="http://facebook.github.io/react-native/" target="_blank" rel="external">http://facebook.github.io/react-native/</a></p>
<p>React-China社区 <a href="http://react-china.org/" target="_blank" rel="external">http://react-china.org/</a></p>
<p>React-native组件库（比较全的组件库） <a href="http://react.parts/" target="_blank" rel="external">http://react.parts/</a></p>
<p>React Native Modules <a href="http://reactnativemodules.com/" target="_blank" rel="external">http://reactnativemodules.com/</a></p>
<p>11款React Native开源移动 UI 组件 <a href="http://www.oschina.net/news/61214/11-react-native-ui-components" target="_blank" rel="external">http://www.oschina.net/news/61214/11-react-native-ui-components</a></p>
<h1 id="业界讨论"><a href="#业界讨论" class="headerlink" title="业界讨论"></a>业界讨论</h1><p>谈谈 React Native - 唐巧 <a href="http://blog.devtang.com/blog/2015/02/01/talk-about-react-native/" target="_blank" rel="external">http://blog.devtang.com/blog/2015/02/01/talk-about-react-native/</a></p>
<p>如何评价React-Native? <a href="http://www.zhihu.com/question/27852694/answer/43990708" target="_blank" rel="external">http://www.zhihu.com/question/27852694/answer/43990708</a></p>
<p>React Native概述：背景、规划和风险 <a href="http://div.io/topic/938" target="_blank" rel="external">http://div.io/topic/938</a></p>
<h1 id="官方指南：-https-github-com-ele828-react-native-guide"><a href="#官方指南：-https-github-com-ele828-react-native-guide" class="headerlink" title="官方指南： https://github.com/ele828/react-native-guide"></a>官方指南： <a href="https://github.com/ele828/react-native-guide" target="_blank" rel="external">https://github.com/ele828/react-native-guide</a></h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自己在学习React-Native过程中整理的一份学习指南，包含 教程、开源app和资源网站等，还在不断更新中。欢迎pull requests！&lt;/p&gt;
&lt;p&gt;React-Native学习指南&lt;/p&gt;
&lt;p&gt;本指南汇集React-Native各类学习资源，给大家提供便利。指
    
    </summary>
    
    
      <category term="前端" scheme="http://godknow.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="React-Native" scheme="http://godknow.cn/tags/React-Native/"/>
    
      <category term="转载" scheme="http://godknow.cn/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>Mac OS X 进程UserEventAgent 占用CPU 100%的解决办法</title>
    <link href="http://godknow.cn/2016/06/26/mac-os-x-jin-cheng-usereventagent-zhan-yong-cpu-100-de-jie-jue-ban-fa/"/>
    <id>http://godknow.cn/2016/06/26/mac-os-x-jin-cheng-usereventagent-zhan-yong-cpu-100-de-jie-jue-ban-fa/</id>
    <published>2016-06-26T14:53:59.000Z</published>
    <updated>2016-06-26T14:54:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>前几天电脑无故发热特别厉害，达到了70+度，一查进程居然有一个UserEventAgent占了100%的CPU，虽未影响系统流畅度，还是受不了这么高的温度，我也不记得对系统和硬件做过什么大的改动，上网查了一下似乎和USB设备有关，后来一忙又把这事放了几天，今天干脆直接申请了Apple支持，电话连线近一小时仍无果（服务还是不错的），只能提供了一些后续的解决方案。<br>闲不住自己试了几遍，发现只有连接鼠标的时候才会有这个问题（不过这鼠标以前用着一切正常..），点开UserEventAgent进程发现打开的文件里很多在/system/Library/下，没看到和鼠标有关的，直接Finder定位到/System/Library/搜索mouse，出来两个目测和鼠标有关的文件：<br>AppleHIDMouse.kext<br>AppleHIDMouseAgent.plugin </p>
<p>本想直接把这文件移动到其他路径，为求保险再搜了一下上面自己猜测的信息，在Apple的技术支持论坛找到一个和上述一样解决方法的帖子，原来只需要删除下面这一个文件即可：<br><code>/System/Library/UserEventPlugins/AppleHIDMouseAgent.plugin/Contents/MacOS/AppleH IDMouseAgent</code></p>
<p>删除之，重启，终于恢复正常。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前几天电脑无故发热特别厉害，达到了70+度，一查进程居然有一个UserEventAgent占了100%的CPU，虽未影响系统流畅度，还是受不了这么高的温度，我也不记得对系统和硬件做过什么大的改动，上网查了一下似乎和USB设备有关，后来一忙又把这事放了几天，今天干脆直接申请了
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Bitcode 理解</title>
    <link href="http://godknow.cn/2016/06/26/bitcode-li-jie/"/>
    <id>http://godknow.cn/2016/06/26/bitcode-li-jie/</id>
    <published>2016-06-26T07:14:20.000Z</published>
    <updated>2016-06-28T05:10:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天试着用Xcode 7 beta 3在真机(iOS 8.3)上运行一下我们的工程，结果发现工程编译不过。看了下问题，得到的信息是我们引入的一个第三方库不包含bitcode。嗯，不知道bitcode是啥，所以就得先看看这货是啥了。</p>
<p><img src="http://cc.cocimg.com/api/uploads/20150702/1435823658708967.png" alt=""></p>
<h1 id="Bitcode是什么？"><a href="#Bitcode是什么？" class="headerlink" title="Bitcode是什么？"></a>Bitcode是什么？</h1><p>找东西嘛，最先想到的当然是先看官方文档了。在<a href="https://developer.apple.com/library/prerelease/ios/documentation/IDEs/Conceptual/AppDistributionGuide/AppThinning/AppThinning.html#//apple_ref/doc/uid/TP40012582-CH35" target="_blank" rel="external">App Distribution Guide – App Thinning (iOS, watchOS)</a>一节中，找到了下面这样一个定义：</p>
<p>Bitcode is an intermediate representation of a compiled program. Apps you upload to iTunes Connect that contain bitcode will be compiled and linked on the App Store. Including bitcode will allow Apple to re-optimize your app binary in the future without the need to submit a new version of your app to the store.</p>
<p>说的是bitcode是被编译程序的一种中间形式的代码。包含bitcode配置的程序将会在App store上被编译和链接。bitcode允许苹果在后期重新优化我们程序的二进制文件，而不需要我们重新提交一个新的版本到App store上。</p>
<p>嗯，看着挺高级的啊。</p>
<p>继续看，在<a href="https://developer.apple.com/library/prerelease/ios/documentation/DeveloperTools/Conceptual/WhatsNewXcode/Articles/xcode_7_0.html" target="_blank" rel="external">What’s New in Xcode-New Features in Xcode 7</a>中，还有一段如下的描述</p>
<p>Bitcode. When you archive for submission to the App Store, Xcode will compile your app into an intermediate representation. The App Store will then compile the bitcode down into the 64 or 32 bit executables as necessary.</p>
<p>当我们提交程序到App store上时，Xcode会将程序编译为一个中间表现形式(bitcode)。然后App store会再将这个botcode编译为可执行的64位或32位程序。</p>
<p>再看看这两段描述都是放在App Thinning(App瘦身)一节中，可以看出其与包的优化有关了。喵大(@onevcat)在其博客<a href="http://onevcat.com/2015/06/ios9-sdk/" target="_blank" rel="external">开发者所需要知道的 iOS 9 SDK 新特性</a>中也描述了iOS 9中苹果在App瘦身中所做的一些改进，大家可以转场到那去研读一下。</p>
<h1 id="Bitcode配置"><a href="#Bitcode配置" class="headerlink" title="Bitcode配置"></a>Bitcode配置</h1><p>在上面的错误提示中，提到了如何处理我们遇到的问题：</p>
<p>You must rebuild it with bitcode enabled (Xcode setting ENABLE_BITCODE), obtain an updated library from the vendor, or disable bitcode for this target. for architecture arm64</p>
<p>要么让第三方库支持，要么关闭target的bitcode选项。</p>
<p>实际上在Xcode 7中，我们新建一个iOS程序时，bitcode选项默认是设置为YES的。我们可以在”Build Settings”-&gt;”Enable Bitcode”选项中看到这个设置。</p>
<p>不过，我们现在需要考虑的是三个平台：iOS，Mac OS，watchOS。</p>
<ul>
<li>对应iOS，bitcode是可选的。</li>
<li>对于watchOS，bitcode是必须的。</li>
<li>Mac OS不支持bitcode。</li>
</ul>
<p>如果我们开启了bitcode，在提交包时，下面这个界面也会有个bitcode选项：</p>
<p><img src="http://cc.cocimg.com/api/uploads/20150817/1439791780516322.png" alt="blob.png"></p>
<p>盗图，我的应用没办法在这个界面显示bitcode，因为依赖于第三方的库，而这个库不支持bitcode，暂时只能设置ENABLE_BITCODE为NO。</p>
<p>所以，如果我们的工程需要支持bitcode，则必要要求所有的引入的第三方库都支持bitcode。我就只能等着公司那些大哥大姐们啥时候提供一个新包给我们了。</p>
<h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>如上面所说，bitcode是一种中间代码。LLVM官方文档有介绍这种文件的格式，有兴趣的可以移步<a href="http://llvm.org/docs/BitCodeFormat.html#llvm-bitcode-file-format" target="_blank" rel="external">LLVM Bitcode File Format</a>。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://developer.apple.com/library/prerelease/ios/documentation/IDEs/Conceptual/AppDistributionGuide/AppThinning/AppThinning.html#//apple_ref/doc/uid/TP40012582-CH35" target="_blank" rel="external">App Distribution Guide – App Thinning (iOS, watchOS)</a></li>
<li><a href="https://developer.apple.com/library/prerelease/ios/documentation/DeveloperTools/Conceptual/WhatsNewXcode/Articles/xcode_7_0.html" target="_blank" rel="external">What’s New in Xcode-New Features in Xcode 7</a></li>
<li><a href="http://onevcat.com/2015/06/ios9-sdk/" target="_blank" rel="external">开发者所需要知道的 iOS 9 SDK 新特性</a></li>
<li><a href="http://llvm.org/docs/BitCodeFormat.html#llvm-bitcode-file-format" target="_blank" rel="external">LLVM Bitcode File Format</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天试着用Xcode 7 beta 3在真机(iOS 8.3)上运行一下我们的工程，结果发现工程编译不过。看了下问题，得到的信息是我们引入的一个第三方库不包含bitcode。嗯，不知道bitcode是啥，所以就得先看看这货是啥了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http
    
    </summary>
    
    
  </entry>
  
</feed>
