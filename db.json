{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/baidu_verify_4XJlx2eMub.html","path":"baidu_verify_4XJlx2eMub.html","modified":1,"renderable":0},{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/favicon.png","path":"favicon.png","modified":1,"renderable":0},{"_id":"source/googleb56fd646cb9e7356.html","path":"googleb56fd646cb9e7356.html","modified":1,"renderable":0},{"_id":"source/about/CHANGELOG.md","path":"about/CHANGELOG.md","modified":1,"renderable":0},{"_id":"source/about/apple-touch-icon.png","path":"about/apple-touch-icon.png","modified":1,"renderable":0},{"_id":"source/about/DOCUMENTATION.md","path":"about/DOCUMENTATION.md","modified":1,"renderable":0},{"_id":"source/about/bower.json","path":"about/bower.json","modified":1,"renderable":0},{"_id":"source/about/circle.yml","path":"about/circle.yml","modified":1,"renderable":0},{"_id":"source/about/LICENSE","path":"about/LICENSE","modified":1,"renderable":0},{"_id":"source/about/index.html","path":"about/index.html","modified":1,"renderable":0},{"_id":"source/about/README.md","path":"about/README.md","modified":1,"renderable":0},{"_id":"source/about/favicon.png","path":"about/favicon.png","modified":1,"renderable":0},{"_id":"source/about/package.json","path":"about/package.json","modified":1,"renderable":0},{"_id":"source/about/karma.conf.js","path":"about/karma.conf.js","modified":1,"renderable":0},{"_id":"source/about/css/aboutme.css","path":"about/css/aboutme.css","modified":1,"renderable":0},{"_id":"source/about/js/impress.js","path":"about/js/impress.js","modified":1,"renderable":0},{"_id":"source/about/test/bootstrap.js","path":"about/test/bootstrap.js","modified":1,"renderable":0},{"_id":"source/about/test/core_tests.js","path":"about/test/core_tests.js","modified":1,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"3fde2bb05f620fc62328372b8211c16fa907cd90","modified":1485086577000},{"_id":"source/baidu_verify_4XJlx2eMub.html","hash":"e2c7795c1487d85f441479a01262cb0aa59c71fe","modified":1483000306000},{"_id":"source/CNAME","hash":"3a408bf5807167111c95ab3ed09027b61e46f1fb","modified":1483000306000},{"_id":"source/favicon.png","hash":"193274214589917f3ccece7b45f4dc2b49cd05bb","modified":1483000306000},{"_id":"source/googleb56fd646cb9e7356.html","hash":"d4a0b8ad0f8a2d917f6195aed032501f56bdfb9b","modified":1483000306000},{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1482814182000},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1482814185000},{"_id":"themes/next/.DS_Store","hash":"c62ba5be68076f8a0048a9baf92a03718190f151","modified":1483063950000},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1482814185000},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1482814183000},{"_id":"themes/next/.javascript_ignore","hash":"f9ea3c5395f8feb225a24e2c32baa79afda30c16","modified":1482814185000},{"_id":"themes/next/README.en.md","hash":"565ba52b3825b85a9f05b41183caca7f18b741d4","modified":1482814186000},{"_id":"themes/next/README.md","hash":"500b5606eb6a09c979d16128f8b00f4bf9bc95ac","modified":1482814186000},{"_id":"themes/next/bower.json","hash":"5abc236d9cc2512f5457ed57c1fba76669eb7399","modified":1482814188000},{"_id":"themes/next/gulpfile.coffee","hash":"61ef0606a8134894d7ac796bc8d0fa4ba6a94483","modified":1482814188000},{"_id":"themes/next/_config.yml","hash":"891d150ae4c7fae29cffa74e9dd1a4048d241713","modified":1483582399000},{"_id":"themes/next/package.json","hash":"877cb98025e59015532c4c9a04a33e2af4ad56f9","modified":1482814194000},{"_id":"source/_posts/.DS_Store","hash":"599a4be3e0e2388a2b9782f9889eed90ac104f0e","modified":1482984117000},{"_id":"source/_posts/Bilibili开源框架ijkplayer.md","hash":"1655b4094217d5045712e622e5c101f84606a502","modified":1483000306000},{"_id":"source/_posts/Bitcode-理解.md","hash":"e4475d735b32cab4dd56bbcf2304c6b35dce2f0a","modified":1483000306000},{"_id":"source/_posts/Git-分支-变基.md","hash":"9628dce3f637b97e6aa9b73459686a5c6afbd01c","modified":1483000306000},{"_id":"source/_posts/JSPatch-–-动态更新iOS-APP.md","hash":"37ccc85e917fe4fd69f54917e2e0381dd4f1795d","modified":1483000306000},{"_id":"source/_posts/Mac-OS-X-进程UserEventAgent-占用CPU-100-的解决办法.md","hash":"eeb92d5c3bf235ac7c5727d12f8b16dc1c1a5928","modified":1483000306000},{"_id":"source/_posts/PC端获取IPA包的方法.md","hash":"8df372ca4f519f6f20ed9ea63c50704a7c2bb212","modified":1483000306000},{"_id":"source/_posts/React-Native学习笔记.md","hash":"d9fdb834c83125cfba186e3115d1e7bf26af17a7","modified":1483000306000},{"_id":"source/_posts/Swift-可选类型和-强制解包.md","hash":"67326cf3034a8d9b3dd336291c2af04d4f08fd63","modified":1483000306000},{"_id":"source/_posts/Swift-中的异常抛出和错误处理.md","hash":"be0cee6da2cae6576ffa99251743db3685c2f291","modified":1483000306000},{"_id":"source/_posts/Swift中的问号-和感叹号.md","hash":"8b86d2433f9e1af544af4e2fc6d31a2eb10b967c","modified":1483000306000},{"_id":"source/_posts/UIWindow-和-UIWindowLevel详解.md","hash":"bd7d19f733118b81d13fa1e1e6bc29a15cbdb6ce","modified":1483000306000},{"_id":"source/_posts/Xib加载的几种方法.md","hash":"a856eeb28f1841878c55eb82277c388e175ce2f4","modified":1483000306000},{"_id":"source/_posts/WWDC2016-随想.md","hash":"37aedf6f6a61006bfeed4798b668f75892285857","modified":1483000306000},{"_id":"source/_posts/iOS-离屏渲染的研究.md","hash":"3a5f0b4e5884da0cfffccef3cace817ca9dc78c2","modified":1483000306000},{"_id":"source/_posts/iOS-开发路线.md","hash":"8dabb4dc8670e6ac7c31cdb46bbdd9f0380bae90","modified":1483000306000},{"_id":"source/_posts/iOS加密的基本介绍.md","hash":"2a90baa782552436f6deb922ff1523a833953bad","modified":1483000306000},{"_id":"source/_posts/OpenCV学习开发笔记(iOS9).md","hash":"9d08e5b53c8b46b5f2bb97fbbfc7a34c2a86ccc0","modified":1483431554000},{"_id":"source/_posts/Scene Kit 上手指南.md","hash":"379c1dc2bcded241c37064b6cd59960f7f08d30a","modified":1489204617000},{"_id":"source/_posts/iOS开发-之-运动GPS采样处理.md","hash":"47b29d6ea2b55faf472991beb6a9ca129b9f080c","modified":1483000306000},{"_id":"source/_posts/willMoveToSuperView导致观察者无法释放bug.md","hash":"675304958fee3d3cff5b7675c667746925b0eb79","modified":1483000306000},{"_id":"source/_posts/iOS控制器总结.md","hash":"70ea7f239ef0726746727c582fbfdf67a99165af","modified":1483000306000},{"_id":"source/_posts/升级Ruby配置CocoaPods安装.md","hash":"643ebe9d69385e49b33bf185ec9860f65a2e05af","modified":1483000306000},{"_id":"source/_posts/xcode-nib-but-the-view-outlet-was-not-set-错误.md","hash":"70733b890b3cb135ce46cc73d50b25b515b6bda0","modified":1483000306000},{"_id":"source/_posts/iOS国际化(本地化).md","hash":"d933202839ade848d4eafcb2979e748aa7acca18","modified":1489204620000},{"_id":"source/_posts/响应者链条传递事件.md","hash":"3b7d8f6f1f302ada6d726f7d3d4dfc9c2fbcea0c","modified":1483000306000},{"_id":"source/_posts/基于Google-I-O-大会，寻求人工智能的意义.md","hash":"3acd03e3a27e923415de08add10fa265668c5e21","modified":1483000306000},{"_id":"source/_posts/来自-Linkedin-的-Swift-编程风格指南.md","hash":"facdd7e075fb560a6e8330a95514fdcf33e7c103","modified":1483000306000},{"_id":"source/_posts/基于-ijkplayer-的iOS视频直播推流仿写.md","hash":"f96ded5320dd298abc317a94f18305bbf302e7aa","modified":1483000306000},{"_id":"source/_posts/早该知道的生活小经验 .md","hash":"725cb5c28834ad0c0a9103ae53079bead1fa102d","modified":1483582466000},{"_id":"source/_posts/比特币及区块链.md","hash":"a7952f21ff38b556cc23af3673312fb42d79e71d","modified":1483000306000},{"_id":"source/_posts/逆向工程-Reveal、IDA、Hopper、https抓包.md","hash":"66690efe0aa37ac17f9f5b199f65d05fc734fb20","modified":1483000306000},{"_id":"source/about/.DS_Store","hash":"b6cdce4427030872cdf46976c1a0f8dde1071cf7","modified":1482891832000},{"_id":"source/about/CHANGELOG.md","hash":"a55a68cdc166611e3e2303e7c5891b46601d5243","modified":1483000306000},{"_id":"source/about/apple-touch-icon.png","hash":"a4305a29b99e4fda4c2ae03fdd5745a7c8d4ecff","modified":1483000306000},{"_id":"source/about/DOCUMENTATION.md","hash":"bec23978ed008a47d81615a99c44a588a61c54db","modified":1483000306000},{"_id":"source/about/bower.json","hash":"1f302dc0725e0e4e417712a545f4dda880100878","modified":1483000306000},{"_id":"source/about/circle.yml","hash":"f4f71174650ea905545e15ebb9cacbe6326bb463","modified":1483000306000},{"_id":"source/about/LICENSE","hash":"e84ec18520fff3cb4ea4035ea0e2478eb0a100d7","modified":1483000306000},{"_id":"source/about/index.html","hash":"7ac4b12ceb41582de6b9e6cc271c6ecd2d7b8d76","modified":1483000306000},{"_id":"source/about/README.md","hash":"e2174a20057922ac2e5d7ab1bca3fcba63e31802","modified":1483000306000},{"_id":"source/about/favicon.png","hash":"84bf722b820ba415290268d5aa3aa379205e4aa1","modified":1483000306000},{"_id":"source/about/package.json","hash":"b452571e555778a3fe04a690361b236007ae9d2c","modified":1483000306000},{"_id":"source/tags/index.md","hash":"ef2b8de0cf453de16538cc152067e8157a9de721","modified":1483000306000},{"_id":"source/categories/index.md","hash":"9400f4c1fc9e97de5d83afb6b6517d8f55beae4f","modified":1483000306000},{"_id":"source/about/karma.conf.js","hash":"7e971b0afdff5eb6ee79c2c2bd8c07b73acdce1f","modified":1483000306000},{"_id":"themes/next/scripts/merge-configs.js","hash":"0c56be2e85c694247cfa327ea6d627b99ca265e8","modified":1482814194000},{"_id":"source/_posts/.MWebMetaData/ImgUpload-6A1EEB688E8CF95E776E31AB4012113C.data","hash":"1a6474ea3c427f45d9c4365088545ee4585a397b","modified":1483000306000},{"_id":"themes/next/source/.DS_Store","hash":"07d7d50412def0f65603d25fadeb1e1997578520","modified":1482914432000},{"_id":"themes/next/layout/_layout.swig","hash":"7a1e4443c3ba1e08c20e64ddbf0b8255d034dab0","modified":1482814191000},{"_id":"themes/next/layout/page.swig","hash":"3727fab9dadb967e9c2204edca787dc72264674a","modified":1482814193000},{"_id":"themes/next/layout/post.swig","hash":"e2e512142961ddfe77eba29eaa88f4a2ee43ae18","modified":1482814193000},{"_id":"themes/next/layout/archive.swig","hash":"b5b59d70fc1563f482fa07afd435752774ad5981","modified":1482814193000},{"_id":"themes/next/layout/schedule.swig","hash":"1f1cdc268f4ef773fd3ae693bbdf7d0b2f45c3a3","modified":1482814193000},{"_id":"themes/next/layout/category.swig","hash":"6422d196ceaff4220d54b8af770e7e957f3364ad","modified":1482814193000},{"_id":"themes/next/layout/tag.swig","hash":"07cf49c49c39a14dfbe9ce8e7d7eea3d4d0a4911","modified":1482814193000},{"_id":"themes/next/languages/de.yml","hash":"1fdea1f84b7f691f5b4dd4d2b43eeb27b10fa0c8","modified":1482814188000},{"_id":"themes/next/languages/default.yml","hash":"767470a80dc257e23e14c3a78e8c52a46c9d6209","modified":1482814189000},{"_id":"themes/next/layout/index.swig","hash":"427d0b95b854e311ae363088ab39a393bf8fdc8b","modified":1482814193000},{"_id":"themes/next/languages/id.yml","hash":"34396bef27c4ab9e9a3c5d3e3aa94b0e3b3a7b0d","modified":1482814190000},{"_id":"themes/next/languages/en.yml","hash":"40057d6608e825d06e0864bac4dcd27ed88ada87","modified":1482814189000},{"_id":"themes/next/languages/fr-FR.yml","hash":"9fca01ef917d33ae2ae6bc04561ec6799dff5351","modified":1482814190000},{"_id":"themes/next/languages/ja.yml","hash":"49f12149edcc1892b26a6207328cda64da20116d","modified":1482814190000},{"_id":"themes/next/languages/ko.yml","hash":"b6bc5d6b0c000deb44099b42d3aebb8c49dbfca9","modified":1482814190000},{"_id":"themes/next/languages/pt-BR.yml","hash":"7742ba4c0d682cbe1d38305332ebc928abd754b5","modified":1482814190000},{"_id":"themes/next/languages/pt.yml","hash":"6b660b117314cad93f08757601df3adb04c68beb","modified":1482814190000},{"_id":"themes/next/languages/ru.yml","hash":"257d11e626cbe4b9b78785a764190b9278f95c28","modified":1482814190000},{"_id":"themes/next/languages/zh-Hans.yml","hash":"f6c9fafa0f5f0050cd07ca2cf5e38fbae3e28145","modified":1482814190000},{"_id":"themes/next/languages/zh-hk.yml","hash":"34c84c6d04447a25bd5eac576922a13947c000e2","modified":1482814190000},{"_id":"themes/next/languages/zh-tw.yml","hash":"c97a5c41149de9b17f33439b0ecf0eff6fdae50e","modified":1482814190000},{"_id":"source/about/css/aboutme.css","hash":"92bdfd48fbcc50b72b60a41114ec9b5b0565f3b3","modified":1483000306000},{"_id":"source/about/js/impress.js","hash":"2307c1ea165cf868e018d84002c0c877f6646394","modified":1483000306000},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1482814220000},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1482814220000},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1482814220000},{"_id":"source/_posts/media/14888548701006.png","hash":"a2fb664795a944ebf0d876f3ceaacc0306130ad3","modified":1488854870000},{"_id":"source/about/test/bootstrap.js","hash":"76a8d0a71ffcdbdd6096fe38d3353cc92f567f06","modified":1483000306000},{"_id":"source/about/test/core_tests.js","hash":"2651ae48c823e0fe0233eede8e701f940b3915cb","modified":1483000306000},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1482814196000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1482814194000},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1482814194000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1482814194000},{"_id":"themes/next/scripts/tags/note.js","hash":"6752925eedbdb939d8ec4d11bdfb75199f18dd70","modified":1482814194000},{"_id":"source/_posts/media/14888555195286.png","hash":"fe6baf7905f9059628003b84a66a27020792c554","modified":1488855519000},{"_id":"source/_posts/media/14888549661144.png","hash":"131ced2170047b3c3da86b7a5fcaeb3417f32588","modified":1488854966000},{"_id":"source/_posts/media/14888549210352.png","hash":"390bf4e8c6369763098ca016dbb6104b86bc3f7d","modified":1488854921000},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1482814196000},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"90035272fa31a3f65b3c0e2cb8a633876ef457dc","modified":1482814196000},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1482814196000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1482814197000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1482814197000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1482814197000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1482814197000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1482814197000},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1482814197000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1482814197000},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1482814197000},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1482814197000},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1482814197000},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1482814197000},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1482814190000},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1482814197000},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1482814190000},{"_id":"source/_posts/media/14888551848421.png","hash":"55579258d092c506345d452fbe5ae94b636bbcd9","modified":1488855184000},{"_id":"source/_posts/media/14888559567651.png","hash":"d51e3bcb53bad77980b6a3903ba52c9d56398b42","modified":1488855956000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"5864f5567ba5efeabcf6ea355013c0b603ee07f2","modified":1482814191000},{"_id":"themes/next/layout/_macro/post.swig","hash":"39a8efd961ea2c5758ca4231d3cc4108c1856930","modified":1482814191000},{"_id":"themes/next/layout/_macro/reward.swig","hash":"37e5b7c42ec17b9b6b786c5512bcc481a21c974e","modified":1482814191000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"43d8830bb19da4fc7a5773866be19fa066b62645","modified":1482814192000},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"14e785adeb0e671ba0ff9a553e6f0d8def6c670c","modified":1482814192000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"4eb278f7b1b7dfe1088c2b411778cc6129df82bb","modified":1482814192000},{"_id":"themes/next/layout/_partials/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1482814192000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"7172c6053118b7c291a56a7860128a652ae66b83","modified":1482814192000},{"_id":"themes/next/layout/_partials/head.swig","hash":"ca56f92e2fa82b03853869f5073ee1a5626a4796","modified":1482814192000},{"_id":"themes/next/layout/_partials/header.swig","hash":"5696ee15fc21eb3a6416902afcf1df454497c552","modified":1482814192000},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"39d613e5a9f8389d4ea52d6082502af8e833b9f2","modified":1482814192000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1482814192000},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1482814195000},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1482814195000},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1482814195000},{"_id":"themes/next/layout/_partials/search.swig","hash":"1431719d1dbba3f5ee385eebc46376d1a960b2d5","modified":1482814192000},{"_id":"themes/next/layout/_scripts/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1482814192000},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1482814192000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1482814196000},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1482814192000},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1482814196000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"0b91cadecead8e0b5211cc42b085998d94af503a","modified":1482814193000},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"78a83c38f69a8747bb74e420e6c9eeef1ea76525","modified":1482814195000},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"715d5b40dc52f319fe4bff0325beb874774d9bd9","modified":1482814195000},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1482814195000},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1482814197000},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"96b29f69b8b916b22f62c9959a117b5a968200a5","modified":1482814197000},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1482814197000},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1482814197000},{"_id":"themes/next/source/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1482814197000},{"_id":"themes/next/source/js/src/post-details.js","hash":"2038f54e289b6da5def09689e69f623187147be5","modified":1482814197000},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1482814197000},{"_id":"themes/next/source/js/src/utils.js","hash":"384e17ff857f073060f5bf8c6e4f4b7353236331","modified":1482814197000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1482814192000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1482814192000},{"_id":"themes/next/layout/_components/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1482814190000},{"_id":"themes/next/layout/_components/algolia-search/dom.swig","hash":"636f1181dd5887a70b4a08ca8f655d4e46635792","modified":1482814190000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1482814198000},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1482814200000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"c8d35a6b9e3bff6d8fdb66de853065af9d37562d","modified":1482814196000},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1482814200000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"bef514826ebf9eb6e99bb2b0d72285106658a1ec","modified":1482814196000},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"c1072942459fa0880e8a33a1bd929176b62b4171","modified":1482814202000},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1482814202000},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1482814202000},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1482814202000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"3f0d6aa424f434e82ea507f740eeff110f996269","modified":1482814196000},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1482814202000},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1482814201000},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1482814201000},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1482814201000},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1482814201000},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1482814216000},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1482814216000},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1482814216000},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1482814216000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1482814216000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1482814216000},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1482814216000},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1482814217000},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1482814217000},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1482814219000},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1482814220000},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1482814220000},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1482814192000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"ff5523d5dacaa77a55a24e50e6e6530c3b98bfad","modified":1482814192000},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1482814192000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1482814192000},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1482814192000},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1482814192000},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1482814192000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1482814192000},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"63315fcf210799f894208c9f512737096df84962","modified":1482814192000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1482814192000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1482814192000},{"_id":"themes/next/layout/_scripts/third-party/comments.swig","hash":"417e16a0fbdcb1b87987787bd7f9fa17eefc2d2b","modified":1482814193000},{"_id":"themes/next/layout/_scripts/third-party/lean-analytics.swig","hash":"92dc60821307fc9769bea9b2d60adaeb798342af","modified":1482814193000},{"_id":"themes/next/layout/_scripts/third-party/localsearch.swig","hash":"b460e27db3dcd4ab40b17d8926a5c4e624f293a9","modified":1482814193000},{"_id":"themes/next/layout/_scripts/third-party/analytics.swig","hash":"394d9fff7951287cc90f52acc2d4cbfd1bae079d","modified":1482814192000},{"_id":"themes/next/layout/_scripts/third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1482814193000},{"_id":"themes/next/layout/_scripts/third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1482814193000},{"_id":"themes/next/layout/_scripts/third-party/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1482814193000},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1482814216000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1482814195000},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"54c90cf7bdbf5c596179d8dae6e671bad1292662","modified":1482814195000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"5304f99581da3a31de3ecec959b7adf9002fde83","modified":1482814195000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1482814195000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1482814195000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"013619c472c7e4b08311c464fcbe9fcf5edde603","modified":1482814195000},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1482814195000},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1482814196000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1482814196000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"4303776991ef28f5742ca51c7dffe6f12f0acf34","modified":1482814196000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1482814195000},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1482814196000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1482814196000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"b49efc66bd055a2d0be7deabfcb02ee72a9a28c8","modified":1482814194000},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"0dfb4b3ba3180d7285e66f270e1d3fa0f132c3d2","modified":1482814194000},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1482814194000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"10994990d6e0b4d965a728a22cf7f6ee29cae9f6","modified":1482814194000},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"711c8830886619d4f4a0598b0cde5499dce50c62","modified":1482814194000},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1482814194000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1482814196000},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1482814196000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"82bbaa6322764779a1ac2e2c8390ce901c7972e2","modified":1482814196000},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1482814196000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1482814196000},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"ff9f163bb05c0709577040a875924d36c9ab99d6","modified":1482814196000},{"_id":"themes/next/source/css/_schemes/Pisces/_full-image.styl","hash":"938d39eedc6e3d33918c1145a5bf1e79991d3fcf","modified":1482814196000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"dcf9fe43b2ef78b923118ba39efedb38760e76b1","modified":1482814196000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"d09280e5b79f3b573edb30f30c7a5f03ac640986","modified":1482814196000},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1482814196000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"9b63bd8effc7cf4b96acdea4d73add7df934a222","modified":1482814196000},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"9ccee9189c910b8a264802d7b2ec305d12dedcd0","modified":1482814197000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"7e899c4c0aa1312666f2534a4700667d1bfd88da","modified":1482814196000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"4eda182cbcc046dbf449aef97c02c230cf80a494","modified":1482814203000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1482814204000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"fb5b49426dee7f1508500e698d1b3c6b04c8fcce","modified":1482814204000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1482814202000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1482814202000},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1482814200000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1482814200000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1482814200000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1482814200000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1482814200000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1482814201000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1482814201000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1482814201000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1482814217000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1482814201000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1482814217000},{"_id":"themes/next/layout/_scripts/third-party/comments/disqus.swig","hash":"fb1d04ede838b52ca7541973f86c3810f1ad396e","modified":1482814193000},{"_id":"themes/next/layout/_scripts/third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1482814193000},{"_id":"themes/next/layout/_scripts/third-party/comments/gentie.swig","hash":"03592d1d731592103a41ebb87437fe4b0a4c78ca","modified":1482814193000},{"_id":"themes/next/layout/_scripts/third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1482814193000},{"_id":"themes/next/layout/_scripts/third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1482814193000},{"_id":"themes/next/layout/_scripts/third-party/analytics/busuanzi-counter.swig","hash":"4fcbf57c4918528ab51d3d042cff92cf5aefb599","modified":1482814193000},{"_id":"themes/next/layout/_scripts/third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1482814193000},{"_id":"themes/next/layout/_scripts/third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1482814193000},{"_id":"themes/next/layout/_scripts/third-party/analytics/facebook-sdk.swig","hash":"394d008e5e94575280407ad8a1607a028026cbc3","modified":1482814193000},{"_id":"themes/next/layout/_scripts/third-party/analytics/google-analytics.swig","hash":"30a23fa7e816496fdec0e932aa42e2d13098a9c2","modified":1482814193000},{"_id":"themes/next/layout/_scripts/third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1482814193000},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"1b22f17fdc38070de50e6d1ab3a32da71aa2d819","modified":1482814206000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"965ce8f688fedbeed504efd498bc9c1622d12362","modified":1482814207000},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1482814219000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"6d7e6a5fc802b13694d8820fc0138037c0977d2e","modified":1482814215000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"97e438cc545714309882fbceadbf344fcaddcec5","modified":1482814216000},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1482814196000},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1482814196000},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"8994ffcce84deac0471532f270f97c44fea54dc0","modified":1482814194000},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1482814194000},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1482814194000},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"7778920dd105fa4de3a7ab206eeba30b1a7bac45","modified":1482814194000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1482814194000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1482814194000},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"4b7f81e1006e7acee3d1c840ccba155239f830cc","modified":1482814194000},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1482814194000},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1482814194000},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1482814194000},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1482814194000},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"c890ce7fe933abad7baf39764a01894924854e92","modified":1482814194000},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1482814194000},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1482814194000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"8fae54591877a73dff0b29b2be2e8935e3c63575","modified":1482814194000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1482814194000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"b25132fe6a7ad67059a2c3afc60feabb479bdd75","modified":1482814194000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1482814194000},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"7f1aab694caf603809e33cff82beea84cd0128fd","modified":1482814194000},{"_id":"themes/next/source/css/_common/components/post/post-more-link.styl","hash":"15063d79b5befc21820baf05d6f20cc1c1787477","modified":1482814194000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"c6dab7661a6b8c678b21b7eb273cef7100f970f6","modified":1482814194000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"e792c8dc41561c96d128e9b421187f1c3dc978a0","modified":1482814194000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1482814194000},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"963105a531403d7aad6d9e5e23e3bfabb8ec065a","modified":1482814194000},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1482814194000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"4eb18b12fa0ea6c35925d9a64f64e2a7dae8c7fd","modified":1482814194000},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1482814194000},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"618f73450cf541f88a4fddc3d22898aee49d105d","modified":1482814195000},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1482814195000},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"3eb73cee103b810fa56901577ecb9c9bb1793cff","modified":1482814195000},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"74d0ba86f698165d13402670382a822c8736a556","modified":1482814195000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"2e7ec9aaa3293941106b1bdd09055246aa3c3dc6","modified":1482814194000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1482814194000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"c44f6a553ec7ea5508f2054a13be33a62a15d3a9","modified":1482814194000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1482814194000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1482814194000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"7690b9596ec3a49befbe529a5a2649abec0faf76","modified":1482814194000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"2d3abbc85b979a648e0e579e45f16a6eba49d1e7","modified":1482814194000},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1482814194000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"234facd038f144bd0fe09a31ed1357c5d74c517f","modified":1482814194000},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"eba491ae624b4c843c8be4c94a044085dad4ba0f","modified":1482814195000},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1482814195000},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"b03f891883446f3a5548b7cc90d29c77e62f1053","modified":1482814195000},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1482814195000},{"_id":"themes/next/source/css/_common/components/third-party/gentie.styl","hash":"586a3ec0f1015e7207cd6a2474362e068c341744","modified":1482814195000},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1482814195000},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"637c6b32c58ecf40041be6e911471cd82671919b","modified":1482814195000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"61d8d967807ef12598d81582fa95b9f600c3ee01","modified":1482814215000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"42348219db93a85d2ee23cb06cebd4d8ab121726","modified":1482814195000},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1482814196000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1482814201000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1482814201000},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1482814201000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1482814201000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1482814201000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1482814201000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1482814200000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"c0522272bbaef2acb3d341912754d6ea2d0ecfc0","modified":1482814212000},{"_id":"public/tags/index.html","hash":"80f6104d1de3f8aab2018c3900d0cba0dbbb9d30","modified":1489204656964},{"_id":"public/categories/index.html","hash":"4e51b49ff7095f86aa7d1e52fb0dfd4fcdfd389c","modified":1489204656982},{"_id":"public/2016/12/29/OpenCVLearning/index.html","hash":"6681d3652f0df8f7ad3bb79765731fe4a691d670","modified":1489204656982},{"_id":"public/2016/12/29/LifeExp/index.html","hash":"4294028e3d5437341456d22f5d678ec0abbb9b1d","modified":1489204656982},{"_id":"public/2016/09/23/ioskai-fa-zhi-yun-dong-gpscai-yang-chu-li-2/index.html","hash":"a2d43567449a629aee68c4a77acf95697d0b2871","modified":1489204656982},{"_id":"public/2016/09/12/xiang-ying-zhe-lian-tiao-chuan-di-shi-jian/index.html","hash":"ae741507bdcc5118d3c5bd6a3beeb8fc9dc37a4b","modified":1489204656982},{"_id":"public/2016/09/10/git-fen-zhi-bian-ji/index.html","hash":"76c65d0cda450aec8ee8f881fb3defbd3a98e99d","modified":1489204656982},{"_id":"public/2016/09/10/willmovetosuperviewdao-zhi-guan-cha-zhe-wu-fa-shi-fang-bug/index.html","hash":"66b5c899c232aa31ed3ebfed45619fa5981472e9","modified":1489204656982},{"_id":"public/2016/09/09/bi-te-bi-ji-qu-kuai-lian/index.html","hash":"fdf874f182eb2a384ad1a74b8ac44f45422953c7","modified":1489204656982},{"_id":"public/2016/08/13/xibjia-zai-de-ji-chong-fang-fa/index.html","hash":"116c99c5e94594268d8bd3d327e70fef5c7ece5b","modified":1489204656982},{"_id":"public/2016/08/08/iosjia-mi-de-ji-ben-jie-shao/index.html","hash":"8e9f08ee5ba90559c1960d65ff8a3166ae047bba","modified":1489204656982},{"_id":"public/2016/08/07/jie-jue-cocoapodan-zhuang-rubyban-ben-di-de-wen-ti/index.html","hash":"fa8ddd72792670ec3c0d07097b2a00ad9e7eb886","modified":1489204656982},{"_id":"public/2016/08/07/pcduan-huo-qu-ipabao-de-fang-fa/index.html","hash":"5237233335c4bd699a730899d26dd4f79cd06c44","modified":1489204656983},{"_id":"public/2016/07/13/swiftzhong-de-ke-xuan-lei-xing-he-qiang-zhi-jie-xi/index.html","hash":"7247720c69cba6ab49434b96ed5340f40c57b01f","modified":1489204656983},{"_id":"public/2016/07/12/ios-kai-fa-lu-xian/index.html","hash":"ddbea09e338cc83aa9b329be491071ad067ecdc2","modified":1489204656983},{"_id":"public/2016/07/07/osshi-pin-zhi-bo-fang/index.html","hash":"97859c70ff9f7183716f02b12c6a6abb1ce04355","modified":1489204656983},{"_id":"public/2016/07/03/lai-zi-linkedin-de-swift-bian-cheng-feng-ge-zhi-nan/index.html","hash":"8c7dc9aa11662ea3ebf4143afbaff26a07428de9","modified":1489204656983},{"_id":"public/2016/06/28/swiftzhong-de-wen-hao-he-gan-tan-hao/index.html","hash":"6eeba245936c2a3100ccdf1430878733eb087714","modified":1489204656983},{"_id":"public/2016/06/28/swift-zhong-de-yi-chang-pao-chu-he-cuo-wu-chu-li/index.html","hash":"882712ec33354123af19a4c70ed996215efcfff9","modified":1489204656983},{"_id":"public/2016/06/28/react-nativexue-xi-bi-ji/index.html","hash":"753078a63884a27e7a6aee59552d24da4ae52253","modified":1489204656983},{"_id":"public/2016/06/26/mac-os-x-jin-cheng-usereventagent-zhan-yong-cpu-100-de-jie-jue-ban-fa/index.html","hash":"9de8f4b09df11acb9a82a63248f1b35c66c8fb18","modified":1489204656983},{"_id":"public/2016/06/26/bitcode-li-jie/index.html","hash":"3c64f0eb641057354af18889168f8cfc9ce20297","modified":1489204656983},{"_id":"public/2016/06/26/bilibilikai-yuan-kuang-jia-ijkplayer/index.html","hash":"a98b4c56813d59995b7607e2d8c2f9462821283c","modified":1489204656983},{"_id":"public/2016/06/23/ni-xiang-gong-cheng-reveal-ida-hopper-httpszhua-bao/index.html","hash":"7d94bb51b0dc0a25d4e23b4dd56c428f574d3306","modified":1489204656983},{"_id":"public/2016/06/15/wwdc2016-sui-xiang/index.html","hash":"e776c2c7b551ea981587e835914df68037ccf6a0","modified":1489204656983},{"_id":"public/2016/06/12/jspatch-dong-tai-geng-xin-ios-app/index.html","hash":"278b377984eb91799f9b8ba7413ec3edd5646628","modified":1489204656984},{"_id":"public/2016/06/11/xcode-nib-but-the-view-outlet-was-not-set-cuo-wu/index.html","hash":"8742602d4dadb969c18da21f56aaf1aa76ba14c1","modified":1489204656984},{"_id":"public/2016/06/11/uiwindow-he-uiwindowlevelxiang-jie/index.html","hash":"d428d255524cbb6c6495469cb6363c0e5bdd6f06","modified":1489204656984},{"_id":"public/2016/06/08/ios-liping-xuanran/index.html","hash":"d0ac15364d1a354e36c5ba9cf9677ff2fde95ef7","modified":1489204656985},{"_id":"public/2016/06/07/ioskong-zhi-qi-tiao-zhuan-zong-jie/index.html","hash":"6f324f67b038fe6a515e23e041a92a6266d105ec","modified":1489204656985},{"_id":"public/2016/05/26/ce-shi/index.html","hash":"5e31a55739c44844577714d414397320bdb5d0b8","modified":1489204656985},{"_id":"public/archives/index.html","hash":"338ecc94640b7087872a1e9cb25d36b77dbf0c97","modified":1489204656985},{"_id":"public/archives/page/2/index.html","hash":"8419cc5854d8c846729c78cd5521dfdf4b997611","modified":1489204656985},{"_id":"public/archives/page/3/index.html","hash":"bed090cc0c31b12db66ad595c3223c9b7ed891ee","modified":1489204656985},{"_id":"public/archives/2016/index.html","hash":"2c33a94135947274560de4829c1d05dff0e98a7e","modified":1489204656985},{"_id":"public/archives/2016/page/2/index.html","hash":"25c86b924ae0e729b76393c98c2e759a418e0ad2","modified":1489204656985},{"_id":"public/archives/2016/page/3/index.html","hash":"dd940b35fc11cedbf7de16b54e91f8aa9483eb52","modified":1489204656985},{"_id":"public/archives/2016/05/index.html","hash":"ad224f31c970cda94ad37cf98f78740aab222dd8","modified":1489204656985},{"_id":"public/archives/2016/06/index.html","hash":"40f5432f8cbb5c39d0a24fce202377c74531da46","modified":1489204656985},{"_id":"public/archives/2016/06/page/2/index.html","hash":"f2d0572efe0197a11a3d6af8c46d1f4baeee8fba","modified":1489204656985},{"_id":"public/archives/2016/07/index.html","hash":"e0fb99321946786adec75a3efd5dcc5e83e82ebe","modified":1489204656985},{"_id":"public/archives/2016/08/index.html","hash":"693a6b02cb81d7db736e21eea58d48f99d005216","modified":1489204657095},{"_id":"public/archives/2016/09/index.html","hash":"6da9aab1a554658dc4b24e7d457529bd0de7d927","modified":1489204657098},{"_id":"public/archives/2016/12/index.html","hash":"7efec93ae336f33807c837d1ab2d9ea105cbe78f","modified":1489204657099},{"_id":"public/archives/2017/index.html","hash":"6a0c7acd986746af8d6c5c3a755802bbaaf63d52","modified":1489204657099},{"_id":"public/archives/2017/01/index.html","hash":"e9af7ad90f2b79aba1bc6c45ca72dcb4dcf29e04","modified":1489204657099},{"_id":"public/categories/生活/index.html","hash":"b73fbf60f54f92afd0fa9bc2c188cadd98fbd3f4","modified":1489204657099},{"_id":"public/index.html","hash":"22482e8533840fb0a52e2cb635b7b6db545e61db","modified":1489204657099},{"_id":"public/page/2/index.html","hash":"01d987c3c45e540ef0d2339609b1d01c95750c6e","modified":1489204657099},{"_id":"public/tags/git/index.html","hash":"dbe0fd1e2b0e05bef838bdb13e2f92d8d1fd7bec","modified":1489204657099},{"_id":"public/tags/iOS/index.html","hash":"9654dde74730ee9c01f676366da5a695d4150702","modified":1489204657099},{"_id":"public/page/3/index.html","hash":"b90affecd45e8c761834d42b23731a67ecfc751a","modified":1489204657099},{"_id":"public/tags/前端/index.html","hash":"81d50c9d71e33fb2f215554e341c07a9ef55f045","modified":1489204657100},{"_id":"public/tags/React-Native/index.html","hash":"22e4f391537ba8dd2a0de94ea84bf29c2a167a3f","modified":1489204657100},{"_id":"public/tags/转载/index.html","hash":"597fd548b3b320f874f5cacd8b8250750ef00907","modified":1489204657100},{"_id":"public/tags/swift/index.html","hash":"6ea496ea1596add04f60416a88eb1d8577455ee8","modified":1489204657100},{"_id":"public/tags/Apple-Inc/index.html","hash":"e9f1fe95470ab7514da116f3ed867f894b9c2b69","modified":1489204657100},{"_id":"public/tags/职业规划/index.html","hash":"78936b84f6ad59b5953f93412e7d8ec0ac89fb61","modified":1489204657100},{"_id":"public/tags/学习笔记/index.html","hash":"be7251cad29b1d5cd5c8651fafa4e5906e847ff6","modified":1489204657100},{"_id":"public/tags/人脸识别/index.html","hash":"bc467831b2ac7777d46e6ceadfc2b1340212c3d5","modified":1489204657100},{"_id":"public/tags/GPS/index.html","hash":"dae3ec8aeae2513b97d1aab1dd847248c5374d0d","modified":1489204657100},{"_id":"public/tags/bug归档/index.html","hash":"0196b835b1df18797c70f8f299b83591781ac630","modified":1489204657100},{"_id":"public/tags/互联网/index.html","hash":"4664e9a8e7727eda290c68e2cd742f9a19f5dbce","modified":1489204657100},{"_id":"public/tags/生活/index.html","hash":"f108ccbae260e2587eebb51d378d8ab9e8c9aaa2","modified":1489204657100},{"_id":"public/2017/01/03/localization/index.html","hash":"1937dcb418428e4d3371af778480e1f3440d02d1","modified":1489204657110},{"_id":"public/baidu_verify_4XJlx2eMub.html","hash":"e2c7795c1487d85f441479a01262cb0aa59c71fe","modified":1489204657110},{"_id":"public/CNAME","hash":"3a408bf5807167111c95ab3ed09027b61e46f1fb","modified":1489204657110},{"_id":"public/favicon.png","hash":"193274214589917f3ccece7b45f4dc2b49cd05bb","modified":1489204657110},{"_id":"public/googleb56fd646cb9e7356.html","hash":"d4a0b8ad0f8a2d917f6195aed032501f56bdfb9b","modified":1489204657110},{"_id":"public/about/CHANGELOG.md","hash":"a55a68cdc166611e3e2303e7c5891b46601d5243","modified":1489204657110},{"_id":"public/about/apple-touch-icon.png","hash":"a4305a29b99e4fda4c2ae03fdd5745a7c8d4ecff","modified":1489204657110},{"_id":"public/about/DOCUMENTATION.md","hash":"bec23978ed008a47d81615a99c44a588a61c54db","modified":1489204657110},{"_id":"public/about/bower.json","hash":"1f302dc0725e0e4e417712a545f4dda880100878","modified":1489204657110},{"_id":"public/about/circle.yml","hash":"f4f71174650ea905545e15ebb9cacbe6326bb463","modified":1489204657111},{"_id":"public/about/LICENSE","hash":"e84ec18520fff3cb4ea4035ea0e2478eb0a100d7","modified":1489204657111},{"_id":"public/about/index.html","hash":"7ac4b12ceb41582de6b9e6cc271c6ecd2d7b8d76","modified":1489204657111},{"_id":"public/about/README.md","hash":"e2174a20057922ac2e5d7ab1bca3fcba63e31802","modified":1489204657111},{"_id":"public/about/favicon.png","hash":"84bf722b820ba415290268d5aa3aa379205e4aa1","modified":1489204657111},{"_id":"public/about/package.json","hash":"b452571e555778a3fe04a690361b236007ae9d2c","modified":1489204657111},{"_id":"public/about/karma.conf.js","hash":"7e971b0afdff5eb6ee79c2c2bd8c07b73acdce1f","modified":1489204657111},{"_id":"public/about/css/aboutme.css","hash":"92bdfd48fbcc50b72b60a41114ec9b5b0565f3b3","modified":1489204657111},{"_id":"public/about/js/impress.js","hash":"2307c1ea165cf868e018d84002c0c877f6646394","modified":1489204657111},{"_id":"public/about/test/bootstrap.js","hash":"76a8d0a71ffcdbdd6096fe38d3353cc92f567f06","modified":1489204657111},{"_id":"public/about/test/core_tests.js","hash":"2651ae48c823e0fe0233eede8e701f940b3915cb","modified":1489204657111},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1489204657111},{"_id":"public/images/algolia_logo.svg","hash":"90035272fa31a3f65b3c0e2cb8a633876ef457dc","modified":1489204657111},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1489204657111},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1489204657111},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1489204657111},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1489204657111},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1489204657111},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1489204657111},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1489204657111},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1489204657111},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1489204657111},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1489204657111},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1489204657111},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1489204657111},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1489204657111},{"_id":"public/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1489204657111},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1489204657115},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1489204657116},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1489204657116},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1489204657116},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1489204657116},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1489204657116},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1489204657116},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1489204657131},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"1b22f17fdc38070de50e6d1ab3a32da71aa2d819","modified":1489204660315},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"965ce8f688fedbeed504efd498bc9c1622d12362","modified":1489204660332},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"6d7e6a5fc802b13694d8820fc0138037c0977d2e","modified":1489204660335},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"97e438cc545714309882fbceadbf344fcaddcec5","modified":1489204660336},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1489204660342},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1489204660342},{"_id":"public/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1489204660346},{"_id":"public/js/src/post-details.js","hash":"2038f54e289b6da5def09689e69f623187147be5","modified":1489204660346},{"_id":"public/js/src/algolia-search.js","hash":"96b29f69b8b916b22f62c9959a117b5a968200a5","modified":1489204660346},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1489204660346},{"_id":"public/js/src/utils.js","hash":"384e17ff857f073060f5bf8c6e4f4b7353236331","modified":1489204660346},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1489204660346},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1489204660346},{"_id":"public/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1489204660346},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1489204660346},{"_id":"public/lib/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1489204660346},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1489204660347},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1489204660347},{"_id":"public/lib/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1489204660347},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1489204660347},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1489204660347},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1489204660347},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1489204660347},{"_id":"public/js/src/schemes/pisces.js","hash":"9ccee9189c910b8a264802d7b2ec305d12dedcd0","modified":1489204660347},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1489204660347},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1489204660348},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1489204660348},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1489204660349},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1489204660349},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1489204660349},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1489204660349},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1489204660349},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1489204660349},{"_id":"public/css/main.css","hash":"38dccd6d86030bb04bf546ba7033aff114713188","modified":1489204660349},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1489204660349},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1489204660349},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"4eda182cbcc046dbf449aef97c02c230cf80a494","modified":1489204660350},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"fb5b49426dee7f1508500e698d1b3c6b04c8fcce","modified":1489204660350},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1489204660350},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1489204660350},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1489204660350},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1489204660350},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1489204660350},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1489204660354},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"61d8d967807ef12598d81582fa95b9f600c3ee01","modified":1489204660354},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"c0522272bbaef2acb3d341912754d6ea2d0ecfc0","modified":1489204660435}],"Category":[{"name":"生活","_id":"cj04pzyyr001ks04euxp667zs"}],"Data":[],"Page":[{"title":"Tagcloud","date":"2016-12-27T08:19:30.000Z","comments":0,"type":"tags","_content":"\n\n","source":"tags/index.md","raw":"---\ntitle: Tagcloud\ndate: 2016-12-27 16:19:30\ncomments: false\ntype: \"tags\"\n---\n\n\n","updated":"2016-12-29T08:31:46.000Z","path":"tags/index.html","layout":"page","_id":"cj04pzyvw0001s04efmyvqa3e","content":"","excerpt":"","more":""},{"title":"categories","date":"2016-12-27T08:19:16.000Z","comments":0,"type":"categories","_content":"\n\n","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2016-12-27 16:19:16\ncomments: false\ntype: \"categories\"\n---\n\n\n","updated":"2016-12-29T08:31:46.000Z","path":"categories/index.html","layout":"page","_id":"cj04pzywg0003s04er0i72syo","content":"","excerpt":"","more":""}],"Post":[{"title":"Bilibili开源框架ijkplayer","id":"18","updated":"2016-06-28T05:11:04.000Z","date":"2016-06-26T01:47:59.000Z","_content":"\n\n\nijkplayer 是一款做视频直播的框架, 基于ffmpeg, 支持 Android 和 iOS, 网上也有很多集成说明, 但是个人觉得还是不够详细, 在这里详细的讲一下在 iOS 中如何集成ijkplayer, 即便以前从没有接触过, 按着下面做也可以集成成功!\n\n# 一. 下载ijkplayer\n\nijkplayer下载地址:[https://github.com/Bilibili/ijkplayer](https://github.com/Bilibili/ijkplayer)\n\nijkplayer下载地址:[https://github.com/Bilibili/ijkplayer](https://github.com/Bilibili/ijkplayer)\n下载完成后解压\n\n\n# 二. 编译 ijkplayer\n\n说是编译 ijkplayer, 其实是编译 ffmpeg, 在这里我们已经下载好了`ijkplayer`, 所以 github 上`README.md`中的`Build iOS`那一步中有一些步骤是不需要的.\n\n说是编译 ijkplayer, 其实是编译 ffmpeg, 在这里我们已经下载好了`ijkplayer`, 所以 github 上`README.md`中的`Build iOS`那一步中有一些步骤是不需要的.\n下面开始一步一步编译:\n\n说是编译 ijkplayer, 其实是编译 ffmpeg, 在这里我们已经下载好了`ijkplayer`, 所以 github 上`README.md`中的`Build iOS`那一步中有一些步骤是不需要的.\n下面开始一步一步编译:\n1.打开终端, cd 到`jkplayer-master`文件夹中, 也就是下载完解压后的文件夹\n\n2.执行命令行`./init-ios.sh`, 这一步是去下载 ffmpeg 的, 时间会久一点, 耐心等一下.如下图:\n\n![img](http://upload-images.jianshu.io/upload_images/1803339-96d2217e323aab4b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n3.在第2步中下载完成后, 执行`cd ios`, 也就是进入到 ios目录中\n\n4.进入 ios 文件夹后, 在终端依次执行`./compile-ffmpeg.sh clean`和`./compile-ffmpeg.sh all`命令, 编译 ffmpeg, 也就是`README.md`中这两步\n*编译时间较久, 耐心等待一下.*\n\n# 三. 打包`IJKMediaFramework.framework`框架\n\n集成 ijkplayer 有两种方法:\n\n集成 ijkplayer 有两种方法:\n一种方法是按照`IJKMediaDemo`工程中那样, 直接导入工程`IJKMediaPlayer.xcodeproj`, 在这里不做介绍\n\n第二种集成方法是把 ijkplayer 打包成`framework`导入工程中使用. 下面开始介绍如何打包`IJKMediaFramework.framework`\n\n1. 首先打开工程`IJKMediaPlayer.xcodeproj`, 位置如下图:\n\n![img](http://upload-images.jianshu.io/upload_images/1803339-607cc84c212faf90.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n2.工程打开后设置工程的 scheme\n\n3.设置好 scheme 后, 分别选择真机和模拟器进行编译, 编译完成后, 进入 Finder, 如下图:\n\n![img](http://upload-images.jianshu.io/upload_images/1803339-344cda905745ff39.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n进入 Finder 后, 可以看到有真机和模拟器两个版本的编译结果\n\n下面开始合并真机和模拟器版本的 framework, 注意不要合并错了\n打开终端, 进行合并, 命令行具体格式为:\n\n```\nlipo -create \"真机版本路径\" \"模拟器版本路径\" -output \"合并后的文件路径\"\n```\n\n下面很重要, 需要用合并后的`IJKMediaFramework`把原来的`IJKMediaFramework`替换掉\n上图中的1、2两步完成后, 绿色框住的那个`IJKMediaFramework.framework`文件就是我们需要的框架了, 可以复制出来, 稍后我们需要导入工程使用.\n\n# 四. iOS工程中集成ijkplayer\n\n新建工程, 导入合并后的`IJKMediaFramework.framework`以及相关依赖框架以及相关依赖框架\n导入框架后, 在`ViewController.m`进行测试, 首先导入`IJKMediaFramework.h`头文件, 编译看有没有错, 如果没有错说明集成成功.\n\n导入框架后, 在`ViewController.m`进行测试, 首先导入`IJKMediaFramework.h`头文件, 编译看有没有错, 如果没有错说明集成成功.\n接着开始在`ViewController.m`文件中使用`IJKMediaFramework`框架进行测试使用, 写一个简单的直播视频进行测试, 在这里看一下运行后的结果, 后面会放上 Demo 供下载.\n\n","source":"_posts/Bilibili开源框架ijkplayer.md","raw":"---\ntitle: Bilibili开源框架ijkplayer\npermalink: bilibilikai-yuan-kuang-jia-ijkplayer\nid: 18\nupdated: '2016-06-28 13:11:04'\ndate: 2016-06-26 09:47:59\ntags:\n---\n\n\n\nijkplayer 是一款做视频直播的框架, 基于ffmpeg, 支持 Android 和 iOS, 网上也有很多集成说明, 但是个人觉得还是不够详细, 在这里详细的讲一下在 iOS 中如何集成ijkplayer, 即便以前从没有接触过, 按着下面做也可以集成成功!\n\n# 一. 下载ijkplayer\n\nijkplayer下载地址:[https://github.com/Bilibili/ijkplayer](https://github.com/Bilibili/ijkplayer)\n\nijkplayer下载地址:[https://github.com/Bilibili/ijkplayer](https://github.com/Bilibili/ijkplayer)\n下载完成后解压\n\n\n# 二. 编译 ijkplayer\n\n说是编译 ijkplayer, 其实是编译 ffmpeg, 在这里我们已经下载好了`ijkplayer`, 所以 github 上`README.md`中的`Build iOS`那一步中有一些步骤是不需要的.\n\n说是编译 ijkplayer, 其实是编译 ffmpeg, 在这里我们已经下载好了`ijkplayer`, 所以 github 上`README.md`中的`Build iOS`那一步中有一些步骤是不需要的.\n下面开始一步一步编译:\n\n说是编译 ijkplayer, 其实是编译 ffmpeg, 在这里我们已经下载好了`ijkplayer`, 所以 github 上`README.md`中的`Build iOS`那一步中有一些步骤是不需要的.\n下面开始一步一步编译:\n1.打开终端, cd 到`jkplayer-master`文件夹中, 也就是下载完解压后的文件夹\n\n2.执行命令行`./init-ios.sh`, 这一步是去下载 ffmpeg 的, 时间会久一点, 耐心等一下.如下图:\n\n![img](http://upload-images.jianshu.io/upload_images/1803339-96d2217e323aab4b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n3.在第2步中下载完成后, 执行`cd ios`, 也就是进入到 ios目录中\n\n4.进入 ios 文件夹后, 在终端依次执行`./compile-ffmpeg.sh clean`和`./compile-ffmpeg.sh all`命令, 编译 ffmpeg, 也就是`README.md`中这两步\n*编译时间较久, 耐心等待一下.*\n\n# 三. 打包`IJKMediaFramework.framework`框架\n\n集成 ijkplayer 有两种方法:\n\n集成 ijkplayer 有两种方法:\n一种方法是按照`IJKMediaDemo`工程中那样, 直接导入工程`IJKMediaPlayer.xcodeproj`, 在这里不做介绍\n\n第二种集成方法是把 ijkplayer 打包成`framework`导入工程中使用. 下面开始介绍如何打包`IJKMediaFramework.framework`\n\n1. 首先打开工程`IJKMediaPlayer.xcodeproj`, 位置如下图:\n\n![img](http://upload-images.jianshu.io/upload_images/1803339-607cc84c212faf90.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n2.工程打开后设置工程的 scheme\n\n3.设置好 scheme 后, 分别选择真机和模拟器进行编译, 编译完成后, 进入 Finder, 如下图:\n\n![img](http://upload-images.jianshu.io/upload_images/1803339-344cda905745ff39.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n进入 Finder 后, 可以看到有真机和模拟器两个版本的编译结果\n\n下面开始合并真机和模拟器版本的 framework, 注意不要合并错了\n打开终端, 进行合并, 命令行具体格式为:\n\n```\nlipo -create \"真机版本路径\" \"模拟器版本路径\" -output \"合并后的文件路径\"\n```\n\n下面很重要, 需要用合并后的`IJKMediaFramework`把原来的`IJKMediaFramework`替换掉\n上图中的1、2两步完成后, 绿色框住的那个`IJKMediaFramework.framework`文件就是我们需要的框架了, 可以复制出来, 稍后我们需要导入工程使用.\n\n# 四. iOS工程中集成ijkplayer\n\n新建工程, 导入合并后的`IJKMediaFramework.framework`以及相关依赖框架以及相关依赖框架\n导入框架后, 在`ViewController.m`进行测试, 首先导入`IJKMediaFramework.h`头文件, 编译看有没有错, 如果没有错说明集成成功.\n\n导入框架后, 在`ViewController.m`进行测试, 首先导入`IJKMediaFramework.h`头文件, 编译看有没有错, 如果没有错说明集成成功.\n接着开始在`ViewController.m`文件中使用`IJKMediaFramework`框架进行测试使用, 写一个简单的直播视频进行测试, 在这里看一下运行后的结果, 后面会放上 Demo 供下载.\n\n","slug":"bilibilikai-yuan-kuang-jia-ijkplayer","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cj04pzyvo0000s04eed753suq","content":"<p>ijkplayer 是一款做视频直播的框架, 基于ffmpeg, 支持 Android 和 iOS, 网上也有很多集成说明, 但是个人觉得还是不够详细, 在这里详细的讲一下在 iOS 中如何集成ijkplayer, 即便以前从没有接触过, 按着下面做也可以集成成功!</p>\n<h1 id=\"一-下载ijkplayer\"><a href=\"#一-下载ijkplayer\" class=\"headerlink\" title=\"一. 下载ijkplayer\"></a>一. 下载ijkplayer</h1><p>ijkplayer下载地址:<a href=\"https://github.com/Bilibili/ijkplayer\" target=\"_blank\" rel=\"external\">https://github.com/Bilibili/ijkplayer</a></p>\n<p>ijkplayer下载地址:<a href=\"https://github.com/Bilibili/ijkplayer\" target=\"_blank\" rel=\"external\">https://github.com/Bilibili/ijkplayer</a><br>下载完成后解压</p>\n<h1 id=\"二-编译-ijkplayer\"><a href=\"#二-编译-ijkplayer\" class=\"headerlink\" title=\"二. 编译 ijkplayer\"></a>二. 编译 ijkplayer</h1><p>说是编译 ijkplayer, 其实是编译 ffmpeg, 在这里我们已经下载好了<code>ijkplayer</code>, 所以 github 上<code>README.md</code>中的<code>Build iOS</code>那一步中有一些步骤是不需要的.</p>\n<p>说是编译 ijkplayer, 其实是编译 ffmpeg, 在这里我们已经下载好了<code>ijkplayer</code>, 所以 github 上<code>README.md</code>中的<code>Build iOS</code>那一步中有一些步骤是不需要的.<br>下面开始一步一步编译:</p>\n<p>说是编译 ijkplayer, 其实是编译 ffmpeg, 在这里我们已经下载好了<code>ijkplayer</code>, 所以 github 上<code>README.md</code>中的<code>Build iOS</code>那一步中有一些步骤是不需要的.<br>下面开始一步一步编译:<br>1.打开终端, cd 到<code>jkplayer-master</code>文件夹中, 也就是下载完解压后的文件夹</p>\n<p>2.执行命令行<code>./init-ios.sh</code>, 这一步是去下载 ffmpeg 的, 时间会久一点, 耐心等一下.如下图:</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1803339-96d2217e323aab4b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"img\"></p>\n<p>3.在第2步中下载完成后, 执行<code>cd ios</code>, 也就是进入到 ios目录中</p>\n<p>4.进入 ios 文件夹后, 在终端依次执行<code>./compile-ffmpeg.sh clean</code>和<code>./compile-ffmpeg.sh all</code>命令, 编译 ffmpeg, 也就是<code>README.md</code>中这两步<br><em>编译时间较久, 耐心等待一下.</em></p>\n<h1 id=\"三-打包IJKMediaFramework-framework框架\"><a href=\"#三-打包IJKMediaFramework-framework框架\" class=\"headerlink\" title=\"三. 打包IJKMediaFramework.framework框架\"></a>三. 打包<code>IJKMediaFramework.framework</code>框架</h1><p>集成 ijkplayer 有两种方法:</p>\n<p>集成 ijkplayer 有两种方法:<br>一种方法是按照<code>IJKMediaDemo</code>工程中那样, 直接导入工程<code>IJKMediaPlayer.xcodeproj</code>, 在这里不做介绍</p>\n<p>第二种集成方法是把 ijkplayer 打包成<code>framework</code>导入工程中使用. 下面开始介绍如何打包<code>IJKMediaFramework.framework</code></p>\n<ol>\n<li>首先打开工程<code>IJKMediaPlayer.xcodeproj</code>, 位置如下图:</li>\n</ol>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1803339-607cc84c212faf90.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"img\"></p>\n<p>2.工程打开后设置工程的 scheme</p>\n<p>3.设置好 scheme 后, 分别选择真机和模拟器进行编译, 编译完成后, 进入 Finder, 如下图:</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1803339-344cda905745ff39.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"img\"></p>\n<p>进入 Finder 后, 可以看到有真机和模拟器两个版本的编译结果</p>\n<p>下面开始合并真机和模拟器版本的 framework, 注意不要合并错了<br>打开终端, 进行合并, 命令行具体格式为:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">lipo -create &quot;真机版本路径&quot; &quot;模拟器版本路径&quot; -output &quot;合并后的文件路径&quot;</div></pre></td></tr></table></figure>\n<p>下面很重要, 需要用合并后的<code>IJKMediaFramework</code>把原来的<code>IJKMediaFramework</code>替换掉<br>上图中的1、2两步完成后, 绿色框住的那个<code>IJKMediaFramework.framework</code>文件就是我们需要的框架了, 可以复制出来, 稍后我们需要导入工程使用.</p>\n<h1 id=\"四-iOS工程中集成ijkplayer\"><a href=\"#四-iOS工程中集成ijkplayer\" class=\"headerlink\" title=\"四. iOS工程中集成ijkplayer\"></a>四. iOS工程中集成ijkplayer</h1><p>新建工程, 导入合并后的<code>IJKMediaFramework.framework</code>以及相关依赖框架以及相关依赖框架<br>导入框架后, 在<code>ViewController.m</code>进行测试, 首先导入<code>IJKMediaFramework.h</code>头文件, 编译看有没有错, 如果没有错说明集成成功.</p>\n<p>导入框架后, 在<code>ViewController.m</code>进行测试, 首先导入<code>IJKMediaFramework.h</code>头文件, 编译看有没有错, 如果没有错说明集成成功.<br>接着开始在<code>ViewController.m</code>文件中使用<code>IJKMediaFramework</code>框架进行测试使用, 写一个简单的直播视频进行测试, 在这里看一下运行后的结果, 后面会放上 Demo 供下载.</p>\n","excerpt":"","more":"<p>ijkplayer 是一款做视频直播的框架, 基于ffmpeg, 支持 Android 和 iOS, 网上也有很多集成说明, 但是个人觉得还是不够详细, 在这里详细的讲一下在 iOS 中如何集成ijkplayer, 即便以前从没有接触过, 按着下面做也可以集成成功!</p>\n<h1 id=\"一-下载ijkplayer\"><a href=\"#一-下载ijkplayer\" class=\"headerlink\" title=\"一. 下载ijkplayer\"></a>一. 下载ijkplayer</h1><p>ijkplayer下载地址:<a href=\"https://github.com/Bilibili/ijkplayer\">https://github.com/Bilibili/ijkplayer</a></p>\n<p>ijkplayer下载地址:<a href=\"https://github.com/Bilibili/ijkplayer\">https://github.com/Bilibili/ijkplayer</a><br>下载完成后解压</p>\n<h1 id=\"二-编译-ijkplayer\"><a href=\"#二-编译-ijkplayer\" class=\"headerlink\" title=\"二. 编译 ijkplayer\"></a>二. 编译 ijkplayer</h1><p>说是编译 ijkplayer, 其实是编译 ffmpeg, 在这里我们已经下载好了<code>ijkplayer</code>, 所以 github 上<code>README.md</code>中的<code>Build iOS</code>那一步中有一些步骤是不需要的.</p>\n<p>说是编译 ijkplayer, 其实是编译 ffmpeg, 在这里我们已经下载好了<code>ijkplayer</code>, 所以 github 上<code>README.md</code>中的<code>Build iOS</code>那一步中有一些步骤是不需要的.<br>下面开始一步一步编译:</p>\n<p>说是编译 ijkplayer, 其实是编译 ffmpeg, 在这里我们已经下载好了<code>ijkplayer</code>, 所以 github 上<code>README.md</code>中的<code>Build iOS</code>那一步中有一些步骤是不需要的.<br>下面开始一步一步编译:<br>1.打开终端, cd 到<code>jkplayer-master</code>文件夹中, 也就是下载完解压后的文件夹</p>\n<p>2.执行命令行<code>./init-ios.sh</code>, 这一步是去下载 ffmpeg 的, 时间会久一点, 耐心等一下.如下图:</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1803339-96d2217e323aab4b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"img\"></p>\n<p>3.在第2步中下载完成后, 执行<code>cd ios</code>, 也就是进入到 ios目录中</p>\n<p>4.进入 ios 文件夹后, 在终端依次执行<code>./compile-ffmpeg.sh clean</code>和<code>./compile-ffmpeg.sh all</code>命令, 编译 ffmpeg, 也就是<code>README.md</code>中这两步<br><em>编译时间较久, 耐心等待一下.</em></p>\n<h1 id=\"三-打包IJKMediaFramework-framework框架\"><a href=\"#三-打包IJKMediaFramework-framework框架\" class=\"headerlink\" title=\"三. 打包IJKMediaFramework.framework框架\"></a>三. 打包<code>IJKMediaFramework.framework</code>框架</h1><p>集成 ijkplayer 有两种方法:</p>\n<p>集成 ijkplayer 有两种方法:<br>一种方法是按照<code>IJKMediaDemo</code>工程中那样, 直接导入工程<code>IJKMediaPlayer.xcodeproj</code>, 在这里不做介绍</p>\n<p>第二种集成方法是把 ijkplayer 打包成<code>framework</code>导入工程中使用. 下面开始介绍如何打包<code>IJKMediaFramework.framework</code></p>\n<ol>\n<li>首先打开工程<code>IJKMediaPlayer.xcodeproj</code>, 位置如下图:</li>\n</ol>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1803339-607cc84c212faf90.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"img\"></p>\n<p>2.工程打开后设置工程的 scheme</p>\n<p>3.设置好 scheme 后, 分别选择真机和模拟器进行编译, 编译完成后, 进入 Finder, 如下图:</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1803339-344cda905745ff39.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"img\"></p>\n<p>进入 Finder 后, 可以看到有真机和模拟器两个版本的编译结果</p>\n<p>下面开始合并真机和模拟器版本的 framework, 注意不要合并错了<br>打开终端, 进行合并, 命令行具体格式为:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">lipo -create &quot;真机版本路径&quot; &quot;模拟器版本路径&quot; -output &quot;合并后的文件路径&quot;</div></pre></td></tr></table></figure>\n<p>下面很重要, 需要用合并后的<code>IJKMediaFramework</code>把原来的<code>IJKMediaFramework</code>替换掉<br>上图中的1、2两步完成后, 绿色框住的那个<code>IJKMediaFramework.framework</code>文件就是我们需要的框架了, 可以复制出来, 稍后我们需要导入工程使用.</p>\n<h1 id=\"四-iOS工程中集成ijkplayer\"><a href=\"#四-iOS工程中集成ijkplayer\" class=\"headerlink\" title=\"四. iOS工程中集成ijkplayer\"></a>四. iOS工程中集成ijkplayer</h1><p>新建工程, 导入合并后的<code>IJKMediaFramework.framework</code>以及相关依赖框架以及相关依赖框架<br>导入框架后, 在<code>ViewController.m</code>进行测试, 首先导入<code>IJKMediaFramework.h</code>头文件, 编译看有没有错, 如果没有错说明集成成功.</p>\n<p>导入框架后, 在<code>ViewController.m</code>进行测试, 首先导入<code>IJKMediaFramework.h</code>头文件, 编译看有没有错, 如果没有错说明集成成功.<br>接着开始在<code>ViewController.m</code>文件中使用<code>IJKMediaFramework</code>框架进行测试使用, 写一个简单的直播视频进行测试, 在这里看一下运行后的结果, 后面会放上 Demo 供下载.</p>\n"},{"title":"Bitcode 理解","id":"19","updated":"2016-06-28T05:10:38.000Z","date":"2016-06-26T07:14:20.000Z","_content":"\n\n\n今天试着用Xcode 7 beta 3在真机(iOS 8.3)上运行一下我们的工程，结果发现工程编译不过。看了下问题，得到的信息是我们引入的一个第三方库不包含bitcode。嗯，不知道bitcode是啥，所以就得先看看这货是啥了。\n\n![](http://cc.cocimg.com/api/uploads/20150702/1435823658708967.png)\n# Bitcode是什么？\n\n找东西嘛，最先想到的当然是先看官方文档了。在[App Distribution Guide – App Thinning (iOS, watchOS)](https://developer.apple.com/library/prerelease/ios/documentation/IDEs/Conceptual/AppDistributionGuide/AppThinning/AppThinning.html#//apple_ref/doc/uid/TP40012582-CH35)一节中，找到了下面这样一个定义：\n\nBitcode is an intermediate representation of a compiled program. Apps you upload to iTunes Connect that contain bitcode will be compiled and linked on the App Store. Including bitcode will allow Apple to re-optimize your app binary in the future without the need to submit a new version of your app to the store.\n\n说的是bitcode是被编译程序的一种中间形式的代码。包含bitcode配置的程序将会在App store上被编译和链接。bitcode允许苹果在后期重新优化我们程序的二进制文件，而不需要我们重新提交一个新的版本到App store上。\n\n嗯，看着挺高级的啊。\n\n继续看，在[What’s New in Xcode-New Features in Xcode 7](https://developer.apple.com/library/prerelease/ios/documentation/DeveloperTools/Conceptual/WhatsNewXcode/Articles/xcode_7_0.html)中，还有一段如下的描述\n\nBitcode. When you archive for submission to the App Store, Xcode will compile your app into an intermediate representation. The App Store will then compile the bitcode down into the 64 or 32 bit executables as necessary.\n\n当我们提交程序到App store上时，Xcode会将程序编译为一个中间表现形式(bitcode)。然后App store会再将这个botcode编译为可执行的64位或32位程序。\n\n再看看这两段描述都是放在App Thinning(App瘦身)一节中，可以看出其与包的优化有关了。喵大(@onevcat)在其博客[开发者所需要知道的 iOS 9 SDK 新特性](http://onevcat.com/2015/06/ios9-sdk/)中也描述了iOS 9中苹果在App瘦身中所做的一些改进，大家可以转场到那去研读一下。\n\n# Bitcode配置\n\n在上面的错误提示中，提到了如何处理我们遇到的问题：\n\nYou must rebuild it with bitcode enabled (Xcode setting ENABLE_BITCODE), obtain an updated library from the vendor, or disable bitcode for this target. for architecture arm64\n\n要么让第三方库支持，要么关闭target的bitcode选项。\n\n实际上在Xcode 7中，我们新建一个iOS程序时，bitcode选项默认是设置为YES的。我们可以在”Build Settings”->”Enable Bitcode”选项中看到这个设置。\n\n不过，我们现在需要考虑的是三个平台：iOS，Mac OS，watchOS。\n\n- 对应iOS，bitcode是可选的。\n- 对于watchOS，bitcode是必须的。\n- Mac OS不支持bitcode。\n\n如果我们开启了bitcode，在提交包时，下面这个界面也会有个bitcode选项：\n\n![blob.png](http://cc.cocimg.com/api/uploads/20150817/1439791780516322.png)\n\n盗图，我的应用没办法在这个界面显示bitcode，因为依赖于第三方的库，而这个库不支持bitcode，暂时只能设置ENABLE_BITCODE为NO。\n\n所以，如果我们的工程需要支持bitcode，则必要要求所有的引入的第三方库都支持bitcode。我就只能等着公司那些大哥大姐们啥时候提供一个新包给我们了。\n\n## 题外话\n\n如上面所说，bitcode是一种中间代码。LLVM官方文档有介绍这种文件的格式，有兴趣的可以移步[LLVM Bitcode File Format](http://llvm.org/docs/BitCodeFormat.html#llvm-bitcode-file-format)。\n\n### 参考\n\n- [App Distribution Guide – App Thinning (iOS, watchOS)](https://developer.apple.com/library/prerelease/ios/documentation/IDEs/Conceptual/AppDistributionGuide/AppThinning/AppThinning.html#//apple_ref/doc/uid/TP40012582-CH35)\n- [What’s New in Xcode-New Features in Xcode 7](https://developer.apple.com/library/prerelease/ios/documentation/DeveloperTools/Conceptual/WhatsNewXcode/Articles/xcode_7_0.html)\n- [开发者所需要知道的 iOS 9 SDK 新特性](http://onevcat.com/2015/06/ios9-sdk/)\n- [LLVM Bitcode File Format](http://llvm.org/docs/BitCodeFormat.html#llvm-bitcode-file-format)\n\n","source":"_posts/Bitcode-理解.md","raw":"---\ntitle: Bitcode 理解\npermalink: bitcode-li-jie\nid: 19\nupdated: '2016-06-28 13:10:38'\ndate: 2016-06-26 15:14:20\ntags:\n---\n\n\n\n今天试着用Xcode 7 beta 3在真机(iOS 8.3)上运行一下我们的工程，结果发现工程编译不过。看了下问题，得到的信息是我们引入的一个第三方库不包含bitcode。嗯，不知道bitcode是啥，所以就得先看看这货是啥了。\n\n![](http://cc.cocimg.com/api/uploads/20150702/1435823658708967.png)\n# Bitcode是什么？\n\n找东西嘛，最先想到的当然是先看官方文档了。在[App Distribution Guide – App Thinning (iOS, watchOS)](https://developer.apple.com/library/prerelease/ios/documentation/IDEs/Conceptual/AppDistributionGuide/AppThinning/AppThinning.html#//apple_ref/doc/uid/TP40012582-CH35)一节中，找到了下面这样一个定义：\n\nBitcode is an intermediate representation of a compiled program. Apps you upload to iTunes Connect that contain bitcode will be compiled and linked on the App Store. Including bitcode will allow Apple to re-optimize your app binary in the future without the need to submit a new version of your app to the store.\n\n说的是bitcode是被编译程序的一种中间形式的代码。包含bitcode配置的程序将会在App store上被编译和链接。bitcode允许苹果在后期重新优化我们程序的二进制文件，而不需要我们重新提交一个新的版本到App store上。\n\n嗯，看着挺高级的啊。\n\n继续看，在[What’s New in Xcode-New Features in Xcode 7](https://developer.apple.com/library/prerelease/ios/documentation/DeveloperTools/Conceptual/WhatsNewXcode/Articles/xcode_7_0.html)中，还有一段如下的描述\n\nBitcode. When you archive for submission to the App Store, Xcode will compile your app into an intermediate representation. The App Store will then compile the bitcode down into the 64 or 32 bit executables as necessary.\n\n当我们提交程序到App store上时，Xcode会将程序编译为一个中间表现形式(bitcode)。然后App store会再将这个botcode编译为可执行的64位或32位程序。\n\n再看看这两段描述都是放在App Thinning(App瘦身)一节中，可以看出其与包的优化有关了。喵大(@onevcat)在其博客[开发者所需要知道的 iOS 9 SDK 新特性](http://onevcat.com/2015/06/ios9-sdk/)中也描述了iOS 9中苹果在App瘦身中所做的一些改进，大家可以转场到那去研读一下。\n\n# Bitcode配置\n\n在上面的错误提示中，提到了如何处理我们遇到的问题：\n\nYou must rebuild it with bitcode enabled (Xcode setting ENABLE_BITCODE), obtain an updated library from the vendor, or disable bitcode for this target. for architecture arm64\n\n要么让第三方库支持，要么关闭target的bitcode选项。\n\n实际上在Xcode 7中，我们新建一个iOS程序时，bitcode选项默认是设置为YES的。我们可以在”Build Settings”->”Enable Bitcode”选项中看到这个设置。\n\n不过，我们现在需要考虑的是三个平台：iOS，Mac OS，watchOS。\n\n- 对应iOS，bitcode是可选的。\n- 对于watchOS，bitcode是必须的。\n- Mac OS不支持bitcode。\n\n如果我们开启了bitcode，在提交包时，下面这个界面也会有个bitcode选项：\n\n![blob.png](http://cc.cocimg.com/api/uploads/20150817/1439791780516322.png)\n\n盗图，我的应用没办法在这个界面显示bitcode，因为依赖于第三方的库，而这个库不支持bitcode，暂时只能设置ENABLE_BITCODE为NO。\n\n所以，如果我们的工程需要支持bitcode，则必要要求所有的引入的第三方库都支持bitcode。我就只能等着公司那些大哥大姐们啥时候提供一个新包给我们了。\n\n## 题外话\n\n如上面所说，bitcode是一种中间代码。LLVM官方文档有介绍这种文件的格式，有兴趣的可以移步[LLVM Bitcode File Format](http://llvm.org/docs/BitCodeFormat.html#llvm-bitcode-file-format)。\n\n### 参考\n\n- [App Distribution Guide – App Thinning (iOS, watchOS)](https://developer.apple.com/library/prerelease/ios/documentation/IDEs/Conceptual/AppDistributionGuide/AppThinning/AppThinning.html#//apple_ref/doc/uid/TP40012582-CH35)\n- [What’s New in Xcode-New Features in Xcode 7](https://developer.apple.com/library/prerelease/ios/documentation/DeveloperTools/Conceptual/WhatsNewXcode/Articles/xcode_7_0.html)\n- [开发者所需要知道的 iOS 9 SDK 新特性](http://onevcat.com/2015/06/ios9-sdk/)\n- [LLVM Bitcode File Format](http://llvm.org/docs/BitCodeFormat.html#llvm-bitcode-file-format)\n\n","slug":"bitcode-li-jie","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cj04pzyw00002s04e1396mi44","content":"<p>今天试着用Xcode 7 beta 3在真机(iOS 8.3)上运行一下我们的工程，结果发现工程编译不过。看了下问题，得到的信息是我们引入的一个第三方库不包含bitcode。嗯，不知道bitcode是啥，所以就得先看看这货是啥了。</p>\n<p><img src=\"http://cc.cocimg.com/api/uploads/20150702/1435823658708967.png\" alt=\"\"></p>\n<h1 id=\"Bitcode是什么？\"><a href=\"#Bitcode是什么？\" class=\"headerlink\" title=\"Bitcode是什么？\"></a>Bitcode是什么？</h1><p>找东西嘛，最先想到的当然是先看官方文档了。在<a href=\"https://developer.apple.com/library/prerelease/ios/documentation/IDEs/Conceptual/AppDistributionGuide/AppThinning/AppThinning.html#//apple_ref/doc/uid/TP40012582-CH35\" target=\"_blank\" rel=\"external\">App Distribution Guide – App Thinning (iOS, watchOS)</a>一节中，找到了下面这样一个定义：</p>\n<p>Bitcode is an intermediate representation of a compiled program. Apps you upload to iTunes Connect that contain bitcode will be compiled and linked on the App Store. Including bitcode will allow Apple to re-optimize your app binary in the future without the need to submit a new version of your app to the store.</p>\n<p>说的是bitcode是被编译程序的一种中间形式的代码。包含bitcode配置的程序将会在App store上被编译和链接。bitcode允许苹果在后期重新优化我们程序的二进制文件，而不需要我们重新提交一个新的版本到App store上。</p>\n<p>嗯，看着挺高级的啊。</p>\n<p>继续看，在<a href=\"https://developer.apple.com/library/prerelease/ios/documentation/DeveloperTools/Conceptual/WhatsNewXcode/Articles/xcode_7_0.html\" target=\"_blank\" rel=\"external\">What’s New in Xcode-New Features in Xcode 7</a>中，还有一段如下的描述</p>\n<p>Bitcode. When you archive for submission to the App Store, Xcode will compile your app into an intermediate representation. The App Store will then compile the bitcode down into the 64 or 32 bit executables as necessary.</p>\n<p>当我们提交程序到App store上时，Xcode会将程序编译为一个中间表现形式(bitcode)。然后App store会再将这个botcode编译为可执行的64位或32位程序。</p>\n<p>再看看这两段描述都是放在App Thinning(App瘦身)一节中，可以看出其与包的优化有关了。喵大(@onevcat)在其博客<a href=\"http://onevcat.com/2015/06/ios9-sdk/\" target=\"_blank\" rel=\"external\">开发者所需要知道的 iOS 9 SDK 新特性</a>中也描述了iOS 9中苹果在App瘦身中所做的一些改进，大家可以转场到那去研读一下。</p>\n<h1 id=\"Bitcode配置\"><a href=\"#Bitcode配置\" class=\"headerlink\" title=\"Bitcode配置\"></a>Bitcode配置</h1><p>在上面的错误提示中，提到了如何处理我们遇到的问题：</p>\n<p>You must rebuild it with bitcode enabled (Xcode setting ENABLE_BITCODE), obtain an updated library from the vendor, or disable bitcode for this target. for architecture arm64</p>\n<p>要么让第三方库支持，要么关闭target的bitcode选项。</p>\n<p>实际上在Xcode 7中，我们新建一个iOS程序时，bitcode选项默认是设置为YES的。我们可以在”Build Settings”-&gt;”Enable Bitcode”选项中看到这个设置。</p>\n<p>不过，我们现在需要考虑的是三个平台：iOS，Mac OS，watchOS。</p>\n<ul>\n<li>对应iOS，bitcode是可选的。</li>\n<li>对于watchOS，bitcode是必须的。</li>\n<li>Mac OS不支持bitcode。</li>\n</ul>\n<p>如果我们开启了bitcode，在提交包时，下面这个界面也会有个bitcode选项：</p>\n<p><img src=\"http://cc.cocimg.com/api/uploads/20150817/1439791780516322.png\" alt=\"blob.png\"></p>\n<p>盗图，我的应用没办法在这个界面显示bitcode，因为依赖于第三方的库，而这个库不支持bitcode，暂时只能设置ENABLE_BITCODE为NO。</p>\n<p>所以，如果我们的工程需要支持bitcode，则必要要求所有的引入的第三方库都支持bitcode。我就只能等着公司那些大哥大姐们啥时候提供一个新包给我们了。</p>\n<h2 id=\"题外话\"><a href=\"#题外话\" class=\"headerlink\" title=\"题外话\"></a>题外话</h2><p>如上面所说，bitcode是一种中间代码。LLVM官方文档有介绍这种文件的格式，有兴趣的可以移步<a href=\"http://llvm.org/docs/BitCodeFormat.html#llvm-bitcode-file-format\" target=\"_blank\" rel=\"external\">LLVM Bitcode File Format</a>。</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ul>\n<li><a href=\"https://developer.apple.com/library/prerelease/ios/documentation/IDEs/Conceptual/AppDistributionGuide/AppThinning/AppThinning.html#//apple_ref/doc/uid/TP40012582-CH35\" target=\"_blank\" rel=\"external\">App Distribution Guide – App Thinning (iOS, watchOS)</a></li>\n<li><a href=\"https://developer.apple.com/library/prerelease/ios/documentation/DeveloperTools/Conceptual/WhatsNewXcode/Articles/xcode_7_0.html\" target=\"_blank\" rel=\"external\">What’s New in Xcode-New Features in Xcode 7</a></li>\n<li><a href=\"http://onevcat.com/2015/06/ios9-sdk/\" target=\"_blank\" rel=\"external\">开发者所需要知道的 iOS 9 SDK 新特性</a></li>\n<li><a href=\"http://llvm.org/docs/BitCodeFormat.html#llvm-bitcode-file-format\" target=\"_blank\" rel=\"external\">LLVM Bitcode File Format</a></li>\n</ul>\n","excerpt":"","more":"<p>今天试着用Xcode 7 beta 3在真机(iOS 8.3)上运行一下我们的工程，结果发现工程编译不过。看了下问题，得到的信息是我们引入的一个第三方库不包含bitcode。嗯，不知道bitcode是啥，所以就得先看看这货是啥了。</p>\n<p><img src=\"http://cc.cocimg.com/api/uploads/20150702/1435823658708967.png\" alt=\"\"></p>\n<h1 id=\"Bitcode是什么？\"><a href=\"#Bitcode是什么？\" class=\"headerlink\" title=\"Bitcode是什么？\"></a>Bitcode是什么？</h1><p>找东西嘛，最先想到的当然是先看官方文档了。在<a href=\"https://developer.apple.com/library/prerelease/ios/documentation/IDEs/Conceptual/AppDistributionGuide/AppThinning/AppThinning.html#//apple_ref/doc/uid/TP40012582-CH35\">App Distribution Guide – App Thinning (iOS, watchOS)</a>一节中，找到了下面这样一个定义：</p>\n<p>Bitcode is an intermediate representation of a compiled program. Apps you upload to iTunes Connect that contain bitcode will be compiled and linked on the App Store. Including bitcode will allow Apple to re-optimize your app binary in the future without the need to submit a new version of your app to the store.</p>\n<p>说的是bitcode是被编译程序的一种中间形式的代码。包含bitcode配置的程序将会在App store上被编译和链接。bitcode允许苹果在后期重新优化我们程序的二进制文件，而不需要我们重新提交一个新的版本到App store上。</p>\n<p>嗯，看着挺高级的啊。</p>\n<p>继续看，在<a href=\"https://developer.apple.com/library/prerelease/ios/documentation/DeveloperTools/Conceptual/WhatsNewXcode/Articles/xcode_7_0.html\">What’s New in Xcode-New Features in Xcode 7</a>中，还有一段如下的描述</p>\n<p>Bitcode. When you archive for submission to the App Store, Xcode will compile your app into an intermediate representation. The App Store will then compile the bitcode down into the 64 or 32 bit executables as necessary.</p>\n<p>当我们提交程序到App store上时，Xcode会将程序编译为一个中间表现形式(bitcode)。然后App store会再将这个botcode编译为可执行的64位或32位程序。</p>\n<p>再看看这两段描述都是放在App Thinning(App瘦身)一节中，可以看出其与包的优化有关了。喵大(@onevcat)在其博客<a href=\"http://onevcat.com/2015/06/ios9-sdk/\">开发者所需要知道的 iOS 9 SDK 新特性</a>中也描述了iOS 9中苹果在App瘦身中所做的一些改进，大家可以转场到那去研读一下。</p>\n<h1 id=\"Bitcode配置\"><a href=\"#Bitcode配置\" class=\"headerlink\" title=\"Bitcode配置\"></a>Bitcode配置</h1><p>在上面的错误提示中，提到了如何处理我们遇到的问题：</p>\n<p>You must rebuild it with bitcode enabled (Xcode setting ENABLE_BITCODE), obtain an updated library from the vendor, or disable bitcode for this target. for architecture arm64</p>\n<p>要么让第三方库支持，要么关闭target的bitcode选项。</p>\n<p>实际上在Xcode 7中，我们新建一个iOS程序时，bitcode选项默认是设置为YES的。我们可以在”Build Settings”-&gt;”Enable Bitcode”选项中看到这个设置。</p>\n<p>不过，我们现在需要考虑的是三个平台：iOS，Mac OS，watchOS。</p>\n<ul>\n<li>对应iOS，bitcode是可选的。</li>\n<li>对于watchOS，bitcode是必须的。</li>\n<li>Mac OS不支持bitcode。</li>\n</ul>\n<p>如果我们开启了bitcode，在提交包时，下面这个界面也会有个bitcode选项：</p>\n<p><img src=\"http://cc.cocimg.com/api/uploads/20150817/1439791780516322.png\" alt=\"blob.png\"></p>\n<p>盗图，我的应用没办法在这个界面显示bitcode，因为依赖于第三方的库，而这个库不支持bitcode，暂时只能设置ENABLE_BITCODE为NO。</p>\n<p>所以，如果我们的工程需要支持bitcode，则必要要求所有的引入的第三方库都支持bitcode。我就只能等着公司那些大哥大姐们啥时候提供一个新包给我们了。</p>\n<h2 id=\"题外话\"><a href=\"#题外话\" class=\"headerlink\" title=\"题外话\"></a>题外话</h2><p>如上面所说，bitcode是一种中间代码。LLVM官方文档有介绍这种文件的格式，有兴趣的可以移步<a href=\"http://llvm.org/docs/BitCodeFormat.html#llvm-bitcode-file-format\">LLVM Bitcode File Format</a>。</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ul>\n<li><a href=\"https://developer.apple.com/library/prerelease/ios/documentation/IDEs/Conceptual/AppDistributionGuide/AppThinning/AppThinning.html#//apple_ref/doc/uid/TP40012582-CH35\">App Distribution Guide – App Thinning (iOS, watchOS)</a></li>\n<li><a href=\"https://developer.apple.com/library/prerelease/ios/documentation/DeveloperTools/Conceptual/WhatsNewXcode/Articles/xcode_7_0.html\">What’s New in Xcode-New Features in Xcode 7</a></li>\n<li><a href=\"http://onevcat.com/2015/06/ios9-sdk/\">开发者所需要知道的 iOS 9 SDK 新特性</a></li>\n<li><a href=\"http://llvm.org/docs/BitCodeFormat.html#llvm-bitcode-file-format\">LLVM Bitcode File Format</a></li>\n</ul>\n"},{"title":"Git 分支 - 变基","id":"36","updated":"2016-09-10T06:27:06.000Z","date":"2016-09-10T06:08:57.000Z","_content":"\n\n\n## 变基\n\n在 Git 中整合来自不同分支的修改主要有两种方法：`merge` 以及 `rebase`。 在本节中我们将学习什么是“变基”，怎样使用“变基”，并将展示该操作的惊艳之处，以及指出在何种情况下你应避免使用它。\n\n### [变基的基本操作](https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA#变基的基本操作)\n\n请回顾之前在 [分支的合并](https://git-scm.com/book/zh/v2/ch00/_basic_merging) 中的一个例子，你会看到开发任务分叉到两个不同分支，又各自提交了更新。\n\n<!------MORE------->\n\n![分叉的提交历史](https://git-scm.com/book/en/v2/book/03-git-branching/images/basic-rebase-1.png)Figure 3-27. 分叉的提交历史\n\n之前介绍过，整合分支最容易的方法是 `merge` 命令。 它会把两个分支的最新快照（`C3` 和 `C4`）以及二者最近的共同祖先（`C2`）进行三方合并，合并的结果是生成一个新的快照（并提交）。\n\n![通过合并操作来整合分叉了的历史](https://git-scm.com/book/en/v2/book/03-git-branching/images/basic-rebase-2.png)Figure 3-28. 通过合并操作来整合分叉了的历史\n\n其实，还有一种方法：你可以提取在 `C4` 中引入的补丁和修改，然后在 `C3` 的基础上再应用一次。 在 Git 中，这种操作就叫做 *变基*。 你可以使用 `rebase` 命令将提交到某一分支上的所有修改都移至另一分支上，就好像“重新播放”一样。\n\n在上面这个例子中，运行：\n\n```\n$ git checkout experiment\n$ git rebase master\nFirst, rewinding head to replay your work on top of it...\nApplying: added staged command\n```\n\n它的原理是首先找到这两个分支（即当前分支 `experiment`、变基操作的目标基底分支 `master`）的最近共同祖先 `C2`，然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件，然后将当前分支指向目标基底 `C3`, 最后以此将之前另存为临时文件的修改依序应用。（译注：写明了 commit id，以便理解，下同）\n\n![将 `C4` 中的修改变基到 `C3` 上](https://git-scm.com/book/en/v2/book/03-git-branching/images/basic-rebase-3.png)Figure 3-29. 将 `C4` 中的修改变基到 `C3` 上\n\n现在回到 `master` 分支，进行一次快进合并。\n\n```\n$ git checkout master\n$ git merge experiment\n```\n\n![master 分支的快进合并](https://git-scm.com/book/en/v2/book/03-git-branching/images/basic-rebase-4.png)Figure 3-30. master 分支的快进合并\n\n此时，`C4'` 指向的快照就和上面使用 `merge` 命令的例子中 `C5` 指向的快照一模一样了。 这两种整合方法的最终结果没有任何区别，但是变基使得提交历史更加整洁。 你在查看一个经过变基的分支的历史记录时会发现，尽管实际的开发工作是并行的，但它们看上去就像是先后串行的一样，提交历史是一条直线没有分叉。\n\n一般我们这样做的目的是为了确保在向远程分支推送时能保持提交历史的整洁——例如向某个别人维护的项目贡献代码时。 在这种情况下，你首先在自己的分支里进行开发，当开发完成时你需要先将你的代码变基到 `origin/master` 上，然后再向主项目提交修改。 这样的话，该项目的维护者就不再需要进行整合工作，只需要快进合并便可。\n\n请注意，无论是通过变基，还是通过三方合并，整合的最终结果所指向的快照始终是一样的，只不过提交历史不同罢了。 变基是将一系列提交按照原有次序依次应用到另一分支上，而合并是把最终结果合在一起。\n\n### [更有趣的变基例子](https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA#更有趣的变基例子)\n\n在对两个分支进行变基时，所生成的“重演”并不一定要在目标分支上应用，你也可以指定另外的一个分支进行应用。 就像 [Figure 3-31](https://git-scm.com/book/zh/v2/ch00/rbdiag_e) 中的例子这样。 你创建了一个特性分支 `server`，为服务端添加了一些功能，提交了 `C3` 和 `C4`。 然后从 `C3` 上创建了特性分支 `client`，为客户端添加了一些功能，提交了 `C8` 和`C9`。 最后，你回到 `server` 分支，又提交了 `C10`。\n\n![从一个特性分支里再分出一个特性分支的提交历史](https://git-scm.com/book/en/v2/book/03-git-branching/images/interesting-rebase-1.png)Figure 3-31. 从一个特性分支里再分出一个特性分支的提交历史\n\n假设你希望将 `client` 中的修改合并到主分支并发布，但暂时并不想合并 `server` 中的修改，因为它们还需要经过更全面的测试。 这时，你就可以使用 `git rebase` 命令的 `--onto` 选项，选中在 `client` 分支里但不在 `server` 分支里的修改（即 `C8` 和 `C9`），将它们在 `master` 分支上重演：\n\n```\n$ git rebase --onto master server client\n```\n\n以上命令的意思是：“取出 `client` 分支，找出处于 `client` 分支和 `server` 分支的共同祖先之后的修改，然后把它们在 `master` 分支上重演一遍”。 这理解起来有一点复杂，不过效果非常酷。\n\n![截取特性分支上的另一个特性分支，然后变基到其他分支](https://git-scm.com/book/en/v2/book/03-git-branching/images/interesting-rebase-2.png)Figure 3-32. 截取特性分支上的另一个特性分支，然后变基到其他分支\n\n现在可以快进合并 `master` 分支了。（如图 [Figure 3-33](https://git-scm.com/book/zh/v2/ch00/rbdiag_g)）：\n\n```\n$ git checkout master\n$ git merge client\n```\n\n![快进合并 master 分支，使之包含来自 client 分支的修改](https://git-scm.com/book/en/v2/book/03-git-branching/images/interesting-rebase-3.png)Figure 3-33. 快进合并 master 分支，使之包含来自 client 分支的修改\n\n接下来你决定将 `server` 分支中的修改也整合进来。 使用 `git rebase [basebranch] [topicbranch]` 命令可以直接将特性分支（即本例中的 `server`）变基到目标分支（即 `master`）上。这样做能省去你先切换到 `server` 分支，再对其执行变基命令的多个步骤。\n\n```\n$ git rebase master server\n```\n\n如图 [Figure 3-34](https://git-scm.com/book/zh/v2/ch00/rbdiag_h) 所示，`server` 中的代码被“续”到了 `master` 后面。\n\n![将 server 中的修改变基到 master 上](https://git-scm.com/book/en/v2/book/03-git-branching/images/interesting-rebase-4.png)Figure 3-34. 将 server 中的修改变基到 master 上\n\n然后就可以快进合并主分支 master 了：\n\n```\n$ git checkout master\n$ git merge server\n```\n\n至此，`client` 和 `server` 分支中的修改都已经整合到主分支里去了，你可以删除这两个分支，最终提交历史会变成图 [Figure 3-35](https://git-scm.com/book/zh/v2/ch00/rbdiag_i) 中的样子：\n\n```\n$ git branch -d client\n$ git branch -d server\n```\n\n![最终的提交历史](https://git-scm.com/book/en/v2/book/03-git-branching/images/interesting-rebase-5.png)Figure 3-35. 最终的提交历史\n\n### [变基的风险](https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA#变基的风险)\n\n呃，奇妙的变基也并非完美无缺，要用它得遵守一条准则：\n\n**不要对在你的仓库外有副本的分支执行变基。**\n\n如果你遵循这条金科玉律，就不会出差错。 否则，人民群众会仇恨你，你的朋友和家人也会嘲笑你，唾弃你。\n\n变基操作的实质是丢弃一些现有的提交，然后相应地新建一些内容一样但实际上不同的提交。 如果你已经将提交推送至某个仓库，而其他人也已经从该仓库拉取提交并进行了后续工作，此时，如果你用 `git rebase` 命令重新整理了提交并再次推送，你的同伴因此将不得不再次将他们手头的工作与你的提交进行整合，如果接下来你还要拉取并整合他们修改过的提交，事情就会变得一团糟。\n\n让我们来看一个在公开的仓库上执行变基操作所带来的问题。 假设你从一个中央服务器克隆然后在它的基础上进行了一些开发。 你的提交历史如图所示：\n\n![克隆一个仓库，然后在它的基础上进行了一些开发](https://git-scm.com/book/en/v2/book/03-git-branching/images/perils-of-rebasing-1.png)Figure 3-36. 克隆一个仓库，然后在它的基础上进行了一些开发\n\n然后，某人又向中央服务器提交了一些修改，其中还包括一次合并。 你抓取了这些在远程分支上的修改，并将其合并到你本地的开发分支，然后你的提交历史就会变成这样：\n\n![抓取别人的提交，合并到自己的开发分支](https://git-scm.com/book/en/v2/book/03-git-branching/images/perils-of-rebasing-2.png)Figure 3-37. 抓取别人的提交，合并到自己的开发分支\n\n接下来，这个人又决定把合并操作回滚，改用变基；继而又用 `git push --force` 命令覆盖了服务器上的提交历史。 之后你从服务器抓取更新，会发现多出来一些新的提交。\n\n![有人推送了经过变基的提交，并丢弃了你的本地开发所基于的一些提交](https://git-scm.com/book/en/v2/book/03-git-branching/images/perils-of-rebasing-3.png)Figure 3-38. 有人推送了经过变基的提交，并丢弃了你的本地开发所基于的一些提交\n\n结果就是你们两人的处境都十分尴尬。 如果你执行 `git pull` 命令，你将合并来自两条提交历史的内容，生成一个新的合并提交，最终仓库会如图所示：\n\n![你将相同的内容又合并了一次，生成了一个新的提交](https://git-scm.com/book/en/v2/book/03-git-branching/images/perils-of-rebasing-4.png)Figure 3-39. 你将相同的内容又合并了一次，生成了一个新的提交\n\n此时如果你执行 `git log` 命令，你会发现有两个提交的作者、日期、日志居然是一样的，这会令人感到混乱。 此外，如果你将这一堆又推送到服务器上，你实际上是将那些已经被变基抛弃的提交又找了回来，这会令人感到更加混乱。 很明显对方并不想在提交历史中看到 `C4` 和 `C6`，因为之前就是他们把这两个提交通过变基丢弃的。\n\n### [用变基解决变基](https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA#用变基解决变基)\n\n如果你 **真的** 遭遇了类似的处境，Git 还有一些高级魔法可以帮到你。 如果团队中的某人强制推送并覆盖了一些你所基于的提交，你需要做的就是检查你做了哪些修改，以及他们覆盖了哪些修改。\n\n实际上，Git 除了对整个提交计算 SHA-1 校验和以外，也对本次提交所引入的修改计算了校验和—— 即 “patch-id”。\n\n如果你拉取被覆盖过的更新并将你手头的工作基于此进行变基的话，一般情况下 Git 都能成功分辨出哪些是你的修改，并把它们应用到新分支上。\n\n举个例子，如果遇到前面提到的 [Figure 3-38](https://git-scm.com/book/zh/v2/ch00/_pre_merge_rebase_work) 那种情境，如果我们不是执行合并，而是执行 `git rebase teamone/master`, Git 将会：\n\n- 检查哪些提交是我们的分支上独有的（C2，C3，C4，C6，C7）\n- 检查其中哪些提交不是合并操作的结果（C2，C3，C4）\n- 检查哪些提交在对方覆盖更新时并没有被纳入目标分支（只有 C2 和 C3，因为 C4 其实就是 C4'）\n- 把查到的这些提交应用在 `teamone/master` 上面\n\n从而我们将得到与 [Figure 3-39](https://git-scm.com/book/zh/v2/ch00/_merge_rebase_work) 中不同的结果，如图 [Figure 3-40](https://git-scm.com/book/zh/v2/ch00/_rebase_rebase_work) 所示。\n\n![在一个被变基然后强制推送的分支上再次执行变基](https://git-scm.com/book/en/v2/book/03-git-branching/images/perils-of-rebasing-5.png)Figure 3-40. 在一个被变基然后强制推送的分支上再次执行变基\n\n要想上述方案有效，还需要对方在变基时确保 C4' 和 C4 是几乎一样的。 否则变基操作将无法识别，并新建另一个类似 C4 的补丁（而这个补丁很可能无法整洁的整合入历史，因为补丁中的修改已经存在于某个地方了）。\n\n在本例中另一种简单的方法是使用 `git pull --rebase` 命令而不是直接 `git pull`。 又或者你可以自己手动完成这个过程，先 `git fetch`，再 `git rebase teamone/master`。\n\n如果你习惯使用 `git pull` ，同时又希望默认使用选项 `--rebase`，你可以执行这条语句 `git config --global pull.rebase true` 来更改 `pull.rebase` 的默认配置。\n\n只要你把变基命令当作是在推送前清理提交使之整洁的工具，并且只在从未推送至共用仓库的提交上执行变基命令，你就不会有事。 假如你在那些已经被推送至共用仓库的提交上执行变基命令，并因此丢弃了一些别人的开发所基于的提交，那你就有大麻烦了，你的同事也会因此鄙视你。\n\n如果你或你的同事在某些情形下决意要这么做，请一定要通知每个人执行 `git pull --rebase` 命令，这样尽管不能避免伤痛，但能有所缓解。\n\n### [变基 vs. 合并](https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA#变基-vs.-合并)\n\n至此，你已在实战中学习了变基和合并的用法，你一定会想问，到底哪种方式更好。 在回答这个问题之前，让我们退后一步，想讨论一下提交历史到底意味着什么。\n\n有一种观点认为，仓库的提交历史即是 **记录实际发生过什么**。 它是针对历史的文档，本身就有价值，不能乱改。 从这个角度看来，改变提交历史是一种亵渎，你使用*谎言*掩盖了实际发生过的事情。 如果由合并产生的提交历史是一团糟怎么办？ 既然事实就是如此，那么这些痕迹就应该被保留下来，让后人能够查阅。\n\n另一种观点则正好相反，他们认为提交历史是 **项目过程中发生的故事**。 没人会出版一本书的第一批草稿，软件维护手册也是需要反复修订才能方便使用。 持这一观点的人会使用 rebase 及 filter-branch 等工具来编写故事，怎么方便后来的读者就怎么写。\n\n现在，让我们回到之前的问题上来，到底合并还是变基好？希望你能明白，并没有一个简单的答案。 Git 是一个非常强大的工具，它允许你对提交历史做许多事情，但每个团队、每个项目对此的需求并不相同。 既然你已经分别学习了两者的用法，相信你能够根据实际情况作出明智的选择。\n\n总的原则是，只对尚未推送或分享给别人的本地修改执行变基操作清理历史，从不对已推送至别处的提交执行变基操作，这样，你才能享受到两种方式带来的便利。\n\n","source":"_posts/Git-分支-变基.md","raw":"---\ntitle: Git 分支 - 变基\npermalink: git-fen-zhi-bian-ji\nid: 36\nupdated: '2016-09-10 14:27:06'\ndate: 2016-09-10 14:08:57\ntags: [git]\n---\n\n\n\n## 变基\n\n在 Git 中整合来自不同分支的修改主要有两种方法：`merge` 以及 `rebase`。 在本节中我们将学习什么是“变基”，怎样使用“变基”，并将展示该操作的惊艳之处，以及指出在何种情况下你应避免使用它。\n\n### [变基的基本操作](https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA#变基的基本操作)\n\n请回顾之前在 [分支的合并](https://git-scm.com/book/zh/v2/ch00/_basic_merging) 中的一个例子，你会看到开发任务分叉到两个不同分支，又各自提交了更新。\n\n<!------MORE------->\n\n![分叉的提交历史](https://git-scm.com/book/en/v2/book/03-git-branching/images/basic-rebase-1.png)Figure 3-27. 分叉的提交历史\n\n之前介绍过，整合分支最容易的方法是 `merge` 命令。 它会把两个分支的最新快照（`C3` 和 `C4`）以及二者最近的共同祖先（`C2`）进行三方合并，合并的结果是生成一个新的快照（并提交）。\n\n![通过合并操作来整合分叉了的历史](https://git-scm.com/book/en/v2/book/03-git-branching/images/basic-rebase-2.png)Figure 3-28. 通过合并操作来整合分叉了的历史\n\n其实，还有一种方法：你可以提取在 `C4` 中引入的补丁和修改，然后在 `C3` 的基础上再应用一次。 在 Git 中，这种操作就叫做 *变基*。 你可以使用 `rebase` 命令将提交到某一分支上的所有修改都移至另一分支上，就好像“重新播放”一样。\n\n在上面这个例子中，运行：\n\n```\n$ git checkout experiment\n$ git rebase master\nFirst, rewinding head to replay your work on top of it...\nApplying: added staged command\n```\n\n它的原理是首先找到这两个分支（即当前分支 `experiment`、变基操作的目标基底分支 `master`）的最近共同祖先 `C2`，然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件，然后将当前分支指向目标基底 `C3`, 最后以此将之前另存为临时文件的修改依序应用。（译注：写明了 commit id，以便理解，下同）\n\n![将 `C4` 中的修改变基到 `C3` 上](https://git-scm.com/book/en/v2/book/03-git-branching/images/basic-rebase-3.png)Figure 3-29. 将 `C4` 中的修改变基到 `C3` 上\n\n现在回到 `master` 分支，进行一次快进合并。\n\n```\n$ git checkout master\n$ git merge experiment\n```\n\n![master 分支的快进合并](https://git-scm.com/book/en/v2/book/03-git-branching/images/basic-rebase-4.png)Figure 3-30. master 分支的快进合并\n\n此时，`C4'` 指向的快照就和上面使用 `merge` 命令的例子中 `C5` 指向的快照一模一样了。 这两种整合方法的最终结果没有任何区别，但是变基使得提交历史更加整洁。 你在查看一个经过变基的分支的历史记录时会发现，尽管实际的开发工作是并行的，但它们看上去就像是先后串行的一样，提交历史是一条直线没有分叉。\n\n一般我们这样做的目的是为了确保在向远程分支推送时能保持提交历史的整洁——例如向某个别人维护的项目贡献代码时。 在这种情况下，你首先在自己的分支里进行开发，当开发完成时你需要先将你的代码变基到 `origin/master` 上，然后再向主项目提交修改。 这样的话，该项目的维护者就不再需要进行整合工作，只需要快进合并便可。\n\n请注意，无论是通过变基，还是通过三方合并，整合的最终结果所指向的快照始终是一样的，只不过提交历史不同罢了。 变基是将一系列提交按照原有次序依次应用到另一分支上，而合并是把最终结果合在一起。\n\n### [更有趣的变基例子](https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA#更有趣的变基例子)\n\n在对两个分支进行变基时，所生成的“重演”并不一定要在目标分支上应用，你也可以指定另外的一个分支进行应用。 就像 [Figure 3-31](https://git-scm.com/book/zh/v2/ch00/rbdiag_e) 中的例子这样。 你创建了一个特性分支 `server`，为服务端添加了一些功能，提交了 `C3` 和 `C4`。 然后从 `C3` 上创建了特性分支 `client`，为客户端添加了一些功能，提交了 `C8` 和`C9`。 最后，你回到 `server` 分支，又提交了 `C10`。\n\n![从一个特性分支里再分出一个特性分支的提交历史](https://git-scm.com/book/en/v2/book/03-git-branching/images/interesting-rebase-1.png)Figure 3-31. 从一个特性分支里再分出一个特性分支的提交历史\n\n假设你希望将 `client` 中的修改合并到主分支并发布，但暂时并不想合并 `server` 中的修改，因为它们还需要经过更全面的测试。 这时，你就可以使用 `git rebase` 命令的 `--onto` 选项，选中在 `client` 分支里但不在 `server` 分支里的修改（即 `C8` 和 `C9`），将它们在 `master` 分支上重演：\n\n```\n$ git rebase --onto master server client\n```\n\n以上命令的意思是：“取出 `client` 分支，找出处于 `client` 分支和 `server` 分支的共同祖先之后的修改，然后把它们在 `master` 分支上重演一遍”。 这理解起来有一点复杂，不过效果非常酷。\n\n![截取特性分支上的另一个特性分支，然后变基到其他分支](https://git-scm.com/book/en/v2/book/03-git-branching/images/interesting-rebase-2.png)Figure 3-32. 截取特性分支上的另一个特性分支，然后变基到其他分支\n\n现在可以快进合并 `master` 分支了。（如图 [Figure 3-33](https://git-scm.com/book/zh/v2/ch00/rbdiag_g)）：\n\n```\n$ git checkout master\n$ git merge client\n```\n\n![快进合并 master 分支，使之包含来自 client 分支的修改](https://git-scm.com/book/en/v2/book/03-git-branching/images/interesting-rebase-3.png)Figure 3-33. 快进合并 master 分支，使之包含来自 client 分支的修改\n\n接下来你决定将 `server` 分支中的修改也整合进来。 使用 `git rebase [basebranch] [topicbranch]` 命令可以直接将特性分支（即本例中的 `server`）变基到目标分支（即 `master`）上。这样做能省去你先切换到 `server` 分支，再对其执行变基命令的多个步骤。\n\n```\n$ git rebase master server\n```\n\n如图 [Figure 3-34](https://git-scm.com/book/zh/v2/ch00/rbdiag_h) 所示，`server` 中的代码被“续”到了 `master` 后面。\n\n![将 server 中的修改变基到 master 上](https://git-scm.com/book/en/v2/book/03-git-branching/images/interesting-rebase-4.png)Figure 3-34. 将 server 中的修改变基到 master 上\n\n然后就可以快进合并主分支 master 了：\n\n```\n$ git checkout master\n$ git merge server\n```\n\n至此，`client` 和 `server` 分支中的修改都已经整合到主分支里去了，你可以删除这两个分支，最终提交历史会变成图 [Figure 3-35](https://git-scm.com/book/zh/v2/ch00/rbdiag_i) 中的样子：\n\n```\n$ git branch -d client\n$ git branch -d server\n```\n\n![最终的提交历史](https://git-scm.com/book/en/v2/book/03-git-branching/images/interesting-rebase-5.png)Figure 3-35. 最终的提交历史\n\n### [变基的风险](https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA#变基的风险)\n\n呃，奇妙的变基也并非完美无缺，要用它得遵守一条准则：\n\n**不要对在你的仓库外有副本的分支执行变基。**\n\n如果你遵循这条金科玉律，就不会出差错。 否则，人民群众会仇恨你，你的朋友和家人也会嘲笑你，唾弃你。\n\n变基操作的实质是丢弃一些现有的提交，然后相应地新建一些内容一样但实际上不同的提交。 如果你已经将提交推送至某个仓库，而其他人也已经从该仓库拉取提交并进行了后续工作，此时，如果你用 `git rebase` 命令重新整理了提交并再次推送，你的同伴因此将不得不再次将他们手头的工作与你的提交进行整合，如果接下来你还要拉取并整合他们修改过的提交，事情就会变得一团糟。\n\n让我们来看一个在公开的仓库上执行变基操作所带来的问题。 假设你从一个中央服务器克隆然后在它的基础上进行了一些开发。 你的提交历史如图所示：\n\n![克隆一个仓库，然后在它的基础上进行了一些开发](https://git-scm.com/book/en/v2/book/03-git-branching/images/perils-of-rebasing-1.png)Figure 3-36. 克隆一个仓库，然后在它的基础上进行了一些开发\n\n然后，某人又向中央服务器提交了一些修改，其中还包括一次合并。 你抓取了这些在远程分支上的修改，并将其合并到你本地的开发分支，然后你的提交历史就会变成这样：\n\n![抓取别人的提交，合并到自己的开发分支](https://git-scm.com/book/en/v2/book/03-git-branching/images/perils-of-rebasing-2.png)Figure 3-37. 抓取别人的提交，合并到自己的开发分支\n\n接下来，这个人又决定把合并操作回滚，改用变基；继而又用 `git push --force` 命令覆盖了服务器上的提交历史。 之后你从服务器抓取更新，会发现多出来一些新的提交。\n\n![有人推送了经过变基的提交，并丢弃了你的本地开发所基于的一些提交](https://git-scm.com/book/en/v2/book/03-git-branching/images/perils-of-rebasing-3.png)Figure 3-38. 有人推送了经过变基的提交，并丢弃了你的本地开发所基于的一些提交\n\n结果就是你们两人的处境都十分尴尬。 如果你执行 `git pull` 命令，你将合并来自两条提交历史的内容，生成一个新的合并提交，最终仓库会如图所示：\n\n![你将相同的内容又合并了一次，生成了一个新的提交](https://git-scm.com/book/en/v2/book/03-git-branching/images/perils-of-rebasing-4.png)Figure 3-39. 你将相同的内容又合并了一次，生成了一个新的提交\n\n此时如果你执行 `git log` 命令，你会发现有两个提交的作者、日期、日志居然是一样的，这会令人感到混乱。 此外，如果你将这一堆又推送到服务器上，你实际上是将那些已经被变基抛弃的提交又找了回来，这会令人感到更加混乱。 很明显对方并不想在提交历史中看到 `C4` 和 `C6`，因为之前就是他们把这两个提交通过变基丢弃的。\n\n### [用变基解决变基](https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA#用变基解决变基)\n\n如果你 **真的** 遭遇了类似的处境，Git 还有一些高级魔法可以帮到你。 如果团队中的某人强制推送并覆盖了一些你所基于的提交，你需要做的就是检查你做了哪些修改，以及他们覆盖了哪些修改。\n\n实际上，Git 除了对整个提交计算 SHA-1 校验和以外，也对本次提交所引入的修改计算了校验和—— 即 “patch-id”。\n\n如果你拉取被覆盖过的更新并将你手头的工作基于此进行变基的话，一般情况下 Git 都能成功分辨出哪些是你的修改，并把它们应用到新分支上。\n\n举个例子，如果遇到前面提到的 [Figure 3-38](https://git-scm.com/book/zh/v2/ch00/_pre_merge_rebase_work) 那种情境，如果我们不是执行合并，而是执行 `git rebase teamone/master`, Git 将会：\n\n- 检查哪些提交是我们的分支上独有的（C2，C3，C4，C6，C7）\n- 检查其中哪些提交不是合并操作的结果（C2，C3，C4）\n- 检查哪些提交在对方覆盖更新时并没有被纳入目标分支（只有 C2 和 C3，因为 C4 其实就是 C4'）\n- 把查到的这些提交应用在 `teamone/master` 上面\n\n从而我们将得到与 [Figure 3-39](https://git-scm.com/book/zh/v2/ch00/_merge_rebase_work) 中不同的结果，如图 [Figure 3-40](https://git-scm.com/book/zh/v2/ch00/_rebase_rebase_work) 所示。\n\n![在一个被变基然后强制推送的分支上再次执行变基](https://git-scm.com/book/en/v2/book/03-git-branching/images/perils-of-rebasing-5.png)Figure 3-40. 在一个被变基然后强制推送的分支上再次执行变基\n\n要想上述方案有效，还需要对方在变基时确保 C4' 和 C4 是几乎一样的。 否则变基操作将无法识别，并新建另一个类似 C4 的补丁（而这个补丁很可能无法整洁的整合入历史，因为补丁中的修改已经存在于某个地方了）。\n\n在本例中另一种简单的方法是使用 `git pull --rebase` 命令而不是直接 `git pull`。 又或者你可以自己手动完成这个过程，先 `git fetch`，再 `git rebase teamone/master`。\n\n如果你习惯使用 `git pull` ，同时又希望默认使用选项 `--rebase`，你可以执行这条语句 `git config --global pull.rebase true` 来更改 `pull.rebase` 的默认配置。\n\n只要你把变基命令当作是在推送前清理提交使之整洁的工具，并且只在从未推送至共用仓库的提交上执行变基命令，你就不会有事。 假如你在那些已经被推送至共用仓库的提交上执行变基命令，并因此丢弃了一些别人的开发所基于的提交，那你就有大麻烦了，你的同事也会因此鄙视你。\n\n如果你或你的同事在某些情形下决意要这么做，请一定要通知每个人执行 `git pull --rebase` 命令，这样尽管不能避免伤痛，但能有所缓解。\n\n### [变基 vs. 合并](https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA#变基-vs.-合并)\n\n至此，你已在实战中学习了变基和合并的用法，你一定会想问，到底哪种方式更好。 在回答这个问题之前，让我们退后一步，想讨论一下提交历史到底意味着什么。\n\n有一种观点认为，仓库的提交历史即是 **记录实际发生过什么**。 它是针对历史的文档，本身就有价值，不能乱改。 从这个角度看来，改变提交历史是一种亵渎，你使用*谎言*掩盖了实际发生过的事情。 如果由合并产生的提交历史是一团糟怎么办？ 既然事实就是如此，那么这些痕迹就应该被保留下来，让后人能够查阅。\n\n另一种观点则正好相反，他们认为提交历史是 **项目过程中发生的故事**。 没人会出版一本书的第一批草稿，软件维护手册也是需要反复修订才能方便使用。 持这一观点的人会使用 rebase 及 filter-branch 等工具来编写故事，怎么方便后来的读者就怎么写。\n\n现在，让我们回到之前的问题上来，到底合并还是变基好？希望你能明白，并没有一个简单的答案。 Git 是一个非常强大的工具，它允许你对提交历史做许多事情，但每个团队、每个项目对此的需求并不相同。 既然你已经分别学习了两者的用法，相信你能够根据实际情况作出明智的选择。\n\n总的原则是，只对尚未推送或分享给别人的本地修改执行变基操作清理历史，从不对已推送至别处的提交执行变基操作，这样，你才能享受到两种方式带来的便利。\n\n","slug":"git-fen-zhi-bian-ji","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cj04pzywi0004s04e0rj9filv","content":"<h2 id=\"变基\"><a href=\"#变基\" class=\"headerlink\" title=\"变基\"></a>变基</h2><p>在 Git 中整合来自不同分支的修改主要有两种方法：<code>merge</code> 以及 <code>rebase</code>。 在本节中我们将学习什么是“变基”，怎样使用“变基”，并将展示该操作的惊艳之处，以及指出在何种情况下你应避免使用它。</p>\n<h3 id=\"变基的基本操作\"><a href=\"#变基的基本操作\" class=\"headerlink\" title=\"变基的基本操作\"></a><a href=\"https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA#变基的基本操作\" target=\"_blank\" rel=\"external\">变基的基本操作</a></h3><p>请回顾之前在 <a href=\"https://git-scm.com/book/zh/v2/ch00/_basic_merging\" target=\"_blank\" rel=\"external\">分支的合并</a> 中的一个例子，你会看到开发任务分叉到两个不同分支，又各自提交了更新。</p>\n<a id=\"more\"></a>\n<p><img src=\"https://git-scm.com/book/en/v2/book/03-git-branching/images/basic-rebase-1.png\" alt=\"分叉的提交历史\">Figure 3-27. 分叉的提交历史</p>\n<p>之前介绍过，整合分支最容易的方法是 <code>merge</code> 命令。 它会把两个分支的最新快照（<code>C3</code> 和 <code>C4</code>）以及二者最近的共同祖先（<code>C2</code>）进行三方合并，合并的结果是生成一个新的快照（并提交）。</p>\n<p><img src=\"https://git-scm.com/book/en/v2/book/03-git-branching/images/basic-rebase-2.png\" alt=\"通过合并操作来整合分叉了的历史\">Figure 3-28. 通过合并操作来整合分叉了的历史</p>\n<p>其实，还有一种方法：你可以提取在 <code>C4</code> 中引入的补丁和修改，然后在 <code>C3</code> 的基础上再应用一次。 在 Git 中，这种操作就叫做 <em>变基</em>。 你可以使用 <code>rebase</code> 命令将提交到某一分支上的所有修改都移至另一分支上，就好像“重新播放”一样。</p>\n<p>在上面这个例子中，运行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git checkout experiment</div><div class=\"line\">$ git rebase master</div><div class=\"line\">First, rewinding head to replay your work on top of it...</div><div class=\"line\">Applying: added staged command</div></pre></td></tr></table></figure>\n<p>它的原理是首先找到这两个分支（即当前分支 <code>experiment</code>、变基操作的目标基底分支 <code>master</code>）的最近共同祖先 <code>C2</code>，然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件，然后将当前分支指向目标基底 <code>C3</code>, 最后以此将之前另存为临时文件的修改依序应用。（译注：写明了 commit id，以便理解，下同）</p>\n<p><img src=\"https://git-scm.com/book/en/v2/book/03-git-branching/images/basic-rebase-3.png\" alt=\"将 `C4` 中的修改变基到 `C3` 上\">Figure 3-29. 将 <code>C4</code> 中的修改变基到 <code>C3</code> 上</p>\n<p>现在回到 <code>master</code> 分支，进行一次快进合并。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git checkout master</div><div class=\"line\">$ git merge experiment</div></pre></td></tr></table></figure>\n<p><img src=\"https://git-scm.com/book/en/v2/book/03-git-branching/images/basic-rebase-4.png\" alt=\"master 分支的快进合并\">Figure 3-30. master 分支的快进合并</p>\n<p>此时，<code>C4&#39;</code> 指向的快照就和上面使用 <code>merge</code> 命令的例子中 <code>C5</code> 指向的快照一模一样了。 这两种整合方法的最终结果没有任何区别，但是变基使得提交历史更加整洁。 你在查看一个经过变基的分支的历史记录时会发现，尽管实际的开发工作是并行的，但它们看上去就像是先后串行的一样，提交历史是一条直线没有分叉。</p>\n<p>一般我们这样做的目的是为了确保在向远程分支推送时能保持提交历史的整洁——例如向某个别人维护的项目贡献代码时。 在这种情况下，你首先在自己的分支里进行开发，当开发完成时你需要先将你的代码变基到 <code>origin/master</code> 上，然后再向主项目提交修改。 这样的话，该项目的维护者就不再需要进行整合工作，只需要快进合并便可。</p>\n<p>请注意，无论是通过变基，还是通过三方合并，整合的最终结果所指向的快照始终是一样的，只不过提交历史不同罢了。 变基是将一系列提交按照原有次序依次应用到另一分支上，而合并是把最终结果合在一起。</p>\n<h3 id=\"更有趣的变基例子\"><a href=\"#更有趣的变基例子\" class=\"headerlink\" title=\"更有趣的变基例子\"></a><a href=\"https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA#更有趣的变基例子\" target=\"_blank\" rel=\"external\">更有趣的变基例子</a></h3><p>在对两个分支进行变基时，所生成的“重演”并不一定要在目标分支上应用，你也可以指定另外的一个分支进行应用。 就像 <a href=\"https://git-scm.com/book/zh/v2/ch00/rbdiag_e\" target=\"_blank\" rel=\"external\">Figure 3-31</a> 中的例子这样。 你创建了一个特性分支 <code>server</code>，为服务端添加了一些功能，提交了 <code>C3</code> 和 <code>C4</code>。 然后从 <code>C3</code> 上创建了特性分支 <code>client</code>，为客户端添加了一些功能，提交了 <code>C8</code> 和<code>C9</code>。 最后，你回到 <code>server</code> 分支，又提交了 <code>C10</code>。</p>\n<p><img src=\"https://git-scm.com/book/en/v2/book/03-git-branching/images/interesting-rebase-1.png\" alt=\"从一个特性分支里再分出一个特性分支的提交历史\">Figure 3-31. 从一个特性分支里再分出一个特性分支的提交历史</p>\n<p>假设你希望将 <code>client</code> 中的修改合并到主分支并发布，但暂时并不想合并 <code>server</code> 中的修改，因为它们还需要经过更全面的测试。 这时，你就可以使用 <code>git rebase</code> 命令的 <code>--onto</code> 选项，选中在 <code>client</code> 分支里但不在 <code>server</code> 分支里的修改（即 <code>C8</code> 和 <code>C9</code>），将它们在 <code>master</code> 分支上重演：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git rebase --onto master server client</div></pre></td></tr></table></figure>\n<p>以上命令的意思是：“取出 <code>client</code> 分支，找出处于 <code>client</code> 分支和 <code>server</code> 分支的共同祖先之后的修改，然后把它们在 <code>master</code> 分支上重演一遍”。 这理解起来有一点复杂，不过效果非常酷。</p>\n<p><img src=\"https://git-scm.com/book/en/v2/book/03-git-branching/images/interesting-rebase-2.png\" alt=\"截取特性分支上的另一个特性分支，然后变基到其他分支\">Figure 3-32. 截取特性分支上的另一个特性分支，然后变基到其他分支</p>\n<p>现在可以快进合并 <code>master</code> 分支了。（如图 <a href=\"https://git-scm.com/book/zh/v2/ch00/rbdiag_g\" target=\"_blank\" rel=\"external\">Figure 3-33</a>）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git checkout master</div><div class=\"line\">$ git merge client</div></pre></td></tr></table></figure>\n<p><img src=\"https://git-scm.com/book/en/v2/book/03-git-branching/images/interesting-rebase-3.png\" alt=\"快进合并 master 分支，使之包含来自 client 分支的修改\">Figure 3-33. 快进合并 master 分支，使之包含来自 client 分支的修改</p>\n<p>接下来你决定将 <code>server</code> 分支中的修改也整合进来。 使用 <code>git rebase [basebranch] [topicbranch]</code> 命令可以直接将特性分支（即本例中的 <code>server</code>）变基到目标分支（即 <code>master</code>）上。这样做能省去你先切换到 <code>server</code> 分支，再对其执行变基命令的多个步骤。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git rebase master server</div></pre></td></tr></table></figure>\n<p>如图 <a href=\"https://git-scm.com/book/zh/v2/ch00/rbdiag_h\" target=\"_blank\" rel=\"external\">Figure 3-34</a> 所示，<code>server</code> 中的代码被“续”到了 <code>master</code> 后面。</p>\n<p><img src=\"https://git-scm.com/book/en/v2/book/03-git-branching/images/interesting-rebase-4.png\" alt=\"将 server 中的修改变基到 master 上\">Figure 3-34. 将 server 中的修改变基到 master 上</p>\n<p>然后就可以快进合并主分支 master 了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git checkout master</div><div class=\"line\">$ git merge server</div></pre></td></tr></table></figure>\n<p>至此，<code>client</code> 和 <code>server</code> 分支中的修改都已经整合到主分支里去了，你可以删除这两个分支，最终提交历史会变成图 <a href=\"https://git-scm.com/book/zh/v2/ch00/rbdiag_i\" target=\"_blank\" rel=\"external\">Figure 3-35</a> 中的样子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git branch -d client</div><div class=\"line\">$ git branch -d server</div></pre></td></tr></table></figure>\n<p><img src=\"https://git-scm.com/book/en/v2/book/03-git-branching/images/interesting-rebase-5.png\" alt=\"最终的提交历史\">Figure 3-35. 最终的提交历史</p>\n<h3 id=\"变基的风险\"><a href=\"#变基的风险\" class=\"headerlink\" title=\"变基的风险\"></a><a href=\"https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA#变基的风险\" target=\"_blank\" rel=\"external\">变基的风险</a></h3><p>呃，奇妙的变基也并非完美无缺，要用它得遵守一条准则：</p>\n<p><strong>不要对在你的仓库外有副本的分支执行变基。</strong></p>\n<p>如果你遵循这条金科玉律，就不会出差错。 否则，人民群众会仇恨你，你的朋友和家人也会嘲笑你，唾弃你。</p>\n<p>变基操作的实质是丢弃一些现有的提交，然后相应地新建一些内容一样但实际上不同的提交。 如果你已经将提交推送至某个仓库，而其他人也已经从该仓库拉取提交并进行了后续工作，此时，如果你用 <code>git rebase</code> 命令重新整理了提交并再次推送，你的同伴因此将不得不再次将他们手头的工作与你的提交进行整合，如果接下来你还要拉取并整合他们修改过的提交，事情就会变得一团糟。</p>\n<p>让我们来看一个在公开的仓库上执行变基操作所带来的问题。 假设你从一个中央服务器克隆然后在它的基础上进行了一些开发。 你的提交历史如图所示：</p>\n<p><img src=\"https://git-scm.com/book/en/v2/book/03-git-branching/images/perils-of-rebasing-1.png\" alt=\"克隆一个仓库，然后在它的基础上进行了一些开发\">Figure 3-36. 克隆一个仓库，然后在它的基础上进行了一些开发</p>\n<p>然后，某人又向中央服务器提交了一些修改，其中还包括一次合并。 你抓取了这些在远程分支上的修改，并将其合并到你本地的开发分支，然后你的提交历史就会变成这样：</p>\n<p><img src=\"https://git-scm.com/book/en/v2/book/03-git-branching/images/perils-of-rebasing-2.png\" alt=\"抓取别人的提交，合并到自己的开发分支\">Figure 3-37. 抓取别人的提交，合并到自己的开发分支</p>\n<p>接下来，这个人又决定把合并操作回滚，改用变基；继而又用 <code>git push --force</code> 命令覆盖了服务器上的提交历史。 之后你从服务器抓取更新，会发现多出来一些新的提交。</p>\n<p><img src=\"https://git-scm.com/book/en/v2/book/03-git-branching/images/perils-of-rebasing-3.png\" alt=\"有人推送了经过变基的提交，并丢弃了你的本地开发所基于的一些提交\">Figure 3-38. 有人推送了经过变基的提交，并丢弃了你的本地开发所基于的一些提交</p>\n<p>结果就是你们两人的处境都十分尴尬。 如果你执行 <code>git pull</code> 命令，你将合并来自两条提交历史的内容，生成一个新的合并提交，最终仓库会如图所示：</p>\n<p><img src=\"https://git-scm.com/book/en/v2/book/03-git-branching/images/perils-of-rebasing-4.png\" alt=\"你将相同的内容又合并了一次，生成了一个新的提交\">Figure 3-39. 你将相同的内容又合并了一次，生成了一个新的提交</p>\n<p>此时如果你执行 <code>git log</code> 命令，你会发现有两个提交的作者、日期、日志居然是一样的，这会令人感到混乱。 此外，如果你将这一堆又推送到服务器上，你实际上是将那些已经被变基抛弃的提交又找了回来，这会令人感到更加混乱。 很明显对方并不想在提交历史中看到 <code>C4</code> 和 <code>C6</code>，因为之前就是他们把这两个提交通过变基丢弃的。</p>\n<h3 id=\"用变基解决变基\"><a href=\"#用变基解决变基\" class=\"headerlink\" title=\"用变基解决变基\"></a><a href=\"https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA#用变基解决变基\" target=\"_blank\" rel=\"external\">用变基解决变基</a></h3><p>如果你 <strong>真的</strong> 遭遇了类似的处境，Git 还有一些高级魔法可以帮到你。 如果团队中的某人强制推送并覆盖了一些你所基于的提交，你需要做的就是检查你做了哪些修改，以及他们覆盖了哪些修改。</p>\n<p>实际上，Git 除了对整个提交计算 SHA-1 校验和以外，也对本次提交所引入的修改计算了校验和—— 即 “patch-id”。</p>\n<p>如果你拉取被覆盖过的更新并将你手头的工作基于此进行变基的话，一般情况下 Git 都能成功分辨出哪些是你的修改，并把它们应用到新分支上。</p>\n<p>举个例子，如果遇到前面提到的 <a href=\"https://git-scm.com/book/zh/v2/ch00/_pre_merge_rebase_work\" target=\"_blank\" rel=\"external\">Figure 3-38</a> 那种情境，如果我们不是执行合并，而是执行 <code>git rebase teamone/master</code>, Git 将会：</p>\n<ul>\n<li>检查哪些提交是我们的分支上独有的（C2，C3，C4，C6，C7）</li>\n<li>检查其中哪些提交不是合并操作的结果（C2，C3，C4）</li>\n<li>检查哪些提交在对方覆盖更新时并没有被纳入目标分支（只有 C2 和 C3，因为 C4 其实就是 C4’）</li>\n<li>把查到的这些提交应用在 <code>teamone/master</code> 上面</li>\n</ul>\n<p>从而我们将得到与 <a href=\"https://git-scm.com/book/zh/v2/ch00/_merge_rebase_work\" target=\"_blank\" rel=\"external\">Figure 3-39</a> 中不同的结果，如图 <a href=\"https://git-scm.com/book/zh/v2/ch00/_rebase_rebase_work\" target=\"_blank\" rel=\"external\">Figure 3-40</a> 所示。</p>\n<p><img src=\"https://git-scm.com/book/en/v2/book/03-git-branching/images/perils-of-rebasing-5.png\" alt=\"在一个被变基然后强制推送的分支上再次执行变基\">Figure 3-40. 在一个被变基然后强制推送的分支上再次执行变基</p>\n<p>要想上述方案有效，还需要对方在变基时确保 C4’ 和 C4 是几乎一样的。 否则变基操作将无法识别，并新建另一个类似 C4 的补丁（而这个补丁很可能无法整洁的整合入历史，因为补丁中的修改已经存在于某个地方了）。</p>\n<p>在本例中另一种简单的方法是使用 <code>git pull --rebase</code> 命令而不是直接 <code>git pull</code>。 又或者你可以自己手动完成这个过程，先 <code>git fetch</code>，再 <code>git rebase teamone/master</code>。</p>\n<p>如果你习惯使用 <code>git pull</code> ，同时又希望默认使用选项 <code>--rebase</code>，你可以执行这条语句 <code>git config --global pull.rebase true</code> 来更改 <code>pull.rebase</code> 的默认配置。</p>\n<p>只要你把变基命令当作是在推送前清理提交使之整洁的工具，并且只在从未推送至共用仓库的提交上执行变基命令，你就不会有事。 假如你在那些已经被推送至共用仓库的提交上执行变基命令，并因此丢弃了一些别人的开发所基于的提交，那你就有大麻烦了，你的同事也会因此鄙视你。</p>\n<p>如果你或你的同事在某些情形下决意要这么做，请一定要通知每个人执行 <code>git pull --rebase</code> 命令，这样尽管不能避免伤痛，但能有所缓解。</p>\n<h3 id=\"变基-vs-合并\"><a href=\"#变基-vs-合并\" class=\"headerlink\" title=\"变基 vs. 合并\"></a><a href=\"https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA#变基-vs.-合并\" target=\"_blank\" rel=\"external\">变基 vs. 合并</a></h3><p>至此，你已在实战中学习了变基和合并的用法，你一定会想问，到底哪种方式更好。 在回答这个问题之前，让我们退后一步，想讨论一下提交历史到底意味着什么。</p>\n<p>有一种观点认为，仓库的提交历史即是 <strong>记录实际发生过什么</strong>。 它是针对历史的文档，本身就有价值，不能乱改。 从这个角度看来，改变提交历史是一种亵渎，你使用<em>谎言</em>掩盖了实际发生过的事情。 如果由合并产生的提交历史是一团糟怎么办？ 既然事实就是如此，那么这些痕迹就应该被保留下来，让后人能够查阅。</p>\n<p>另一种观点则正好相反，他们认为提交历史是 <strong>项目过程中发生的故事</strong>。 没人会出版一本书的第一批草稿，软件维护手册也是需要反复修订才能方便使用。 持这一观点的人会使用 rebase 及 filter-branch 等工具来编写故事，怎么方便后来的读者就怎么写。</p>\n<p>现在，让我们回到之前的问题上来，到底合并还是变基好？希望你能明白，并没有一个简单的答案。 Git 是一个非常强大的工具，它允许你对提交历史做许多事情，但每个团队、每个项目对此的需求并不相同。 既然你已经分别学习了两者的用法，相信你能够根据实际情况作出明智的选择。</p>\n<p>总的原则是，只对尚未推送或分享给别人的本地修改执行变基操作清理历史，从不对已推送至别处的提交执行变基操作，这样，你才能享受到两种方式带来的便利。</p>\n","excerpt":"<h2 id=\"变基\"><a href=\"#变基\" class=\"headerlink\" title=\"变基\"></a>变基</h2><p>在 Git 中整合来自不同分支的修改主要有两种方法：<code>merge</code> 以及 <code>rebase</code>。 在本节中我们将学习什么是“变基”，怎样使用“变基”，并将展示该操作的惊艳之处，以及指出在何种情况下你应避免使用它。</p>\n<h3 id=\"变基的基本操作\"><a href=\"#变基的基本操作\" class=\"headerlink\" title=\"变基的基本操作\"></a><a href=\"https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA#变基的基本操作\">变基的基本操作</a></h3><p>请回顾之前在 <a href=\"https://git-scm.com/book/zh/v2/ch00/_basic_merging\">分支的合并</a> 中的一个例子，你会看到开发任务分叉到两个不同分支，又各自提交了更新。</p>","more":"<p><img src=\"https://git-scm.com/book/en/v2/book/03-git-branching/images/basic-rebase-1.png\" alt=\"分叉的提交历史\">Figure 3-27. 分叉的提交历史</p>\n<p>之前介绍过，整合分支最容易的方法是 <code>merge</code> 命令。 它会把两个分支的最新快照（<code>C3</code> 和 <code>C4</code>）以及二者最近的共同祖先（<code>C2</code>）进行三方合并，合并的结果是生成一个新的快照（并提交）。</p>\n<p><img src=\"https://git-scm.com/book/en/v2/book/03-git-branching/images/basic-rebase-2.png\" alt=\"通过合并操作来整合分叉了的历史\">Figure 3-28. 通过合并操作来整合分叉了的历史</p>\n<p>其实，还有一种方法：你可以提取在 <code>C4</code> 中引入的补丁和修改，然后在 <code>C3</code> 的基础上再应用一次。 在 Git 中，这种操作就叫做 <em>变基</em>。 你可以使用 <code>rebase</code> 命令将提交到某一分支上的所有修改都移至另一分支上，就好像“重新播放”一样。</p>\n<p>在上面这个例子中，运行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git checkout experiment</div><div class=\"line\">$ git rebase master</div><div class=\"line\">First, rewinding head to replay your work on top of it...</div><div class=\"line\">Applying: added staged command</div></pre></td></tr></table></figure>\n<p>它的原理是首先找到这两个分支（即当前分支 <code>experiment</code>、变基操作的目标基底分支 <code>master</code>）的最近共同祖先 <code>C2</code>，然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件，然后将当前分支指向目标基底 <code>C3</code>, 最后以此将之前另存为临时文件的修改依序应用。（译注：写明了 commit id，以便理解，下同）</p>\n<p><img src=\"https://git-scm.com/book/en/v2/book/03-git-branching/images/basic-rebase-3.png\" alt=\"将 `C4` 中的修改变基到 `C3` 上\">Figure 3-29. 将 <code>C4</code> 中的修改变基到 <code>C3</code> 上</p>\n<p>现在回到 <code>master</code> 分支，进行一次快进合并。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git checkout master</div><div class=\"line\">$ git merge experiment</div></pre></td></tr></table></figure>\n<p><img src=\"https://git-scm.com/book/en/v2/book/03-git-branching/images/basic-rebase-4.png\" alt=\"master 分支的快进合并\">Figure 3-30. master 分支的快进合并</p>\n<p>此时，<code>C4&#39;</code> 指向的快照就和上面使用 <code>merge</code> 命令的例子中 <code>C5</code> 指向的快照一模一样了。 这两种整合方法的最终结果没有任何区别，但是变基使得提交历史更加整洁。 你在查看一个经过变基的分支的历史记录时会发现，尽管实际的开发工作是并行的，但它们看上去就像是先后串行的一样，提交历史是一条直线没有分叉。</p>\n<p>一般我们这样做的目的是为了确保在向远程分支推送时能保持提交历史的整洁——例如向某个别人维护的项目贡献代码时。 在这种情况下，你首先在自己的分支里进行开发，当开发完成时你需要先将你的代码变基到 <code>origin/master</code> 上，然后再向主项目提交修改。 这样的话，该项目的维护者就不再需要进行整合工作，只需要快进合并便可。</p>\n<p>请注意，无论是通过变基，还是通过三方合并，整合的最终结果所指向的快照始终是一样的，只不过提交历史不同罢了。 变基是将一系列提交按照原有次序依次应用到另一分支上，而合并是把最终结果合在一起。</p>\n<h3 id=\"更有趣的变基例子\"><a href=\"#更有趣的变基例子\" class=\"headerlink\" title=\"更有趣的变基例子\"></a><a href=\"https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA#更有趣的变基例子\">更有趣的变基例子</a></h3><p>在对两个分支进行变基时，所生成的“重演”并不一定要在目标分支上应用，你也可以指定另外的一个分支进行应用。 就像 <a href=\"https://git-scm.com/book/zh/v2/ch00/rbdiag_e\">Figure 3-31</a> 中的例子这样。 你创建了一个特性分支 <code>server</code>，为服务端添加了一些功能，提交了 <code>C3</code> 和 <code>C4</code>。 然后从 <code>C3</code> 上创建了特性分支 <code>client</code>，为客户端添加了一些功能，提交了 <code>C8</code> 和<code>C9</code>。 最后，你回到 <code>server</code> 分支，又提交了 <code>C10</code>。</p>\n<p><img src=\"https://git-scm.com/book/en/v2/book/03-git-branching/images/interesting-rebase-1.png\" alt=\"从一个特性分支里再分出一个特性分支的提交历史\">Figure 3-31. 从一个特性分支里再分出一个特性分支的提交历史</p>\n<p>假设你希望将 <code>client</code> 中的修改合并到主分支并发布，但暂时并不想合并 <code>server</code> 中的修改，因为它们还需要经过更全面的测试。 这时，你就可以使用 <code>git rebase</code> 命令的 <code>--onto</code> 选项，选中在 <code>client</code> 分支里但不在 <code>server</code> 分支里的修改（即 <code>C8</code> 和 <code>C9</code>），将它们在 <code>master</code> 分支上重演：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git rebase --onto master server client</div></pre></td></tr></table></figure>\n<p>以上命令的意思是：“取出 <code>client</code> 分支，找出处于 <code>client</code> 分支和 <code>server</code> 分支的共同祖先之后的修改，然后把它们在 <code>master</code> 分支上重演一遍”。 这理解起来有一点复杂，不过效果非常酷。</p>\n<p><img src=\"https://git-scm.com/book/en/v2/book/03-git-branching/images/interesting-rebase-2.png\" alt=\"截取特性分支上的另一个特性分支，然后变基到其他分支\">Figure 3-32. 截取特性分支上的另一个特性分支，然后变基到其他分支</p>\n<p>现在可以快进合并 <code>master</code> 分支了。（如图 <a href=\"https://git-scm.com/book/zh/v2/ch00/rbdiag_g\">Figure 3-33</a>）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git checkout master</div><div class=\"line\">$ git merge client</div></pre></td></tr></table></figure>\n<p><img src=\"https://git-scm.com/book/en/v2/book/03-git-branching/images/interesting-rebase-3.png\" alt=\"快进合并 master 分支，使之包含来自 client 分支的修改\">Figure 3-33. 快进合并 master 分支，使之包含来自 client 分支的修改</p>\n<p>接下来你决定将 <code>server</code> 分支中的修改也整合进来。 使用 <code>git rebase [basebranch] [topicbranch]</code> 命令可以直接将特性分支（即本例中的 <code>server</code>）变基到目标分支（即 <code>master</code>）上。这样做能省去你先切换到 <code>server</code> 分支，再对其执行变基命令的多个步骤。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git rebase master server</div></pre></td></tr></table></figure>\n<p>如图 <a href=\"https://git-scm.com/book/zh/v2/ch00/rbdiag_h\">Figure 3-34</a> 所示，<code>server</code> 中的代码被“续”到了 <code>master</code> 后面。</p>\n<p><img src=\"https://git-scm.com/book/en/v2/book/03-git-branching/images/interesting-rebase-4.png\" alt=\"将 server 中的修改变基到 master 上\">Figure 3-34. 将 server 中的修改变基到 master 上</p>\n<p>然后就可以快进合并主分支 master 了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git checkout master</div><div class=\"line\">$ git merge server</div></pre></td></tr></table></figure>\n<p>至此，<code>client</code> 和 <code>server</code> 分支中的修改都已经整合到主分支里去了，你可以删除这两个分支，最终提交历史会变成图 <a href=\"https://git-scm.com/book/zh/v2/ch00/rbdiag_i\">Figure 3-35</a> 中的样子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git branch -d client</div><div class=\"line\">$ git branch -d server</div></pre></td></tr></table></figure>\n<p><img src=\"https://git-scm.com/book/en/v2/book/03-git-branching/images/interesting-rebase-5.png\" alt=\"最终的提交历史\">Figure 3-35. 最终的提交历史</p>\n<h3 id=\"变基的风险\"><a href=\"#变基的风险\" class=\"headerlink\" title=\"变基的风险\"></a><a href=\"https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA#变基的风险\">变基的风险</a></h3><p>呃，奇妙的变基也并非完美无缺，要用它得遵守一条准则：</p>\n<p><strong>不要对在你的仓库外有副本的分支执行变基。</strong></p>\n<p>如果你遵循这条金科玉律，就不会出差错。 否则，人民群众会仇恨你，你的朋友和家人也会嘲笑你，唾弃你。</p>\n<p>变基操作的实质是丢弃一些现有的提交，然后相应地新建一些内容一样但实际上不同的提交。 如果你已经将提交推送至某个仓库，而其他人也已经从该仓库拉取提交并进行了后续工作，此时，如果你用 <code>git rebase</code> 命令重新整理了提交并再次推送，你的同伴因此将不得不再次将他们手头的工作与你的提交进行整合，如果接下来你还要拉取并整合他们修改过的提交，事情就会变得一团糟。</p>\n<p>让我们来看一个在公开的仓库上执行变基操作所带来的问题。 假设你从一个中央服务器克隆然后在它的基础上进行了一些开发。 你的提交历史如图所示：</p>\n<p><img src=\"https://git-scm.com/book/en/v2/book/03-git-branching/images/perils-of-rebasing-1.png\" alt=\"克隆一个仓库，然后在它的基础上进行了一些开发\">Figure 3-36. 克隆一个仓库，然后在它的基础上进行了一些开发</p>\n<p>然后，某人又向中央服务器提交了一些修改，其中还包括一次合并。 你抓取了这些在远程分支上的修改，并将其合并到你本地的开发分支，然后你的提交历史就会变成这样：</p>\n<p><img src=\"https://git-scm.com/book/en/v2/book/03-git-branching/images/perils-of-rebasing-2.png\" alt=\"抓取别人的提交，合并到自己的开发分支\">Figure 3-37. 抓取别人的提交，合并到自己的开发分支</p>\n<p>接下来，这个人又决定把合并操作回滚，改用变基；继而又用 <code>git push --force</code> 命令覆盖了服务器上的提交历史。 之后你从服务器抓取更新，会发现多出来一些新的提交。</p>\n<p><img src=\"https://git-scm.com/book/en/v2/book/03-git-branching/images/perils-of-rebasing-3.png\" alt=\"有人推送了经过变基的提交，并丢弃了你的本地开发所基于的一些提交\">Figure 3-38. 有人推送了经过变基的提交，并丢弃了你的本地开发所基于的一些提交</p>\n<p>结果就是你们两人的处境都十分尴尬。 如果你执行 <code>git pull</code> 命令，你将合并来自两条提交历史的内容，生成一个新的合并提交，最终仓库会如图所示：</p>\n<p><img src=\"https://git-scm.com/book/en/v2/book/03-git-branching/images/perils-of-rebasing-4.png\" alt=\"你将相同的内容又合并了一次，生成了一个新的提交\">Figure 3-39. 你将相同的内容又合并了一次，生成了一个新的提交</p>\n<p>此时如果你执行 <code>git log</code> 命令，你会发现有两个提交的作者、日期、日志居然是一样的，这会令人感到混乱。 此外，如果你将这一堆又推送到服务器上，你实际上是将那些已经被变基抛弃的提交又找了回来，这会令人感到更加混乱。 很明显对方并不想在提交历史中看到 <code>C4</code> 和 <code>C6</code>，因为之前就是他们把这两个提交通过变基丢弃的。</p>\n<h3 id=\"用变基解决变基\"><a href=\"#用变基解决变基\" class=\"headerlink\" title=\"用变基解决变基\"></a><a href=\"https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA#用变基解决变基\">用变基解决变基</a></h3><p>如果你 <strong>真的</strong> 遭遇了类似的处境，Git 还有一些高级魔法可以帮到你。 如果团队中的某人强制推送并覆盖了一些你所基于的提交，你需要做的就是检查你做了哪些修改，以及他们覆盖了哪些修改。</p>\n<p>实际上，Git 除了对整个提交计算 SHA-1 校验和以外，也对本次提交所引入的修改计算了校验和—— 即 “patch-id”。</p>\n<p>如果你拉取被覆盖过的更新并将你手头的工作基于此进行变基的话，一般情况下 Git 都能成功分辨出哪些是你的修改，并把它们应用到新分支上。</p>\n<p>举个例子，如果遇到前面提到的 <a href=\"https://git-scm.com/book/zh/v2/ch00/_pre_merge_rebase_work\">Figure 3-38</a> 那种情境，如果我们不是执行合并，而是执行 <code>git rebase teamone/master</code>, Git 将会：</p>\n<ul>\n<li>检查哪些提交是我们的分支上独有的（C2，C3，C4，C6，C7）</li>\n<li>检查其中哪些提交不是合并操作的结果（C2，C3，C4）</li>\n<li>检查哪些提交在对方覆盖更新时并没有被纳入目标分支（只有 C2 和 C3，因为 C4 其实就是 C4’）</li>\n<li>把查到的这些提交应用在 <code>teamone/master</code> 上面</li>\n</ul>\n<p>从而我们将得到与 <a href=\"https://git-scm.com/book/zh/v2/ch00/_merge_rebase_work\">Figure 3-39</a> 中不同的结果，如图 <a href=\"https://git-scm.com/book/zh/v2/ch00/_rebase_rebase_work\">Figure 3-40</a> 所示。</p>\n<p><img src=\"https://git-scm.com/book/en/v2/book/03-git-branching/images/perils-of-rebasing-5.png\" alt=\"在一个被变基然后强制推送的分支上再次执行变基\">Figure 3-40. 在一个被变基然后强制推送的分支上再次执行变基</p>\n<p>要想上述方案有效，还需要对方在变基时确保 C4’ 和 C4 是几乎一样的。 否则变基操作将无法识别，并新建另一个类似 C4 的补丁（而这个补丁很可能无法整洁的整合入历史，因为补丁中的修改已经存在于某个地方了）。</p>\n<p>在本例中另一种简单的方法是使用 <code>git pull --rebase</code> 命令而不是直接 <code>git pull</code>。 又或者你可以自己手动完成这个过程，先 <code>git fetch</code>，再 <code>git rebase teamone/master</code>。</p>\n<p>如果你习惯使用 <code>git pull</code> ，同时又希望默认使用选项 <code>--rebase</code>，你可以执行这条语句 <code>git config --global pull.rebase true</code> 来更改 <code>pull.rebase</code> 的默认配置。</p>\n<p>只要你把变基命令当作是在推送前清理提交使之整洁的工具，并且只在从未推送至共用仓库的提交上执行变基命令，你就不会有事。 假如你在那些已经被推送至共用仓库的提交上执行变基命令，并因此丢弃了一些别人的开发所基于的提交，那你就有大麻烦了，你的同事也会因此鄙视你。</p>\n<p>如果你或你的同事在某些情形下决意要这么做，请一定要通知每个人执行 <code>git pull --rebase</code> 命令，这样尽管不能避免伤痛，但能有所缓解。</p>\n<h3 id=\"变基-vs-合并\"><a href=\"#变基-vs-合并\" class=\"headerlink\" title=\"变基 vs. 合并\"></a><a href=\"https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA#变基-vs.-合并\">变基 vs. 合并</a></h3><p>至此，你已在实战中学习了变基和合并的用法，你一定会想问，到底哪种方式更好。 在回答这个问题之前，让我们退后一步，想讨论一下提交历史到底意味着什么。</p>\n<p>有一种观点认为，仓库的提交历史即是 <strong>记录实际发生过什么</strong>。 它是针对历史的文档，本身就有价值，不能乱改。 从这个角度看来，改变提交历史是一种亵渎，你使用<em>谎言</em>掩盖了实际发生过的事情。 如果由合并产生的提交历史是一团糟怎么办？ 既然事实就是如此，那么这些痕迹就应该被保留下来，让后人能够查阅。</p>\n<p>另一种观点则正好相反，他们认为提交历史是 <strong>项目过程中发生的故事</strong>。 没人会出版一本书的第一批草稿，软件维护手册也是需要反复修订才能方便使用。 持这一观点的人会使用 rebase 及 filter-branch 等工具来编写故事，怎么方便后来的读者就怎么写。</p>\n<p>现在，让我们回到之前的问题上来，到底合并还是变基好？希望你能明白，并没有一个简单的答案。 Git 是一个非常强大的工具，它允许你对提交历史做许多事情，但每个团队、每个项目对此的需求并不相同。 既然你已经分别学习了两者的用法，相信你能够根据实际情况作出明智的选择。</p>\n<p>总的原则是，只对尚未推送或分享给别人的本地修改执行变基操作清理历史，从不对已推送至别处的提交执行变基操作，这样，你才能享受到两种方式带来的便利。</p>"},{"title":"JSPatch – 动态更新iOS APP","id":"13","updated":"2016-06-28T05:11:21.000Z","date":"2016-06-12T04:11:58.000Z","_content":"\n\n\n只需在项目中引入极小的引擎，就可以使用JavaScript调用任何Objective-C的原生接口，获得脚本语言的能力：动态更新APP，替换项目原生代码修复bug。\n\n---\n\n# 用途\n\n是否有过这样的经历：新版本上线后发现有个严重的bug，可能会导致crash率激增，可能会使网络请求无法发出，这时能做的只是赶紧修复bug然后提交等待漫长的AppStore审核，再盼望用户快点升级，付出巨大的人力和时间成本，才能完成此次bug的修复。\n\n使用JSPatch可以解决这样的问题，只需在项目中引入JSPatch，就可以在发现bug时下发JS脚本补丁，替换原生方法，无需更新APP即时修复bug。\n\n# 例子\n\n上述代码中取数组元素处可能会超出数组范围导致crash。如果在项目里引用了JSPatch，就可以下发JS脚本修复这个bug：\n\n这样 JPTableViewController 里的 -tableView:didSelectRowAtIndexPath: 就替换成了这个JS脚本里的实现，在用户无感知的情况下修复了这个bug。\n\n更多的使用文档和demo请参考github项目主页。\n\n# 原理\n\nJSPatch用iOS内置的JavaScriptCore.framework作为JS引擎，但没有用它JSExport的特性进行JS-OC函数互调，而是通过Objective-C Runtime，从JS传递要调用的类名函数名到Objective-C，再使用NSInvocation动态调用对应的OC方法。详细的实现原理以及实现过程中遇到的各种坑和hack方法会另有文章介绍。\n\n# 方案对比\n\n目前已经有一些方案可以实现动态打补丁，例如WaxPatch，可以用Lua调用OC方法，相对于WaxPatch，JSPatch的优势是：\n\n1.JS语言\n\n1.JS语言\n\nJS比Lua在应用开发领域有更广泛的应用，目前前端开发和终端开发有融合的趋势，作为扩展的脚本语言，JS是不二之选。\n\n2.符合Apple规则\n\n2.符合Apple规则\n\nJSPatch更符合Apple的规则。iOS Developer Program License Agreement里3.3.2提到不可动态下发可执行代码，但通过苹果JavaScriptCore.framework或WebKit执行的代码除外，JS正是通过JavaScriptCore.framework执行的。\n\n3.小巧\n\n3.小巧\n\n使用系统内置的JavaScriptCore.framework，无需内嵌脚本引擎，体积小巧。\n\n4.支持block\n\n4.支持block\n\nwax在几年前就停止了开发和维护，不支持Objective-C里block跟Lua程序的互传，虽然一些第三方已经实现block，但使用时参数上也有比较多的限制。\n\n相对于WaxPatch，JSPatch劣势在于不支持iOS6，因为需要引入JavaScriptCore.framework。另外目前内存的使用上会高于wax，持续改进中。\n\n# 风险\n\nJSPatch让脚本语言获得调用所有原生OC方法的能力，不像web前端把能力局限在浏览器，使用上会有一些安全风险：\n\n1.若在网络传输过程中下发明文JS，可能会被中间人篡改JS脚本，执行任意方法，盗取APP里的相关信息。可以对传输过程进行加密，或用直接使用https解决。\n\n2.若下载完后的JS保存在本地没有加密，在未越狱的机器上用户也可以手动替换或篡改脚本。这点危害没有第一点大，因为操作者是手机拥有者，不存在APP内相关信息被盗用的风险。若要避免用户修改代码影响APP运行，可以选择简单的加密存储。\n\n其他用途\n\nJSPatch可以动态打补丁，自由修改APP里的代码，理论上还可以完全用JSPatch实现一个业务模块，甚至整个APP，跟wax一样，但不推荐这么做，因为：\n\n1. JSPatch和wax一样都是通过Objective-C Runtime的接口通过字符串反射找到对应的类和方法进行调用，这中间的字符串处理会损耗一定的性能，另外两种语言间的类型转换也有性能损耗，若用来做一个完整的业务模块，大量的频繁来回互调，可能有性能问题。\n2. 开发过程中需要用OC的思维写JS/Lua，丧失了脚本语言自己的特性。\n3. JSPatch和wax都没有IDE支持，开发效率低。\n\n若想动态为APP添加模块，目前React Native给出了很好的方案，解决了上述三个问题：\n\n1. JS/OC不会频繁通信，会在事件触发时批量传递，提高效率。（详见React Native通信机制详解）\n2. 开发过程无需考虑OC的感受，遵从React框架的思想进行纯JS开发就行，剩下的事情React Native帮你处理好了。\n3. React Native连IDE都准备好了。\n\n所以动态添加业务模块目前还是推荐尝试React Native，但React Native并不会提供原生OC接口的反射调用和方法替换，无法做到修改原生代码，JSPatch以小巧的引擎补足这个缺口，配合React Native用统一的JS语言让一个原生APP时刻处于可扩展可修改的状态。\n\n\n\n","source":"_posts/JSPatch-–-动态更新iOS-APP.md","raw":"---\ntitle: JSPatch – 动态更新iOS APP\ntags: iOS\npermalink: jspatch-dong-tai-geng-xin-ios-app\nid: 13\nupdated: '2016-06-28 13:11:21'\ndate: 2016-06-12 12:11:58\n---\n\n\n\n只需在项目中引入极小的引擎，就可以使用JavaScript调用任何Objective-C的原生接口，获得脚本语言的能力：动态更新APP，替换项目原生代码修复bug。\n\n---\n\n# 用途\n\n是否有过这样的经历：新版本上线后发现有个严重的bug，可能会导致crash率激增，可能会使网络请求无法发出，这时能做的只是赶紧修复bug然后提交等待漫长的AppStore审核，再盼望用户快点升级，付出巨大的人力和时间成本，才能完成此次bug的修复。\n\n使用JSPatch可以解决这样的问题，只需在项目中引入JSPatch，就可以在发现bug时下发JS脚本补丁，替换原生方法，无需更新APP即时修复bug。\n\n# 例子\n\n上述代码中取数组元素处可能会超出数组范围导致crash。如果在项目里引用了JSPatch，就可以下发JS脚本修复这个bug：\n\n这样 JPTableViewController 里的 -tableView:didSelectRowAtIndexPath: 就替换成了这个JS脚本里的实现，在用户无感知的情况下修复了这个bug。\n\n更多的使用文档和demo请参考github项目主页。\n\n# 原理\n\nJSPatch用iOS内置的JavaScriptCore.framework作为JS引擎，但没有用它JSExport的特性进行JS-OC函数互调，而是通过Objective-C Runtime，从JS传递要调用的类名函数名到Objective-C，再使用NSInvocation动态调用对应的OC方法。详细的实现原理以及实现过程中遇到的各种坑和hack方法会另有文章介绍。\n\n# 方案对比\n\n目前已经有一些方案可以实现动态打补丁，例如WaxPatch，可以用Lua调用OC方法，相对于WaxPatch，JSPatch的优势是：\n\n1.JS语言\n\n1.JS语言\n\nJS比Lua在应用开发领域有更广泛的应用，目前前端开发和终端开发有融合的趋势，作为扩展的脚本语言，JS是不二之选。\n\n2.符合Apple规则\n\n2.符合Apple规则\n\nJSPatch更符合Apple的规则。iOS Developer Program License Agreement里3.3.2提到不可动态下发可执行代码，但通过苹果JavaScriptCore.framework或WebKit执行的代码除外，JS正是通过JavaScriptCore.framework执行的。\n\n3.小巧\n\n3.小巧\n\n使用系统内置的JavaScriptCore.framework，无需内嵌脚本引擎，体积小巧。\n\n4.支持block\n\n4.支持block\n\nwax在几年前就停止了开发和维护，不支持Objective-C里block跟Lua程序的互传，虽然一些第三方已经实现block，但使用时参数上也有比较多的限制。\n\n相对于WaxPatch，JSPatch劣势在于不支持iOS6，因为需要引入JavaScriptCore.framework。另外目前内存的使用上会高于wax，持续改进中。\n\n# 风险\n\nJSPatch让脚本语言获得调用所有原生OC方法的能力，不像web前端把能力局限在浏览器，使用上会有一些安全风险：\n\n1.若在网络传输过程中下发明文JS，可能会被中间人篡改JS脚本，执行任意方法，盗取APP里的相关信息。可以对传输过程进行加密，或用直接使用https解决。\n\n2.若下载完后的JS保存在本地没有加密，在未越狱的机器上用户也可以手动替换或篡改脚本。这点危害没有第一点大，因为操作者是手机拥有者，不存在APP内相关信息被盗用的风险。若要避免用户修改代码影响APP运行，可以选择简单的加密存储。\n\n其他用途\n\nJSPatch可以动态打补丁，自由修改APP里的代码，理论上还可以完全用JSPatch实现一个业务模块，甚至整个APP，跟wax一样，但不推荐这么做，因为：\n\n1. JSPatch和wax一样都是通过Objective-C Runtime的接口通过字符串反射找到对应的类和方法进行调用，这中间的字符串处理会损耗一定的性能，另外两种语言间的类型转换也有性能损耗，若用来做一个完整的业务模块，大量的频繁来回互调，可能有性能问题。\n2. 开发过程中需要用OC的思维写JS/Lua，丧失了脚本语言自己的特性。\n3. JSPatch和wax都没有IDE支持，开发效率低。\n\n若想动态为APP添加模块，目前React Native给出了很好的方案，解决了上述三个问题：\n\n1. JS/OC不会频繁通信，会在事件触发时批量传递，提高效率。（详见React Native通信机制详解）\n2. 开发过程无需考虑OC的感受，遵从React框架的思想进行纯JS开发就行，剩下的事情React Native帮你处理好了。\n3. React Native连IDE都准备好了。\n\n所以动态添加业务模块目前还是推荐尝试React Native，但React Native并不会提供原生OC接口的反射调用和方法替换，无法做到修改原生代码，JSPatch以小巧的引擎补足这个缺口，配合React Native用统一的JS语言让一个原生APP时刻处于可扩展可修改的状态。\n\n\n\n","slug":"jspatch-dong-tai-geng-xin-ios-app","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cj04pzywk0005s04eb4z3vv29","content":"<p>只需在项目中引入极小的引擎，就可以使用JavaScript调用任何Objective-C的原生接口，获得脚本语言的能力：动态更新APP，替换项目原生代码修复bug。</p>\n<hr>\n<h1 id=\"用途\"><a href=\"#用途\" class=\"headerlink\" title=\"用途\"></a>用途</h1><p>是否有过这样的经历：新版本上线后发现有个严重的bug，可能会导致crash率激增，可能会使网络请求无法发出，这时能做的只是赶紧修复bug然后提交等待漫长的AppStore审核，再盼望用户快点升级，付出巨大的人力和时间成本，才能完成此次bug的修复。</p>\n<p>使用JSPatch可以解决这样的问题，只需在项目中引入JSPatch，就可以在发现bug时下发JS脚本补丁，替换原生方法，无需更新APP即时修复bug。</p>\n<h1 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h1><p>上述代码中取数组元素处可能会超出数组范围导致crash。如果在项目里引用了JSPatch，就可以下发JS脚本修复这个bug：</p>\n<p>这样 JPTableViewController 里的 -tableView:didSelectRowAtIndexPath: 就替换成了这个JS脚本里的实现，在用户无感知的情况下修复了这个bug。</p>\n<p>更多的使用文档和demo请参考github项目主页。</p>\n<h1 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h1><p>JSPatch用iOS内置的JavaScriptCore.framework作为JS引擎，但没有用它JSExport的特性进行JS-OC函数互调，而是通过Objective-C Runtime，从JS传递要调用的类名函数名到Objective-C，再使用NSInvocation动态调用对应的OC方法。详细的实现原理以及实现过程中遇到的各种坑和hack方法会另有文章介绍。</p>\n<h1 id=\"方案对比\"><a href=\"#方案对比\" class=\"headerlink\" title=\"方案对比\"></a>方案对比</h1><p>目前已经有一些方案可以实现动态打补丁，例如WaxPatch，可以用Lua调用OC方法，相对于WaxPatch，JSPatch的优势是：</p>\n<p>1.JS语言</p>\n<p>1.JS语言</p>\n<p>JS比Lua在应用开发领域有更广泛的应用，目前前端开发和终端开发有融合的趋势，作为扩展的脚本语言，JS是不二之选。</p>\n<p>2.符合Apple规则</p>\n<p>2.符合Apple规则</p>\n<p>JSPatch更符合Apple的规则。iOS Developer Program License Agreement里3.3.2提到不可动态下发可执行代码，但通过苹果JavaScriptCore.framework或WebKit执行的代码除外，JS正是通过JavaScriptCore.framework执行的。</p>\n<p>3.小巧</p>\n<p>3.小巧</p>\n<p>使用系统内置的JavaScriptCore.framework，无需内嵌脚本引擎，体积小巧。</p>\n<p>4.支持block</p>\n<p>4.支持block</p>\n<p>wax在几年前就停止了开发和维护，不支持Objective-C里block跟Lua程序的互传，虽然一些第三方已经实现block，但使用时参数上也有比较多的限制。</p>\n<p>相对于WaxPatch，JSPatch劣势在于不支持iOS6，因为需要引入JavaScriptCore.framework。另外目前内存的使用上会高于wax，持续改进中。</p>\n<h1 id=\"风险\"><a href=\"#风险\" class=\"headerlink\" title=\"风险\"></a>风险</h1><p>JSPatch让脚本语言获得调用所有原生OC方法的能力，不像web前端把能力局限在浏览器，使用上会有一些安全风险：</p>\n<p>1.若在网络传输过程中下发明文JS，可能会被中间人篡改JS脚本，执行任意方法，盗取APP里的相关信息。可以对传输过程进行加密，或用直接使用https解决。</p>\n<p>2.若下载完后的JS保存在本地没有加密，在未越狱的机器上用户也可以手动替换或篡改脚本。这点危害没有第一点大，因为操作者是手机拥有者，不存在APP内相关信息被盗用的风险。若要避免用户修改代码影响APP运行，可以选择简单的加密存储。</p>\n<p>其他用途</p>\n<p>JSPatch可以动态打补丁，自由修改APP里的代码，理论上还可以完全用JSPatch实现一个业务模块，甚至整个APP，跟wax一样，但不推荐这么做，因为：</p>\n<ol>\n<li>JSPatch和wax一样都是通过Objective-C Runtime的接口通过字符串反射找到对应的类和方法进行调用，这中间的字符串处理会损耗一定的性能，另外两种语言间的类型转换也有性能损耗，若用来做一个完整的业务模块，大量的频繁来回互调，可能有性能问题。</li>\n<li>开发过程中需要用OC的思维写JS/Lua，丧失了脚本语言自己的特性。</li>\n<li>JSPatch和wax都没有IDE支持，开发效率低。</li>\n</ol>\n<p>若想动态为APP添加模块，目前React Native给出了很好的方案，解决了上述三个问题：</p>\n<ol>\n<li>JS/OC不会频繁通信，会在事件触发时批量传递，提高效率。（详见React Native通信机制详解）</li>\n<li>开发过程无需考虑OC的感受，遵从React框架的思想进行纯JS开发就行，剩下的事情React Native帮你处理好了。</li>\n<li>React Native连IDE都准备好了。</li>\n</ol>\n<p>所以动态添加业务模块目前还是推荐尝试React Native，但React Native并不会提供原生OC接口的反射调用和方法替换，无法做到修改原生代码，JSPatch以小巧的引擎补足这个缺口，配合React Native用统一的JS语言让一个原生APP时刻处于可扩展可修改的状态。</p>\n","excerpt":"","more":"<p>只需在项目中引入极小的引擎，就可以使用JavaScript调用任何Objective-C的原生接口，获得脚本语言的能力：动态更新APP，替换项目原生代码修复bug。</p>\n<hr>\n<h1 id=\"用途\"><a href=\"#用途\" class=\"headerlink\" title=\"用途\"></a>用途</h1><p>是否有过这样的经历：新版本上线后发现有个严重的bug，可能会导致crash率激增，可能会使网络请求无法发出，这时能做的只是赶紧修复bug然后提交等待漫长的AppStore审核，再盼望用户快点升级，付出巨大的人力和时间成本，才能完成此次bug的修复。</p>\n<p>使用JSPatch可以解决这样的问题，只需在项目中引入JSPatch，就可以在发现bug时下发JS脚本补丁，替换原生方法，无需更新APP即时修复bug。</p>\n<h1 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h1><p>上述代码中取数组元素处可能会超出数组范围导致crash。如果在项目里引用了JSPatch，就可以下发JS脚本修复这个bug：</p>\n<p>这样 JPTableViewController 里的 -tableView:didSelectRowAtIndexPath: 就替换成了这个JS脚本里的实现，在用户无感知的情况下修复了这个bug。</p>\n<p>更多的使用文档和demo请参考github项目主页。</p>\n<h1 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h1><p>JSPatch用iOS内置的JavaScriptCore.framework作为JS引擎，但没有用它JSExport的特性进行JS-OC函数互调，而是通过Objective-C Runtime，从JS传递要调用的类名函数名到Objective-C，再使用NSInvocation动态调用对应的OC方法。详细的实现原理以及实现过程中遇到的各种坑和hack方法会另有文章介绍。</p>\n<h1 id=\"方案对比\"><a href=\"#方案对比\" class=\"headerlink\" title=\"方案对比\"></a>方案对比</h1><p>目前已经有一些方案可以实现动态打补丁，例如WaxPatch，可以用Lua调用OC方法，相对于WaxPatch，JSPatch的优势是：</p>\n<p>1.JS语言</p>\n<p>1.JS语言</p>\n<p>JS比Lua在应用开发领域有更广泛的应用，目前前端开发和终端开发有融合的趋势，作为扩展的脚本语言，JS是不二之选。</p>\n<p>2.符合Apple规则</p>\n<p>2.符合Apple规则</p>\n<p>JSPatch更符合Apple的规则。iOS Developer Program License Agreement里3.3.2提到不可动态下发可执行代码，但通过苹果JavaScriptCore.framework或WebKit执行的代码除外，JS正是通过JavaScriptCore.framework执行的。</p>\n<p>3.小巧</p>\n<p>3.小巧</p>\n<p>使用系统内置的JavaScriptCore.framework，无需内嵌脚本引擎，体积小巧。</p>\n<p>4.支持block</p>\n<p>4.支持block</p>\n<p>wax在几年前就停止了开发和维护，不支持Objective-C里block跟Lua程序的互传，虽然一些第三方已经实现block，但使用时参数上也有比较多的限制。</p>\n<p>相对于WaxPatch，JSPatch劣势在于不支持iOS6，因为需要引入JavaScriptCore.framework。另外目前内存的使用上会高于wax，持续改进中。</p>\n<h1 id=\"风险\"><a href=\"#风险\" class=\"headerlink\" title=\"风险\"></a>风险</h1><p>JSPatch让脚本语言获得调用所有原生OC方法的能力，不像web前端把能力局限在浏览器，使用上会有一些安全风险：</p>\n<p>1.若在网络传输过程中下发明文JS，可能会被中间人篡改JS脚本，执行任意方法，盗取APP里的相关信息。可以对传输过程进行加密，或用直接使用https解决。</p>\n<p>2.若下载完后的JS保存在本地没有加密，在未越狱的机器上用户也可以手动替换或篡改脚本。这点危害没有第一点大，因为操作者是手机拥有者，不存在APP内相关信息被盗用的风险。若要避免用户修改代码影响APP运行，可以选择简单的加密存储。</p>\n<p>其他用途</p>\n<p>JSPatch可以动态打补丁，自由修改APP里的代码，理论上还可以完全用JSPatch实现一个业务模块，甚至整个APP，跟wax一样，但不推荐这么做，因为：</p>\n<ol>\n<li>JSPatch和wax一样都是通过Objective-C Runtime的接口通过字符串反射找到对应的类和方法进行调用，这中间的字符串处理会损耗一定的性能，另外两种语言间的类型转换也有性能损耗，若用来做一个完整的业务模块，大量的频繁来回互调，可能有性能问题。</li>\n<li>开发过程中需要用OC的思维写JS/Lua，丧失了脚本语言自己的特性。</li>\n<li>JSPatch和wax都没有IDE支持，开发效率低。</li>\n</ol>\n<p>若想动态为APP添加模块，目前React Native给出了很好的方案，解决了上述三个问题：</p>\n<ol>\n<li>JS/OC不会频繁通信，会在事件触发时批量传递，提高效率。（详见React Native通信机制详解）</li>\n<li>开发过程无需考虑OC的感受，遵从React框架的思想进行纯JS开发就行，剩下的事情React Native帮你处理好了。</li>\n<li>React Native连IDE都准备好了。</li>\n</ol>\n<p>所以动态添加业务模块目前还是推荐尝试React Native，但React Native并不会提供原生OC接口的反射调用和方法替换，无法做到修改原生代码，JSPatch以小巧的引擎补足这个缺口，配合React Native用统一的JS语言让一个原生APP时刻处于可扩展可修改的状态。</p>\n"},{"title":"Mac OS X 进程UserEventAgent 占用CPU 100%的解决办法","id":"20","updated":"2016-06-26T14:54:49.000Z","date":"2016-06-26T14:53:59.000Z","_content":"\n\n\n前几天电脑无故发热特别厉害，达到了70+度，一查进程居然有一个UserEventAgent占了100%的CPU，虽未影响系统流畅度，还是受不了这么高的温度，我也不记得对系统和硬件做过什么大的改动，上网查了一下似乎和USB设备有关，后来一忙又把这事放了几天，今天干脆直接申请了Apple支持，电话连线近一小时仍无果（服务还是不错的），只能提供了一些后续的解决方案。 \n闲不住自己试了几遍，发现只有连接鼠标的时候才会有这个问题（不过这鼠标以前用着一切正常..），点开UserEventAgent进程发现打开的文件里很多在/system/Library/下，没看到和鼠标有关的，直接Finder定位到/System/Library/搜索mouse，出来两个目测和鼠标有关的文件： \nAppleHIDMouse.kext \nAppleHIDMouseAgent.plugin \n\n本想直接把这文件移动到其他路径，为求保险再搜了一下上面自己猜测的信息，在Apple的技术支持论坛找到一个和上述一样解决方法的帖子，原来只需要删除下面这一个文件即可： \n```/System/Library/UserEventPlugins/AppleHIDMouseAgent.plugin/Contents/MacOS/AppleH IDMouseAgent \n```\n\n删除之，重启，终于恢复正常。","source":"_posts/Mac-OS-X-进程UserEventAgent-占用CPU-100-的解决办法.md","raw":"---\ntitle: Mac OS X 进程UserEventAgent 占用CPU 100%的解决办法\npermalink: mac-os-x-jin-cheng-usereventagent-zhan-yong-cpu-100-de-jie-jue-ban-fa\nid: 20\nupdated: '2016-06-26 22:54:49'\ndate: 2016-06-26 22:53:59\ntags:\n---\n\n\n\n前几天电脑无故发热特别厉害，达到了70+度，一查进程居然有一个UserEventAgent占了100%的CPU，虽未影响系统流畅度，还是受不了这么高的温度，我也不记得对系统和硬件做过什么大的改动，上网查了一下似乎和USB设备有关，后来一忙又把这事放了几天，今天干脆直接申请了Apple支持，电话连线近一小时仍无果（服务还是不错的），只能提供了一些后续的解决方案。 \n闲不住自己试了几遍，发现只有连接鼠标的时候才会有这个问题（不过这鼠标以前用着一切正常..），点开UserEventAgent进程发现打开的文件里很多在/system/Library/下，没看到和鼠标有关的，直接Finder定位到/System/Library/搜索mouse，出来两个目测和鼠标有关的文件： \nAppleHIDMouse.kext \nAppleHIDMouseAgent.plugin \n\n本想直接把这文件移动到其他路径，为求保险再搜了一下上面自己猜测的信息，在Apple的技术支持论坛找到一个和上述一样解决方法的帖子，原来只需要删除下面这一个文件即可： \n```/System/Library/UserEventPlugins/AppleHIDMouseAgent.plugin/Contents/MacOS/AppleH IDMouseAgent \n```\n\n删除之，重启，终于恢复正常。","slug":"mac-os-x-jin-cheng-usereventagent-zhan-yong-cpu-100-de-jie-jue-ban-fa","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cj04pzywv0007s04een4lr1jh","content":"<p>前几天电脑无故发热特别厉害，达到了70+度，一查进程居然有一个UserEventAgent占了100%的CPU，虽未影响系统流畅度，还是受不了这么高的温度，我也不记得对系统和硬件做过什么大的改动，上网查了一下似乎和USB设备有关，后来一忙又把这事放了几天，今天干脆直接申请了Apple支持，电话连线近一小时仍无果（服务还是不错的），只能提供了一些后续的解决方案。<br>闲不住自己试了几遍，发现只有连接鼠标的时候才会有这个问题（不过这鼠标以前用着一切正常..），点开UserEventAgent进程发现打开的文件里很多在/system/Library/下，没看到和鼠标有关的，直接Finder定位到/System/Library/搜索mouse，出来两个目测和鼠标有关的文件：<br>AppleHIDMouse.kext<br>AppleHIDMouseAgent.plugin </p>\n<p>本想直接把这文件移动到其他路径，为求保险再搜了一下上面自己猜测的信息，在Apple的技术支持论坛找到一个和上述一样解决方法的帖子，原来只需要删除下面这一个文件即可：<br><code>/System/Library/UserEventPlugins/AppleHIDMouseAgent.plugin/Contents/MacOS/AppleH IDMouseAgent</code></p>\n<p>删除之，重启，终于恢复正常。</p>\n","excerpt":"","more":"<p>前几天电脑无故发热特别厉害，达到了70+度，一查进程居然有一个UserEventAgent占了100%的CPU，虽未影响系统流畅度，还是受不了这么高的温度，我也不记得对系统和硬件做过什么大的改动，上网查了一下似乎和USB设备有关，后来一忙又把这事放了几天，今天干脆直接申请了Apple支持，电话连线近一小时仍无果（服务还是不错的），只能提供了一些后续的解决方案。<br>闲不住自己试了几遍，发现只有连接鼠标的时候才会有这个问题（不过这鼠标以前用着一切正常..），点开UserEventAgent进程发现打开的文件里很多在/system/Library/下，没看到和鼠标有关的，直接Finder定位到/System/Library/搜索mouse，出来两个目测和鼠标有关的文件：<br>AppleHIDMouse.kext<br>AppleHIDMouseAgent.plugin </p>\n<p>本想直接把这文件移动到其他路径，为求保险再搜了一下上面自己猜测的信息，在Apple的技术支持论坛找到一个和上述一样解决方法的帖子，原来只需要删除下面这一个文件即可：<br><code>/System/Library/UserEventPlugins/AppleHIDMouseAgent.plugin/Contents/MacOS/AppleH IDMouseAgent</code></p>\n<p>删除之，重启，终于恢复正常。</p>\n"},{"title":"PC端获取IPA包的方法","id":"30","updated":"2016-08-07T04:30:15.000Z","date":"2016-08-07T04:29:16.000Z","_content":"\n\n\n# IPA包的下载流程\n\n1. 使用iTunes软件\n   \n2. 登入自己的苹果账号\n   \n3. 找到应用界面\n   \n4. 选中AppStore\n   \n5. 搜索要下载的应用\n   \n6. 已购买应用显示下载，未购买应用显示购买\n   \n7. 点击下载或购买后，会下载IPA包\n   \n8. 下载完成后，会看到已下载标志\n   \n9. 点击我的应用\n   \n10. 已经下载的应用都列出来了\n    \n11. 点中一个包，选择在Finder中显示\n    \n12. 所有已下载的ipa包，都在文件夹中\n    \n\n# 补充\n\n1. 在iTunes的设置中，也可以直接查看缓存文件夹位置\n   \n   \n   用命令行即可打开文件夹\n       open /Users/mac/Music/iTunes/iTunes\\ Media\n2. 应用的状态可能不止下载或购买，还可能有更新等，万变不离其宗，无论是什么状态，最终都可以下载IPA包\n   \n3. 缓存的包如果被删除，需要重新下载。如果IPA包有更新版本，也可以在我的应用界面直接更新\n   \n4. 如果想查看包内容，可以修改.ipa后缀名为.zip，然后解压即可\n\n\n","source":"_posts/PC端获取IPA包的方法.md","raw":"---\ntitle: PC端获取IPA包的方法\ntags: 'iOS'\npermalink: pcduan-huo-qu-ipabao-de-fang-fa\nid: 30\nupdated: '2016-08-07 12:30:15'\ndate: 2016-08-07 12:29:16\n---\n\n\n\n# IPA包的下载流程\n\n1. 使用iTunes软件\n   \n2. 登入自己的苹果账号\n   \n3. 找到应用界面\n   \n4. 选中AppStore\n   \n5. 搜索要下载的应用\n   \n6. 已购买应用显示下载，未购买应用显示购买\n   \n7. 点击下载或购买后，会下载IPA包\n   \n8. 下载完成后，会看到已下载标志\n   \n9. 点击我的应用\n   \n10. 已经下载的应用都列出来了\n    \n11. 点中一个包，选择在Finder中显示\n    \n12. 所有已下载的ipa包，都在文件夹中\n    \n\n# 补充\n\n1. 在iTunes的设置中，也可以直接查看缓存文件夹位置\n   \n   \n   用命令行即可打开文件夹\n       open /Users/mac/Music/iTunes/iTunes\\ Media\n2. 应用的状态可能不止下载或购买，还可能有更新等，万变不离其宗，无论是什么状态，最终都可以下载IPA包\n   \n3. 缓存的包如果被删除，需要重新下载。如果IPA包有更新版本，也可以在我的应用界面直接更新\n   \n4. 如果想查看包内容，可以修改.ipa后缀名为.zip，然后解压即可\n\n\n","slug":"pcduan-huo-qu-ipabao-de-fang-fa","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cj04pzyww0008s04el9yrqmlh","content":"<h1 id=\"IPA包的下载流程\"><a href=\"#IPA包的下载流程\" class=\"headerlink\" title=\"IPA包的下载流程\"></a>IPA包的下载流程</h1><ol>\n<li><p>使用iTunes软件</p>\n</li>\n<li><p>登入自己的苹果账号</p>\n</li>\n<li><p>找到应用界面</p>\n</li>\n<li><p>选中AppStore</p>\n</li>\n<li><p>搜索要下载的应用</p>\n</li>\n<li><p>已购买应用显示下载，未购买应用显示购买</p>\n</li>\n<li><p>点击下载或购买后，会下载IPA包</p>\n</li>\n<li><p>下载完成后，会看到已下载标志</p>\n</li>\n<li><p>点击我的应用</p>\n</li>\n<li><p>已经下载的应用都列出来了</p>\n</li>\n<li><p>点中一个包，选择在Finder中显示</p>\n</li>\n<li><p>所有已下载的ipa包，都在文件夹中</p>\n</li>\n</ol>\n<h1 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h1><ol>\n<li>在iTunes的设置中，也可以直接查看缓存文件夹位置</li>\n</ol>\n<p>   用命令行即可打开文件夹<br>       open /Users/mac/Music/iTunes/iTunes\\ Media</p>\n<ol>\n<li><p>应用的状态可能不止下载或购买，还可能有更新等，万变不离其宗，无论是什么状态，最终都可以下载IPA包</p>\n</li>\n<li><p>缓存的包如果被删除，需要重新下载。如果IPA包有更新版本，也可以在我的应用界面直接更新</p>\n</li>\n<li><p>如果想查看包内容，可以修改.ipa后缀名为.zip，然后解压即可</p>\n</li>\n</ol>\n","excerpt":"","more":"<h1 id=\"IPA包的下载流程\"><a href=\"#IPA包的下载流程\" class=\"headerlink\" title=\"IPA包的下载流程\"></a>IPA包的下载流程</h1><ol>\n<li><p>使用iTunes软件</p>\n</li>\n<li><p>登入自己的苹果账号</p>\n</li>\n<li><p>找到应用界面</p>\n</li>\n<li><p>选中AppStore</p>\n</li>\n<li><p>搜索要下载的应用</p>\n</li>\n<li><p>已购买应用显示下载，未购买应用显示购买</p>\n</li>\n<li><p>点击下载或购买后，会下载IPA包</p>\n</li>\n<li><p>下载完成后，会看到已下载标志</p>\n</li>\n<li><p>点击我的应用</p>\n</li>\n<li><p>已经下载的应用都列出来了</p>\n</li>\n<li><p>点中一个包，选择在Finder中显示</p>\n</li>\n<li><p>所有已下载的ipa包，都在文件夹中</p>\n</li>\n</ol>\n<h1 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h1><ol>\n<li>在iTunes的设置中，也可以直接查看缓存文件夹位置</li>\n</ol>\n<p>   用命令行即可打开文件夹<br>       open /Users/mac/Music/iTunes/iTunes\\ Media</p>\n<ol>\n<li><p>应用的状态可能不止下载或购买，还可能有更新等，万变不离其宗，无论是什么状态，最终都可以下载IPA包</p>\n</li>\n<li><p>缓存的包如果被删除，需要重新下载。如果IPA包有更新版本，也可以在我的应用界面直接更新</p>\n</li>\n<li><p>如果想查看包内容，可以修改.ipa后缀名为.zip，然后解压即可</p>\n</li>\n</ol>\n"},{"title":"React-Native学习笔记","id":"21","updated":"2016-07-13T07:01:00.000Z","date":"2016-06-27T16:47:14.000Z","_content":"\n\n\n自己在学习React-Native过程中整理的一份学习指南，包含 教程、开源app和资源网站等，还在不断更新中。欢迎pull requests！\n\nReact-Native学习指南\n\n本指南汇集React-Native各类学习资源，给大家提供便利。指南正在不断的更新，大家有好的资源欢迎Pull Requests！\n\n同时还有Awesome React-Native系列\n\nhttps://github.com/jondot/awesome-react-native\n\n# 教程\n\nreact-native 官方api文档 http://facebook.github.io/react-native/docs/getting-started.html\n\nreact-native 中文api文档 (翻译中) https://github.com/ecomfe/react-native-cn\n\nreact.js中文文档 http://reactjs.cn/\n\nreact.js入门教程(gitbook) http://hulufei.gitbooks.io/react-tutorial/content/introduction.html\n\nreact.js快速入门教程 - 阮一峰 http://www.ruanyifeng.com/blog/2015/03/react.html\n\nreact.js视频教程 http://react.nodejs-china.org/t/reactjszhong-wen-shi-pin-jiao-cheng-bai-du-wang-pan/584\n\nreact-native第一课 http://html-js.com/article/2783\n\n深入浅出 React Native：使用 JavaScript 构建原生应用 http://zhuanlan.zhihu.com/FrontendMagazine/19996445\n\nReact Native通信机制详解 http://blog.cnbang.net/tech/2698/\n\nReact Native布局篇 http://segmentfault.com/a/1190000002658374\n\nReact Native 基础练习指北（一） http://segmentfault.com/a/1190000002645929\n\nReact Native 基础练习指北（二） http://segmentfault.com/a/1190000002647733\n\n构建一个简单的列表页和2页导航 http://www.xn--cnq920ntha.cn/archives/235#6838470-tsina-1-17436-6a377b1a66595f9ede646cf5c012734c\n\nDiary of Building an iOS App with React Native http://herman.asia/building-a-flashcard-app-with-react-native\n\nUse React Native in Existing iOS App http://blog-en.leapoahead.com/post/use-react-native-in-existing-ios-app\n\ntcomb-form-native使用视频教程(需翻墙) http://react.rocks/example/tcomb-form-native\n\n# 开源APP\n\n研究源码也是一个很好的学习方式\n\n官方演示App https://github.com/facebook/react-native/tree/master/Examples\n\nReactNativeRubyChina https://github.com/henter/ReactNativeRubyChina\n\nHackerNews-React-Native https://github.com/iSimar/HackerNews-React-Native\n\nReact-Native新闻客户端 https://github.com/tabalt/ReactNativeNews\n\nnewswatch(新闻客户端) https://github.com/bradoyler/newswatch-react-native\n\nbuyscreen(购买页面) https://github.com/appintheair/react-native-buyscreen\n\nV2EX客户端 https://github.com/samuel1112/v2er\n\nreact-native-todo https://github.com/joemaddalone/react-native-todo\n\nreact-native-beer https://github.com/muratsu/react-native-beer\n\nreact-native-stars https://github.com/86/react-native-stars\n\n模仿天猫首页的app https://github.com/baofen14787/react-native-demo\n\nReactNativeChess https://github.com/csarsam/ReactNativeChess\n\nreact native 编写的音乐软件 https://github.com/Johnqing/miumiu\n\nreact-native-pokedex https://github.com/ababol/react-native-pokedex\n\nCNode-React-Native https://github.com/SFantasy/CNode-React-Native\n\n8tracks电台客户端 https://github.com/voronianski/EightTracksReactNative\n\nReact-Native实现的计算器 https://github.com/yoxisem544/Calculator-using-React-Native\n\n房产搜索app https://github.com/jawee/react-native-PropertyFinder\n\n知乎专栏app https://github.com/LeezQ/react-native-zhihu-app\n\nForeignExchangeApp https://github.com/peralmq/ForeignExchangeApp\n\n# 工具\n\nreact-native-snippets(代码提示) https://github.com/Shrugs/react-native-snippets\n\nreact-native-babel(使用ES6+) https://github.com/roman01la/react-native-babel\n\n资源网站\n\nReact-native官网 http://facebook.github.io/react-native/\n\nReact-China社区 http://react-china.org/\n\nReact-native组件库（比较全的组件库） http://react.parts/\n\nReact Native Modules http://reactnativemodules.com/\n\n11款React Native开源移动 UI 组件 http://www.oschina.net/news/61214/11-react-native-ui-components\n\n# 业界讨论\n\n谈谈 React Native - 唐巧 http://blog.devtang.com/blog/2015/02/01/talk-about-react-native/\n\n如何评价React-Native? http://www.zhihu.com/question/27852694/answer/43990708\n\nReact Native概述：背景、规划和风险 http://div.io/topic/938\n\n# 官方指南： https://github.com/ele828/react-native-guide\n\n","source":"_posts/React-Native学习笔记.md","raw":"---\ntitle: React-Native学习笔记\ntags: [前端, React-Native, 转载]\npermalink: react-nativexue-xi-bi-ji\nid: 21\nupdated: '2016-07-13 15:01:00'\ndate: 2016-06-28 00:47:14\n---\n\n\n\n自己在学习React-Native过程中整理的一份学习指南，包含 教程、开源app和资源网站等，还在不断更新中。欢迎pull requests！\n\nReact-Native学习指南\n\n本指南汇集React-Native各类学习资源，给大家提供便利。指南正在不断的更新，大家有好的资源欢迎Pull Requests！\n\n同时还有Awesome React-Native系列\n\nhttps://github.com/jondot/awesome-react-native\n\n# 教程\n\nreact-native 官方api文档 http://facebook.github.io/react-native/docs/getting-started.html\n\nreact-native 中文api文档 (翻译中) https://github.com/ecomfe/react-native-cn\n\nreact.js中文文档 http://reactjs.cn/\n\nreact.js入门教程(gitbook) http://hulufei.gitbooks.io/react-tutorial/content/introduction.html\n\nreact.js快速入门教程 - 阮一峰 http://www.ruanyifeng.com/blog/2015/03/react.html\n\nreact.js视频教程 http://react.nodejs-china.org/t/reactjszhong-wen-shi-pin-jiao-cheng-bai-du-wang-pan/584\n\nreact-native第一课 http://html-js.com/article/2783\n\n深入浅出 React Native：使用 JavaScript 构建原生应用 http://zhuanlan.zhihu.com/FrontendMagazine/19996445\n\nReact Native通信机制详解 http://blog.cnbang.net/tech/2698/\n\nReact Native布局篇 http://segmentfault.com/a/1190000002658374\n\nReact Native 基础练习指北（一） http://segmentfault.com/a/1190000002645929\n\nReact Native 基础练习指北（二） http://segmentfault.com/a/1190000002647733\n\n构建一个简单的列表页和2页导航 http://www.xn--cnq920ntha.cn/archives/235#6838470-tsina-1-17436-6a377b1a66595f9ede646cf5c012734c\n\nDiary of Building an iOS App with React Native http://herman.asia/building-a-flashcard-app-with-react-native\n\nUse React Native in Existing iOS App http://blog-en.leapoahead.com/post/use-react-native-in-existing-ios-app\n\ntcomb-form-native使用视频教程(需翻墙) http://react.rocks/example/tcomb-form-native\n\n# 开源APP\n\n研究源码也是一个很好的学习方式\n\n官方演示App https://github.com/facebook/react-native/tree/master/Examples\n\nReactNativeRubyChina https://github.com/henter/ReactNativeRubyChina\n\nHackerNews-React-Native https://github.com/iSimar/HackerNews-React-Native\n\nReact-Native新闻客户端 https://github.com/tabalt/ReactNativeNews\n\nnewswatch(新闻客户端) https://github.com/bradoyler/newswatch-react-native\n\nbuyscreen(购买页面) https://github.com/appintheair/react-native-buyscreen\n\nV2EX客户端 https://github.com/samuel1112/v2er\n\nreact-native-todo https://github.com/joemaddalone/react-native-todo\n\nreact-native-beer https://github.com/muratsu/react-native-beer\n\nreact-native-stars https://github.com/86/react-native-stars\n\n模仿天猫首页的app https://github.com/baofen14787/react-native-demo\n\nReactNativeChess https://github.com/csarsam/ReactNativeChess\n\nreact native 编写的音乐软件 https://github.com/Johnqing/miumiu\n\nreact-native-pokedex https://github.com/ababol/react-native-pokedex\n\nCNode-React-Native https://github.com/SFantasy/CNode-React-Native\n\n8tracks电台客户端 https://github.com/voronianski/EightTracksReactNative\n\nReact-Native实现的计算器 https://github.com/yoxisem544/Calculator-using-React-Native\n\n房产搜索app https://github.com/jawee/react-native-PropertyFinder\n\n知乎专栏app https://github.com/LeezQ/react-native-zhihu-app\n\nForeignExchangeApp https://github.com/peralmq/ForeignExchangeApp\n\n# 工具\n\nreact-native-snippets(代码提示) https://github.com/Shrugs/react-native-snippets\n\nreact-native-babel(使用ES6+) https://github.com/roman01la/react-native-babel\n\n资源网站\n\nReact-native官网 http://facebook.github.io/react-native/\n\nReact-China社区 http://react-china.org/\n\nReact-native组件库（比较全的组件库） http://react.parts/\n\nReact Native Modules http://reactnativemodules.com/\n\n11款React Native开源移动 UI 组件 http://www.oschina.net/news/61214/11-react-native-ui-components\n\n# 业界讨论\n\n谈谈 React Native - 唐巧 http://blog.devtang.com/blog/2015/02/01/talk-about-react-native/\n\n如何评价React-Native? http://www.zhihu.com/question/27852694/answer/43990708\n\nReact Native概述：背景、规划和风险 http://div.io/topic/938\n\n# 官方指南： https://github.com/ele828/react-native-guide\n\n","slug":"react-nativexue-xi-bi-ji","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cj04pzywx0009s04equ9rylrf","content":"<p>自己在学习React-Native过程中整理的一份学习指南，包含 教程、开源app和资源网站等，还在不断更新中。欢迎pull requests！</p>\n<p>React-Native学习指南</p>\n<p>本指南汇集React-Native各类学习资源，给大家提供便利。指南正在不断的更新，大家有好的资源欢迎Pull Requests！</p>\n<p>同时还有Awesome React-Native系列</p>\n<p><a href=\"https://github.com/jondot/awesome-react-native\" target=\"_blank\" rel=\"external\">https://github.com/jondot/awesome-react-native</a></p>\n<h1 id=\"教程\"><a href=\"#教程\" class=\"headerlink\" title=\"教程\"></a>教程</h1><p>react-native 官方api文档 <a href=\"http://facebook.github.io/react-native/docs/getting-started.html\" target=\"_blank\" rel=\"external\">http://facebook.github.io/react-native/docs/getting-started.html</a></p>\n<p>react-native 中文api文档 (翻译中) <a href=\"https://github.com/ecomfe/react-native-cn\" target=\"_blank\" rel=\"external\">https://github.com/ecomfe/react-native-cn</a></p>\n<p>react.js中文文档 <a href=\"http://reactjs.cn/\" target=\"_blank\" rel=\"external\">http://reactjs.cn/</a></p>\n<p>react.js入门教程(gitbook) <a href=\"http://hulufei.gitbooks.io/react-tutorial/content/introduction.html\" target=\"_blank\" rel=\"external\">http://hulufei.gitbooks.io/react-tutorial/content/introduction.html</a></p>\n<p>react.js快速入门教程 - 阮一峰 <a href=\"http://www.ruanyifeng.com/blog/2015/03/react.html\" target=\"_blank\" rel=\"external\">http://www.ruanyifeng.com/blog/2015/03/react.html</a></p>\n<p>react.js视频教程 <a href=\"http://react.nodejs-china.org/t/reactjszhong-wen-shi-pin-jiao-cheng-bai-du-wang-pan/584\" target=\"_blank\" rel=\"external\">http://react.nodejs-china.org/t/reactjszhong-wen-shi-pin-jiao-cheng-bai-du-wang-pan/584</a></p>\n<p>react-native第一课 <a href=\"http://html-js.com/article/2783\" target=\"_blank\" rel=\"external\">http://html-js.com/article/2783</a></p>\n<p>深入浅出 React Native：使用 JavaScript 构建原生应用 <a href=\"http://zhuanlan.zhihu.com/FrontendMagazine/19996445\" target=\"_blank\" rel=\"external\">http://zhuanlan.zhihu.com/FrontendMagazine/19996445</a></p>\n<p>React Native通信机制详解 <a href=\"http://blog.cnbang.net/tech/2698/\" target=\"_blank\" rel=\"external\">http://blog.cnbang.net/tech/2698/</a></p>\n<p>React Native布局篇 <a href=\"http://segmentfault.com/a/1190000002658374\" target=\"_blank\" rel=\"external\">http://segmentfault.com/a/1190000002658374</a></p>\n<p>React Native 基础练习指北（一） <a href=\"http://segmentfault.com/a/1190000002645929\" target=\"_blank\" rel=\"external\">http://segmentfault.com/a/1190000002645929</a></p>\n<p>React Native 基础练习指北（二） <a href=\"http://segmentfault.com/a/1190000002647733\" target=\"_blank\" rel=\"external\">http://segmentfault.com/a/1190000002647733</a></p>\n<p>构建一个简单的列表页和2页导航 <a href=\"http://www.xn--cnq920ntha.cn/archives/235#6838470-tsina-1-17436-6a377b1a66595f9ede646cf5c012734c\" target=\"_blank\" rel=\"external\">http://www.xn--cnq920ntha.cn/archives/235#6838470-tsina-1-17436-6a377b1a66595f9ede646cf5c012734c</a></p>\n<p>Diary of Building an iOS App with React Native <a href=\"http://herman.asia/building-a-flashcard-app-with-react-native\" target=\"_blank\" rel=\"external\">http://herman.asia/building-a-flashcard-app-with-react-native</a></p>\n<p>Use React Native in Existing iOS App <a href=\"http://blog-en.leapoahead.com/post/use-react-native-in-existing-ios-app\" target=\"_blank\" rel=\"external\">http://blog-en.leapoahead.com/post/use-react-native-in-existing-ios-app</a></p>\n<p>tcomb-form-native使用视频教程(需翻墙) <a href=\"http://react.rocks/example/tcomb-form-native\" target=\"_blank\" rel=\"external\">http://react.rocks/example/tcomb-form-native</a></p>\n<h1 id=\"开源APP\"><a href=\"#开源APP\" class=\"headerlink\" title=\"开源APP\"></a>开源APP</h1><p>研究源码也是一个很好的学习方式</p>\n<p>官方演示App <a href=\"https://github.com/facebook/react-native/tree/master/Examples\" target=\"_blank\" rel=\"external\">https://github.com/facebook/react-native/tree/master/Examples</a></p>\n<p>ReactNativeRubyChina <a href=\"https://github.com/henter/ReactNativeRubyChina\" target=\"_blank\" rel=\"external\">https://github.com/henter/ReactNativeRubyChina</a></p>\n<p>HackerNews-React-Native <a href=\"https://github.com/iSimar/HackerNews-React-Native\" target=\"_blank\" rel=\"external\">https://github.com/iSimar/HackerNews-React-Native</a></p>\n<p>React-Native新闻客户端 <a href=\"https://github.com/tabalt/ReactNativeNews\" target=\"_blank\" rel=\"external\">https://github.com/tabalt/ReactNativeNews</a></p>\n<p>newswatch(新闻客户端) <a href=\"https://github.com/bradoyler/newswatch-react-native\" target=\"_blank\" rel=\"external\">https://github.com/bradoyler/newswatch-react-native</a></p>\n<p>buyscreen(购买页面) <a href=\"https://github.com/appintheair/react-native-buyscreen\" target=\"_blank\" rel=\"external\">https://github.com/appintheair/react-native-buyscreen</a></p>\n<p>V2EX客户端 <a href=\"https://github.com/samuel1112/v2er\" target=\"_blank\" rel=\"external\">https://github.com/samuel1112/v2er</a></p>\n<p>react-native-todo <a href=\"https://github.com/joemaddalone/react-native-todo\" target=\"_blank\" rel=\"external\">https://github.com/joemaddalone/react-native-todo</a></p>\n<p>react-native-beer <a href=\"https://github.com/muratsu/react-native-beer\" target=\"_blank\" rel=\"external\">https://github.com/muratsu/react-native-beer</a></p>\n<p>react-native-stars <a href=\"https://github.com/86/react-native-stars\" target=\"_blank\" rel=\"external\">https://github.com/86/react-native-stars</a></p>\n<p>模仿天猫首页的app <a href=\"https://github.com/baofen14787/react-native-demo\" target=\"_blank\" rel=\"external\">https://github.com/baofen14787/react-native-demo</a></p>\n<p>ReactNativeChess <a href=\"https://github.com/csarsam/ReactNativeChess\" target=\"_blank\" rel=\"external\">https://github.com/csarsam/ReactNativeChess</a></p>\n<p>react native 编写的音乐软件 <a href=\"https://github.com/Johnqing/miumiu\" target=\"_blank\" rel=\"external\">https://github.com/Johnqing/miumiu</a></p>\n<p>react-native-pokedex <a href=\"https://github.com/ababol/react-native-pokedex\" target=\"_blank\" rel=\"external\">https://github.com/ababol/react-native-pokedex</a></p>\n<p>CNode-React-Native <a href=\"https://github.com/SFantasy/CNode-React-Native\" target=\"_blank\" rel=\"external\">https://github.com/SFantasy/CNode-React-Native</a></p>\n<p>8tracks电台客户端 <a href=\"https://github.com/voronianski/EightTracksReactNative\" target=\"_blank\" rel=\"external\">https://github.com/voronianski/EightTracksReactNative</a></p>\n<p>React-Native实现的计算器 <a href=\"https://github.com/yoxisem544/Calculator-using-React-Native\" target=\"_blank\" rel=\"external\">https://github.com/yoxisem544/Calculator-using-React-Native</a></p>\n<p>房产搜索app <a href=\"https://github.com/jawee/react-native-PropertyFinder\" target=\"_blank\" rel=\"external\">https://github.com/jawee/react-native-PropertyFinder</a></p>\n<p>知乎专栏app <a href=\"https://github.com/LeezQ/react-native-zhihu-app\" target=\"_blank\" rel=\"external\">https://github.com/LeezQ/react-native-zhihu-app</a></p>\n<p>ForeignExchangeApp <a href=\"https://github.com/peralmq/ForeignExchangeApp\" target=\"_blank\" rel=\"external\">https://github.com/peralmq/ForeignExchangeApp</a></p>\n<h1 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h1><p>react-native-snippets(代码提示) <a href=\"https://github.com/Shrugs/react-native-snippets\" target=\"_blank\" rel=\"external\">https://github.com/Shrugs/react-native-snippets</a></p>\n<p>react-native-babel(使用ES6+) <a href=\"https://github.com/roman01la/react-native-babel\" target=\"_blank\" rel=\"external\">https://github.com/roman01la/react-native-babel</a></p>\n<p>资源网站</p>\n<p>React-native官网 <a href=\"http://facebook.github.io/react-native/\" target=\"_blank\" rel=\"external\">http://facebook.github.io/react-native/</a></p>\n<p>React-China社区 <a href=\"http://react-china.org/\" target=\"_blank\" rel=\"external\">http://react-china.org/</a></p>\n<p>React-native组件库（比较全的组件库） <a href=\"http://react.parts/\" target=\"_blank\" rel=\"external\">http://react.parts/</a></p>\n<p>React Native Modules <a href=\"http://reactnativemodules.com/\" target=\"_blank\" rel=\"external\">http://reactnativemodules.com/</a></p>\n<p>11款React Native开源移动 UI 组件 <a href=\"http://www.oschina.net/news/61214/11-react-native-ui-components\" target=\"_blank\" rel=\"external\">http://www.oschina.net/news/61214/11-react-native-ui-components</a></p>\n<h1 id=\"业界讨论\"><a href=\"#业界讨论\" class=\"headerlink\" title=\"业界讨论\"></a>业界讨论</h1><p>谈谈 React Native - 唐巧 <a href=\"http://blog.devtang.com/blog/2015/02/01/talk-about-react-native/\" target=\"_blank\" rel=\"external\">http://blog.devtang.com/blog/2015/02/01/talk-about-react-native/</a></p>\n<p>如何评价React-Native? <a href=\"http://www.zhihu.com/question/27852694/answer/43990708\" target=\"_blank\" rel=\"external\">http://www.zhihu.com/question/27852694/answer/43990708</a></p>\n<p>React Native概述：背景、规划和风险 <a href=\"http://div.io/topic/938\" target=\"_blank\" rel=\"external\">http://div.io/topic/938</a></p>\n<h1 id=\"官方指南：-https-github-com-ele828-react-native-guide\"><a href=\"#官方指南：-https-github-com-ele828-react-native-guide\" class=\"headerlink\" title=\"官方指南： https://github.com/ele828/react-native-guide\"></a>官方指南： <a href=\"https://github.com/ele828/react-native-guide\" target=\"_blank\" rel=\"external\">https://github.com/ele828/react-native-guide</a></h1>","excerpt":"","more":"<p>自己在学习React-Native过程中整理的一份学习指南，包含 教程、开源app和资源网站等，还在不断更新中。欢迎pull requests！</p>\n<p>React-Native学习指南</p>\n<p>本指南汇集React-Native各类学习资源，给大家提供便利。指南正在不断的更新，大家有好的资源欢迎Pull Requests！</p>\n<p>同时还有Awesome React-Native系列</p>\n<p><a href=\"https://github.com/jondot/awesome-react-native\">https://github.com/jondot/awesome-react-native</a></p>\n<h1 id=\"教程\"><a href=\"#教程\" class=\"headerlink\" title=\"教程\"></a>教程</h1><p>react-native 官方api文档 <a href=\"http://facebook.github.io/react-native/docs/getting-started.html\">http://facebook.github.io/react-native/docs/getting-started.html</a></p>\n<p>react-native 中文api文档 (翻译中) <a href=\"https://github.com/ecomfe/react-native-cn\">https://github.com/ecomfe/react-native-cn</a></p>\n<p>react.js中文文档 <a href=\"http://reactjs.cn/\">http://reactjs.cn/</a></p>\n<p>react.js入门教程(gitbook) <a href=\"http://hulufei.gitbooks.io/react-tutorial/content/introduction.html\">http://hulufei.gitbooks.io/react-tutorial/content/introduction.html</a></p>\n<p>react.js快速入门教程 - 阮一峰 <a href=\"http://www.ruanyifeng.com/blog/2015/03/react.html\">http://www.ruanyifeng.com/blog/2015/03/react.html</a></p>\n<p>react.js视频教程 <a href=\"http://react.nodejs-china.org/t/reactjszhong-wen-shi-pin-jiao-cheng-bai-du-wang-pan/584\">http://react.nodejs-china.org/t/reactjszhong-wen-shi-pin-jiao-cheng-bai-du-wang-pan/584</a></p>\n<p>react-native第一课 <a href=\"http://html-js.com/article/2783\">http://html-js.com/article/2783</a></p>\n<p>深入浅出 React Native：使用 JavaScript 构建原生应用 <a href=\"http://zhuanlan.zhihu.com/FrontendMagazine/19996445\">http://zhuanlan.zhihu.com/FrontendMagazine/19996445</a></p>\n<p>React Native通信机制详解 <a href=\"http://blog.cnbang.net/tech/2698/\">http://blog.cnbang.net/tech/2698/</a></p>\n<p>React Native布局篇 <a href=\"http://segmentfault.com/a/1190000002658374\">http://segmentfault.com/a/1190000002658374</a></p>\n<p>React Native 基础练习指北（一） <a href=\"http://segmentfault.com/a/1190000002645929\">http://segmentfault.com/a/1190000002645929</a></p>\n<p>React Native 基础练习指北（二） <a href=\"http://segmentfault.com/a/1190000002647733\">http://segmentfault.com/a/1190000002647733</a></p>\n<p>构建一个简单的列表页和2页导航 <a href=\"http://www.xn--cnq920ntha.cn/archives/235#6838470-tsina-1-17436-6a377b1a66595f9ede646cf5c012734c\">http://www.xn--cnq920ntha.cn/archives/235#6838470-tsina-1-17436-6a377b1a66595f9ede646cf5c012734c</a></p>\n<p>Diary of Building an iOS App with React Native <a href=\"http://herman.asia/building-a-flashcard-app-with-react-native\">http://herman.asia/building-a-flashcard-app-with-react-native</a></p>\n<p>Use React Native in Existing iOS App <a href=\"http://blog-en.leapoahead.com/post/use-react-native-in-existing-ios-app\">http://blog-en.leapoahead.com/post/use-react-native-in-existing-ios-app</a></p>\n<p>tcomb-form-native使用视频教程(需翻墙) <a href=\"http://react.rocks/example/tcomb-form-native\">http://react.rocks/example/tcomb-form-native</a></p>\n<h1 id=\"开源APP\"><a href=\"#开源APP\" class=\"headerlink\" title=\"开源APP\"></a>开源APP</h1><p>研究源码也是一个很好的学习方式</p>\n<p>官方演示App <a href=\"https://github.com/facebook/react-native/tree/master/Examples\">https://github.com/facebook/react-native/tree/master/Examples</a></p>\n<p>ReactNativeRubyChina <a href=\"https://github.com/henter/ReactNativeRubyChina\">https://github.com/henter/ReactNativeRubyChina</a></p>\n<p>HackerNews-React-Native <a href=\"https://github.com/iSimar/HackerNews-React-Native\">https://github.com/iSimar/HackerNews-React-Native</a></p>\n<p>React-Native新闻客户端 <a href=\"https://github.com/tabalt/ReactNativeNews\">https://github.com/tabalt/ReactNativeNews</a></p>\n<p>newswatch(新闻客户端) <a href=\"https://github.com/bradoyler/newswatch-react-native\">https://github.com/bradoyler/newswatch-react-native</a></p>\n<p>buyscreen(购买页面) <a href=\"https://github.com/appintheair/react-native-buyscreen\">https://github.com/appintheair/react-native-buyscreen</a></p>\n<p>V2EX客户端 <a href=\"https://github.com/samuel1112/v2er\">https://github.com/samuel1112/v2er</a></p>\n<p>react-native-todo <a href=\"https://github.com/joemaddalone/react-native-todo\">https://github.com/joemaddalone/react-native-todo</a></p>\n<p>react-native-beer <a href=\"https://github.com/muratsu/react-native-beer\">https://github.com/muratsu/react-native-beer</a></p>\n<p>react-native-stars <a href=\"https://github.com/86/react-native-stars\">https://github.com/86/react-native-stars</a></p>\n<p>模仿天猫首页的app <a href=\"https://github.com/baofen14787/react-native-demo\">https://github.com/baofen14787/react-native-demo</a></p>\n<p>ReactNativeChess <a href=\"https://github.com/csarsam/ReactNativeChess\">https://github.com/csarsam/ReactNativeChess</a></p>\n<p>react native 编写的音乐软件 <a href=\"https://github.com/Johnqing/miumiu\">https://github.com/Johnqing/miumiu</a></p>\n<p>react-native-pokedex <a href=\"https://github.com/ababol/react-native-pokedex\">https://github.com/ababol/react-native-pokedex</a></p>\n<p>CNode-React-Native <a href=\"https://github.com/SFantasy/CNode-React-Native\">https://github.com/SFantasy/CNode-React-Native</a></p>\n<p>8tracks电台客户端 <a href=\"https://github.com/voronianski/EightTracksReactNative\">https://github.com/voronianski/EightTracksReactNative</a></p>\n<p>React-Native实现的计算器 <a href=\"https://github.com/yoxisem544/Calculator-using-React-Native\">https://github.com/yoxisem544/Calculator-using-React-Native</a></p>\n<p>房产搜索app <a href=\"https://github.com/jawee/react-native-PropertyFinder\">https://github.com/jawee/react-native-PropertyFinder</a></p>\n<p>知乎专栏app <a href=\"https://github.com/LeezQ/react-native-zhihu-app\">https://github.com/LeezQ/react-native-zhihu-app</a></p>\n<p>ForeignExchangeApp <a href=\"https://github.com/peralmq/ForeignExchangeApp\">https://github.com/peralmq/ForeignExchangeApp</a></p>\n<h1 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h1><p>react-native-snippets(代码提示) <a href=\"https://github.com/Shrugs/react-native-snippets\">https://github.com/Shrugs/react-native-snippets</a></p>\n<p>react-native-babel(使用ES6+) <a href=\"https://github.com/roman01la/react-native-babel\">https://github.com/roman01la/react-native-babel</a></p>\n<p>资源网站</p>\n<p>React-native官网 <a href=\"http://facebook.github.io/react-native/\">http://facebook.github.io/react-native/</a></p>\n<p>React-China社区 <a href=\"http://react-china.org/\">http://react-china.org/</a></p>\n<p>React-native组件库（比较全的组件库） <a href=\"http://react.parts/\">http://react.parts/</a></p>\n<p>React Native Modules <a href=\"http://reactnativemodules.com/\">http://reactnativemodules.com/</a></p>\n<p>11款React Native开源移动 UI 组件 <a href=\"http://www.oschina.net/news/61214/11-react-native-ui-components\">http://www.oschina.net/news/61214/11-react-native-ui-components</a></p>\n<h1 id=\"业界讨论\"><a href=\"#业界讨论\" class=\"headerlink\" title=\"业界讨论\"></a>业界讨论</h1><p>谈谈 React Native - 唐巧 <a href=\"http://blog.devtang.com/blog/2015/02/01/talk-about-react-native/\">http://blog.devtang.com/blog/2015/02/01/talk-about-react-native/</a></p>\n<p>如何评价React-Native? <a href=\"http://www.zhihu.com/question/27852694/answer/43990708\">http://www.zhihu.com/question/27852694/answer/43990708</a></p>\n<p>React Native概述：背景、规划和风险 <a href=\"http://div.io/topic/938\">http://div.io/topic/938</a></p>\n<h1 id=\"官方指南：-https-github-com-ele828-react-native-guide\"><a href=\"#官方指南：-https-github-com-ele828-react-native-guide\" class=\"headerlink\" title=\"官方指南： https://github.com/ele828/react-native-guide\"></a>官方指南： <a href=\"https://github.com/ele828/react-native-guide\">https://github.com/ele828/react-native-guide</a></h1>"},{"title":"Swift (?)可选类型和 (!)强制解包","id":"29","updated":"2016-07-20T19:05:09.000Z","date":"2016-07-13T07:00:33.000Z","_content":"\n\n\n很多Swift初学者在学习过程中对问号和感叹号比较迷惑，\nSwift中**问号**表示这是一个可选类型。\n翻译：某个常量或者变量可能是一个类型，也可能什么都没有，**我不确定它是否真的会有值，也许会是nil**。\n\n比如：\n\n> let number1 = “123”\n>\n> let number2 = number1.toInt()\n>\n> //number2是Int?类型 或者叫optional Int\n\nnumber2，可能包含Int值，也可能什么都没有（那就是nil）\n\n当我们通过if语句判断，number2确实有值时，可以使用**感叹号**来表示。\n\n翻译：**我确定这个可选类型的值内有正确的内容，请使用它**。\n\n> if number2 != nil {\n>\n>     println(number2!)\n\n感叹号，被称为可选值的强制解析（无论如何请一定要使用这个值，我保证这里面肯定有东西）\n\n然而在使用强制解析的时候，一定要确保包中的内容确实不会为 nil，**否则会报错**。\n\n","source":"_posts/Swift-可选类型和-强制解包.md","raw":"---\ntitle: Swift (?)可选类型和 (!)强制解包\npermalink: swiftzhong-de-ke-xuan-lei-xing-he-qiang-zhi-jie-xi\nid: 29\nupdated: '2016-07-21 03:05:09'\ndate: 2016-07-13 15:00:33\ntags: swift\n---\n\n\n\n很多Swift初学者在学习过程中对问号和感叹号比较迷惑，\nSwift中**问号**表示这是一个可选类型。\n翻译：某个常量或者变量可能是一个类型，也可能什么都没有，**我不确定它是否真的会有值，也许会是nil**。\n\n比如：\n\n> let number1 = “123”\n>\n> let number2 = number1.toInt()\n>\n> //number2是Int?类型 或者叫optional Int\n\nnumber2，可能包含Int值，也可能什么都没有（那就是nil）\n\n当我们通过if语句判断，number2确实有值时，可以使用**感叹号**来表示。\n\n翻译：**我确定这个可选类型的值内有正确的内容，请使用它**。\n\n> if number2 != nil {\n>\n>     println(number2!)\n\n感叹号，被称为可选值的强制解析（无论如何请一定要使用这个值，我保证这里面肯定有东西）\n\n然而在使用强制解析的时候，一定要确保包中的内容确实不会为 nil，**否则会报错**。\n\n","slug":"swiftzhong-de-ke-xuan-lei-xing-he-qiang-zhi-jie-xi","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cj04pzyx2000cs04e7tbltrsi","content":"<p>很多Swift初学者在学习过程中对问号和感叹号比较迷惑，<br>Swift中<strong>问号</strong>表示这是一个可选类型。<br>翻译：某个常量或者变量可能是一个类型，也可能什么都没有，<strong>我不确定它是否真的会有值，也许会是nil</strong>。</p>\n<p>比如：</p>\n<blockquote>\n<p>let number1 = “123”</p>\n<p>let number2 = number1.toInt()</p>\n<p>//number2是Int?类型 或者叫optional Int</p>\n</blockquote>\n<p>number2，可能包含Int值，也可能什么都没有（那就是nil）</p>\n<p>当我们通过if语句判断，number2确实有值时，可以使用<strong>感叹号</strong>来表示。</p>\n<p>翻译：<strong>我确定这个可选类型的值内有正确的内容，请使用它</strong>。</p>\n<blockquote>\n<p>if number2 != nil {</p>\n<pre><code>println(number2!)\n</code></pre></blockquote>\n<p>感叹号，被称为可选值的强制解析（无论如何请一定要使用这个值，我保证这里面肯定有东西）</p>\n<p>然而在使用强制解析的时候，一定要确保包中的内容确实不会为 nil，<strong>否则会报错</strong>。</p>\n","excerpt":"","more":"<p>很多Swift初学者在学习过程中对问号和感叹号比较迷惑，<br>Swift中<strong>问号</strong>表示这是一个可选类型。<br>翻译：某个常量或者变量可能是一个类型，也可能什么都没有，<strong>我不确定它是否真的会有值，也许会是nil</strong>。</p>\n<p>比如：</p>\n<blockquote>\n<p>let number1 = “123”</p>\n<p>let number2 = number1.toInt()</p>\n<p>//number2是Int?类型 或者叫optional Int</p>\n</blockquote>\n<p>number2，可能包含Int值，也可能什么都没有（那就是nil）</p>\n<p>当我们通过if语句判断，number2确实有值时，可以使用<strong>感叹号</strong>来表示。</p>\n<p>翻译：<strong>我确定这个可选类型的值内有正确的内容，请使用它</strong>。</p>\n<blockquote>\n<p>if number2 != nil {</p>\n<pre><code>println(number2!)\n</code></pre></blockquote>\n<p>感叹号，被称为可选值的强制解析（无论如何请一定要使用这个值，我保证这里面肯定有东西）</p>\n<p>然而在使用强制解析的时候，一定要确保包中的内容确实不会为 nil，<strong>否则会报错</strong>。</p>\n"},{"title":"Swift 中的异常抛出和错误处理","id":"23","updated":"2016-06-28T04:20:14.000Z","date":"2016-06-28T04:19:24.000Z","_content":"\n\n# 前言\nSwift语言对其错误处理进行了新的设计，当然了，重新设计后的结果使得该错误处理系统用起来更爽。今天的主题就是系统的搞一下Swift中的错误处理，以及看一下Swift中是如何抛出异常的。在编译型语言中，错误一般分为编译错误和运行时错误。我们平时在代码中处理的错误为运行时错误，我们对异常进行处理的操作的目的是为了防止程序出现错误而导致其他的副作用，比如用户数据未保存等等。\n\n在今天的文章中，先给出主动产生异常的几种情况，然后再给出如何处理被动异常。\n\n# 问题总结\n\n**一、主动退出程序的几种情况**\n\n在Objective-C中，在单元测试时我们会使用断言，断言中条件满足时会产生异常，并打印出相应的断言错误，在Swift中也有几种产生异常的语法。在本篇博客的第一部分就给出这几种方法。\n\n**1.Fatal Errors（致命的错误）**\n\n使用fatalError()函数可以立即终止你的应用程序，在fatalError()中可以给出终止信息。使用fatalError()函数，会毫无条件的终止你的应用程序，用起来也是比较简单的，就是一个函数的调用。下方这个Demo一目了然呢，在此就不做过多赘述了。\n\n![img](http://files.jb51.net/file_images/article/201602/201602261147512.png)\n\n**2. Assertions（断言）**\n\n在单元测试中是少不了断言的，Swift中的断言和Objective-C的区别不是太大，使用方法也是大同小异。下方就是断言的两种方法，由代码提示可知，在断言中的提示条件是可选的。断言会在Debug模式下起作用，但是在Release版本中就会被忽略。\n\n![img](http://files.jb51.net/file_images/article/201602/201602261147513.png)\n\n在assert()函数中, 第一个参数是Bool类型，第二个参数是输出的信息。当条件为true时，断言不执行，相应的断言信息不打印。当条件为false时，断言执行，并且打印相应的断言信息。\n\n![img](http://files.jb51.net/file_images/article/201602/201602261147514.png)\n\nassertionFailure()函数只有一个Message参数，并且该参数也是可以省略的，assertionFailure()没有条件。如下所示：\n\n![img](http://files.jb51.net/file_images/article/201602/201602261147515.png)\n\n**3. 先决条件（Preconditions）**\n\nPreconditions的用法和断言一样，不过有一点需要主要，Preconditions在debug和release模式下都会被执行，除非使用–Ounchecked进行编译。下方截图是代码提示给出的Preconditions函数的提示，如下所示：\n\n![img](http://files.jb51.net/file_images/article/201602/201602261147516.png)\n\n关于Preconditions的具体用法请参照断言，和断言用法一样，在此就不做过多的赘述了。\n\n**二.Swift中的错误处理**\n\n在Objective-C中，如果你处理过错误的话，那么你将会对NSError很熟悉。在Swift中，如果你要定义你自己的错误类型，你只需要实现ErrorType协议即可。声明完错误类型后，就可以在处理错误抛出异常时使用自定义的错误类型了。下方将会一步步带你走完Swift中的错误处理的路程。\n\n**1.使用枚举创建错误类型**\n\n（1）.遵循ErrorType协议，自定义错误类型。下方定义了一个错误类型枚举，该枚举遵循了ErrorType协议，在接下来的代码中我们将会使用这个MyCustomErrorType枚举，错误枚举的实现如下所示：\n\n```\n //定义错误类型\n enum MyCustomErrorType: ErrorType {\n case ErrorReason\n case ErrorReason\n case ErrorReason\n } \n```\n\n（2）.在我们的函数定义时可以使用throws关键字，以及在函数中使用throw关键字对错误进行抛出，抛出的错误类型就可以使用上面我们自己定义的错误类型。下方函数就是一个可以抛出错误的函数，抛出的错误就是我们在上面枚举中所定义的类型。具体代码如下所示：\n\n```\n func myThrowFunc() throws {\n let test:Int? = nil\n guard test != nil else {\n throw MyCustomErrorType.ErrorReason\n }\n }\n```\n\n（3）.上面函数的功能是对错误进行抛出，接下来就该使用do-catch来处理抛出的错误。使用try对错误进行捕捉，使用do-catch对错误进行处理。具体处理方式如下所示。在下方错误处理中类似于switch-case语句，catch后边可以枚举匹配错误类型，具体如下所示：　　　　\n\n![img](http://files.jb51.net/file_images/article/201602/201602261147517.png)\n\n（4）在枚举实现错误类型中我们可以通过值绑定的形式为错误添加错误代码和错误原因。在声明枚举时，我们使用了枚举元素值绑定的特性（关于枚举使用的更多细节请参考之前的博客《窥探Swift之别样的枚举类型》）。在声明枚举成员ErrorState时，我们为其绑定了两个变量，一个是错误代码errorCode, 另一个是错误原因errorReason。这两者可以在抛出错误时为其传入相应的值，如下方代码片段中的throwError函数所示，在抛出错误是为errorCode指定的错误代码为404，为errorReason指定的错误原因是“not found”。\n\n　　最后就是使用do-catch处理异常了，在catch中对绑定的错误代码和错误原因进行了获取，并且通过where子句进行了错误代码的筛选。此处catch的用法与switch-case中获取枚举绑定值的用法是一样的，所以在此就不做过多的赘述。具体实现方式如下代码所示：\n\n![img](http://files.jb51.net/file_images/article/201602/201602261147518.png)\n\n**2.使用结构体为错误处理添加Reason**\n\n在上面的内容中，使用枚举遵循ErrorType协议的方式定义了特定的错误类型。接下来我们将使用结构体来遵循ErrorType协议，为错误类型添加错误原因。也就是说，我们可以在抛出错误时，给自定义错误类型提供错误原因。该功能在开发中是非常常用的，而且用起来也是非常爽的。接下来就看一下如何为我们的错误类型添加错误原因。\n\n（1）使用结构体创建错误类型，下方名为MyErrorType的结构体遵循了ErrorType协议，并且在MyErrorType结构体中，声明了一个reason常量，该reason常量中存储的就是错误原因，具体实现方式如下：\n\n```\n struct MyErrorType: ErrorType {\n let reason : String\n }\n```\n\n（2）上面定义完错误类型结构体后，在错误抛出中就可以使用了。在错误抛出时，可以传入一个错误原因，具体代码如下所示：\n\n```\n func myThrowFunc() throws {\n let test:Int? = nil\n guard test != nil else {\n throw MyErrorType(reason: \"我是详细的错误原因，存储在error中\")\n }\n } \n```\n\n（3）最后要对抛出的错误进行do-catch处理，在处理时，可以对错误原因进行打印，错误原因存储在error中，具体操作和打印结果如下所示：　　　　　　\n\n![img](http://files.jb51.net/file_images/article/201602/201602261147519.png)\n\n由上面的输出结果可知，error是我们自定义的MyErrorType类型，我们可以使用下面的代码来代替catch中的print语句，如下所示：　　　　\n\n![img](http://files.jb51.net/file_images/article/201602/2016022611475110.png)\n\n上面的做法似乎有些麻烦，还有一种简化输出的方法，就是在上述结构体中实现CustomDebugStringConvertible协议，对描述信息进行一个重写，就可以在打印error时，只打印错误信息，下方是重写后的结构体。　　　\n\n```\n struct MyErrorType: ErrorType,CustomDebugStringConvertible {\n let reason : String\n var debugDescription: String {\n return \"错误类型-----\\(self.dynamicType): \\(reason)\"\n }\n } \n```\n\n修改后，输出结果如下，直接打印error输出的就是错误信息，而不是MyErrorType类型。\n\n![img](http://files.jb51.net/file_images/article/201602/2016022611475111.png)\n\n**3.使String类型遵循ErrorType协议，直接使用String提供错误原因**\n\n在“2”中，我们使用了结构体遵循ErrorType协议的形式，来为错误提供错误信息的。在接下来的部分，我们将通过更为简单的方式为抛出的错误提供错误信息。这种方式更为简单，也易于理解，具体方式如下方代码所示：　　　　\n\n![img](http://files.jb51.net/file_images/article/201602/2016022611475112.png)\n\n**三、在错误处理中使用内置关键字**\n\n**1.初探这些内置关键字**\n\n在Swift中提供了一些内置关键字（__FILE__, __FUNCTION__, __LINE__等）来获取上下文信息，在本篇博客的第三部分，将会给出如何在我们的错误处理中使用这些内置关键字。下方就是这些内置关键字的作用，如下所示：\n\n![img](http://files.jb51.net/file_images/article/201602/2016022611475113.png)\n\n上面说是内置关键字，其实就是存储代码上下文的宏定义，上方代码段简单的给出了这些内置关键字的作用与用法，在接下来将在ErrorType中使用这些内置关键字，让我们的错误信息更加丰富多彩。　\n\n**2.在ErrorType中使用上述内置关键字**\n\n如果想在ErrorType中使用这些上下文内置关键字，我们只需要对ErrorType进行扩展，使其在ErrorType提供错误信息时给出出错的上下文信息。当然，这实现起来比较简单，就是在ErrorType中添加了一个扩展方法contextString()。该方法的作用就是提供错误的上下文信息，也就是在出错的地方，调用contextString()方法生成上下文描述信息即可。对ErrorType协议的具体延展实现如下代码段所示.\n\n在下方代码片段中，我们对ErrorType进行了扩展，为ErrorType添加了contextString的函数实现。contextString()函数有三个默认参数，分别是file--当前文件名，function--当前出错的函数名，line--当前抛出异常的行数。上述三个参数都有参数默认值，分别对应着__FILE__, __FUNCTION__, __LINE__。该扩展函数的返回值为这三个参数组成从字符串信息。具体实现如下所示：\n\n![img](http://files.jb51.net/file_images/article/201602/2016022611475214.png)\n\n**3.使用扩展的contextString方法**\n\n上面我们使用结构体实现ErrorType协议的形式，为错误类型添加错误原因。接下来我们将在添加reason的同时，使用contextString()函数添加描述信息。下方CustomErrorType结构体遵循了ErrorType协议，其中添加了一个reason常量来存储错误原因，一个context常量来存储上下文信息，并且为该结构体添加了一个构造函数，在构造函数中初始化和reason常量。具体实现如下所示：　　\n\n![img](http://files.jb51.net/file_images/article/201602/2016022611475215.png)\n\n**4. 抛出并捕获异常**\n\n在下方代码中函数throwError()抛出了异常，该抛出的错误类型是CustomErrorType。在创建CustomErrorType类型实例，也就是err变量时，我们指定了错误原因，也就是为reason赋了一个值。在创建完err实例后，我们又调用延展contextString()函数获取异常的上下文信息，并把返回的内容存储在err实例的context属性中。最后使用throw关键字抛出err实例，如下方第一部分代码所示。\n\n在创建抛出异常的函数后，我们需要对抛出的异常进行捕获。也就是使用try对异常进行捕获，使用do-catch对异常进行处理，具体操作如下方第二段代码所示。\n\n　　　![img](http://files.jb51.net/file_images/article/201602/2016022611475216.png)　\n\n**5. 分析打印结果**\n\n经过上述步骤如果你在Playground中进行试验的，那么在控制台上你将会看到如下信息。从打印出的信息我们可以看到，信息包括reason：错误原因，和context：异常上下文。在下方的输出结果中，文件名我们可以看到是<EXPR>这并不是确切的文件名，因为我们是在Playground中使用的，并且不是确切的Swift源文件，所以获取不到确切的文件名。\n\n![img](http://files.jb51.net/file_images/article/201602/2016022611475217.png)\n\n为了观察确切的文件名，我们需要在确切的Swift源文件中抛出上述异常。在特定Swift源文件中，我们会看到下方的输出结果。从下方的输出日志中，我们可以清楚的看到文件名是一个详细的文件路径。如下所示：　　　　\n\n![img](http://files.jb51.net/file_images/article/201602/2016022611475218.png)\n\n","source":"_posts/Swift-中的异常抛出和错误处理.md","raw":"---\ntitle: Swift 中的异常抛出和错误处理\ntags: swift\npermalink: swift-zhong-de-yi-chang-pao-chu-he-cuo-wu-chu-li\nid: 23\nupdated: '2016-06-28 12:20:14'\ndate: 2016-06-28 12:19:24\n---\n\n\n# 前言\nSwift语言对其错误处理进行了新的设计，当然了，重新设计后的结果使得该错误处理系统用起来更爽。今天的主题就是系统的搞一下Swift中的错误处理，以及看一下Swift中是如何抛出异常的。在编译型语言中，错误一般分为编译错误和运行时错误。我们平时在代码中处理的错误为运行时错误，我们对异常进行处理的操作的目的是为了防止程序出现错误而导致其他的副作用，比如用户数据未保存等等。\n\n在今天的文章中，先给出主动产生异常的几种情况，然后再给出如何处理被动异常。\n\n# 问题总结\n\n**一、主动退出程序的几种情况**\n\n在Objective-C中，在单元测试时我们会使用断言，断言中条件满足时会产生异常，并打印出相应的断言错误，在Swift中也有几种产生异常的语法。在本篇博客的第一部分就给出这几种方法。\n\n**1.Fatal Errors（致命的错误）**\n\n使用fatalError()函数可以立即终止你的应用程序，在fatalError()中可以给出终止信息。使用fatalError()函数，会毫无条件的终止你的应用程序，用起来也是比较简单的，就是一个函数的调用。下方这个Demo一目了然呢，在此就不做过多赘述了。\n\n![img](http://files.jb51.net/file_images/article/201602/201602261147512.png)\n\n**2. Assertions（断言）**\n\n在单元测试中是少不了断言的，Swift中的断言和Objective-C的区别不是太大，使用方法也是大同小异。下方就是断言的两种方法，由代码提示可知，在断言中的提示条件是可选的。断言会在Debug模式下起作用，但是在Release版本中就会被忽略。\n\n![img](http://files.jb51.net/file_images/article/201602/201602261147513.png)\n\n在assert()函数中, 第一个参数是Bool类型，第二个参数是输出的信息。当条件为true时，断言不执行，相应的断言信息不打印。当条件为false时，断言执行，并且打印相应的断言信息。\n\n![img](http://files.jb51.net/file_images/article/201602/201602261147514.png)\n\nassertionFailure()函数只有一个Message参数，并且该参数也是可以省略的，assertionFailure()没有条件。如下所示：\n\n![img](http://files.jb51.net/file_images/article/201602/201602261147515.png)\n\n**3. 先决条件（Preconditions）**\n\nPreconditions的用法和断言一样，不过有一点需要主要，Preconditions在debug和release模式下都会被执行，除非使用–Ounchecked进行编译。下方截图是代码提示给出的Preconditions函数的提示，如下所示：\n\n![img](http://files.jb51.net/file_images/article/201602/201602261147516.png)\n\n关于Preconditions的具体用法请参照断言，和断言用法一样，在此就不做过多的赘述了。\n\n**二.Swift中的错误处理**\n\n在Objective-C中，如果你处理过错误的话，那么你将会对NSError很熟悉。在Swift中，如果你要定义你自己的错误类型，你只需要实现ErrorType协议即可。声明完错误类型后，就可以在处理错误抛出异常时使用自定义的错误类型了。下方将会一步步带你走完Swift中的错误处理的路程。\n\n**1.使用枚举创建错误类型**\n\n（1）.遵循ErrorType协议，自定义错误类型。下方定义了一个错误类型枚举，该枚举遵循了ErrorType协议，在接下来的代码中我们将会使用这个MyCustomErrorType枚举，错误枚举的实现如下所示：\n\n```\n //定义错误类型\n enum MyCustomErrorType: ErrorType {\n case ErrorReason\n case ErrorReason\n case ErrorReason\n } \n```\n\n（2）.在我们的函数定义时可以使用throws关键字，以及在函数中使用throw关键字对错误进行抛出，抛出的错误类型就可以使用上面我们自己定义的错误类型。下方函数就是一个可以抛出错误的函数，抛出的错误就是我们在上面枚举中所定义的类型。具体代码如下所示：\n\n```\n func myThrowFunc() throws {\n let test:Int? = nil\n guard test != nil else {\n throw MyCustomErrorType.ErrorReason\n }\n }\n```\n\n（3）.上面函数的功能是对错误进行抛出，接下来就该使用do-catch来处理抛出的错误。使用try对错误进行捕捉，使用do-catch对错误进行处理。具体处理方式如下所示。在下方错误处理中类似于switch-case语句，catch后边可以枚举匹配错误类型，具体如下所示：　　　　\n\n![img](http://files.jb51.net/file_images/article/201602/201602261147517.png)\n\n（4）在枚举实现错误类型中我们可以通过值绑定的形式为错误添加错误代码和错误原因。在声明枚举时，我们使用了枚举元素值绑定的特性（关于枚举使用的更多细节请参考之前的博客《窥探Swift之别样的枚举类型》）。在声明枚举成员ErrorState时，我们为其绑定了两个变量，一个是错误代码errorCode, 另一个是错误原因errorReason。这两者可以在抛出错误时为其传入相应的值，如下方代码片段中的throwError函数所示，在抛出错误是为errorCode指定的错误代码为404，为errorReason指定的错误原因是“not found”。\n\n　　最后就是使用do-catch处理异常了，在catch中对绑定的错误代码和错误原因进行了获取，并且通过where子句进行了错误代码的筛选。此处catch的用法与switch-case中获取枚举绑定值的用法是一样的，所以在此就不做过多的赘述。具体实现方式如下代码所示：\n\n![img](http://files.jb51.net/file_images/article/201602/201602261147518.png)\n\n**2.使用结构体为错误处理添加Reason**\n\n在上面的内容中，使用枚举遵循ErrorType协议的方式定义了特定的错误类型。接下来我们将使用结构体来遵循ErrorType协议，为错误类型添加错误原因。也就是说，我们可以在抛出错误时，给自定义错误类型提供错误原因。该功能在开发中是非常常用的，而且用起来也是非常爽的。接下来就看一下如何为我们的错误类型添加错误原因。\n\n（1）使用结构体创建错误类型，下方名为MyErrorType的结构体遵循了ErrorType协议，并且在MyErrorType结构体中，声明了一个reason常量，该reason常量中存储的就是错误原因，具体实现方式如下：\n\n```\n struct MyErrorType: ErrorType {\n let reason : String\n }\n```\n\n（2）上面定义完错误类型结构体后，在错误抛出中就可以使用了。在错误抛出时，可以传入一个错误原因，具体代码如下所示：\n\n```\n func myThrowFunc() throws {\n let test:Int? = nil\n guard test != nil else {\n throw MyErrorType(reason: \"我是详细的错误原因，存储在error中\")\n }\n } \n```\n\n（3）最后要对抛出的错误进行do-catch处理，在处理时，可以对错误原因进行打印，错误原因存储在error中，具体操作和打印结果如下所示：　　　　　　\n\n![img](http://files.jb51.net/file_images/article/201602/201602261147519.png)\n\n由上面的输出结果可知，error是我们自定义的MyErrorType类型，我们可以使用下面的代码来代替catch中的print语句，如下所示：　　　　\n\n![img](http://files.jb51.net/file_images/article/201602/2016022611475110.png)\n\n上面的做法似乎有些麻烦，还有一种简化输出的方法，就是在上述结构体中实现CustomDebugStringConvertible协议，对描述信息进行一个重写，就可以在打印error时，只打印错误信息，下方是重写后的结构体。　　　\n\n```\n struct MyErrorType: ErrorType,CustomDebugStringConvertible {\n let reason : String\n var debugDescription: String {\n return \"错误类型-----\\(self.dynamicType): \\(reason)\"\n }\n } \n```\n\n修改后，输出结果如下，直接打印error输出的就是错误信息，而不是MyErrorType类型。\n\n![img](http://files.jb51.net/file_images/article/201602/2016022611475111.png)\n\n**3.使String类型遵循ErrorType协议，直接使用String提供错误原因**\n\n在“2”中，我们使用了结构体遵循ErrorType协议的形式，来为错误提供错误信息的。在接下来的部分，我们将通过更为简单的方式为抛出的错误提供错误信息。这种方式更为简单，也易于理解，具体方式如下方代码所示：　　　　\n\n![img](http://files.jb51.net/file_images/article/201602/2016022611475112.png)\n\n**三、在错误处理中使用内置关键字**\n\n**1.初探这些内置关键字**\n\n在Swift中提供了一些内置关键字（__FILE__, __FUNCTION__, __LINE__等）来获取上下文信息，在本篇博客的第三部分，将会给出如何在我们的错误处理中使用这些内置关键字。下方就是这些内置关键字的作用，如下所示：\n\n![img](http://files.jb51.net/file_images/article/201602/2016022611475113.png)\n\n上面说是内置关键字，其实就是存储代码上下文的宏定义，上方代码段简单的给出了这些内置关键字的作用与用法，在接下来将在ErrorType中使用这些内置关键字，让我们的错误信息更加丰富多彩。　\n\n**2.在ErrorType中使用上述内置关键字**\n\n如果想在ErrorType中使用这些上下文内置关键字，我们只需要对ErrorType进行扩展，使其在ErrorType提供错误信息时给出出错的上下文信息。当然，这实现起来比较简单，就是在ErrorType中添加了一个扩展方法contextString()。该方法的作用就是提供错误的上下文信息，也就是在出错的地方，调用contextString()方法生成上下文描述信息即可。对ErrorType协议的具体延展实现如下代码段所示.\n\n在下方代码片段中，我们对ErrorType进行了扩展，为ErrorType添加了contextString的函数实现。contextString()函数有三个默认参数，分别是file--当前文件名，function--当前出错的函数名，line--当前抛出异常的行数。上述三个参数都有参数默认值，分别对应着__FILE__, __FUNCTION__, __LINE__。该扩展函数的返回值为这三个参数组成从字符串信息。具体实现如下所示：\n\n![img](http://files.jb51.net/file_images/article/201602/2016022611475214.png)\n\n**3.使用扩展的contextString方法**\n\n上面我们使用结构体实现ErrorType协议的形式，为错误类型添加错误原因。接下来我们将在添加reason的同时，使用contextString()函数添加描述信息。下方CustomErrorType结构体遵循了ErrorType协议，其中添加了一个reason常量来存储错误原因，一个context常量来存储上下文信息，并且为该结构体添加了一个构造函数，在构造函数中初始化和reason常量。具体实现如下所示：　　\n\n![img](http://files.jb51.net/file_images/article/201602/2016022611475215.png)\n\n**4. 抛出并捕获异常**\n\n在下方代码中函数throwError()抛出了异常，该抛出的错误类型是CustomErrorType。在创建CustomErrorType类型实例，也就是err变量时，我们指定了错误原因，也就是为reason赋了一个值。在创建完err实例后，我们又调用延展contextString()函数获取异常的上下文信息，并把返回的内容存储在err实例的context属性中。最后使用throw关键字抛出err实例，如下方第一部分代码所示。\n\n在创建抛出异常的函数后，我们需要对抛出的异常进行捕获。也就是使用try对异常进行捕获，使用do-catch对异常进行处理，具体操作如下方第二段代码所示。\n\n　　　![img](http://files.jb51.net/file_images/article/201602/2016022611475216.png)　\n\n**5. 分析打印结果**\n\n经过上述步骤如果你在Playground中进行试验的，那么在控制台上你将会看到如下信息。从打印出的信息我们可以看到，信息包括reason：错误原因，和context：异常上下文。在下方的输出结果中，文件名我们可以看到是<EXPR>这并不是确切的文件名，因为我们是在Playground中使用的，并且不是确切的Swift源文件，所以获取不到确切的文件名。\n\n![img](http://files.jb51.net/file_images/article/201602/2016022611475217.png)\n\n为了观察确切的文件名，我们需要在确切的Swift源文件中抛出上述异常。在特定Swift源文件中，我们会看到下方的输出结果。从下方的输出日志中，我们可以清楚的看到文件名是一个详细的文件路径。如下所示：　　　　\n\n![img](http://files.jb51.net/file_images/article/201602/2016022611475218.png)\n\n","slug":"swift-zhong-de-yi-chang-pao-chu-he-cuo-wu-chu-li","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cj04pzyx5000ds04ecljvcam6","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>Swift语言对其错误处理进行了新的设计，当然了，重新设计后的结果使得该错误处理系统用起来更爽。今天的主题就是系统的搞一下Swift中的错误处理，以及看一下Swift中是如何抛出异常的。在编译型语言中，错误一般分为编译错误和运行时错误。我们平时在代码中处理的错误为运行时错误，我们对异常进行处理的操作的目的是为了防止程序出现错误而导致其他的副作用，比如用户数据未保存等等。</p>\n<p>在今天的文章中，先给出主动产生异常的几种情况，然后再给出如何处理被动异常。</p>\n<h1 id=\"问题总结\"><a href=\"#问题总结\" class=\"headerlink\" title=\"问题总结\"></a>问题总结</h1><p><strong>一、主动退出程序的几种情况</strong></p>\n<p>在Objective-C中，在单元测试时我们会使用断言，断言中条件满足时会产生异常，并打印出相应的断言错误，在Swift中也有几种产生异常的语法。在本篇博客的第一部分就给出这几种方法。</p>\n<p><strong>1.Fatal Errors（致命的错误）</strong></p>\n<p>使用fatalError()函数可以立即终止你的应用程序，在fatalError()中可以给出终止信息。使用fatalError()函数，会毫无条件的终止你的应用程序，用起来也是比较简单的，就是一个函数的调用。下方这个Demo一目了然呢，在此就不做过多赘述了。</p>\n<p><img src=\"http://files.jb51.net/file_images/article/201602/201602261147512.png\" alt=\"img\"></p>\n<p><strong>2. Assertions（断言）</strong></p>\n<p>在单元测试中是少不了断言的，Swift中的断言和Objective-C的区别不是太大，使用方法也是大同小异。下方就是断言的两种方法，由代码提示可知，在断言中的提示条件是可选的。断言会在Debug模式下起作用，但是在Release版本中就会被忽略。</p>\n<p><img src=\"http://files.jb51.net/file_images/article/201602/201602261147513.png\" alt=\"img\"></p>\n<p>在assert()函数中, 第一个参数是Bool类型，第二个参数是输出的信息。当条件为true时，断言不执行，相应的断言信息不打印。当条件为false时，断言执行，并且打印相应的断言信息。</p>\n<p><img src=\"http://files.jb51.net/file_images/article/201602/201602261147514.png\" alt=\"img\"></p>\n<p>assertionFailure()函数只有一个Message参数，并且该参数也是可以省略的，assertionFailure()没有条件。如下所示：</p>\n<p><img src=\"http://files.jb51.net/file_images/article/201602/201602261147515.png\" alt=\"img\"></p>\n<p><strong>3. 先决条件（Preconditions）</strong></p>\n<p>Preconditions的用法和断言一样，不过有一点需要主要，Preconditions在debug和release模式下都会被执行，除非使用–Ounchecked进行编译。下方截图是代码提示给出的Preconditions函数的提示，如下所示：</p>\n<p><img src=\"http://files.jb51.net/file_images/article/201602/201602261147516.png\" alt=\"img\"></p>\n<p>关于Preconditions的具体用法请参照断言，和断言用法一样，在此就不做过多的赘述了。</p>\n<p><strong>二.Swift中的错误处理</strong></p>\n<p>在Objective-C中，如果你处理过错误的话，那么你将会对NSError很熟悉。在Swift中，如果你要定义你自己的错误类型，你只需要实现ErrorType协议即可。声明完错误类型后，就可以在处理错误抛出异常时使用自定义的错误类型了。下方将会一步步带你走完Swift中的错误处理的路程。</p>\n<p><strong>1.使用枚举创建错误类型</strong></p>\n<p>（1）.遵循ErrorType协议，自定义错误类型。下方定义了一个错误类型枚举，该枚举遵循了ErrorType协议，在接下来的代码中我们将会使用这个MyCustomErrorType枚举，错误枚举的实现如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">//定义错误类型</div><div class=\"line\">enum MyCustomErrorType: ErrorType &#123;</div><div class=\"line\">case ErrorReason</div><div class=\"line\">case ErrorReason</div><div class=\"line\">case ErrorReason</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>（2）.在我们的函数定义时可以使用throws关键字，以及在函数中使用throw关键字对错误进行抛出，抛出的错误类型就可以使用上面我们自己定义的错误类型。下方函数就是一个可以抛出错误的函数，抛出的错误就是我们在上面枚举中所定义的类型。具体代码如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">func myThrowFunc() throws &#123;</div><div class=\"line\">let test:Int? = nil</div><div class=\"line\">guard test != nil else &#123;</div><div class=\"line\">throw MyCustomErrorType.ErrorReason</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>（3）.上面函数的功能是对错误进行抛出，接下来就该使用do-catch来处理抛出的错误。使用try对错误进行捕捉，使用do-catch对错误进行处理。具体处理方式如下所示。在下方错误处理中类似于switch-case语句，catch后边可以枚举匹配错误类型，具体如下所示：　　　　</p>\n<p><img src=\"http://files.jb51.net/file_images/article/201602/201602261147517.png\" alt=\"img\"></p>\n<p>（4）在枚举实现错误类型中我们可以通过值绑定的形式为错误添加错误代码和错误原因。在声明枚举时，我们使用了枚举元素值绑定的特性（关于枚举使用的更多细节请参考之前的博客《窥探Swift之别样的枚举类型》）。在声明枚举成员ErrorState时，我们为其绑定了两个变量，一个是错误代码errorCode, 另一个是错误原因errorReason。这两者可以在抛出错误时为其传入相应的值，如下方代码片段中的throwError函数所示，在抛出错误是为errorCode指定的错误代码为404，为errorReason指定的错误原因是“not found”。</p>\n<p>　　最后就是使用do-catch处理异常了，在catch中对绑定的错误代码和错误原因进行了获取，并且通过where子句进行了错误代码的筛选。此处catch的用法与switch-case中获取枚举绑定值的用法是一样的，所以在此就不做过多的赘述。具体实现方式如下代码所示：</p>\n<p><img src=\"http://files.jb51.net/file_images/article/201602/201602261147518.png\" alt=\"img\"></p>\n<p><strong>2.使用结构体为错误处理添加Reason</strong></p>\n<p>在上面的内容中，使用枚举遵循ErrorType协议的方式定义了特定的错误类型。接下来我们将使用结构体来遵循ErrorType协议，为错误类型添加错误原因。也就是说，我们可以在抛出错误时，给自定义错误类型提供错误原因。该功能在开发中是非常常用的，而且用起来也是非常爽的。接下来就看一下如何为我们的错误类型添加错误原因。</p>\n<p>（1）使用结构体创建错误类型，下方名为MyErrorType的结构体遵循了ErrorType协议，并且在MyErrorType结构体中，声明了一个reason常量，该reason常量中存储的就是错误原因，具体实现方式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct MyErrorType: ErrorType &#123;</div><div class=\"line\">let reason : String</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>（2）上面定义完错误类型结构体后，在错误抛出中就可以使用了。在错误抛出时，可以传入一个错误原因，具体代码如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">func myThrowFunc() throws &#123;</div><div class=\"line\">let test:Int? = nil</div><div class=\"line\">guard test != nil else &#123;</div><div class=\"line\">throw MyErrorType(reason: &quot;我是详细的错误原因，存储在error中&quot;)</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>（3）最后要对抛出的错误进行do-catch处理，在处理时，可以对错误原因进行打印，错误原因存储在error中，具体操作和打印结果如下所示：　　　　　　</p>\n<p><img src=\"http://files.jb51.net/file_images/article/201602/201602261147519.png\" alt=\"img\"></p>\n<p>由上面的输出结果可知，error是我们自定义的MyErrorType类型，我们可以使用下面的代码来代替catch中的print语句，如下所示：　　　　</p>\n<p><img src=\"http://files.jb51.net/file_images/article/201602/2016022611475110.png\" alt=\"img\"></p>\n<p>上面的做法似乎有些麻烦，还有一种简化输出的方法，就是在上述结构体中实现CustomDebugStringConvertible协议，对描述信息进行一个重写，就可以在打印error时，只打印错误信息，下方是重写后的结构体。　　　</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct MyErrorType: ErrorType,CustomDebugStringConvertible &#123;</div><div class=\"line\">let reason : String</div><div class=\"line\">var debugDescription: String &#123;</div><div class=\"line\">return &quot;错误类型-----\\(self.dynamicType): \\(reason)&quot;</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>修改后，输出结果如下，直接打印error输出的就是错误信息，而不是MyErrorType类型。</p>\n<p><img src=\"http://files.jb51.net/file_images/article/201602/2016022611475111.png\" alt=\"img\"></p>\n<p><strong>3.使String类型遵循ErrorType协议，直接使用String提供错误原因</strong></p>\n<p>在“2”中，我们使用了结构体遵循ErrorType协议的形式，来为错误提供错误信息的。在接下来的部分，我们将通过更为简单的方式为抛出的错误提供错误信息。这种方式更为简单，也易于理解，具体方式如下方代码所示：　　　　</p>\n<p><img src=\"http://files.jb51.net/file_images/article/201602/2016022611475112.png\" alt=\"img\"></p>\n<p><strong>三、在错误处理中使用内置关键字</strong></p>\n<p><strong>1.初探这些内置关键字</strong></p>\n<p>在Swift中提供了一些内置关键字（<strong>FILE</strong>, <strong>FUNCTION</strong>, <strong>LINE</strong>等）来获取上下文信息，在本篇博客的第三部分，将会给出如何在我们的错误处理中使用这些内置关键字。下方就是这些内置关键字的作用，如下所示：</p>\n<p><img src=\"http://files.jb51.net/file_images/article/201602/2016022611475113.png\" alt=\"img\"></p>\n<p>上面说是内置关键字，其实就是存储代码上下文的宏定义，上方代码段简单的给出了这些内置关键字的作用与用法，在接下来将在ErrorType中使用这些内置关键字，让我们的错误信息更加丰富多彩。　</p>\n<p><strong>2.在ErrorType中使用上述内置关键字</strong></p>\n<p>如果想在ErrorType中使用这些上下文内置关键字，我们只需要对ErrorType进行扩展，使其在ErrorType提供错误信息时给出出错的上下文信息。当然，这实现起来比较简单，就是在ErrorType中添加了一个扩展方法contextString()。该方法的作用就是提供错误的上下文信息，也就是在出错的地方，调用contextString()方法生成上下文描述信息即可。对ErrorType协议的具体延展实现如下代码段所示.</p>\n<p>在下方代码片段中，我们对ErrorType进行了扩展，为ErrorType添加了contextString的函数实现。contextString()函数有三个默认参数，分别是file–当前文件名，function–当前出错的函数名，line–当前抛出异常的行数。上述三个参数都有参数默认值，分别对应着<strong>FILE</strong>, <strong>FUNCTION</strong>, <strong>LINE</strong>。该扩展函数的返回值为这三个参数组成从字符串信息。具体实现如下所示：</p>\n<p><img src=\"http://files.jb51.net/file_images/article/201602/2016022611475214.png\" alt=\"img\"></p>\n<p><strong>3.使用扩展的contextString方法</strong></p>\n<p>上面我们使用结构体实现ErrorType协议的形式，为错误类型添加错误原因。接下来我们将在添加reason的同时，使用contextString()函数添加描述信息。下方CustomErrorType结构体遵循了ErrorType协议，其中添加了一个reason常量来存储错误原因，一个context常量来存储上下文信息，并且为该结构体添加了一个构造函数，在构造函数中初始化和reason常量。具体实现如下所示：　　</p>\n<p><img src=\"http://files.jb51.net/file_images/article/201602/2016022611475215.png\" alt=\"img\"></p>\n<p><strong>4. 抛出并捕获异常</strong></p>\n<p>在下方代码中函数throwError()抛出了异常，该抛出的错误类型是CustomErrorType。在创建CustomErrorType类型实例，也就是err变量时，我们指定了错误原因，也就是为reason赋了一个值。在创建完err实例后，我们又调用延展contextString()函数获取异常的上下文信息，并把返回的内容存储在err实例的context属性中。最后使用throw关键字抛出err实例，如下方第一部分代码所示。</p>\n<p>在创建抛出异常的函数后，我们需要对抛出的异常进行捕获。也就是使用try对异常进行捕获，使用do-catch对异常进行处理，具体操作如下方第二段代码所示。</p>\n<p>　　　<img src=\"http://files.jb51.net/file_images/article/201602/2016022611475216.png\" alt=\"img\">　</p>\n<p><strong>5. 分析打印结果</strong></p>\n<p>经过上述步骤如果你在Playground中进行试验的，那么在控制台上你将会看到如下信息。从打印出的信息我们可以看到，信息包括reason：错误原因，和context：异常上下文。在下方的输出结果中，文件名我们可以看到是<expr>这并不是确切的文件名，因为我们是在Playground中使用的，并且不是确切的Swift源文件，所以获取不到确切的文件名。</expr></p>\n<p><img src=\"http://files.jb51.net/file_images/article/201602/2016022611475217.png\" alt=\"img\"></p>\n<p>为了观察确切的文件名，我们需要在确切的Swift源文件中抛出上述异常。在特定Swift源文件中，我们会看到下方的输出结果。从下方的输出日志中，我们可以清楚的看到文件名是一个详细的文件路径。如下所示：　　　　</p>\n<p><img src=\"http://files.jb51.net/file_images/article/201602/2016022611475218.png\" alt=\"img\"></p>\n","excerpt":"","more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>Swift语言对其错误处理进行了新的设计，当然了，重新设计后的结果使得该错误处理系统用起来更爽。今天的主题就是系统的搞一下Swift中的错误处理，以及看一下Swift中是如何抛出异常的。在编译型语言中，错误一般分为编译错误和运行时错误。我们平时在代码中处理的错误为运行时错误，我们对异常进行处理的操作的目的是为了防止程序出现错误而导致其他的副作用，比如用户数据未保存等等。</p>\n<p>在今天的文章中，先给出主动产生异常的几种情况，然后再给出如何处理被动异常。</p>\n<h1 id=\"问题总结\"><a href=\"#问题总结\" class=\"headerlink\" title=\"问题总结\"></a>问题总结</h1><p><strong>一、主动退出程序的几种情况</strong></p>\n<p>在Objective-C中，在单元测试时我们会使用断言，断言中条件满足时会产生异常，并打印出相应的断言错误，在Swift中也有几种产生异常的语法。在本篇博客的第一部分就给出这几种方法。</p>\n<p><strong>1.Fatal Errors（致命的错误）</strong></p>\n<p>使用fatalError()函数可以立即终止你的应用程序，在fatalError()中可以给出终止信息。使用fatalError()函数，会毫无条件的终止你的应用程序，用起来也是比较简单的，就是一个函数的调用。下方这个Demo一目了然呢，在此就不做过多赘述了。</p>\n<p><img src=\"http://files.jb51.net/file_images/article/201602/201602261147512.png\" alt=\"img\"></p>\n<p><strong>2. Assertions（断言）</strong></p>\n<p>在单元测试中是少不了断言的，Swift中的断言和Objective-C的区别不是太大，使用方法也是大同小异。下方就是断言的两种方法，由代码提示可知，在断言中的提示条件是可选的。断言会在Debug模式下起作用，但是在Release版本中就会被忽略。</p>\n<p><img src=\"http://files.jb51.net/file_images/article/201602/201602261147513.png\" alt=\"img\"></p>\n<p>在assert()函数中, 第一个参数是Bool类型，第二个参数是输出的信息。当条件为true时，断言不执行，相应的断言信息不打印。当条件为false时，断言执行，并且打印相应的断言信息。</p>\n<p><img src=\"http://files.jb51.net/file_images/article/201602/201602261147514.png\" alt=\"img\"></p>\n<p>assertionFailure()函数只有一个Message参数，并且该参数也是可以省略的，assertionFailure()没有条件。如下所示：</p>\n<p><img src=\"http://files.jb51.net/file_images/article/201602/201602261147515.png\" alt=\"img\"></p>\n<p><strong>3. 先决条件（Preconditions）</strong></p>\n<p>Preconditions的用法和断言一样，不过有一点需要主要，Preconditions在debug和release模式下都会被执行，除非使用–Ounchecked进行编译。下方截图是代码提示给出的Preconditions函数的提示，如下所示：</p>\n<p><img src=\"http://files.jb51.net/file_images/article/201602/201602261147516.png\" alt=\"img\"></p>\n<p>关于Preconditions的具体用法请参照断言，和断言用法一样，在此就不做过多的赘述了。</p>\n<p><strong>二.Swift中的错误处理</strong></p>\n<p>在Objective-C中，如果你处理过错误的话，那么你将会对NSError很熟悉。在Swift中，如果你要定义你自己的错误类型，你只需要实现ErrorType协议即可。声明完错误类型后，就可以在处理错误抛出异常时使用自定义的错误类型了。下方将会一步步带你走完Swift中的错误处理的路程。</p>\n<p><strong>1.使用枚举创建错误类型</strong></p>\n<p>（1）.遵循ErrorType协议，自定义错误类型。下方定义了一个错误类型枚举，该枚举遵循了ErrorType协议，在接下来的代码中我们将会使用这个MyCustomErrorType枚举，错误枚举的实现如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">//定义错误类型</div><div class=\"line\">enum MyCustomErrorType: ErrorType &#123;</div><div class=\"line\">case ErrorReason</div><div class=\"line\">case ErrorReason</div><div class=\"line\">case ErrorReason</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>（2）.在我们的函数定义时可以使用throws关键字，以及在函数中使用throw关键字对错误进行抛出，抛出的错误类型就可以使用上面我们自己定义的错误类型。下方函数就是一个可以抛出错误的函数，抛出的错误就是我们在上面枚举中所定义的类型。具体代码如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">func myThrowFunc() throws &#123;</div><div class=\"line\">let test:Int? = nil</div><div class=\"line\">guard test != nil else &#123;</div><div class=\"line\">throw MyCustomErrorType.ErrorReason</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>（3）.上面函数的功能是对错误进行抛出，接下来就该使用do-catch来处理抛出的错误。使用try对错误进行捕捉，使用do-catch对错误进行处理。具体处理方式如下所示。在下方错误处理中类似于switch-case语句，catch后边可以枚举匹配错误类型，具体如下所示：　　　　</p>\n<p><img src=\"http://files.jb51.net/file_images/article/201602/201602261147517.png\" alt=\"img\"></p>\n<p>（4）在枚举实现错误类型中我们可以通过值绑定的形式为错误添加错误代码和错误原因。在声明枚举时，我们使用了枚举元素值绑定的特性（关于枚举使用的更多细节请参考之前的博客《窥探Swift之别样的枚举类型》）。在声明枚举成员ErrorState时，我们为其绑定了两个变量，一个是错误代码errorCode, 另一个是错误原因errorReason。这两者可以在抛出错误时为其传入相应的值，如下方代码片段中的throwError函数所示，在抛出错误是为errorCode指定的错误代码为404，为errorReason指定的错误原因是“not found”。</p>\n<p>　　最后就是使用do-catch处理异常了，在catch中对绑定的错误代码和错误原因进行了获取，并且通过where子句进行了错误代码的筛选。此处catch的用法与switch-case中获取枚举绑定值的用法是一样的，所以在此就不做过多的赘述。具体实现方式如下代码所示：</p>\n<p><img src=\"http://files.jb51.net/file_images/article/201602/201602261147518.png\" alt=\"img\"></p>\n<p><strong>2.使用结构体为错误处理添加Reason</strong></p>\n<p>在上面的内容中，使用枚举遵循ErrorType协议的方式定义了特定的错误类型。接下来我们将使用结构体来遵循ErrorType协议，为错误类型添加错误原因。也就是说，我们可以在抛出错误时，给自定义错误类型提供错误原因。该功能在开发中是非常常用的，而且用起来也是非常爽的。接下来就看一下如何为我们的错误类型添加错误原因。</p>\n<p>（1）使用结构体创建错误类型，下方名为MyErrorType的结构体遵循了ErrorType协议，并且在MyErrorType结构体中，声明了一个reason常量，该reason常量中存储的就是错误原因，具体实现方式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct MyErrorType: ErrorType &#123;</div><div class=\"line\">let reason : String</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>（2）上面定义完错误类型结构体后，在错误抛出中就可以使用了。在错误抛出时，可以传入一个错误原因，具体代码如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">func myThrowFunc() throws &#123;</div><div class=\"line\">let test:Int? = nil</div><div class=\"line\">guard test != nil else &#123;</div><div class=\"line\">throw MyErrorType(reason: &quot;我是详细的错误原因，存储在error中&quot;)</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>（3）最后要对抛出的错误进行do-catch处理，在处理时，可以对错误原因进行打印，错误原因存储在error中，具体操作和打印结果如下所示：　　　　　　</p>\n<p><img src=\"http://files.jb51.net/file_images/article/201602/201602261147519.png\" alt=\"img\"></p>\n<p>由上面的输出结果可知，error是我们自定义的MyErrorType类型，我们可以使用下面的代码来代替catch中的print语句，如下所示：　　　　</p>\n<p><img src=\"http://files.jb51.net/file_images/article/201602/2016022611475110.png\" alt=\"img\"></p>\n<p>上面的做法似乎有些麻烦，还有一种简化输出的方法，就是在上述结构体中实现CustomDebugStringConvertible协议，对描述信息进行一个重写，就可以在打印error时，只打印错误信息，下方是重写后的结构体。　　　</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct MyErrorType: ErrorType,CustomDebugStringConvertible &#123;</div><div class=\"line\">let reason : String</div><div class=\"line\">var debugDescription: String &#123;</div><div class=\"line\">return &quot;错误类型-----\\(self.dynamicType): \\(reason)&quot;</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>修改后，输出结果如下，直接打印error输出的就是错误信息，而不是MyErrorType类型。</p>\n<p><img src=\"http://files.jb51.net/file_images/article/201602/2016022611475111.png\" alt=\"img\"></p>\n<p><strong>3.使String类型遵循ErrorType协议，直接使用String提供错误原因</strong></p>\n<p>在“2”中，我们使用了结构体遵循ErrorType协议的形式，来为错误提供错误信息的。在接下来的部分，我们将通过更为简单的方式为抛出的错误提供错误信息。这种方式更为简单，也易于理解，具体方式如下方代码所示：　　　　</p>\n<p><img src=\"http://files.jb51.net/file_images/article/201602/2016022611475112.png\" alt=\"img\"></p>\n<p><strong>三、在错误处理中使用内置关键字</strong></p>\n<p><strong>1.初探这些内置关键字</strong></p>\n<p>在Swift中提供了一些内置关键字（<strong>FILE</strong>, <strong>FUNCTION</strong>, <strong>LINE</strong>等）来获取上下文信息，在本篇博客的第三部分，将会给出如何在我们的错误处理中使用这些内置关键字。下方就是这些内置关键字的作用，如下所示：</p>\n<p><img src=\"http://files.jb51.net/file_images/article/201602/2016022611475113.png\" alt=\"img\"></p>\n<p>上面说是内置关键字，其实就是存储代码上下文的宏定义，上方代码段简单的给出了这些内置关键字的作用与用法，在接下来将在ErrorType中使用这些内置关键字，让我们的错误信息更加丰富多彩。　</p>\n<p><strong>2.在ErrorType中使用上述内置关键字</strong></p>\n<p>如果想在ErrorType中使用这些上下文内置关键字，我们只需要对ErrorType进行扩展，使其在ErrorType提供错误信息时给出出错的上下文信息。当然，这实现起来比较简单，就是在ErrorType中添加了一个扩展方法contextString()。该方法的作用就是提供错误的上下文信息，也就是在出错的地方，调用contextString()方法生成上下文描述信息即可。对ErrorType协议的具体延展实现如下代码段所示.</p>\n<p>在下方代码片段中，我们对ErrorType进行了扩展，为ErrorType添加了contextString的函数实现。contextString()函数有三个默认参数，分别是file–当前文件名，function–当前出错的函数名，line–当前抛出异常的行数。上述三个参数都有参数默认值，分别对应着<strong>FILE</strong>, <strong>FUNCTION</strong>, <strong>LINE</strong>。该扩展函数的返回值为这三个参数组成从字符串信息。具体实现如下所示：</p>\n<p><img src=\"http://files.jb51.net/file_images/article/201602/2016022611475214.png\" alt=\"img\"></p>\n<p><strong>3.使用扩展的contextString方法</strong></p>\n<p>上面我们使用结构体实现ErrorType协议的形式，为错误类型添加错误原因。接下来我们将在添加reason的同时，使用contextString()函数添加描述信息。下方CustomErrorType结构体遵循了ErrorType协议，其中添加了一个reason常量来存储错误原因，一个context常量来存储上下文信息，并且为该结构体添加了一个构造函数，在构造函数中初始化和reason常量。具体实现如下所示：　　</p>\n<p><img src=\"http://files.jb51.net/file_images/article/201602/2016022611475215.png\" alt=\"img\"></p>\n<p><strong>4. 抛出并捕获异常</strong></p>\n<p>在下方代码中函数throwError()抛出了异常，该抛出的错误类型是CustomErrorType。在创建CustomErrorType类型实例，也就是err变量时，我们指定了错误原因，也就是为reason赋了一个值。在创建完err实例后，我们又调用延展contextString()函数获取异常的上下文信息，并把返回的内容存储在err实例的context属性中。最后使用throw关键字抛出err实例，如下方第一部分代码所示。</p>\n<p>在创建抛出异常的函数后，我们需要对抛出的异常进行捕获。也就是使用try对异常进行捕获，使用do-catch对异常进行处理，具体操作如下方第二段代码所示。</p>\n<p>　　　<img src=\"http://files.jb51.net/file_images/article/201602/2016022611475216.png\" alt=\"img\">　</p>\n<p><strong>5. 分析打印结果</strong></p>\n<p>经过上述步骤如果你在Playground中进行试验的，那么在控制台上你将会看到如下信息。从打印出的信息我们可以看到，信息包括reason：错误原因，和context：异常上下文。在下方的输出结果中，文件名我们可以看到是<EXPR>这并不是确切的文件名，因为我们是在Playground中使用的，并且不是确切的Swift源文件，所以获取不到确切的文件名。</p>\n<p><img src=\"http://files.jb51.net/file_images/article/201602/2016022611475217.png\" alt=\"img\"></p>\n<p>为了观察确切的文件名，我们需要在确切的Swift源文件中抛出上述异常。在特定Swift源文件中，我们会看到下方的输出结果。从下方的输出日志中，我们可以清楚的看到文件名是一个详细的文件路径。如下所示：　　　　</p>\n<p><img src=\"http://files.jb51.net/file_images/article/201602/2016022611475218.png\" alt=\"img\"></p>\n"},{"title":"Swift中的问号?和感叹号!","id":"24","updated":"2016-06-28T08:53:38.000Z","date":"2016-06-28T08:50:22.000Z","_content":"\n\n\n本文转载自：[代码手工艺人](http://joeyio.com/ios/2014/06/04/swift---/)的博客，原文名称：Swift之 ? 和 !\n\nSwift语言使用var定义变量，但和别的语言不同，Swift里不会自动给变量赋初始值，也就是说变量不会有默认值，所以要求使用变量之前必须要对其初始化。如果在使用变量之前不进行初始化就会报错：\n\n```\nvar stringValue : String \n//error: variable 'stringValue' used before being initialized\n//let hashValue = stringValue.hashValue\n//                            ^\nlet hashValue = stringValue.hashValue\n```\n\n上面了解到的是普通值，接下来Optional值要上场了。经[喵神](http://onevcat.com/)提醒，Optional其实是个`enum`，里面有`None`和`Some`两种类型。其实所谓的nil就是`Optional.None`, 非nil就是`Optional.Some`, 然后会通过`Some(T)`包装（wrap）原始值，这也是为什么在使用Optional的时候要拆包（从enum里取出来原始值）的原因, 也是PlayGround会把Optional值显示为类似`{Some \"hello world\"}`的原因，这里是enum Optional的定义：\n\n```\nenum Optional<T> : LogicValue, Reflectable {\n    case None\n    case Some(T)\n    init()\n    init(_ some: T)\n\n    /// Allow use in a Boolean context.\n    func getLogicValue() -> Bool\n\n    /// Haskell's fmap, which was mis-named\n    func map<U>(f: (T) -> U) -> U?\n    func getMirror() -> Mirror\n}\n```\n\n声明为Optional只需要在类型后面**紧跟**一个`?`即可。如:\n\n```\nvar strValue: String?   //?相当于下面这种写法的语法糖\nvar strValue: Optional<Int>  \n```\n\n一旦声明为Optional的，如果不显式的赋值就会有个默认值nil。判断一个Optional的值是否有值，可以用if来判断：\n\n```\nif strValue {\n    //do sth with strValue\n}\n```\n\n然后怎么使用Optional值呢？文档中也有提到说，在使用Optional值的时候需要在具体的操作，比如调用方法、属性、下标索引等前面需要加上一个`?`，经[喵神](http://onevcat.com/)指正，”Optional Chaining的问号的意思是询问是否响应后面这个方法，和原来的`isResponseToSelector`有些类似”，如果是nil值，也就是`Optional.None`，固然不能响应后面的方法，所以就会跳过，如果有值，就是`Optional.Some`，可能就会拆包(unwrap)，然后对拆包后的值执行后面的操作，比如：\n\n```\nlet hashValue = strValue?.hashValue \n```\n\nstrValue是Optional的字符串，如果strValue是nil，则hashValue也为nil，如果strValue不为nil，hashValue就是strValue字符串的哈希值\n\n到这里我们看到了`?`的两种使用场景:1.声明Optional值变量\n2.用在对Optional值操作中，用来判断是否能响应后面的操作\n\n另外，对于Optional值，不能直接进行操作，否则会报错：\n\n```\n//error: 'String?' does not have a member named 'hashValue'\n//let hashValue = strValue.hashValue\n//                ^        ~~~~~~~~~\n\nlet hashValue = strValue.hashValue\n```\n\n上面提到Optional值需要拆包(unwrap)后才能得到原来值，然后才能对其操作，那怎么来拆包呢？拆包提到了几种方法，一种是`Optional Binding`， 比如：\n\n```\nif let str = strValue {\n    let hashValue = str.hashValue\n}\n```\n\n还有一种是在具体的操作前添加`!`符号，好吧，这又是什么诡异的语法?!\n\n直接上例子，strValue是Optional的String：\n\n```\nlet hashValue = strValue!.hashValue \n```\n\n这里的`!`表示“我确定这里的的strValue一定是非nil的，尽情调用吧” ，比如这种情况:\n\n```\nif strValue {\n    let hashValue = strValue!.hashValue\n}\n```\n\n{}里的strValue一定是非nil的，所以就能直接加上!，强制拆包(unwrap)并执行后面的操作。 当然如果不加判断，strValue不小心为nil的话，就会出错，crash掉。\n\n考虑下这一种情况，我们有一个自定义的`MyViewController`类，类中有一个属性是`myLabel`，myLabel是在viewDidLoad中进行初始化。因为是在viewDidLoad中初始化，所以不能直接声明为普通值：`var myLabel : UILabel`，因为非Optional的变量必须在声明时或者构造器中进行初始化，但我们是想在viewDidLoad中初始化，所以就只能声明为Optional：`var myLabel: UILabel?`, 虽然我们确定在viewDidLoad中会初始化，并且在ViewController的生命周期内不会置为nil，但是在对myLabel操作时，每次依然要加上`!`来强制拆包(在读取值的时候，也可以用`?`，谢谢iPresent在回复中提醒)，比如:\n\n```\nmyLabel!.text = \"text\"\nmyLabel!.frame = CGRectMake(0, 0, 10, 10)\n...\n```\n\n对于这种类型的值，我们可以直接这么声明：`var myLabel: UILabel!`, 果然是高(hao)大(gui)上(yi)的语法!, 这种是特殊的Optional，称为`Implicitly Unwrapped Optionals`, 直译就是隐式拆包的Optional，就等于说你每次对这种类型的值操作时，都会自动在操作前补上一个`!`进行拆包，然后在执行后面的操作，当然如果该值是nil，也一样会报错crash掉。\n\n```\nvar myLabel: UILabel!  //!相当于下面这种写法的语法糖\nvar myLabel: ImplicitlyUnwrappedOptional<UILabel>\n```\n\n\n\nSwift是门新生的语言，我们有幸见证了它的诞生，激动之余也在佩服苹果大刀阔斧的推出一个新的语言替代一个已经比较成熟语言的魄力，今天在知乎日报上看到一个回答是说Swift是一门玩具语言，正当想去吐槽，发现回答已经被删除了。个人认为苹果是很认真的推出Swift的，从Swift的各种细微的设计也能看的出来。\n\n另外这两个小符号就花费了我不少的时间来理解，可能依然会有错误和不妥之处，欢迎大家指正，本文旨在抛砖引玉。除此之外，Swift还有很多很棒的特性，WWDC 2014 会有四五个和Swift语言相关的Video，大家也可以去关注一下。\n\n最后要感谢[喵神](http://onevcat.com/)的纠正了多处有问题的地方，thx, have fun!\n\n主要参考自苹果的官方文档《The Swift Programming Language》，可以在[这里](https://developer.apple.com/swift/)下载到\n\n","source":"_posts/Swift中的问号-和感叹号.md","raw":"---\ntitle: Swift中的问号?和感叹号!\ntags: [转载, swift]\npermalink: swiftzhong-de-wen-hao-he-gan-tan-hao\nid: 24\nupdated: '2016-06-28 16:53:38'\ndate: 2016-06-28 16:50:22\n---\n\n\n\n本文转载自：[代码手工艺人](http://joeyio.com/ios/2014/06/04/swift---/)的博客，原文名称：Swift之 ? 和 !\n\nSwift语言使用var定义变量，但和别的语言不同，Swift里不会自动给变量赋初始值，也就是说变量不会有默认值，所以要求使用变量之前必须要对其初始化。如果在使用变量之前不进行初始化就会报错：\n\n```\nvar stringValue : String \n//error: variable 'stringValue' used before being initialized\n//let hashValue = stringValue.hashValue\n//                            ^\nlet hashValue = stringValue.hashValue\n```\n\n上面了解到的是普通值，接下来Optional值要上场了。经[喵神](http://onevcat.com/)提醒，Optional其实是个`enum`，里面有`None`和`Some`两种类型。其实所谓的nil就是`Optional.None`, 非nil就是`Optional.Some`, 然后会通过`Some(T)`包装（wrap）原始值，这也是为什么在使用Optional的时候要拆包（从enum里取出来原始值）的原因, 也是PlayGround会把Optional值显示为类似`{Some \"hello world\"}`的原因，这里是enum Optional的定义：\n\n```\nenum Optional<T> : LogicValue, Reflectable {\n    case None\n    case Some(T)\n    init()\n    init(_ some: T)\n\n    /// Allow use in a Boolean context.\n    func getLogicValue() -> Bool\n\n    /// Haskell's fmap, which was mis-named\n    func map<U>(f: (T) -> U) -> U?\n    func getMirror() -> Mirror\n}\n```\n\n声明为Optional只需要在类型后面**紧跟**一个`?`即可。如:\n\n```\nvar strValue: String?   //?相当于下面这种写法的语法糖\nvar strValue: Optional<Int>  \n```\n\n一旦声明为Optional的，如果不显式的赋值就会有个默认值nil。判断一个Optional的值是否有值，可以用if来判断：\n\n```\nif strValue {\n    //do sth with strValue\n}\n```\n\n然后怎么使用Optional值呢？文档中也有提到说，在使用Optional值的时候需要在具体的操作，比如调用方法、属性、下标索引等前面需要加上一个`?`，经[喵神](http://onevcat.com/)指正，”Optional Chaining的问号的意思是询问是否响应后面这个方法，和原来的`isResponseToSelector`有些类似”，如果是nil值，也就是`Optional.None`，固然不能响应后面的方法，所以就会跳过，如果有值，就是`Optional.Some`，可能就会拆包(unwrap)，然后对拆包后的值执行后面的操作，比如：\n\n```\nlet hashValue = strValue?.hashValue \n```\n\nstrValue是Optional的字符串，如果strValue是nil，则hashValue也为nil，如果strValue不为nil，hashValue就是strValue字符串的哈希值\n\n到这里我们看到了`?`的两种使用场景:1.声明Optional值变量\n2.用在对Optional值操作中，用来判断是否能响应后面的操作\n\n另外，对于Optional值，不能直接进行操作，否则会报错：\n\n```\n//error: 'String?' does not have a member named 'hashValue'\n//let hashValue = strValue.hashValue\n//                ^        ~~~~~~~~~\n\nlet hashValue = strValue.hashValue\n```\n\n上面提到Optional值需要拆包(unwrap)后才能得到原来值，然后才能对其操作，那怎么来拆包呢？拆包提到了几种方法，一种是`Optional Binding`， 比如：\n\n```\nif let str = strValue {\n    let hashValue = str.hashValue\n}\n```\n\n还有一种是在具体的操作前添加`!`符号，好吧，这又是什么诡异的语法?!\n\n直接上例子，strValue是Optional的String：\n\n```\nlet hashValue = strValue!.hashValue \n```\n\n这里的`!`表示“我确定这里的的strValue一定是非nil的，尽情调用吧” ，比如这种情况:\n\n```\nif strValue {\n    let hashValue = strValue!.hashValue\n}\n```\n\n{}里的strValue一定是非nil的，所以就能直接加上!，强制拆包(unwrap)并执行后面的操作。 当然如果不加判断，strValue不小心为nil的话，就会出错，crash掉。\n\n考虑下这一种情况，我们有一个自定义的`MyViewController`类，类中有一个属性是`myLabel`，myLabel是在viewDidLoad中进行初始化。因为是在viewDidLoad中初始化，所以不能直接声明为普通值：`var myLabel : UILabel`，因为非Optional的变量必须在声明时或者构造器中进行初始化，但我们是想在viewDidLoad中初始化，所以就只能声明为Optional：`var myLabel: UILabel?`, 虽然我们确定在viewDidLoad中会初始化，并且在ViewController的生命周期内不会置为nil，但是在对myLabel操作时，每次依然要加上`!`来强制拆包(在读取值的时候，也可以用`?`，谢谢iPresent在回复中提醒)，比如:\n\n```\nmyLabel!.text = \"text\"\nmyLabel!.frame = CGRectMake(0, 0, 10, 10)\n...\n```\n\n对于这种类型的值，我们可以直接这么声明：`var myLabel: UILabel!`, 果然是高(hao)大(gui)上(yi)的语法!, 这种是特殊的Optional，称为`Implicitly Unwrapped Optionals`, 直译就是隐式拆包的Optional，就等于说你每次对这种类型的值操作时，都会自动在操作前补上一个`!`进行拆包，然后在执行后面的操作，当然如果该值是nil，也一样会报错crash掉。\n\n```\nvar myLabel: UILabel!  //!相当于下面这种写法的语法糖\nvar myLabel: ImplicitlyUnwrappedOptional<UILabel>\n```\n\n\n\nSwift是门新生的语言，我们有幸见证了它的诞生，激动之余也在佩服苹果大刀阔斧的推出一个新的语言替代一个已经比较成熟语言的魄力，今天在知乎日报上看到一个回答是说Swift是一门玩具语言，正当想去吐槽，发现回答已经被删除了。个人认为苹果是很认真的推出Swift的，从Swift的各种细微的设计也能看的出来。\n\n另外这两个小符号就花费了我不少的时间来理解，可能依然会有错误和不妥之处，欢迎大家指正，本文旨在抛砖引玉。除此之外，Swift还有很多很棒的特性，WWDC 2014 会有四五个和Swift语言相关的Video，大家也可以去关注一下。\n\n最后要感谢[喵神](http://onevcat.com/)的纠正了多处有问题的地方，thx, have fun!\n\n主要参考自苹果的官方文档《The Swift Programming Language》，可以在[这里](https://developer.apple.com/swift/)下载到\n\n","slug":"swiftzhong-de-wen-hao-he-gan-tan-hao","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cj04pzyxb000fs04ele7izsw7","content":"<p>本文转载自：<a href=\"http://joeyio.com/ios/2014/06/04/swift---/\" target=\"_blank\" rel=\"external\">代码手工艺人</a>的博客，原文名称：Swift之 ? 和 !</p>\n<p>Swift语言使用var定义变量，但和别的语言不同，Swift里不会自动给变量赋初始值，也就是说变量不会有默认值，所以要求使用变量之前必须要对其初始化。如果在使用变量之前不进行初始化就会报错：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">var stringValue : String </div><div class=\"line\">//error: variable &apos;stringValue&apos; used before being initialized</div><div class=\"line\">//let hashValue = stringValue.hashValue</div><div class=\"line\">//                            ^</div><div class=\"line\">let hashValue = stringValue.hashValue</div></pre></td></tr></table></figure>\n<p>上面了解到的是普通值，接下来Optional值要上场了。经<a href=\"http://onevcat.com/\" target=\"_blank\" rel=\"external\">喵神</a>提醒，Optional其实是个<code>enum</code>，里面有<code>None</code>和<code>Some</code>两种类型。其实所谓的nil就是<code>Optional.None</code>, 非nil就是<code>Optional.Some</code>, 然后会通过<code>Some(T)</code>包装（wrap）原始值，这也是为什么在使用Optional的时候要拆包（从enum里取出来原始值）的原因, 也是PlayGround会把Optional值显示为类似<code>{Some &quot;hello world&quot;}</code>的原因，这里是enum Optional的定义：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">enum Optional&lt;T&gt; : LogicValue, Reflectable &#123;</div><div class=\"line\">    case None</div><div class=\"line\">    case Some(T)</div><div class=\"line\">    init()</div><div class=\"line\">    init(_ some: T)</div><div class=\"line\"></div><div class=\"line\">    /// Allow use in a Boolean context.</div><div class=\"line\">    func getLogicValue() -&gt; Bool</div><div class=\"line\"></div><div class=\"line\">    /// Haskell&apos;s fmap, which was mis-named</div><div class=\"line\">    func map&lt;U&gt;(f: (T) -&gt; U) -&gt; U?</div><div class=\"line\">    func getMirror() -&gt; Mirror</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>声明为Optional只需要在类型后面<strong>紧跟</strong>一个<code>?</code>即可。如:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">var strValue: String?   //?相当于下面这种写法的语法糖</div><div class=\"line\">var strValue: Optional&lt;Int&gt;</div></pre></td></tr></table></figure>\n<p>一旦声明为Optional的，如果不显式的赋值就会有个默认值nil。判断一个Optional的值是否有值，可以用if来判断：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">if strValue &#123;</div><div class=\"line\">    //do sth with strValue</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>然后怎么使用Optional值呢？文档中也有提到说，在使用Optional值的时候需要在具体的操作，比如调用方法、属性、下标索引等前面需要加上一个<code>?</code>，经<a href=\"http://onevcat.com/\" target=\"_blank\" rel=\"external\">喵神</a>指正，”Optional Chaining的问号的意思是询问是否响应后面这个方法，和原来的<code>isResponseToSelector</code>有些类似”，如果是nil值，也就是<code>Optional.None</code>，固然不能响应后面的方法，所以就会跳过，如果有值，就是<code>Optional.Some</code>，可能就会拆包(unwrap)，然后对拆包后的值执行后面的操作，比如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">let hashValue = strValue?.hashValue</div></pre></td></tr></table></figure>\n<p>strValue是Optional的字符串，如果strValue是nil，则hashValue也为nil，如果strValue不为nil，hashValue就是strValue字符串的哈希值</p>\n<p>到这里我们看到了<code>?</code>的两种使用场景:1.声明Optional值变量<br>2.用在对Optional值操作中，用来判断是否能响应后面的操作</p>\n<p>另外，对于Optional值，不能直接进行操作，否则会报错：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">//error: &apos;String?&apos; does not have a member named &apos;hashValue&apos;</div><div class=\"line\">//let hashValue = strValue.hashValue</div><div class=\"line\">//                ^        ~~~~~~~~~</div><div class=\"line\"></div><div class=\"line\">let hashValue = strValue.hashValue</div></pre></td></tr></table></figure>\n<p>上面提到Optional值需要拆包(unwrap)后才能得到原来值，然后才能对其操作，那怎么来拆包呢？拆包提到了几种方法，一种是<code>Optional Binding</code>， 比如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">if let str = strValue &#123;</div><div class=\"line\">    let hashValue = str.hashValue</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>还有一种是在具体的操作前添加<code>!</code>符号，好吧，这又是什么诡异的语法?!</p>\n<p>直接上例子，strValue是Optional的String：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">let hashValue = strValue!.hashValue</div></pre></td></tr></table></figure>\n<p>这里的<code>!</code>表示“我确定这里的的strValue一定是非nil的，尽情调用吧” ，比如这种情况:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">if strValue &#123;</div><div class=\"line\">    let hashValue = strValue!.hashValue</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>{}里的strValue一定是非nil的，所以就能直接加上!，强制拆包(unwrap)并执行后面的操作。 当然如果不加判断，strValue不小心为nil的话，就会出错，crash掉。</p>\n<p>考虑下这一种情况，我们有一个自定义的<code>MyViewController</code>类，类中有一个属性是<code>myLabel</code>，myLabel是在viewDidLoad中进行初始化。因为是在viewDidLoad中初始化，所以不能直接声明为普通值：<code>var myLabel : UILabel</code>，因为非Optional的变量必须在声明时或者构造器中进行初始化，但我们是想在viewDidLoad中初始化，所以就只能声明为Optional：<code>var myLabel: UILabel?</code>, 虽然我们确定在viewDidLoad中会初始化，并且在ViewController的生命周期内不会置为nil，但是在对myLabel操作时，每次依然要加上<code>!</code>来强制拆包(在读取值的时候，也可以用<code>?</code>，谢谢iPresent在回复中提醒)，比如:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">myLabel!.text = &quot;text&quot;</div><div class=\"line\">myLabel!.frame = CGRectMake(0, 0, 10, 10)</div><div class=\"line\">...</div></pre></td></tr></table></figure>\n<p>对于这种类型的值，我们可以直接这么声明：<code>var myLabel: UILabel!</code>, 果然是高(hao)大(gui)上(yi)的语法!, 这种是特殊的Optional，称为<code>Implicitly Unwrapped Optionals</code>, 直译就是隐式拆包的Optional，就等于说你每次对这种类型的值操作时，都会自动在操作前补上一个<code>!</code>进行拆包，然后在执行后面的操作，当然如果该值是nil，也一样会报错crash掉。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">var myLabel: UILabel!  //!相当于下面这种写法的语法糖</div><div class=\"line\">var myLabel: ImplicitlyUnwrappedOptional&lt;UILabel&gt;</div></pre></td></tr></table></figure>\n<p>Swift是门新生的语言，我们有幸见证了它的诞生，激动之余也在佩服苹果大刀阔斧的推出一个新的语言替代一个已经比较成熟语言的魄力，今天在知乎日报上看到一个回答是说Swift是一门玩具语言，正当想去吐槽，发现回答已经被删除了。个人认为苹果是很认真的推出Swift的，从Swift的各种细微的设计也能看的出来。</p>\n<p>另外这两个小符号就花费了我不少的时间来理解，可能依然会有错误和不妥之处，欢迎大家指正，本文旨在抛砖引玉。除此之外，Swift还有很多很棒的特性，WWDC 2014 会有四五个和Swift语言相关的Video，大家也可以去关注一下。</p>\n<p>最后要感谢<a href=\"http://onevcat.com/\" target=\"_blank\" rel=\"external\">喵神</a>的纠正了多处有问题的地方，thx, have fun!</p>\n<p>主要参考自苹果的官方文档《The Swift Programming Language》，可以在<a href=\"https://developer.apple.com/swift/\" target=\"_blank\" rel=\"external\">这里</a>下载到</p>\n","excerpt":"","more":"<p>本文转载自：<a href=\"http://joeyio.com/ios/2014/06/04/swift---/\">代码手工艺人</a>的博客，原文名称：Swift之 ? 和 !</p>\n<p>Swift语言使用var定义变量，但和别的语言不同，Swift里不会自动给变量赋初始值，也就是说变量不会有默认值，所以要求使用变量之前必须要对其初始化。如果在使用变量之前不进行初始化就会报错：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">var stringValue : String </div><div class=\"line\">//error: variable &apos;stringValue&apos; used before being initialized</div><div class=\"line\">//let hashValue = stringValue.hashValue</div><div class=\"line\">//                            ^</div><div class=\"line\">let hashValue = stringValue.hashValue</div></pre></td></tr></table></figure>\n<p>上面了解到的是普通值，接下来Optional值要上场了。经<a href=\"http://onevcat.com/\">喵神</a>提醒，Optional其实是个<code>enum</code>，里面有<code>None</code>和<code>Some</code>两种类型。其实所谓的nil就是<code>Optional.None</code>, 非nil就是<code>Optional.Some</code>, 然后会通过<code>Some(T)</code>包装（wrap）原始值，这也是为什么在使用Optional的时候要拆包（从enum里取出来原始值）的原因, 也是PlayGround会把Optional值显示为类似<code>{Some &quot;hello world&quot;}</code>的原因，这里是enum Optional的定义：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">enum Optional&lt;T&gt; : LogicValue, Reflectable &#123;</div><div class=\"line\">    case None</div><div class=\"line\">    case Some(T)</div><div class=\"line\">    init()</div><div class=\"line\">    init(_ some: T)</div><div class=\"line\"></div><div class=\"line\">    /// Allow use in a Boolean context.</div><div class=\"line\">    func getLogicValue() -&gt; Bool</div><div class=\"line\"></div><div class=\"line\">    /// Haskell&apos;s fmap, which was mis-named</div><div class=\"line\">    func map&lt;U&gt;(f: (T) -&gt; U) -&gt; U?</div><div class=\"line\">    func getMirror() -&gt; Mirror</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>声明为Optional只需要在类型后面<strong>紧跟</strong>一个<code>?</code>即可。如:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">var strValue: String?   //?相当于下面这种写法的语法糖</div><div class=\"line\">var strValue: Optional&lt;Int&gt;</div></pre></td></tr></table></figure>\n<p>一旦声明为Optional的，如果不显式的赋值就会有个默认值nil。判断一个Optional的值是否有值，可以用if来判断：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">if strValue &#123;</div><div class=\"line\">    //do sth with strValue</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>然后怎么使用Optional值呢？文档中也有提到说，在使用Optional值的时候需要在具体的操作，比如调用方法、属性、下标索引等前面需要加上一个<code>?</code>，经<a href=\"http://onevcat.com/\">喵神</a>指正，”Optional Chaining的问号的意思是询问是否响应后面这个方法，和原来的<code>isResponseToSelector</code>有些类似”，如果是nil值，也就是<code>Optional.None</code>，固然不能响应后面的方法，所以就会跳过，如果有值，就是<code>Optional.Some</code>，可能就会拆包(unwrap)，然后对拆包后的值执行后面的操作，比如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">let hashValue = strValue?.hashValue</div></pre></td></tr></table></figure>\n<p>strValue是Optional的字符串，如果strValue是nil，则hashValue也为nil，如果strValue不为nil，hashValue就是strValue字符串的哈希值</p>\n<p>到这里我们看到了<code>?</code>的两种使用场景:1.声明Optional值变量<br>2.用在对Optional值操作中，用来判断是否能响应后面的操作</p>\n<p>另外，对于Optional值，不能直接进行操作，否则会报错：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">//error: &apos;String?&apos; does not have a member named &apos;hashValue&apos;</div><div class=\"line\">//let hashValue = strValue.hashValue</div><div class=\"line\">//                ^        ~~~~~~~~~</div><div class=\"line\"></div><div class=\"line\">let hashValue = strValue.hashValue</div></pre></td></tr></table></figure>\n<p>上面提到Optional值需要拆包(unwrap)后才能得到原来值，然后才能对其操作，那怎么来拆包呢？拆包提到了几种方法，一种是<code>Optional Binding</code>， 比如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">if let str = strValue &#123;</div><div class=\"line\">    let hashValue = str.hashValue</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>还有一种是在具体的操作前添加<code>!</code>符号，好吧，这又是什么诡异的语法?!</p>\n<p>直接上例子，strValue是Optional的String：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">let hashValue = strValue!.hashValue</div></pre></td></tr></table></figure>\n<p>这里的<code>!</code>表示“我确定这里的的strValue一定是非nil的，尽情调用吧” ，比如这种情况:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">if strValue &#123;</div><div class=\"line\">    let hashValue = strValue!.hashValue</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>{}里的strValue一定是非nil的，所以就能直接加上!，强制拆包(unwrap)并执行后面的操作。 当然如果不加判断，strValue不小心为nil的话，就会出错，crash掉。</p>\n<p>考虑下这一种情况，我们有一个自定义的<code>MyViewController</code>类，类中有一个属性是<code>myLabel</code>，myLabel是在viewDidLoad中进行初始化。因为是在viewDidLoad中初始化，所以不能直接声明为普通值：<code>var myLabel : UILabel</code>，因为非Optional的变量必须在声明时或者构造器中进行初始化，但我们是想在viewDidLoad中初始化，所以就只能声明为Optional：<code>var myLabel: UILabel?</code>, 虽然我们确定在viewDidLoad中会初始化，并且在ViewController的生命周期内不会置为nil，但是在对myLabel操作时，每次依然要加上<code>!</code>来强制拆包(在读取值的时候，也可以用<code>?</code>，谢谢iPresent在回复中提醒)，比如:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">myLabel!.text = &quot;text&quot;</div><div class=\"line\">myLabel!.frame = CGRectMake(0, 0, 10, 10)</div><div class=\"line\">...</div></pre></td></tr></table></figure>\n<p>对于这种类型的值，我们可以直接这么声明：<code>var myLabel: UILabel!</code>, 果然是高(hao)大(gui)上(yi)的语法!, 这种是特殊的Optional，称为<code>Implicitly Unwrapped Optionals</code>, 直译就是隐式拆包的Optional，就等于说你每次对这种类型的值操作时，都会自动在操作前补上一个<code>!</code>进行拆包，然后在执行后面的操作，当然如果该值是nil，也一样会报错crash掉。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">var myLabel: UILabel!  //!相当于下面这种写法的语法糖</div><div class=\"line\">var myLabel: ImplicitlyUnwrappedOptional&lt;UILabel&gt;</div></pre></td></tr></table></figure>\n<p>Swift是门新生的语言，我们有幸见证了它的诞生，激动之余也在佩服苹果大刀阔斧的推出一个新的语言替代一个已经比较成熟语言的魄力，今天在知乎日报上看到一个回答是说Swift是一门玩具语言，正当想去吐槽，发现回答已经被删除了。个人认为苹果是很认真的推出Swift的，从Swift的各种细微的设计也能看的出来。</p>\n<p>另外这两个小符号就花费了我不少的时间来理解，可能依然会有错误和不妥之处，欢迎大家指正，本文旨在抛砖引玉。除此之外，Swift还有很多很棒的特性，WWDC 2014 会有四五个和Swift语言相关的Video，大家也可以去关注一下。</p>\n<p>最后要感谢<a href=\"http://onevcat.com/\">喵神</a>的纠正了多处有问题的地方，thx, have fun!</p>\n<p>主要参考自苹果的官方文档《The Swift Programming Language》，可以在<a href=\"https://developer.apple.com/swift/\">这里</a>下载到</p>\n"},{"title":"UIWindow 和 UIWindowLevel详解","id":"10","updated":"2016-06-23T14:41:08.000Z","date":"2016-06-11T02:13:09.000Z","_content":"\n\n\n一、UIWindow是一种特殊的UIView，通常在一个程序中只会有一个UIWindow，但可以手动创建多个UIWindow，同时加到程序里面。UIWindow在程序中主要起到三个作用：\n\n　　1、作为容器，包含app所要显示的所有视图\n\n　　2、传递触摸消息到程序中view和其他对象\n\n　　3、与UIViewController协同工作，方便完成设备方向旋转的支持\n\n二、通常我们可以采取两种方法将view添加到UIWindow中：\n\n　　1、addSubview\n\n　　直接将view通过addSubview方式添加到window中，程序负责维护view的生命周期以及刷新，但是并不会为去理会view对应的ViewController，因此采用这种方法将view添加到window以后，我们还要保持view对应的ViewController的有效性，不能过早释放。\n\n　　2、rootViewController\n\n　　rootViewController时UIWindow的一个遍历方法，通过设置该属性为要添加view对应的ViewController，UIWindow将会自动将其view添加到当前window中，同时负责ViewController和view的生命周期的维护，防止其过早释放\n\n三、WindowLevel\n\n　　UIWindow在显示的时候会根据UIWindowLevel进行排序的，即Level高的将排在所有Level比他低的层级的前面。下面我们来看UIWindowLevel的定义：\n\n```\n　　　　const UIWindowLevel UIWindowLevelNormal;\n　　　　const UIWindowLevel UIWindowLevelAlert;\n　　　　const UIWindowLevel UIWindowLevelStatusBar;\n　　　　typedef CGFloat UIWindowLevel;\n```\n\n　　[iOS](http://lib.csdn.net/base/swift)系统中定义了三个window层级，其中每一个层级又可以分好多子层级(从UIWindow的头文件中可以看到成员变量CGFloat _windowSublevel;)，不过系统并没有把则个属性开出来。UIWindow的默认级别是UIWindowLevelNormal，我们打印输出这三个level的值分别如下：\n\n\n\n1. 2012-03-27 22:46:08.752 UIViewSample[395:f803] Normal window level: 0.000000  \n2. 2012-03-27 22:46:08.754 UIViewSample[395:f803] Normal window level: 2000.000000  \n3. 2012-03-27 22:46:08.755 UIViewSample[395:f803] Normal window level: 1000.000000  \n\n　　这样印证了他们级别的高低顺序从小到大为Normal < StatusBar < Alert，下面请看小的测试代码：\n\n　　运行结果如下图：\n\n![img](http://pic002.cnblogs.com/images/2012/302680/2012032722535669.jpg)\n\n　　我们可以注意到两点：\n\n　　1）我们生成的normalWindow虽然是在第一个默认的window之后调用makeKeyAndVisible，但是仍然没有显示出来。这说明当Level层级相同的时候，只有第一个设置为KeyWindow的显示出来，后面同级的再设置KeyWindow也不会显示。\n\n　　2）statusLevelWindow在alertLevelWindow之后调用makeKeyAndVisible，淡仍然只是显示在alertLevelWindow的下方。这说明UIWindow在显示的时候是不管KeyWindow是谁，都是Level优先的，即Level最高的始终显示在最前面。\n\n","source":"_posts/UIWindow-和-UIWindowLevel详解.md","raw":"---\ntitle: UIWindow 和 UIWindowLevel详解\ntags: 'iOS'\npermalink: uiwindow-he-uiwindowlevelxiang-jie\nid: 10\nupdated: '2016-06-23 22:41:08'\ndate: 2016-06-11 10:13:09\n---\n\n\n\n一、UIWindow是一种特殊的UIView，通常在一个程序中只会有一个UIWindow，但可以手动创建多个UIWindow，同时加到程序里面。UIWindow在程序中主要起到三个作用：\n\n　　1、作为容器，包含app所要显示的所有视图\n\n　　2、传递触摸消息到程序中view和其他对象\n\n　　3、与UIViewController协同工作，方便完成设备方向旋转的支持\n\n二、通常我们可以采取两种方法将view添加到UIWindow中：\n\n　　1、addSubview\n\n　　直接将view通过addSubview方式添加到window中，程序负责维护view的生命周期以及刷新，但是并不会为去理会view对应的ViewController，因此采用这种方法将view添加到window以后，我们还要保持view对应的ViewController的有效性，不能过早释放。\n\n　　2、rootViewController\n\n　　rootViewController时UIWindow的一个遍历方法，通过设置该属性为要添加view对应的ViewController，UIWindow将会自动将其view添加到当前window中，同时负责ViewController和view的生命周期的维护，防止其过早释放\n\n三、WindowLevel\n\n　　UIWindow在显示的时候会根据UIWindowLevel进行排序的，即Level高的将排在所有Level比他低的层级的前面。下面我们来看UIWindowLevel的定义：\n\n```\n　　　　const UIWindowLevel UIWindowLevelNormal;\n　　　　const UIWindowLevel UIWindowLevelAlert;\n　　　　const UIWindowLevel UIWindowLevelStatusBar;\n　　　　typedef CGFloat UIWindowLevel;\n```\n\n　　[iOS](http://lib.csdn.net/base/swift)系统中定义了三个window层级，其中每一个层级又可以分好多子层级(从UIWindow的头文件中可以看到成员变量CGFloat _windowSublevel;)，不过系统并没有把则个属性开出来。UIWindow的默认级别是UIWindowLevelNormal，我们打印输出这三个level的值分别如下：\n\n\n\n1. 2012-03-27 22:46:08.752 UIViewSample[395:f803] Normal window level: 0.000000  \n2. 2012-03-27 22:46:08.754 UIViewSample[395:f803] Normal window level: 2000.000000  \n3. 2012-03-27 22:46:08.755 UIViewSample[395:f803] Normal window level: 1000.000000  \n\n　　这样印证了他们级别的高低顺序从小到大为Normal < StatusBar < Alert，下面请看小的测试代码：\n\n　　运行结果如下图：\n\n![img](http://pic002.cnblogs.com/images/2012/302680/2012032722535669.jpg)\n\n　　我们可以注意到两点：\n\n　　1）我们生成的normalWindow虽然是在第一个默认的window之后调用makeKeyAndVisible，但是仍然没有显示出来。这说明当Level层级相同的时候，只有第一个设置为KeyWindow的显示出来，后面同级的再设置KeyWindow也不会显示。\n\n　　2）statusLevelWindow在alertLevelWindow之后调用makeKeyAndVisible，淡仍然只是显示在alertLevelWindow的下方。这说明UIWindow在显示的时候是不管KeyWindow是谁，都是Level优先的，即Level最高的始终显示在最前面。\n\n","slug":"uiwindow-he-uiwindowlevelxiang-jie","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cj04pzyxd000hs04erzghhl0w","content":"<p>一、UIWindow是一种特殊的UIView，通常在一个程序中只会有一个UIWindow，但可以手动创建多个UIWindow，同时加到程序里面。UIWindow在程序中主要起到三个作用：</p>\n<p>　　1、作为容器，包含app所要显示的所有视图</p>\n<p>　　2、传递触摸消息到程序中view和其他对象</p>\n<p>　　3、与UIViewController协同工作，方便完成设备方向旋转的支持</p>\n<p>二、通常我们可以采取两种方法将view添加到UIWindow中：</p>\n<p>　　1、addSubview</p>\n<p>　　直接将view通过addSubview方式添加到window中，程序负责维护view的生命周期以及刷新，但是并不会为去理会view对应的ViewController，因此采用这种方法将view添加到window以后，我们还要保持view对应的ViewController的有效性，不能过早释放。</p>\n<p>　　2、rootViewController</p>\n<p>　　rootViewController时UIWindow的一个遍历方法，通过设置该属性为要添加view对应的ViewController，UIWindow将会自动将其view添加到当前window中，同时负责ViewController和view的生命周期的维护，防止其过早释放</p>\n<p>三、WindowLevel</p>\n<p>　　UIWindow在显示的时候会根据UIWindowLevel进行排序的，即Level高的将排在所有Level比他低的层级的前面。下面我们来看UIWindowLevel的定义：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">　　　　const UIWindowLevel UIWindowLevelNormal;</div><div class=\"line\">　　　　const UIWindowLevel UIWindowLevelAlert;</div><div class=\"line\">　　　　const UIWindowLevel UIWindowLevelStatusBar;</div><div class=\"line\">　　　　typedef CGFloat UIWindowLevel;</div></pre></td></tr></table></figure>\n<p>　　<a href=\"http://lib.csdn.net/base/swift\" target=\"_blank\" rel=\"external\">iOS</a>系统中定义了三个window层级，其中每一个层级又可以分好多子层级(从UIWindow的头文件中可以看到成员变量CGFloat _windowSublevel;)，不过系统并没有把则个属性开出来。UIWindow的默认级别是UIWindowLevelNormal，我们打印输出这三个level的值分别如下：</p>\n<ol>\n<li>2012-03-27 22:46:08.752 UIViewSample[395:f803] Normal window level: 0.000000  </li>\n<li>2012-03-27 22:46:08.754 UIViewSample[395:f803] Normal window level: 2000.000000  </li>\n<li>2012-03-27 22:46:08.755 UIViewSample[395:f803] Normal window level: 1000.000000  </li>\n</ol>\n<p>　　这样印证了他们级别的高低顺序从小到大为Normal &lt; StatusBar &lt; Alert，下面请看小的测试代码：</p>\n<p>　　运行结果如下图：</p>\n<p><img src=\"http://pic002.cnblogs.com/images/2012/302680/2012032722535669.jpg\" alt=\"img\"></p>\n<p>　　我们可以注意到两点：</p>\n<p>　　1）我们生成的normalWindow虽然是在第一个默认的window之后调用makeKeyAndVisible，但是仍然没有显示出来。这说明当Level层级相同的时候，只有第一个设置为KeyWindow的显示出来，后面同级的再设置KeyWindow也不会显示。</p>\n<p>　　2）statusLevelWindow在alertLevelWindow之后调用makeKeyAndVisible，淡仍然只是显示在alertLevelWindow的下方。这说明UIWindow在显示的时候是不管KeyWindow是谁，都是Level优先的，即Level最高的始终显示在最前面。</p>\n","excerpt":"","more":"<p>一、UIWindow是一种特殊的UIView，通常在一个程序中只会有一个UIWindow，但可以手动创建多个UIWindow，同时加到程序里面。UIWindow在程序中主要起到三个作用：</p>\n<p>　　1、作为容器，包含app所要显示的所有视图</p>\n<p>　　2、传递触摸消息到程序中view和其他对象</p>\n<p>　　3、与UIViewController协同工作，方便完成设备方向旋转的支持</p>\n<p>二、通常我们可以采取两种方法将view添加到UIWindow中：</p>\n<p>　　1、addSubview</p>\n<p>　　直接将view通过addSubview方式添加到window中，程序负责维护view的生命周期以及刷新，但是并不会为去理会view对应的ViewController，因此采用这种方法将view添加到window以后，我们还要保持view对应的ViewController的有效性，不能过早释放。</p>\n<p>　　2、rootViewController</p>\n<p>　　rootViewController时UIWindow的一个遍历方法，通过设置该属性为要添加view对应的ViewController，UIWindow将会自动将其view添加到当前window中，同时负责ViewController和view的生命周期的维护，防止其过早释放</p>\n<p>三、WindowLevel</p>\n<p>　　UIWindow在显示的时候会根据UIWindowLevel进行排序的，即Level高的将排在所有Level比他低的层级的前面。下面我们来看UIWindowLevel的定义：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">　　　　const UIWindowLevel UIWindowLevelNormal;</div><div class=\"line\">　　　　const UIWindowLevel UIWindowLevelAlert;</div><div class=\"line\">　　　　const UIWindowLevel UIWindowLevelStatusBar;</div><div class=\"line\">　　　　typedef CGFloat UIWindowLevel;</div></pre></td></tr></table></figure>\n<p>　　<a href=\"http://lib.csdn.net/base/swift\">iOS</a>系统中定义了三个window层级，其中每一个层级又可以分好多子层级(从UIWindow的头文件中可以看到成员变量CGFloat _windowSublevel;)，不过系统并没有把则个属性开出来。UIWindow的默认级别是UIWindowLevelNormal，我们打印输出这三个level的值分别如下：</p>\n<ol>\n<li>2012-03-27 22:46:08.752 UIViewSample[395:f803] Normal window level: 0.000000  </li>\n<li>2012-03-27 22:46:08.754 UIViewSample[395:f803] Normal window level: 2000.000000  </li>\n<li>2012-03-27 22:46:08.755 UIViewSample[395:f803] Normal window level: 1000.000000  </li>\n</ol>\n<p>　　这样印证了他们级别的高低顺序从小到大为Normal &lt; StatusBar &lt; Alert，下面请看小的测试代码：</p>\n<p>　　运行结果如下图：</p>\n<p><img src=\"http://pic002.cnblogs.com/images/2012/302680/2012032722535669.jpg\" alt=\"img\"></p>\n<p>　　我们可以注意到两点：</p>\n<p>　　1）我们生成的normalWindow虽然是在第一个默认的window之后调用makeKeyAndVisible，但是仍然没有显示出来。这说明当Level层级相同的时候，只有第一个设置为KeyWindow的显示出来，后面同级的再设置KeyWindow也不会显示。</p>\n<p>　　2）statusLevelWindow在alertLevelWindow之后调用makeKeyAndVisible，淡仍然只是显示在alertLevelWindow的下方。这说明UIWindow在显示的时候是不管KeyWindow是谁，都是Level优先的，即Level最高的始终显示在最前面。</p>\n"},{"title":"Xib加载的几种方法","id":"33","updated":"2016-08-25T04:50:56.000Z","date":"2016-08-13T07:00:33.000Z","_content":"\n\n\n> 一，本质\n\n xib本质是`XML`代码（在编译时`Xcode`将`xib`中内容转换成代码）\n\n注：如果一个`view`是从`xib`中加载出来的，默认`width`与`height`是`xib`中描述的尺寸，frame中(x,y)值默认为零\n\n> 二、控制器中加载xib\n\n加载方式一：\n\n```\nNSArray *newsArr = [[NSBundle mainBundle] loadNibNamed:@\"news\" owner:nil options:nil];\nUIView *newsView = newsArr.firstObject;\n```\n\n注：\n“`loadNibNamed:owner:options`” 方法返回值是一个`NSArray`，因为一个xib中可以放多个`view`，但一般情况我们都只放一个在`xib`中\n\n加载方式二：\n\n```\nUINib *nib = [UINib nibWithNibName:@\"news\" bundle:[NSBundle mainBundle]];//[NSBundle mainBundle]作为参数时，可以传nil，切记[NSBundle mainBundle]调用其他方法时不可以为nil，用nil调用方法等于什么操作都没做\nUIView *news = [[nib instantiateWithOwner:nil options:nil] firstObject];\n```\n\n> 三、使用xib加载view的注意事项\n\n1，如果一个`view`是从`xib`加载出来的，那么`xib`绑定的`View`初始化过程中，不会执行`init`方法和`initWithFrame`方法，因此在页面中如果通过 `alloc init` 来初始化该`view`，界面会是空白\n2，如果多个页面中用到该`view`，最好在`xib`绑定的类中提供快速创建的类方法\n\n```\n+ (instancetype)viewForXib\n{\n    return [[[NSBundle mainBundle] loadNibNamed:NSStringFromClass(self) owner:nil options:nil] firstObject];\n}\n```","source":"_posts/Xib加载的几种方法.md","raw":"---\ntitle: Xib加载的几种方法\npermalink: xibjia-zai-de-ji-chong-fang-fa\nid: 33\nupdated: '2016-08-25 12:50:56'\ndate: 2016-08-13 15:00:33\ntags:\n---\n\n\n\n> 一，本质\n\n xib本质是`XML`代码（在编译时`Xcode`将`xib`中内容转换成代码）\n\n注：如果一个`view`是从`xib`中加载出来的，默认`width`与`height`是`xib`中描述的尺寸，frame中(x,y)值默认为零\n\n> 二、控制器中加载xib\n\n加载方式一：\n\n```\nNSArray *newsArr = [[NSBundle mainBundle] loadNibNamed:@\"news\" owner:nil options:nil];\nUIView *newsView = newsArr.firstObject;\n```\n\n注：\n“`loadNibNamed:owner:options`” 方法返回值是一个`NSArray`，因为一个xib中可以放多个`view`，但一般情况我们都只放一个在`xib`中\n\n加载方式二：\n\n```\nUINib *nib = [UINib nibWithNibName:@\"news\" bundle:[NSBundle mainBundle]];//[NSBundle mainBundle]作为参数时，可以传nil，切记[NSBundle mainBundle]调用其他方法时不可以为nil，用nil调用方法等于什么操作都没做\nUIView *news = [[nib instantiateWithOwner:nil options:nil] firstObject];\n```\n\n> 三、使用xib加载view的注意事项\n\n1，如果一个`view`是从`xib`加载出来的，那么`xib`绑定的`View`初始化过程中，不会执行`init`方法和`initWithFrame`方法，因此在页面中如果通过 `alloc init` 来初始化该`view`，界面会是空白\n2，如果多个页面中用到该`view`，最好在`xib`绑定的类中提供快速创建的类方法\n\n```\n+ (instancetype)viewForXib\n{\n    return [[[NSBundle mainBundle] loadNibNamed:NSStringFromClass(self) owner:nil options:nil] firstObject];\n}\n```","slug":"xibjia-zai-de-ji-chong-fang-fa","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cj04pzyxh000js04eexpjgzya","content":"<blockquote>\n<p>一，本质</p>\n</blockquote>\n<p> xib本质是<code>XML</code>代码（在编译时<code>Xcode</code>将<code>xib</code>中内容转换成代码）</p>\n<p>注：如果一个<code>view</code>是从<code>xib</code>中加载出来的，默认<code>width</code>与<code>height</code>是<code>xib</code>中描述的尺寸，frame中(x,y)值默认为零</p>\n<blockquote>\n<p>二、控制器中加载xib</p>\n</blockquote>\n<p>加载方式一：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">NSArray *newsArr = [[NSBundle mainBundle] loadNibNamed:@&quot;news&quot; owner:nil options:nil];</div><div class=\"line\">UIView *newsView = newsArr.firstObject;</div></pre></td></tr></table></figure>\n<p>注：<br>“<code>loadNibNamed:owner:options</code>” 方法返回值是一个<code>NSArray</code>，因为一个xib中可以放多个<code>view</code>，但一般情况我们都只放一个在<code>xib</code>中</p>\n<p>加载方式二：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">UINib *nib = [UINib nibWithNibName:@&quot;news&quot; bundle:[NSBundle mainBundle]];//[NSBundle mainBundle]作为参数时，可以传nil，切记[NSBundle mainBundle]调用其他方法时不可以为nil，用nil调用方法等于什么操作都没做</div><div class=\"line\">UIView *news = [[nib instantiateWithOwner:nil options:nil] firstObject];</div></pre></td></tr></table></figure>\n<blockquote>\n<p>三、使用xib加载view的注意事项</p>\n</blockquote>\n<p>1，如果一个<code>view</code>是从<code>xib</code>加载出来的，那么<code>xib</code>绑定的<code>View</code>初始化过程中，不会执行<code>init</code>方法和<code>initWithFrame</code>方法，因此在页面中如果通过 <code>alloc init</code> 来初始化该<code>view</code>，界面会是空白<br>2，如果多个页面中用到该<code>view</code>，最好在<code>xib</code>绑定的类中提供快速创建的类方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">+ (instancetype)viewForXib</div><div class=\"line\">&#123;</div><div class=\"line\">    return [[[NSBundle mainBundle] loadNibNamed:NSStringFromClass(self) owner:nil options:nil] firstObject];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","excerpt":"","more":"<blockquote>\n<p>一，本质</p>\n</blockquote>\n<p> xib本质是<code>XML</code>代码（在编译时<code>Xcode</code>将<code>xib</code>中内容转换成代码）</p>\n<p>注：如果一个<code>view</code>是从<code>xib</code>中加载出来的，默认<code>width</code>与<code>height</code>是<code>xib</code>中描述的尺寸，frame中(x,y)值默认为零</p>\n<blockquote>\n<p>二、控制器中加载xib</p>\n</blockquote>\n<p>加载方式一：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">NSArray *newsArr = [[NSBundle mainBundle] loadNibNamed:@&quot;news&quot; owner:nil options:nil];</div><div class=\"line\">UIView *newsView = newsArr.firstObject;</div></pre></td></tr></table></figure>\n<p>注：<br>“<code>loadNibNamed:owner:options</code>” 方法返回值是一个<code>NSArray</code>，因为一个xib中可以放多个<code>view</code>，但一般情况我们都只放一个在<code>xib</code>中</p>\n<p>加载方式二：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">UINib *nib = [UINib nibWithNibName:@&quot;news&quot; bundle:[NSBundle mainBundle]];//[NSBundle mainBundle]作为参数时，可以传nil，切记[NSBundle mainBundle]调用其他方法时不可以为nil，用nil调用方法等于什么操作都没做</div><div class=\"line\">UIView *news = [[nib instantiateWithOwner:nil options:nil] firstObject];</div></pre></td></tr></table></figure>\n<blockquote>\n<p>三、使用xib加载view的注意事项</p>\n</blockquote>\n<p>1，如果一个<code>view</code>是从<code>xib</code>加载出来的，那么<code>xib</code>绑定的<code>View</code>初始化过程中，不会执行<code>init</code>方法和<code>initWithFrame</code>方法，因此在页面中如果通过 <code>alloc init</code> 来初始化该<code>view</code>，界面会是空白<br>2，如果多个页面中用到该<code>view</code>，最好在<code>xib</code>绑定的类中提供快速创建的类方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">+ (instancetype)viewForXib</div><div class=\"line\">&#123;</div><div class=\"line\">    return [[[NSBundle mainBundle] loadNibNamed:NSStringFromClass(self) owner:nil options:nil] firstObject];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"WWDC2016 随想","id":"14","updated":"2016-06-23T14:40:47.000Z","date":"2016-06-15T14:09:31.000Z","_content":"\n\n\n![](https://ooo.0o0.ooo/2016/06/15/5762136dd098c.jpg)\n\n凌晨 1 点钟，熬夜看了今年的 WWDC，一些随想分享给大家。\n\n###时光\n\n因为刚刚说的原因，结果我到 12 点都还没有睡着，我在迷迷糊糊中躺到了快一点钟，watch 震动了，于是我翻身走到客厅，打开电脑，连上直播地址。对了，还有一些朋友不知道直播地址，大家可以记一下，每年直播地址都是固定的：wwdc.apple.com 。\n\n由于英语不是特别过硬，还是选择了有同声中文字幕的优酷直播。这里要吐槽下优酷的直播分发真的做的挺差的，一起看直播的群友都表示看标清都卡。\n\n###内容\n\n这次的 WWDC keynote 主要分成 4 个部分，其实就是四个平台：watchOS, tvOS，macOS（原来叫 OS X）, iOS。整个分享中规中矩，分别给大家介绍一下我觉得值得关注的改进吧。\n\n###watchOS\n\n有些人觉得 watchOS离自己比较遥远,但是对于拥有apple watch 并且饱受启动应用缓慢之苦的我来说简直是天大的福音。\n\nwatchOS 推出了 watchOS 3，启动速度快了7倍，基本上是秒开，但是不知道耗电是不是也是更多了。关于这个，后续有一个 session 主题分享《Architecting for Performance on watchOS 3》https://developer.apple.com/videos/play/wwdc2016/227/，感兴趣的朋友可以关注。\n\n增加了 scribbles 功能，其实就是一种手写输入，手写居然还支持中文，我当时就在想：手表这么小的地方，你倒是写一个复杂一点的字试试看呢？我对此功能不太看好。\n\n别的改进都很小，比如增加了滑动更换主题，快速报警，现场还花大力气介绍一款叫 breathe 的应用，而这个应用就是指导你深呼吸的。不知道大家喜不喜欢，反正我是不会用的。\n\n###tvOS\n\n这部分直接跳过吧，原因你懂的。\n\n\n\n###macOS\n\nOS X 更名为了 macOS，可以支持通过 apple watch 解锁电脑了。哦耶，我的手表终于不再只是用来看时间了 !\n\n\n<!------MORE------->\n\n\n剪切版支持从手机上复制，在电脑上粘贴，这个还是挺有用的，我平常都是用 QQ 或微信的文件传输助手做类似的事情。\n\noptimize storage 功能可以把老文件自动存在云端，据说可以节省大概 100G 的空间。不过我猜想，iCloud 的免费空间应该不够用吧？是不是得花钱买些容量才行。\n\napple pay 可以在 PC 的浏览器上直接支付，点击支付时，需要在手机上确认授权。整个体验类似于拿微信或支付宝扫二维码付款。\n\nsiri 可以在 mac 上使用了，并且 siri 的结果可以 pin 在一个列表中，并可以拖动到别的地方。我有一阵子很喜欢用 iPhone 上的 siri，不过还是不太稳定。mac 上一般办公室是不太方便用 siri 的，家里的话要是没有培养出习惯，估计也不太会使用。所以这个功能到底实用性有多大还不确定。\n\n增加了一个名为 picture in picture 的功能，其实就是看视频的时候可以固定住视频。\n\n###iOS\n\n介绍了 10 个特性，我选一些有意思的介绍吧。\n\nSiri 可以和微信整合，这个很赞，你可以直接用 siri 控制发信息给微信中的好友。\n\n系统的 Map 整合了大量的应用，比如可以在上面看大众点评的评价，可以直接叫滴滴打车。如果做得好，Map 很可能成为一个重要的打车入口，想到这儿就能明白为什么苹果投了滴滴 10 亿美金了。\n\n不过就苹果系统 Map 的那个糟糕体验，我不确定我是否能够接受它。反正我已经喜欢上了高德地图里面的郭德纲和林志玲的声音，离线的地图和导航也很适合中国这种按流量计费的移动网络环境。相比而言，系统自带的 Map 有些不接地气。\n\nhomekit 与智能家居的整合，整体的效果非常酷，但整个还需要依赖生态产业的配合。当前来看，国内的小米在这方面做得比苹果还是要快一些。\n\n电话功能终于支持恶意电话提醒了，现场提到用的是腾讯的解决方案。嗯，360 估计是没有翻身的可能了（可能和小周在库克面前炫耀360手机多好用有关）。另外，phone  extension 似乎可以做更多的事情。\n\niMessage 可以发更多的内容，tap to replace to emoji 功能的交互设计还是挺有意思的，省却了选择 emoji 的时间。不过现场演示出现了 Bug，还是挺尴尬的。另外，大家都已经习惯了微信，而且 iMessage 只能和 iPhone 用户发，我觉得这些功能做得再有意思，也没有多大用。大家的直觉还是用微信来社交。\n\n中国元素\n\n这次 WWDC 中多次提到了中国，以及中国的互联网产品，包括微信，大众点评，滴滴。中国为苹果的赢收增长做出了巨大的贡献，我们也能看到苹果越来越重视中国区的需求了。比如恶意来电提醒，就是一个特别针对中国区用户的设计。\n\n###Developer\n\n这次 Tim Cook 专门介绍了针对开发者做的 iPad 版的 Swift Playground，其实这哪是一个 Playground 啊，这就是一个学习编程的 3D 游戏！整个 App 设计得非常用心，效果看起来也非常棒。\n\n不过 Tim Cook 毕竟是做销售出身的，他不明白，其实我们真正关心的是，Swift 3 什么时候推出啊！结果他在 keynote 上啥都没说，让我们以为 Swift 3 没戏了，结果，我们事后又发现 Swift 3 的内容安静地躺在苹果的官方网站上：https://developer.apple.com/swift/ 。所以说，Tim Cook 还是不了解我们， iPad 版的 Swift Playground 太酷，那也就是给小孩学编程入门用的，大量的程序员还是关心的是 Swift 啥时候稳定，Xcode 有啥有意思的功能不，这些都被 Cook 给忽视了。\n\n还算我眼睛尖，我在他的一页大量的 feature list 中，看到了下面的一行字：\n\n这意味着，Xcode 终于官方支持插件了！妈妈再也不用担心升级 Xcode 的时候插件失效了！我今天翻了一下日程，WWDC 中专门有一个 session 做相关的介绍，是：《Using and Extending the Xcode Source Editor》\nhttps://developer.apple.com/videos/play/wwdc2016/414/\n\n###结语\n\n最后看完 WWDC，已经是零辰 3 点钟了，有一点点失落。今年的内容惊喜不多，但是，我终归是又一次熬夜观看了直播。希望自己能保持这样对技术的激情，也希望苹果明年的 WWDC 能有一些惊喜。\n\n哦，我整理了一个后续值得观注的 session 列表，分享给大家：\n\n\nImproving Existing Apps with Modern Best Practices\nhttps://developer.apple.com/videos/play/wwdc2016/213/\n\nWhat’s New in Cocoa Touch\nhttps://developer.apple.com/videos/play/wwdc2016/205/\n\nWhat’s New in Foundation for Swift\nhttps://developer.apple.com/videos/play/wwdc2016/207/\n\nWhat’s New in UICollectionView in iOS 10\nhttps://developer.apple.com/videos/play/wwdc2016/219/\n\nTypography and Fonts\nhttps://developer.apple.com/videos/play/wwdc2016/803/\n\nAdvanced Testing and Continuous Integration\nhttps://developer.apple.com/videos/play/wwdc2016/409/\n\nDebugging Tips and Tricks\nhttps://developer.apple.com/videos/play/wwdc2016/417/\n\nGetting Started with Swift ( 有最新 Swift 3 的内容）\nhttps://developer.apple.com/videos/play/wwdc2016/404/\n\nGoing Server-side with Swift Open Source\nhttps://developer.apple.com/videos/play/wwdc2016/415/\n\nIntroduction to Xcode ( 看看 Xcode 8 的新功能有啥）\nhttps://developer.apple.com/videos/play/wwdc2016/413/\n\nSwift API Design Guidelines\nhttps://developer.apple.com/videos/play/wwdc2016/403/\n\nUnderstanding Swift Performance\nhttps://developer.apple.com/videos/play/wwdc2016/416/\n\nUsing and Extending the Xcode Source Editor（了解 Xcode 编辑器的插件功能）\nhttps://developer.apple.com/videos/play/wwdc2016/414/\n\nWhat’s New in LLVM\nhttps://developer.apple.com/videos/play/wwdc2016/405/\n\nWhat’s New in Swift\nhttps://developer.apple.com/videos/play/wwdc2016/402/\n\nWhat’s New in Xcode App Signing\nhttps://developer.apple.com/videos/play/wwdc2016/401/\n\nConcurrent Programming With GCD in Swift 3\nhttps://developer.apple.com/videos/play/wwdc2016/720/\n\nNSURLSession: New Features and Best Practices\nhttps://developer.apple.com/videos/play/wwdc2016/711/\n\n","source":"_posts/WWDC2016-随想.md","raw":"---\ntitle: WWDC2016 随想\ntags: 'Apple.Inc'\npermalink: wwdc2016-sui-xiang\nid: 14\nupdated: '2016-06-23 22:40:47'\ndate: 2016-06-15 22:09:31\n---\n\n\n\n![](https://ooo.0o0.ooo/2016/06/15/5762136dd098c.jpg)\n\n凌晨 1 点钟，熬夜看了今年的 WWDC，一些随想分享给大家。\n\n###时光\n\n因为刚刚说的原因，结果我到 12 点都还没有睡着，我在迷迷糊糊中躺到了快一点钟，watch 震动了，于是我翻身走到客厅，打开电脑，连上直播地址。对了，还有一些朋友不知道直播地址，大家可以记一下，每年直播地址都是固定的：wwdc.apple.com 。\n\n由于英语不是特别过硬，还是选择了有同声中文字幕的优酷直播。这里要吐槽下优酷的直播分发真的做的挺差的，一起看直播的群友都表示看标清都卡。\n\n###内容\n\n这次的 WWDC keynote 主要分成 4 个部分，其实就是四个平台：watchOS, tvOS，macOS（原来叫 OS X）, iOS。整个分享中规中矩，分别给大家介绍一下我觉得值得关注的改进吧。\n\n###watchOS\n\n有些人觉得 watchOS离自己比较遥远,但是对于拥有apple watch 并且饱受启动应用缓慢之苦的我来说简直是天大的福音。\n\nwatchOS 推出了 watchOS 3，启动速度快了7倍，基本上是秒开，但是不知道耗电是不是也是更多了。关于这个，后续有一个 session 主题分享《Architecting for Performance on watchOS 3》https://developer.apple.com/videos/play/wwdc2016/227/，感兴趣的朋友可以关注。\n\n增加了 scribbles 功能，其实就是一种手写输入，手写居然还支持中文，我当时就在想：手表这么小的地方，你倒是写一个复杂一点的字试试看呢？我对此功能不太看好。\n\n别的改进都很小，比如增加了滑动更换主题，快速报警，现场还花大力气介绍一款叫 breathe 的应用，而这个应用就是指导你深呼吸的。不知道大家喜不喜欢，反正我是不会用的。\n\n###tvOS\n\n这部分直接跳过吧，原因你懂的。\n\n\n\n###macOS\n\nOS X 更名为了 macOS，可以支持通过 apple watch 解锁电脑了。哦耶，我的手表终于不再只是用来看时间了 !\n\n\n<!------MORE------->\n\n\n剪切版支持从手机上复制，在电脑上粘贴，这个还是挺有用的，我平常都是用 QQ 或微信的文件传输助手做类似的事情。\n\noptimize storage 功能可以把老文件自动存在云端，据说可以节省大概 100G 的空间。不过我猜想，iCloud 的免费空间应该不够用吧？是不是得花钱买些容量才行。\n\napple pay 可以在 PC 的浏览器上直接支付，点击支付时，需要在手机上确认授权。整个体验类似于拿微信或支付宝扫二维码付款。\n\nsiri 可以在 mac 上使用了，并且 siri 的结果可以 pin 在一个列表中，并可以拖动到别的地方。我有一阵子很喜欢用 iPhone 上的 siri，不过还是不太稳定。mac 上一般办公室是不太方便用 siri 的，家里的话要是没有培养出习惯，估计也不太会使用。所以这个功能到底实用性有多大还不确定。\n\n增加了一个名为 picture in picture 的功能，其实就是看视频的时候可以固定住视频。\n\n###iOS\n\n介绍了 10 个特性，我选一些有意思的介绍吧。\n\nSiri 可以和微信整合，这个很赞，你可以直接用 siri 控制发信息给微信中的好友。\n\n系统的 Map 整合了大量的应用，比如可以在上面看大众点评的评价，可以直接叫滴滴打车。如果做得好，Map 很可能成为一个重要的打车入口，想到这儿就能明白为什么苹果投了滴滴 10 亿美金了。\n\n不过就苹果系统 Map 的那个糟糕体验，我不确定我是否能够接受它。反正我已经喜欢上了高德地图里面的郭德纲和林志玲的声音，离线的地图和导航也很适合中国这种按流量计费的移动网络环境。相比而言，系统自带的 Map 有些不接地气。\n\nhomekit 与智能家居的整合，整体的效果非常酷，但整个还需要依赖生态产业的配合。当前来看，国内的小米在这方面做得比苹果还是要快一些。\n\n电话功能终于支持恶意电话提醒了，现场提到用的是腾讯的解决方案。嗯，360 估计是没有翻身的可能了（可能和小周在库克面前炫耀360手机多好用有关）。另外，phone  extension 似乎可以做更多的事情。\n\niMessage 可以发更多的内容，tap to replace to emoji 功能的交互设计还是挺有意思的，省却了选择 emoji 的时间。不过现场演示出现了 Bug，还是挺尴尬的。另外，大家都已经习惯了微信，而且 iMessage 只能和 iPhone 用户发，我觉得这些功能做得再有意思，也没有多大用。大家的直觉还是用微信来社交。\n\n中国元素\n\n这次 WWDC 中多次提到了中国，以及中国的互联网产品，包括微信，大众点评，滴滴。中国为苹果的赢收增长做出了巨大的贡献，我们也能看到苹果越来越重视中国区的需求了。比如恶意来电提醒，就是一个特别针对中国区用户的设计。\n\n###Developer\n\n这次 Tim Cook 专门介绍了针对开发者做的 iPad 版的 Swift Playground，其实这哪是一个 Playground 啊，这就是一个学习编程的 3D 游戏！整个 App 设计得非常用心，效果看起来也非常棒。\n\n不过 Tim Cook 毕竟是做销售出身的，他不明白，其实我们真正关心的是，Swift 3 什么时候推出啊！结果他在 keynote 上啥都没说，让我们以为 Swift 3 没戏了，结果，我们事后又发现 Swift 3 的内容安静地躺在苹果的官方网站上：https://developer.apple.com/swift/ 。所以说，Tim Cook 还是不了解我们， iPad 版的 Swift Playground 太酷，那也就是给小孩学编程入门用的，大量的程序员还是关心的是 Swift 啥时候稳定，Xcode 有啥有意思的功能不，这些都被 Cook 给忽视了。\n\n还算我眼睛尖，我在他的一页大量的 feature list 中，看到了下面的一行字：\n\n这意味着，Xcode 终于官方支持插件了！妈妈再也不用担心升级 Xcode 的时候插件失效了！我今天翻了一下日程，WWDC 中专门有一个 session 做相关的介绍，是：《Using and Extending the Xcode Source Editor》\nhttps://developer.apple.com/videos/play/wwdc2016/414/\n\n###结语\n\n最后看完 WWDC，已经是零辰 3 点钟了，有一点点失落。今年的内容惊喜不多，但是，我终归是又一次熬夜观看了直播。希望自己能保持这样对技术的激情，也希望苹果明年的 WWDC 能有一些惊喜。\n\n哦，我整理了一个后续值得观注的 session 列表，分享给大家：\n\n\nImproving Existing Apps with Modern Best Practices\nhttps://developer.apple.com/videos/play/wwdc2016/213/\n\nWhat’s New in Cocoa Touch\nhttps://developer.apple.com/videos/play/wwdc2016/205/\n\nWhat’s New in Foundation for Swift\nhttps://developer.apple.com/videos/play/wwdc2016/207/\n\nWhat’s New in UICollectionView in iOS 10\nhttps://developer.apple.com/videos/play/wwdc2016/219/\n\nTypography and Fonts\nhttps://developer.apple.com/videos/play/wwdc2016/803/\n\nAdvanced Testing and Continuous Integration\nhttps://developer.apple.com/videos/play/wwdc2016/409/\n\nDebugging Tips and Tricks\nhttps://developer.apple.com/videos/play/wwdc2016/417/\n\nGetting Started with Swift ( 有最新 Swift 3 的内容）\nhttps://developer.apple.com/videos/play/wwdc2016/404/\n\nGoing Server-side with Swift Open Source\nhttps://developer.apple.com/videos/play/wwdc2016/415/\n\nIntroduction to Xcode ( 看看 Xcode 8 的新功能有啥）\nhttps://developer.apple.com/videos/play/wwdc2016/413/\n\nSwift API Design Guidelines\nhttps://developer.apple.com/videos/play/wwdc2016/403/\n\nUnderstanding Swift Performance\nhttps://developer.apple.com/videos/play/wwdc2016/416/\n\nUsing and Extending the Xcode Source Editor（了解 Xcode 编辑器的插件功能）\nhttps://developer.apple.com/videos/play/wwdc2016/414/\n\nWhat’s New in LLVM\nhttps://developer.apple.com/videos/play/wwdc2016/405/\n\nWhat’s New in Swift\nhttps://developer.apple.com/videos/play/wwdc2016/402/\n\nWhat’s New in Xcode App Signing\nhttps://developer.apple.com/videos/play/wwdc2016/401/\n\nConcurrent Programming With GCD in Swift 3\nhttps://developer.apple.com/videos/play/wwdc2016/720/\n\nNSURLSession: New Features and Best Practices\nhttps://developer.apple.com/videos/play/wwdc2016/711/\n\n","slug":"wwdc2016-sui-xiang","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cj04pzyxk000ls04ej3ini6v8","content":"<p><img src=\"https://ooo.0o0.ooo/2016/06/15/5762136dd098c.jpg\" alt=\"\"></p>\n<p>凌晨 1 点钟，熬夜看了今年的 WWDC，一些随想分享给大家。</p>\n<p>###时光</p>\n<p>因为刚刚说的原因，结果我到 12 点都还没有睡着，我在迷迷糊糊中躺到了快一点钟，watch 震动了，于是我翻身走到客厅，打开电脑，连上直播地址。对了，还有一些朋友不知道直播地址，大家可以记一下，每年直播地址都是固定的：wwdc.apple.com 。</p>\n<p>由于英语不是特别过硬，还是选择了有同声中文字幕的优酷直播。这里要吐槽下优酷的直播分发真的做的挺差的，一起看直播的群友都表示看标清都卡。</p>\n<p>###内容</p>\n<p>这次的 WWDC keynote 主要分成 4 个部分，其实就是四个平台：watchOS, tvOS，macOS（原来叫 OS X）, iOS。整个分享中规中矩，分别给大家介绍一下我觉得值得关注的改进吧。</p>\n<p>###watchOS</p>\n<p>有些人觉得 watchOS离自己比较遥远,但是对于拥有apple watch 并且饱受启动应用缓慢之苦的我来说简直是天大的福音。</p>\n<p>watchOS 推出了 watchOS 3，启动速度快了7倍，基本上是秒开，但是不知道耗电是不是也是更多了。关于这个，后续有一个 session 主题分享《Architecting for Performance on watchOS 3》<a href=\"https://developer.apple.com/videos/play/wwdc2016/227/，感兴趣的朋友可以关注。\" target=\"_blank\" rel=\"external\">https://developer.apple.com/videos/play/wwdc2016/227/，感兴趣的朋友可以关注。</a></p>\n<p>增加了 scribbles 功能，其实就是一种手写输入，手写居然还支持中文，我当时就在想：手表这么小的地方，你倒是写一个复杂一点的字试试看呢？我对此功能不太看好。</p>\n<p>别的改进都很小，比如增加了滑动更换主题，快速报警，现场还花大力气介绍一款叫 breathe 的应用，而这个应用就是指导你深呼吸的。不知道大家喜不喜欢，反正我是不会用的。</p>\n<p>###tvOS</p>\n<p>这部分直接跳过吧，原因你懂的。</p>\n<p>###macOS</p>\n<p>OS X 更名为了 macOS，可以支持通过 apple watch 解锁电脑了。哦耶，我的手表终于不再只是用来看时间了 !</p>\n<a id=\"more\"></a>\n<p>剪切版支持从手机上复制，在电脑上粘贴，这个还是挺有用的，我平常都是用 QQ 或微信的文件传输助手做类似的事情。</p>\n<p>optimize storage 功能可以把老文件自动存在云端，据说可以节省大概 100G 的空间。不过我猜想，iCloud 的免费空间应该不够用吧？是不是得花钱买些容量才行。</p>\n<p>apple pay 可以在 PC 的浏览器上直接支付，点击支付时，需要在手机上确认授权。整个体验类似于拿微信或支付宝扫二维码付款。</p>\n<p>siri 可以在 mac 上使用了，并且 siri 的结果可以 pin 在一个列表中，并可以拖动到别的地方。我有一阵子很喜欢用 iPhone 上的 siri，不过还是不太稳定。mac 上一般办公室是不太方便用 siri 的，家里的话要是没有培养出习惯，估计也不太会使用。所以这个功能到底实用性有多大还不确定。</p>\n<p>增加了一个名为 picture in picture 的功能，其实就是看视频的时候可以固定住视频。</p>\n<p>###iOS</p>\n<p>介绍了 10 个特性，我选一些有意思的介绍吧。</p>\n<p>Siri 可以和微信整合，这个很赞，你可以直接用 siri 控制发信息给微信中的好友。</p>\n<p>系统的 Map 整合了大量的应用，比如可以在上面看大众点评的评价，可以直接叫滴滴打车。如果做得好，Map 很可能成为一个重要的打车入口，想到这儿就能明白为什么苹果投了滴滴 10 亿美金了。</p>\n<p>不过就苹果系统 Map 的那个糟糕体验，我不确定我是否能够接受它。反正我已经喜欢上了高德地图里面的郭德纲和林志玲的声音，离线的地图和导航也很适合中国这种按流量计费的移动网络环境。相比而言，系统自带的 Map 有些不接地气。</p>\n<p>homekit 与智能家居的整合，整体的效果非常酷，但整个还需要依赖生态产业的配合。当前来看，国内的小米在这方面做得比苹果还是要快一些。</p>\n<p>电话功能终于支持恶意电话提醒了，现场提到用的是腾讯的解决方案。嗯，360 估计是没有翻身的可能了（可能和小周在库克面前炫耀360手机多好用有关）。另外，phone  extension 似乎可以做更多的事情。</p>\n<p>iMessage 可以发更多的内容，tap to replace to emoji 功能的交互设计还是挺有意思的，省却了选择 emoji 的时间。不过现场演示出现了 Bug，还是挺尴尬的。另外，大家都已经习惯了微信，而且 iMessage 只能和 iPhone 用户发，我觉得这些功能做得再有意思，也没有多大用。大家的直觉还是用微信来社交。</p>\n<p>中国元素</p>\n<p>这次 WWDC 中多次提到了中国，以及中国的互联网产品，包括微信，大众点评，滴滴。中国为苹果的赢收增长做出了巨大的贡献，我们也能看到苹果越来越重视中国区的需求了。比如恶意来电提醒，就是一个特别针对中国区用户的设计。</p>\n<p>###Developer</p>\n<p>这次 Tim Cook 专门介绍了针对开发者做的 iPad 版的 Swift Playground，其实这哪是一个 Playground 啊，这就是一个学习编程的 3D 游戏！整个 App 设计得非常用心，效果看起来也非常棒。</p>\n<p>不过 Tim Cook 毕竟是做销售出身的，他不明白，其实我们真正关心的是，Swift 3 什么时候推出啊！结果他在 keynote 上啥都没说，让我们以为 Swift 3 没戏了，结果，我们事后又发现 Swift 3 的内容安静地躺在苹果的官方网站上：<a href=\"https://developer.apple.com/swift/\" target=\"_blank\" rel=\"external\">https://developer.apple.com/swift/</a> 。所以说，Tim Cook 还是不了解我们， iPad 版的 Swift Playground 太酷，那也就是给小孩学编程入门用的，大量的程序员还是关心的是 Swift 啥时候稳定，Xcode 有啥有意思的功能不，这些都被 Cook 给忽视了。</p>\n<p>还算我眼睛尖，我在他的一页大量的 feature list 中，看到了下面的一行字：</p>\n<p>这意味着，Xcode 终于官方支持插件了！妈妈再也不用担心升级 Xcode 的时候插件失效了！我今天翻了一下日程，WWDC 中专门有一个 session 做相关的介绍，是：《Using and Extending the Xcode Source Editor》<br><a href=\"https://developer.apple.com/videos/play/wwdc2016/414/\" target=\"_blank\" rel=\"external\">https://developer.apple.com/videos/play/wwdc2016/414/</a></p>\n<p>###结语</p>\n<p>最后看完 WWDC，已经是零辰 3 点钟了，有一点点失落。今年的内容惊喜不多，但是，我终归是又一次熬夜观看了直播。希望自己能保持这样对技术的激情，也希望苹果明年的 WWDC 能有一些惊喜。</p>\n<p>哦，我整理了一个后续值得观注的 session 列表，分享给大家：</p>\n<p>Improving Existing Apps with Modern Best Practices<br><a href=\"https://developer.apple.com/videos/play/wwdc2016/213/\" target=\"_blank\" rel=\"external\">https://developer.apple.com/videos/play/wwdc2016/213/</a></p>\n<p>What’s New in Cocoa Touch<br><a href=\"https://developer.apple.com/videos/play/wwdc2016/205/\" target=\"_blank\" rel=\"external\">https://developer.apple.com/videos/play/wwdc2016/205/</a></p>\n<p>What’s New in Foundation for Swift<br><a href=\"https://developer.apple.com/videos/play/wwdc2016/207/\" target=\"_blank\" rel=\"external\">https://developer.apple.com/videos/play/wwdc2016/207/</a></p>\n<p>What’s New in UICollectionView in iOS 10<br><a href=\"https://developer.apple.com/videos/play/wwdc2016/219/\" target=\"_blank\" rel=\"external\">https://developer.apple.com/videos/play/wwdc2016/219/</a></p>\n<p>Typography and Fonts<br><a href=\"https://developer.apple.com/videos/play/wwdc2016/803/\" target=\"_blank\" rel=\"external\">https://developer.apple.com/videos/play/wwdc2016/803/</a></p>\n<p>Advanced Testing and Continuous Integration<br><a href=\"https://developer.apple.com/videos/play/wwdc2016/409/\" target=\"_blank\" rel=\"external\">https://developer.apple.com/videos/play/wwdc2016/409/</a></p>\n<p>Debugging Tips and Tricks<br><a href=\"https://developer.apple.com/videos/play/wwdc2016/417/\" target=\"_blank\" rel=\"external\">https://developer.apple.com/videos/play/wwdc2016/417/</a></p>\n<p>Getting Started with Swift ( 有最新 Swift 3 的内容）<br><a href=\"https://developer.apple.com/videos/play/wwdc2016/404/\" target=\"_blank\" rel=\"external\">https://developer.apple.com/videos/play/wwdc2016/404/</a></p>\n<p>Going Server-side with Swift Open Source<br><a href=\"https://developer.apple.com/videos/play/wwdc2016/415/\" target=\"_blank\" rel=\"external\">https://developer.apple.com/videos/play/wwdc2016/415/</a></p>\n<p>Introduction to Xcode ( 看看 Xcode 8 的新功能有啥）<br><a href=\"https://developer.apple.com/videos/play/wwdc2016/413/\" target=\"_blank\" rel=\"external\">https://developer.apple.com/videos/play/wwdc2016/413/</a></p>\n<p>Swift API Design Guidelines<br><a href=\"https://developer.apple.com/videos/play/wwdc2016/403/\" target=\"_blank\" rel=\"external\">https://developer.apple.com/videos/play/wwdc2016/403/</a></p>\n<p>Understanding Swift Performance<br><a href=\"https://developer.apple.com/videos/play/wwdc2016/416/\" target=\"_blank\" rel=\"external\">https://developer.apple.com/videos/play/wwdc2016/416/</a></p>\n<p>Using and Extending the Xcode Source Editor（了解 Xcode 编辑器的插件功能）<br><a href=\"https://developer.apple.com/videos/play/wwdc2016/414/\" target=\"_blank\" rel=\"external\">https://developer.apple.com/videos/play/wwdc2016/414/</a></p>\n<p>What’s New in LLVM<br><a href=\"https://developer.apple.com/videos/play/wwdc2016/405/\" target=\"_blank\" rel=\"external\">https://developer.apple.com/videos/play/wwdc2016/405/</a></p>\n<p>What’s New in Swift<br><a href=\"https://developer.apple.com/videos/play/wwdc2016/402/\" target=\"_blank\" rel=\"external\">https://developer.apple.com/videos/play/wwdc2016/402/</a></p>\n<p>What’s New in Xcode App Signing<br><a href=\"https://developer.apple.com/videos/play/wwdc2016/401/\" target=\"_blank\" rel=\"external\">https://developer.apple.com/videos/play/wwdc2016/401/</a></p>\n<p>Concurrent Programming With GCD in Swift 3<br><a href=\"https://developer.apple.com/videos/play/wwdc2016/720/\" target=\"_blank\" rel=\"external\">https://developer.apple.com/videos/play/wwdc2016/720/</a></p>\n<p>NSURLSession: New Features and Best Practices<br><a href=\"https://developer.apple.com/videos/play/wwdc2016/711/\" target=\"_blank\" rel=\"external\">https://developer.apple.com/videos/play/wwdc2016/711/</a></p>\n","excerpt":"<p><img src=\"https://ooo.0o0.ooo/2016/06/15/5762136dd098c.jpg\" alt=\"\"></p>\n<p>凌晨 1 点钟，熬夜看了今年的 WWDC，一些随想分享给大家。</p>\n<p>###时光</p>\n<p>因为刚刚说的原因，结果我到 12 点都还没有睡着，我在迷迷糊糊中躺到了快一点钟，watch 震动了，于是我翻身走到客厅，打开电脑，连上直播地址。对了，还有一些朋友不知道直播地址，大家可以记一下，每年直播地址都是固定的：wwdc.apple.com 。</p>\n<p>由于英语不是特别过硬，还是选择了有同声中文字幕的优酷直播。这里要吐槽下优酷的直播分发真的做的挺差的，一起看直播的群友都表示看标清都卡。</p>\n<p>###内容</p>\n<p>这次的 WWDC keynote 主要分成 4 个部分，其实就是四个平台：watchOS, tvOS，macOS（原来叫 OS X）, iOS。整个分享中规中矩，分别给大家介绍一下我觉得值得关注的改进吧。</p>\n<p>###watchOS</p>\n<p>有些人觉得 watchOS离自己比较遥远,但是对于拥有apple watch 并且饱受启动应用缓慢之苦的我来说简直是天大的福音。</p>\n<p>watchOS 推出了 watchOS 3，启动速度快了7倍，基本上是秒开，但是不知道耗电是不是也是更多了。关于这个，后续有一个 session 主题分享《Architecting for Performance on watchOS 3》<a href=\"https://developer.apple.com/videos/play/wwdc2016/227/，感兴趣的朋友可以关注。\">https://developer.apple.com/videos/play/wwdc2016/227/，感兴趣的朋友可以关注。</a></p>\n<p>增加了 scribbles 功能，其实就是一种手写输入，手写居然还支持中文，我当时就在想：手表这么小的地方，你倒是写一个复杂一点的字试试看呢？我对此功能不太看好。</p>\n<p>别的改进都很小，比如增加了滑动更换主题，快速报警，现场还花大力气介绍一款叫 breathe 的应用，而这个应用就是指导你深呼吸的。不知道大家喜不喜欢，反正我是不会用的。</p>\n<p>###tvOS</p>\n<p>这部分直接跳过吧，原因你懂的。</p>\n<p>###macOS</p>\n<p>OS X 更名为了 macOS，可以支持通过 apple watch 解锁电脑了。哦耶，我的手表终于不再只是用来看时间了 !</p>","more":"<p>剪切版支持从手机上复制，在电脑上粘贴，这个还是挺有用的，我平常都是用 QQ 或微信的文件传输助手做类似的事情。</p>\n<p>optimize storage 功能可以把老文件自动存在云端，据说可以节省大概 100G 的空间。不过我猜想，iCloud 的免费空间应该不够用吧？是不是得花钱买些容量才行。</p>\n<p>apple pay 可以在 PC 的浏览器上直接支付，点击支付时，需要在手机上确认授权。整个体验类似于拿微信或支付宝扫二维码付款。</p>\n<p>siri 可以在 mac 上使用了，并且 siri 的结果可以 pin 在一个列表中，并可以拖动到别的地方。我有一阵子很喜欢用 iPhone 上的 siri，不过还是不太稳定。mac 上一般办公室是不太方便用 siri 的，家里的话要是没有培养出习惯，估计也不太会使用。所以这个功能到底实用性有多大还不确定。</p>\n<p>增加了一个名为 picture in picture 的功能，其实就是看视频的时候可以固定住视频。</p>\n<p>###iOS</p>\n<p>介绍了 10 个特性，我选一些有意思的介绍吧。</p>\n<p>Siri 可以和微信整合，这个很赞，你可以直接用 siri 控制发信息给微信中的好友。</p>\n<p>系统的 Map 整合了大量的应用，比如可以在上面看大众点评的评价，可以直接叫滴滴打车。如果做得好，Map 很可能成为一个重要的打车入口，想到这儿就能明白为什么苹果投了滴滴 10 亿美金了。</p>\n<p>不过就苹果系统 Map 的那个糟糕体验，我不确定我是否能够接受它。反正我已经喜欢上了高德地图里面的郭德纲和林志玲的声音，离线的地图和导航也很适合中国这种按流量计费的移动网络环境。相比而言，系统自带的 Map 有些不接地气。</p>\n<p>homekit 与智能家居的整合，整体的效果非常酷，但整个还需要依赖生态产业的配合。当前来看，国内的小米在这方面做得比苹果还是要快一些。</p>\n<p>电话功能终于支持恶意电话提醒了，现场提到用的是腾讯的解决方案。嗯，360 估计是没有翻身的可能了（可能和小周在库克面前炫耀360手机多好用有关）。另外，phone  extension 似乎可以做更多的事情。</p>\n<p>iMessage 可以发更多的内容，tap to replace to emoji 功能的交互设计还是挺有意思的，省却了选择 emoji 的时间。不过现场演示出现了 Bug，还是挺尴尬的。另外，大家都已经习惯了微信，而且 iMessage 只能和 iPhone 用户发，我觉得这些功能做得再有意思，也没有多大用。大家的直觉还是用微信来社交。</p>\n<p>中国元素</p>\n<p>这次 WWDC 中多次提到了中国，以及中国的互联网产品，包括微信，大众点评，滴滴。中国为苹果的赢收增长做出了巨大的贡献，我们也能看到苹果越来越重视中国区的需求了。比如恶意来电提醒，就是一个特别针对中国区用户的设计。</p>\n<p>###Developer</p>\n<p>这次 Tim Cook 专门介绍了针对开发者做的 iPad 版的 Swift Playground，其实这哪是一个 Playground 啊，这就是一个学习编程的 3D 游戏！整个 App 设计得非常用心，效果看起来也非常棒。</p>\n<p>不过 Tim Cook 毕竟是做销售出身的，他不明白，其实我们真正关心的是，Swift 3 什么时候推出啊！结果他在 keynote 上啥都没说，让我们以为 Swift 3 没戏了，结果，我们事后又发现 Swift 3 的内容安静地躺在苹果的官方网站上：<a href=\"https://developer.apple.com/swift/\">https://developer.apple.com/swift/</a> 。所以说，Tim Cook 还是不了解我们， iPad 版的 Swift Playground 太酷，那也就是给小孩学编程入门用的，大量的程序员还是关心的是 Swift 啥时候稳定，Xcode 有啥有意思的功能不，这些都被 Cook 给忽视了。</p>\n<p>还算我眼睛尖，我在他的一页大量的 feature list 中，看到了下面的一行字：</p>\n<p>这意味着，Xcode 终于官方支持插件了！妈妈再也不用担心升级 Xcode 的时候插件失效了！我今天翻了一下日程，WWDC 中专门有一个 session 做相关的介绍，是：《Using and Extending the Xcode Source Editor》<br><a href=\"https://developer.apple.com/videos/play/wwdc2016/414/\">https://developer.apple.com/videos/play/wwdc2016/414/</a></p>\n<p>###结语</p>\n<p>最后看完 WWDC，已经是零辰 3 点钟了，有一点点失落。今年的内容惊喜不多，但是，我终归是又一次熬夜观看了直播。希望自己能保持这样对技术的激情，也希望苹果明年的 WWDC 能有一些惊喜。</p>\n<p>哦，我整理了一个后续值得观注的 session 列表，分享给大家：</p>\n<p>Improving Existing Apps with Modern Best Practices<br><a href=\"https://developer.apple.com/videos/play/wwdc2016/213/\">https://developer.apple.com/videos/play/wwdc2016/213/</a></p>\n<p>What’s New in Cocoa Touch<br><a href=\"https://developer.apple.com/videos/play/wwdc2016/205/\">https://developer.apple.com/videos/play/wwdc2016/205/</a></p>\n<p>What’s New in Foundation for Swift<br><a href=\"https://developer.apple.com/videos/play/wwdc2016/207/\">https://developer.apple.com/videos/play/wwdc2016/207/</a></p>\n<p>What’s New in UICollectionView in iOS 10<br><a href=\"https://developer.apple.com/videos/play/wwdc2016/219/\">https://developer.apple.com/videos/play/wwdc2016/219/</a></p>\n<p>Typography and Fonts<br><a href=\"https://developer.apple.com/videos/play/wwdc2016/803/\">https://developer.apple.com/videos/play/wwdc2016/803/</a></p>\n<p>Advanced Testing and Continuous Integration<br><a href=\"https://developer.apple.com/videos/play/wwdc2016/409/\">https://developer.apple.com/videos/play/wwdc2016/409/</a></p>\n<p>Debugging Tips and Tricks<br><a href=\"https://developer.apple.com/videos/play/wwdc2016/417/\">https://developer.apple.com/videos/play/wwdc2016/417/</a></p>\n<p>Getting Started with Swift ( 有最新 Swift 3 的内容）<br><a href=\"https://developer.apple.com/videos/play/wwdc2016/404/\">https://developer.apple.com/videos/play/wwdc2016/404/</a></p>\n<p>Going Server-side with Swift Open Source<br><a href=\"https://developer.apple.com/videos/play/wwdc2016/415/\">https://developer.apple.com/videos/play/wwdc2016/415/</a></p>\n<p>Introduction to Xcode ( 看看 Xcode 8 的新功能有啥）<br><a href=\"https://developer.apple.com/videos/play/wwdc2016/413/\">https://developer.apple.com/videos/play/wwdc2016/413/</a></p>\n<p>Swift API Design Guidelines<br><a href=\"https://developer.apple.com/videos/play/wwdc2016/403/\">https://developer.apple.com/videos/play/wwdc2016/403/</a></p>\n<p>Understanding Swift Performance<br><a href=\"https://developer.apple.com/videos/play/wwdc2016/416/\">https://developer.apple.com/videos/play/wwdc2016/416/</a></p>\n<p>Using and Extending the Xcode Source Editor（了解 Xcode 编辑器的插件功能）<br><a href=\"https://developer.apple.com/videos/play/wwdc2016/414/\">https://developer.apple.com/videos/play/wwdc2016/414/</a></p>\n<p>What’s New in LLVM<br><a href=\"https://developer.apple.com/videos/play/wwdc2016/405/\">https://developer.apple.com/videos/play/wwdc2016/405/</a></p>\n<p>What’s New in Swift<br><a href=\"https://developer.apple.com/videos/play/wwdc2016/402/\">https://developer.apple.com/videos/play/wwdc2016/402/</a></p>\n<p>What’s New in Xcode App Signing<br><a href=\"https://developer.apple.com/videos/play/wwdc2016/401/\">https://developer.apple.com/videos/play/wwdc2016/401/</a></p>\n<p>Concurrent Programming With GCD in Swift 3<br><a href=\"https://developer.apple.com/videos/play/wwdc2016/720/\">https://developer.apple.com/videos/play/wwdc2016/720/</a></p>\n<p>NSURLSession: New Features and Best Practices<br><a href=\"https://developer.apple.com/videos/play/wwdc2016/711/\">https://developer.apple.com/videos/play/wwdc2016/711/</a></p>"},{"title":"iOS 离屏渲染的研究","id":"6","updated":"2016-06-23T14:42:04.000Z","date":"2016-06-08T06:35:45.000Z","_content":"\n\n\n![大图](https://ooo.0o0.ooo/2016/06/08/5757f7f1bb0a7.png)\n\n# GPU渲染机制：\n\nCPU 计算好显示内容提交到 GPU，GPU 渲染完成后将渲染结果放入帧缓冲区，随后视频控制器会按照 VSync 信号逐行读取帧缓冲区的数据，经过可能的数模转换传递给显示器显示。\n\n# GPU屏幕渲染有以下两种方式：\n- On-Screen Rendering\n\n意为当前屏幕渲染，指的是GPU的渲染操作是在当前用于显示的屏幕缓冲区中进行。\n\n- Off-Screen Rendering\n意为离屏渲染，指的是GPU在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作。\n特殊的离屏渲染：\n如果将不在GPU的当前屏幕缓冲区中进行的渲染都称为离屏渲染，那么就还有另一种特殊的“离屏渲染”方式： CPU渲染。\n如果我们重写了drawRect方法，并且使用任何Core Graphics的技术进行了绘制操作，就涉及到了CPU渲染。整个渲染过程由CPU在App内 同步地\n完成，渲染得到的bitmap最后再交由GPU用于显示。\n备注：CoreGraphic通常是线程安全的，所以可以进行异步绘制，显示的时候再放回主线程，一个简单的异步绘制过程大致如下\n```\n- (void)display {\n  dispatch_async(backgroundQueue, ^{\n      CGContextRef ctx = CGBitmapContextCreate(...);\n      // draw in context...\n      CGImageRef img = CGBitmapContextCreateImage(ctx);\n      CFRelease(ctx);\n      dispatch_async(mainQueue, ^{\n          layer.contents = img;\n      });\n  });\n}\n```\n# 离屏渲染的触发方式\n\n设置了以下属性时，都会触发离屏绘制：\n\n- shouldRasterize（光栅化）\n- masks（遮罩）\n- shadows（阴影）\n- edge antialiasing（抗锯齿）\n- group opacity（不透明）\n- 复杂形状设置圆角等\n- 渐变\n\n其中shouldRasterize（光栅化）是比较特别的一种：\n光栅化概念：将图转化为一个个栅格组成的图象。\n光栅化特点：每个元素对应帧缓冲区中的一像素。\n\nshouldRasterize = YES在其他属性触发离屏渲染的同时，会将光栅化后的内容缓存起来，如果对应的layer及其sublayers没有发生改变，在下一帧的时候可以直接复用。shouldRasterize = YES，这将隐式的创建一个位图，各种阴影遮罩等效果也会保存到位图中并缓存起来，从而减少渲染的频度（不是矢量图）。\n\n相当于光栅化是把GPU的操作转到CPU上了，生成位图缓存，直接读取复用。\n\n当你使用光栅化时，你可以开启“Color Hits Green and Misses Red”来检查该场景下光栅化操作是否是一个好的选择。绿色表示缓存被复用，红色表示缓存在被重复创建。\n\n如果光栅化的层变红得太频繁那么光栅化对优化可能没有多少用处。位图缓存从内存中删除又重新创建得太过频繁，红色表明缓存重建得太迟。可以针对性的选择某个较小而较深的层结构进行光栅化，来尝试减少渲染时间。\n\n注意：\n对于经常变动的内容,这个时候不要开启,否则会造成性能的浪费\n\n例如我们日程经常打交道的TableViewCell,因为TableViewCell的重绘是很频繁的（因为Cell的复用）,如果Cell的内容不断变化,则Cell需要不断重绘,如果此时设置了cell.layer可光栅化。则会造成大量的离屏渲染,降低图形性能。\n\n为什么会使用离屏渲染\n\n当使用圆角，阴影，遮罩的时候，图层属性的混合体被指定为在未预合成之前不能直接在屏幕中绘制，所以就需要屏幕外渲染被唤起。\n\n屏幕外渲染并不意味着软件绘制，但是它意味着图层必须在被显示之前在一个屏幕外上下文中被渲染（不论CPU还是GPU）。\n\n所以当使用离屏渲染的时候会很容易造成性能消耗，因为在OPENGL里离屏渲染会单独在内存中创建一个屏幕外缓冲区并进行渲染，而屏幕外缓冲区跟当前屏幕缓冲区上下文切换是很耗性能的。\n\nInstruments监测离屏渲染\n\nInstruments的Core Animation工具中有几个和离屏渲染相关的检查选项：\n\n- Color Offscreen-Rendered Yellow\n开启后会把那些需要离屏渲染的图层高亮成黄色，这就意味着黄色图层可能存在性能问题。\n\n- Color Hits Green and Misses Red\n如果shouldRasterize被设置成YES，对应的渲染结果会被缓存，如果图层是绿色，就表示这些缓存被复用；如果是红色就表示缓存会被重复创建，这就表示该处存在性能问题了。\n\n# iOS版本上的优化\n\niOS 9.0 之前UIimageView跟UIButton设置圆角都会触发离屏渲染\n\niOS 9.0 之后UIButton设置圆角会触发离屏渲染，而UIImageView里png图片设置圆角不会触发离屏渲染了，如果设置其他阴影效果之类的还是会触发离屏渲染的。\n\n这可能是苹果也意识到离屏渲染会产生性能问题，所以能不产生离屏渲染的地方苹果也就不用离屏渲染了。\n\n引用出处:[iOS离屏渲染](http://github.com/kidteaing)\n\n","source":"_posts/iOS-离屏渲染的研究.md","raw":"---\ntitle: iOS 离屏渲染的研究\ntags: 'iOS'\npermalink: ios-liping-xuanran\nid: 6\nupdated: '2016-06-23 22:42:04'\ndate: 2016-06-08 14:35:45\n---\n\n\n\n![大图](https://ooo.0o0.ooo/2016/06/08/5757f7f1bb0a7.png)\n\n# GPU渲染机制：\n\nCPU 计算好显示内容提交到 GPU，GPU 渲染完成后将渲染结果放入帧缓冲区，随后视频控制器会按照 VSync 信号逐行读取帧缓冲区的数据，经过可能的数模转换传递给显示器显示。\n\n# GPU屏幕渲染有以下两种方式：\n- On-Screen Rendering\n\n意为当前屏幕渲染，指的是GPU的渲染操作是在当前用于显示的屏幕缓冲区中进行。\n\n- Off-Screen Rendering\n意为离屏渲染，指的是GPU在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作。\n特殊的离屏渲染：\n如果将不在GPU的当前屏幕缓冲区中进行的渲染都称为离屏渲染，那么就还有另一种特殊的“离屏渲染”方式： CPU渲染。\n如果我们重写了drawRect方法，并且使用任何Core Graphics的技术进行了绘制操作，就涉及到了CPU渲染。整个渲染过程由CPU在App内 同步地\n完成，渲染得到的bitmap最后再交由GPU用于显示。\n备注：CoreGraphic通常是线程安全的，所以可以进行异步绘制，显示的时候再放回主线程，一个简单的异步绘制过程大致如下\n```\n- (void)display {\n  dispatch_async(backgroundQueue, ^{\n      CGContextRef ctx = CGBitmapContextCreate(...);\n      // draw in context...\n      CGImageRef img = CGBitmapContextCreateImage(ctx);\n      CFRelease(ctx);\n      dispatch_async(mainQueue, ^{\n          layer.contents = img;\n      });\n  });\n}\n```\n# 离屏渲染的触发方式\n\n设置了以下属性时，都会触发离屏绘制：\n\n- shouldRasterize（光栅化）\n- masks（遮罩）\n- shadows（阴影）\n- edge antialiasing（抗锯齿）\n- group opacity（不透明）\n- 复杂形状设置圆角等\n- 渐变\n\n其中shouldRasterize（光栅化）是比较特别的一种：\n光栅化概念：将图转化为一个个栅格组成的图象。\n光栅化特点：每个元素对应帧缓冲区中的一像素。\n\nshouldRasterize = YES在其他属性触发离屏渲染的同时，会将光栅化后的内容缓存起来，如果对应的layer及其sublayers没有发生改变，在下一帧的时候可以直接复用。shouldRasterize = YES，这将隐式的创建一个位图，各种阴影遮罩等效果也会保存到位图中并缓存起来，从而减少渲染的频度（不是矢量图）。\n\n相当于光栅化是把GPU的操作转到CPU上了，生成位图缓存，直接读取复用。\n\n当你使用光栅化时，你可以开启“Color Hits Green and Misses Red”来检查该场景下光栅化操作是否是一个好的选择。绿色表示缓存被复用，红色表示缓存在被重复创建。\n\n如果光栅化的层变红得太频繁那么光栅化对优化可能没有多少用处。位图缓存从内存中删除又重新创建得太过频繁，红色表明缓存重建得太迟。可以针对性的选择某个较小而较深的层结构进行光栅化，来尝试减少渲染时间。\n\n注意：\n对于经常变动的内容,这个时候不要开启,否则会造成性能的浪费\n\n例如我们日程经常打交道的TableViewCell,因为TableViewCell的重绘是很频繁的（因为Cell的复用）,如果Cell的内容不断变化,则Cell需要不断重绘,如果此时设置了cell.layer可光栅化。则会造成大量的离屏渲染,降低图形性能。\n\n为什么会使用离屏渲染\n\n当使用圆角，阴影，遮罩的时候，图层属性的混合体被指定为在未预合成之前不能直接在屏幕中绘制，所以就需要屏幕外渲染被唤起。\n\n屏幕外渲染并不意味着软件绘制，但是它意味着图层必须在被显示之前在一个屏幕外上下文中被渲染（不论CPU还是GPU）。\n\n所以当使用离屏渲染的时候会很容易造成性能消耗，因为在OPENGL里离屏渲染会单独在内存中创建一个屏幕外缓冲区并进行渲染，而屏幕外缓冲区跟当前屏幕缓冲区上下文切换是很耗性能的。\n\nInstruments监测离屏渲染\n\nInstruments的Core Animation工具中有几个和离屏渲染相关的检查选项：\n\n- Color Offscreen-Rendered Yellow\n开启后会把那些需要离屏渲染的图层高亮成黄色，这就意味着黄色图层可能存在性能问题。\n\n- Color Hits Green and Misses Red\n如果shouldRasterize被设置成YES，对应的渲染结果会被缓存，如果图层是绿色，就表示这些缓存被复用；如果是红色就表示缓存会被重复创建，这就表示该处存在性能问题了。\n\n# iOS版本上的优化\n\niOS 9.0 之前UIimageView跟UIButton设置圆角都会触发离屏渲染\n\niOS 9.0 之后UIButton设置圆角会触发离屏渲染，而UIImageView里png图片设置圆角不会触发离屏渲染了，如果设置其他阴影效果之类的还是会触发离屏渲染的。\n\n这可能是苹果也意识到离屏渲染会产生性能问题，所以能不产生离屏渲染的地方苹果也就不用离屏渲染了。\n\n引用出处:[iOS离屏渲染](http://github.com/kidteaing)\n\n","slug":"ios-liping-xuanran","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cj04pzyxs000os04eaybphg0r","content":"<p><img src=\"https://ooo.0o0.ooo/2016/06/08/5757f7f1bb0a7.png\" alt=\"大图\"></p>\n<h1 id=\"GPU渲染机制：\"><a href=\"#GPU渲染机制：\" class=\"headerlink\" title=\"GPU渲染机制：\"></a>GPU渲染机制：</h1><p>CPU 计算好显示内容提交到 GPU，GPU 渲染完成后将渲染结果放入帧缓冲区，随后视频控制器会按照 VSync 信号逐行读取帧缓冲区的数据，经过可能的数模转换传递给显示器显示。</p>\n<h1 id=\"GPU屏幕渲染有以下两种方式：\"><a href=\"#GPU屏幕渲染有以下两种方式：\" class=\"headerlink\" title=\"GPU屏幕渲染有以下两种方式：\"></a>GPU屏幕渲染有以下两种方式：</h1><ul>\n<li>On-Screen Rendering</li>\n</ul>\n<p>意为当前屏幕渲染，指的是GPU的渲染操作是在当前用于显示的屏幕缓冲区中进行。</p>\n<ul>\n<li>Off-Screen Rendering<br>意为离屏渲染，指的是GPU在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作。<br>特殊的离屏渲染：<br>如果将不在GPU的当前屏幕缓冲区中进行的渲染都称为离屏渲染，那么就还有另一种特殊的“离屏渲染”方式： CPU渲染。<br>如果我们重写了drawRect方法，并且使用任何Core Graphics的技术进行了绘制操作，就涉及到了CPU渲染。整个渲染过程由CPU在App内 同步地<br>完成，渲染得到的bitmap最后再交由GPU用于显示。<br>备注：CoreGraphic通常是线程安全的，所以可以进行异步绘制，显示的时候再放回主线程，一个简单的异步绘制过程大致如下<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)display &#123;</div><div class=\"line\">  dispatch_async(backgroundQueue, ^&#123;</div><div class=\"line\">      CGContextRef ctx = CGBitmapContextCreate(...);</div><div class=\"line\">      // draw in context...</div><div class=\"line\">      CGImageRef img = CGBitmapContextCreateImage(ctx);</div><div class=\"line\">      CFRelease(ctx);</div><div class=\"line\">      dispatch_async(mainQueue, ^&#123;</div><div class=\"line\">          layer.contents = img;</div><div class=\"line\">      &#125;);</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h1 id=\"离屏渲染的触发方式\"><a href=\"#离屏渲染的触发方式\" class=\"headerlink\" title=\"离屏渲染的触发方式\"></a>离屏渲染的触发方式</h1><p>设置了以下属性时，都会触发离屏绘制：</p>\n<ul>\n<li>shouldRasterize（光栅化）</li>\n<li>masks（遮罩）</li>\n<li>shadows（阴影）</li>\n<li>edge antialiasing（抗锯齿）</li>\n<li>group opacity（不透明）</li>\n<li>复杂形状设置圆角等</li>\n<li>渐变</li>\n</ul>\n<p>其中shouldRasterize（光栅化）是比较特别的一种：<br>光栅化概念：将图转化为一个个栅格组成的图象。<br>光栅化特点：每个元素对应帧缓冲区中的一像素。</p>\n<p>shouldRasterize = YES在其他属性触发离屏渲染的同时，会将光栅化后的内容缓存起来，如果对应的layer及其sublayers没有发生改变，在下一帧的时候可以直接复用。shouldRasterize = YES，这将隐式的创建一个位图，各种阴影遮罩等效果也会保存到位图中并缓存起来，从而减少渲染的频度（不是矢量图）。</p>\n<p>相当于光栅化是把GPU的操作转到CPU上了，生成位图缓存，直接读取复用。</p>\n<p>当你使用光栅化时，你可以开启“Color Hits Green and Misses Red”来检查该场景下光栅化操作是否是一个好的选择。绿色表示缓存被复用，红色表示缓存在被重复创建。</p>\n<p>如果光栅化的层变红得太频繁那么光栅化对优化可能没有多少用处。位图缓存从内存中删除又重新创建得太过频繁，红色表明缓存重建得太迟。可以针对性的选择某个较小而较深的层结构进行光栅化，来尝试减少渲染时间。</p>\n<p>注意：<br>对于经常变动的内容,这个时候不要开启,否则会造成性能的浪费</p>\n<p>例如我们日程经常打交道的TableViewCell,因为TableViewCell的重绘是很频繁的（因为Cell的复用）,如果Cell的内容不断变化,则Cell需要不断重绘,如果此时设置了cell.layer可光栅化。则会造成大量的离屏渲染,降低图形性能。</p>\n<p>为什么会使用离屏渲染</p>\n<p>当使用圆角，阴影，遮罩的时候，图层属性的混合体被指定为在未预合成之前不能直接在屏幕中绘制，所以就需要屏幕外渲染被唤起。</p>\n<p>屏幕外渲染并不意味着软件绘制，但是它意味着图层必须在被显示之前在一个屏幕外上下文中被渲染（不论CPU还是GPU）。</p>\n<p>所以当使用离屏渲染的时候会很容易造成性能消耗，因为在OPENGL里离屏渲染会单独在内存中创建一个屏幕外缓冲区并进行渲染，而屏幕外缓冲区跟当前屏幕缓冲区上下文切换是很耗性能的。</p>\n<p>Instruments监测离屏渲染</p>\n<p>Instruments的Core Animation工具中有几个和离屏渲染相关的检查选项：</p>\n<ul>\n<li><p>Color Offscreen-Rendered Yellow<br>开启后会把那些需要离屏渲染的图层高亮成黄色，这就意味着黄色图层可能存在性能问题。</p>\n</li>\n<li><p>Color Hits Green and Misses Red<br>如果shouldRasterize被设置成YES，对应的渲染结果会被缓存，如果图层是绿色，就表示这些缓存被复用；如果是红色就表示缓存会被重复创建，这就表示该处存在性能问题了。</p>\n</li>\n</ul>\n<h1 id=\"iOS版本上的优化\"><a href=\"#iOS版本上的优化\" class=\"headerlink\" title=\"iOS版本上的优化\"></a>iOS版本上的优化</h1><p>iOS 9.0 之前UIimageView跟UIButton设置圆角都会触发离屏渲染</p>\n<p>iOS 9.0 之后UIButton设置圆角会触发离屏渲染，而UIImageView里png图片设置圆角不会触发离屏渲染了，如果设置其他阴影效果之类的还是会触发离屏渲染的。</p>\n<p>这可能是苹果也意识到离屏渲染会产生性能问题，所以能不产生离屏渲染的地方苹果也就不用离屏渲染了。</p>\n<p>引用出处:<a href=\"http://github.com/kidteaing\" target=\"_blank\" rel=\"external\">iOS离屏渲染</a></p>\n","excerpt":"","more":"<p><img src=\"https://ooo.0o0.ooo/2016/06/08/5757f7f1bb0a7.png\" alt=\"大图\"></p>\n<h1 id=\"GPU渲染机制：\"><a href=\"#GPU渲染机制：\" class=\"headerlink\" title=\"GPU渲染机制：\"></a>GPU渲染机制：</h1><p>CPU 计算好显示内容提交到 GPU，GPU 渲染完成后将渲染结果放入帧缓冲区，随后视频控制器会按照 VSync 信号逐行读取帧缓冲区的数据，经过可能的数模转换传递给显示器显示。</p>\n<h1 id=\"GPU屏幕渲染有以下两种方式：\"><a href=\"#GPU屏幕渲染有以下两种方式：\" class=\"headerlink\" title=\"GPU屏幕渲染有以下两种方式：\"></a>GPU屏幕渲染有以下两种方式：</h1><ul>\n<li>On-Screen Rendering</li>\n</ul>\n<p>意为当前屏幕渲染，指的是GPU的渲染操作是在当前用于显示的屏幕缓冲区中进行。</p>\n<ul>\n<li>Off-Screen Rendering<br>意为离屏渲染，指的是GPU在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作。<br>特殊的离屏渲染：<br>如果将不在GPU的当前屏幕缓冲区中进行的渲染都称为离屏渲染，那么就还有另一种特殊的“离屏渲染”方式： CPU渲染。<br>如果我们重写了drawRect方法，并且使用任何Core Graphics的技术进行了绘制操作，就涉及到了CPU渲染。整个渲染过程由CPU在App内 同步地<br>完成，渲染得到的bitmap最后再交由GPU用于显示。<br>备注：CoreGraphic通常是线程安全的，所以可以进行异步绘制，显示的时候再放回主线程，一个简单的异步绘制过程大致如下<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)display &#123;</div><div class=\"line\">  dispatch_async(backgroundQueue, ^&#123;</div><div class=\"line\">      CGContextRef ctx = CGBitmapContextCreate(...);</div><div class=\"line\">      // draw in context...</div><div class=\"line\">      CGImageRef img = CGBitmapContextCreateImage(ctx);</div><div class=\"line\">      CFRelease(ctx);</div><div class=\"line\">      dispatch_async(mainQueue, ^&#123;</div><div class=\"line\">          layer.contents = img;</div><div class=\"line\">      &#125;);</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h1 id=\"离屏渲染的触发方式\"><a href=\"#离屏渲染的触发方式\" class=\"headerlink\" title=\"离屏渲染的触发方式\"></a>离屏渲染的触发方式</h1><p>设置了以下属性时，都会触发离屏绘制：</p>\n<ul>\n<li>shouldRasterize（光栅化）</li>\n<li>masks（遮罩）</li>\n<li>shadows（阴影）</li>\n<li>edge antialiasing（抗锯齿）</li>\n<li>group opacity（不透明）</li>\n<li>复杂形状设置圆角等</li>\n<li>渐变</li>\n</ul>\n<p>其中shouldRasterize（光栅化）是比较特别的一种：<br>光栅化概念：将图转化为一个个栅格组成的图象。<br>光栅化特点：每个元素对应帧缓冲区中的一像素。</p>\n<p>shouldRasterize = YES在其他属性触发离屏渲染的同时，会将光栅化后的内容缓存起来，如果对应的layer及其sublayers没有发生改变，在下一帧的时候可以直接复用。shouldRasterize = YES，这将隐式的创建一个位图，各种阴影遮罩等效果也会保存到位图中并缓存起来，从而减少渲染的频度（不是矢量图）。</p>\n<p>相当于光栅化是把GPU的操作转到CPU上了，生成位图缓存，直接读取复用。</p>\n<p>当你使用光栅化时，你可以开启“Color Hits Green and Misses Red”来检查该场景下光栅化操作是否是一个好的选择。绿色表示缓存被复用，红色表示缓存在被重复创建。</p>\n<p>如果光栅化的层变红得太频繁那么光栅化对优化可能没有多少用处。位图缓存从内存中删除又重新创建得太过频繁，红色表明缓存重建得太迟。可以针对性的选择某个较小而较深的层结构进行光栅化，来尝试减少渲染时间。</p>\n<p>注意：<br>对于经常变动的内容,这个时候不要开启,否则会造成性能的浪费</p>\n<p>例如我们日程经常打交道的TableViewCell,因为TableViewCell的重绘是很频繁的（因为Cell的复用）,如果Cell的内容不断变化,则Cell需要不断重绘,如果此时设置了cell.layer可光栅化。则会造成大量的离屏渲染,降低图形性能。</p>\n<p>为什么会使用离屏渲染</p>\n<p>当使用圆角，阴影，遮罩的时候，图层属性的混合体被指定为在未预合成之前不能直接在屏幕中绘制，所以就需要屏幕外渲染被唤起。</p>\n<p>屏幕外渲染并不意味着软件绘制，但是它意味着图层必须在被显示之前在一个屏幕外上下文中被渲染（不论CPU还是GPU）。</p>\n<p>所以当使用离屏渲染的时候会很容易造成性能消耗，因为在OPENGL里离屏渲染会单独在内存中创建一个屏幕外缓冲区并进行渲染，而屏幕外缓冲区跟当前屏幕缓冲区上下文切换是很耗性能的。</p>\n<p>Instruments监测离屏渲染</p>\n<p>Instruments的Core Animation工具中有几个和离屏渲染相关的检查选项：</p>\n<ul>\n<li><p>Color Offscreen-Rendered Yellow<br>开启后会把那些需要离屏渲染的图层高亮成黄色，这就意味着黄色图层可能存在性能问题。</p>\n</li>\n<li><p>Color Hits Green and Misses Red<br>如果shouldRasterize被设置成YES，对应的渲染结果会被缓存，如果图层是绿色，就表示这些缓存被复用；如果是红色就表示缓存会被重复创建，这就表示该处存在性能问题了。</p>\n</li>\n</ul>\n<h1 id=\"iOS版本上的优化\"><a href=\"#iOS版本上的优化\" class=\"headerlink\" title=\"iOS版本上的优化\"></a>iOS版本上的优化</h1><p>iOS 9.0 之前UIimageView跟UIButton设置圆角都会触发离屏渲染</p>\n<p>iOS 9.0 之后UIButton设置圆角会触发离屏渲染，而UIImageView里png图片设置圆角不会触发离屏渲染了，如果设置其他阴影效果之类的还是会触发离屏渲染的。</p>\n<p>这可能是苹果也意识到离屏渲染会产生性能问题，所以能不产生离屏渲染的地方苹果也就不用离屏渲染了。</p>\n<p>引用出处:<a href=\"http://github.com/kidteaing\">iOS离屏渲染</a></p>\n"},{"title":"iOS 开发路线","id":"28","updated":"2016-07-13T06:56:44.000Z","date":"2016-07-12T11:59:43.000Z","_content":"\n\n\n前言\n\n学习iOS的人都想知道学习iOS需要学习哪些东西呢，本人搜集到github上有这么一个路径图，这里基本包含了开发中必须要掌握的一些技术知识。\n\n![预览图](https://raw.githubusercontent.com/shaojiankui/iOS-Route/master/look.jpg)\n\n[查看路线详情](http://ios.skyfox.org/route.html)\n\n来源\n[github地址iOS学习路线](https://github.com/shaojiankui/iOS-Route)\n\n此图片非本人所画，若原作者不允许使用此图，请及时告知，谢谢！\n\n","source":"_posts/iOS-开发路线.md","raw":"---\ntitle: iOS 开发路线\npermalink: ios-kai-fa-lu-xian\nid: 28\nupdated: '2016-07-13 14:56:44'\ndate: 2016-07-12 19:59:43\ntags: [职业规划]\n---\n\n\n\n前言\n\n学习iOS的人都想知道学习iOS需要学习哪些东西呢，本人搜集到github上有这么一个路径图，这里基本包含了开发中必须要掌握的一些技术知识。\n\n![预览图](https://raw.githubusercontent.com/shaojiankui/iOS-Route/master/look.jpg)\n\n[查看路线详情](http://ios.skyfox.org/route.html)\n\n来源\n[github地址iOS学习路线](https://github.com/shaojiankui/iOS-Route)\n\n此图片非本人所画，若原作者不允许使用此图，请及时告知，谢谢！\n\n","slug":"ios-kai-fa-lu-xian","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cj04pzyxt000ps04eyvs0s890","content":"<p>前言</p>\n<p>学习iOS的人都想知道学习iOS需要学习哪些东西呢，本人搜集到github上有这么一个路径图，这里基本包含了开发中必须要掌握的一些技术知识。</p>\n<p><img src=\"https://raw.githubusercontent.com/shaojiankui/iOS-Route/master/look.jpg\" alt=\"预览图\"></p>\n<p><a href=\"http://ios.skyfox.org/route.html\" target=\"_blank\" rel=\"external\">查看路线详情</a></p>\n<p>来源<br><a href=\"https://github.com/shaojiankui/iOS-Route\" target=\"_blank\" rel=\"external\">github地址iOS学习路线</a></p>\n<p>此图片非本人所画，若原作者不允许使用此图，请及时告知，谢谢！</p>\n","excerpt":"","more":"<p>前言</p>\n<p>学习iOS的人都想知道学习iOS需要学习哪些东西呢，本人搜集到github上有这么一个路径图，这里基本包含了开发中必须要掌握的一些技术知识。</p>\n<p><img src=\"https://raw.githubusercontent.com/shaojiankui/iOS-Route/master/look.jpg\" alt=\"预览图\"></p>\n<p><a href=\"http://ios.skyfox.org/route.html\">查看路线详情</a></p>\n<p>来源<br><a href=\"https://github.com/shaojiankui/iOS-Route\">github地址iOS学习路线</a></p>\n<p>此图片非本人所画，若原作者不允许使用此图，请及时告知，谢谢！</p>\n"},{"title":"iOS加密的基本介绍","id":"32","updated":"2016-08-14T09:59:10.000Z","date":"2016-08-08T05:52:13.000Z","_content":"\n\n\n安全隐患：在iOS开发过程中，尽管在发送数据的过程中，密码进行了“二进制”的转换，但实际上密码还是明文，可以通过一些拦截软件被拦截（青花瓷等等），不能保证我们数据的安全性。\n\n加密选择：一般公司都会有一套自己的加密方案，按照公司接口文档的规定去加密\n\n平常用到的解决办法：\n\n# 1.Base64加密\n\n> Base64加密因其算法和充当密钥的索引表都是公开的，所以不属于加密算法，它的本质是将“二进制”数据转换成字符串，方便使用HTTP协议、用于公开的代码加密、URL加密，防止数据明文传输。\n\n例如：有的网络请求上，会希望只传递字符串\n\n1.URL中的参数，直接带上图片的传输\n\n2.银联的网络接口，把整个消费凭据生成一个数据格式，然后进行Base64的编码，编码完成后传给服务器\n\n特点：编码完成后的结果，只有64个字符。\n\n转换方法：\n\n> 1.将每三个字节分成一组，一共24个二进制位：3*8=24\n>\n> 2.将这24个二进制位分成4组，每组有6个二进制位：24/4=6\n>\n> 3.在每组前加两00，扩展成32个二进制位，即4个字节：4*(6+2)=32\n>\n> 4.根据Base64索引表就可得到对应的符号值。\n\nBase64索引表\n\n下面来看看它的具体转换过程：\n\n加密的具体过程图\n\n苹果在iOS7之后自带Base64加密，具体方法如下：\n\n\n<!------MORE------->\n\n# 2.MD5加密\n\n> MD5即Message-Digest Algorithm 5（信息-摘要算法5），用于确保信息传输完整一致。是计算机广泛使用的杂凑算法之一（又译摘要算法、哈希算法），主流编程语言普遍已有MD5实现。作用是让大容量信息在用数字签名软件签署私人密钥前被\"压缩\"成一种保密的格式（就是把一个任意长度的字节串变换成一定长的十六进制数字串）。\n>\n> MD5加密对输入信息生成唯一的128位散列值（32个字符），声称是不可逆的，但是目前可以通过以下网站解密[MD5解密网站](http://www.cmd5.com) ，主要运用在数字签名、文件完整性验证以及口令加密等方面。\n\n先来看看基本的加密算法实现过程：\n\n![img](http://upload-images.jianshu.io/upload_images/974583-36ecd58f885b2b01.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n不过在平常的开发中我们一般都会用到第三方：例如 ** Security 的NSString+Hash.h** 等等，主要原因稍后会介绍。\n\n基本使用方法：\n\n![img](http://upload-images.jianshu.io/upload_images/974583-2d1695260849a0e8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n因为MD5生成的简单字符串会到目前会被轻易的破解，所以我们需要对其进行改进。\n\n1.**\\*加盐（Salt）***：在明文的固定位置插入随机串，然后再进行MD5\n\n![img](http://upload-images.jianshu.io/upload_images/974583-54897bb397997310.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n注：加的盐必须足够长，足够保密或者可以计入时间戳\n\n如果还不行的话可以使用辅助手段 IP记录   手机短信记录   操作异常或者比较敏感的操作等手法。\n\n2.**\\*HMAC+MD5***：HMAC本来就是一种加密算法，再加上MD5，算得上双重保障\n\nSecurity第三方有此方法\n\n3.**先加密，后乱序**：先对明文进行MD5，然后对加密得到的MD5串的字符进行乱序，总之宗旨就是：黑客就算攻破了数据库，也无法解密出正确的明文\n\n> 使用MD5的好处：快速校验\n\n# 3. 对于重要数据，使用RSA进行数字签名，起到防篡改作用\n\n# 4 .对于比较敏感的数据，如用户信息（登陆、注册等），客户端发送使用RSA加密，服务器返回使用DES(AES)加密\n\n原因：客户端发送之所以使用RSA加密，是因为RSA解密需要知道服务器私钥，而服务器私钥一般盗取难度较大；\n\n# 5.钥匙串（keychain）\n\niOS 7.0.3版本后加入，使用256位AES加密\n\n> keychain Services：（iOS密钥链服务）提供了针对用户设备上的密码、密钥、证书、笔记和自定义数据的安全存储解决方案。保存的信息不会因App被删除而丢失，在用户重新安装App后依然有效，数据还在，是目前在设备中保存关键数据的唯一安全的地方。\n\n那么，如何在应用里使用keychain呢？\n\n我们需要导入Security.framework ，keychain的操作接口声明在头文件SecItem.h里，直接使用SecItem.h里方法操作keychain，需要写的代码较为复杂，我们可以使用已经封装好了的工具类KeychainItemWrapper来对keychain进行操作。KeychainItemWrapper是apple官方例子“GenericKeychain”里一个访问keychain常用操作的封装类，在官网上下载了GenericKeychain项目后，**只需要把“KeychainItemWrapper.h”和“KeychainItemWrapper.m”拷贝到我们项目，并导入Security.framework 。同时需要设置ARC（-fno-objc-arc）。**\n\n我们来看看使用方法：\n\n保存数据\n\n取出数据\n\n其他具体的使用方法，自己看API。\n\n第三方封装的有**SSKeychain**，使用方法更为简便。\n\n![img](http://upload-images.jianshu.io/upload_images/974583-6949590f265968a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![img](http://upload-images.jianshu.io/upload_images/974583-a16cfe95dc2702ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n# 6.Cookie（小甜饼）\n\n由服务器生成，发送给客户端，将cookie的key/value保存到某个目录的文本文件内。\n\n最典型的应用是判定注册用户是否已经登录，另一个重要的应用场合是“购物车”。\n\n简单使用方法：\n\n![img](http://upload-images.jianshu.io/upload_images/974583-ff4a1b563a0f2ddb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n原文链接：http://www.jianshu.com/p/2beffa24e889\n\n","source":"_posts/iOS加密的基本介绍.md","raw":"---\ntitle: iOS加密的基本介绍\npermalink: iosjia-mi-de-ji-ben-jie-shao\nid: 32\nupdated: '2016-08-14 17:59:10'\ndate: 2016-08-08 13:52:13\ntags:\n---\n\n\n\n安全隐患：在iOS开发过程中，尽管在发送数据的过程中，密码进行了“二进制”的转换，但实际上密码还是明文，可以通过一些拦截软件被拦截（青花瓷等等），不能保证我们数据的安全性。\n\n加密选择：一般公司都会有一套自己的加密方案，按照公司接口文档的规定去加密\n\n平常用到的解决办法：\n\n# 1.Base64加密\n\n> Base64加密因其算法和充当密钥的索引表都是公开的，所以不属于加密算法，它的本质是将“二进制”数据转换成字符串，方便使用HTTP协议、用于公开的代码加密、URL加密，防止数据明文传输。\n\n例如：有的网络请求上，会希望只传递字符串\n\n1.URL中的参数，直接带上图片的传输\n\n2.银联的网络接口，把整个消费凭据生成一个数据格式，然后进行Base64的编码，编码完成后传给服务器\n\n特点：编码完成后的结果，只有64个字符。\n\n转换方法：\n\n> 1.将每三个字节分成一组，一共24个二进制位：3*8=24\n>\n> 2.将这24个二进制位分成4组，每组有6个二进制位：24/4=6\n>\n> 3.在每组前加两00，扩展成32个二进制位，即4个字节：4*(6+2)=32\n>\n> 4.根据Base64索引表就可得到对应的符号值。\n\nBase64索引表\n\n下面来看看它的具体转换过程：\n\n加密的具体过程图\n\n苹果在iOS7之后自带Base64加密，具体方法如下：\n\n\n<!------MORE------->\n\n# 2.MD5加密\n\n> MD5即Message-Digest Algorithm 5（信息-摘要算法5），用于确保信息传输完整一致。是计算机广泛使用的杂凑算法之一（又译摘要算法、哈希算法），主流编程语言普遍已有MD5实现。作用是让大容量信息在用数字签名软件签署私人密钥前被\"压缩\"成一种保密的格式（就是把一个任意长度的字节串变换成一定长的十六进制数字串）。\n>\n> MD5加密对输入信息生成唯一的128位散列值（32个字符），声称是不可逆的，但是目前可以通过以下网站解密[MD5解密网站](http://www.cmd5.com) ，主要运用在数字签名、文件完整性验证以及口令加密等方面。\n\n先来看看基本的加密算法实现过程：\n\n![img](http://upload-images.jianshu.io/upload_images/974583-36ecd58f885b2b01.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n不过在平常的开发中我们一般都会用到第三方：例如 ** Security 的NSString+Hash.h** 等等，主要原因稍后会介绍。\n\n基本使用方法：\n\n![img](http://upload-images.jianshu.io/upload_images/974583-2d1695260849a0e8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n因为MD5生成的简单字符串会到目前会被轻易的破解，所以我们需要对其进行改进。\n\n1.**\\*加盐（Salt）***：在明文的固定位置插入随机串，然后再进行MD5\n\n![img](http://upload-images.jianshu.io/upload_images/974583-54897bb397997310.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n注：加的盐必须足够长，足够保密或者可以计入时间戳\n\n如果还不行的话可以使用辅助手段 IP记录   手机短信记录   操作异常或者比较敏感的操作等手法。\n\n2.**\\*HMAC+MD5***：HMAC本来就是一种加密算法，再加上MD5，算得上双重保障\n\nSecurity第三方有此方法\n\n3.**先加密，后乱序**：先对明文进行MD5，然后对加密得到的MD5串的字符进行乱序，总之宗旨就是：黑客就算攻破了数据库，也无法解密出正确的明文\n\n> 使用MD5的好处：快速校验\n\n# 3. 对于重要数据，使用RSA进行数字签名，起到防篡改作用\n\n# 4 .对于比较敏感的数据，如用户信息（登陆、注册等），客户端发送使用RSA加密，服务器返回使用DES(AES)加密\n\n原因：客户端发送之所以使用RSA加密，是因为RSA解密需要知道服务器私钥，而服务器私钥一般盗取难度较大；\n\n# 5.钥匙串（keychain）\n\niOS 7.0.3版本后加入，使用256位AES加密\n\n> keychain Services：（iOS密钥链服务）提供了针对用户设备上的密码、密钥、证书、笔记和自定义数据的安全存储解决方案。保存的信息不会因App被删除而丢失，在用户重新安装App后依然有效，数据还在，是目前在设备中保存关键数据的唯一安全的地方。\n\n那么，如何在应用里使用keychain呢？\n\n我们需要导入Security.framework ，keychain的操作接口声明在头文件SecItem.h里，直接使用SecItem.h里方法操作keychain，需要写的代码较为复杂，我们可以使用已经封装好了的工具类KeychainItemWrapper来对keychain进行操作。KeychainItemWrapper是apple官方例子“GenericKeychain”里一个访问keychain常用操作的封装类，在官网上下载了GenericKeychain项目后，**只需要把“KeychainItemWrapper.h”和“KeychainItemWrapper.m”拷贝到我们项目，并导入Security.framework 。同时需要设置ARC（-fno-objc-arc）。**\n\n我们来看看使用方法：\n\n保存数据\n\n取出数据\n\n其他具体的使用方法，自己看API。\n\n第三方封装的有**SSKeychain**，使用方法更为简便。\n\n![img](http://upload-images.jianshu.io/upload_images/974583-6949590f265968a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![img](http://upload-images.jianshu.io/upload_images/974583-a16cfe95dc2702ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n# 6.Cookie（小甜饼）\n\n由服务器生成，发送给客户端，将cookie的key/value保存到某个目录的文本文件内。\n\n最典型的应用是判定注册用户是否已经登录，另一个重要的应用场合是“购物车”。\n\n简单使用方法：\n\n![img](http://upload-images.jianshu.io/upload_images/974583-ff4a1b563a0f2ddb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n原文链接：http://www.jianshu.com/p/2beffa24e889\n\n","slug":"iosjia-mi-de-ji-ben-jie-shao","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cj04pzyxv000ss04e2u5u5d91","content":"<p>安全隐患：在iOS开发过程中，尽管在发送数据的过程中，密码进行了“二进制”的转换，但实际上密码还是明文，可以通过一些拦截软件被拦截（青花瓷等等），不能保证我们数据的安全性。</p>\n<p>加密选择：一般公司都会有一套自己的加密方案，按照公司接口文档的规定去加密</p>\n<p>平常用到的解决办法：</p>\n<h1 id=\"1-Base64加密\"><a href=\"#1-Base64加密\" class=\"headerlink\" title=\"1.Base64加密\"></a>1.Base64加密</h1><blockquote>\n<p>Base64加密因其算法和充当密钥的索引表都是公开的，所以不属于加密算法，它的本质是将“二进制”数据转换成字符串，方便使用HTTP协议、用于公开的代码加密、URL加密，防止数据明文传输。</p>\n</blockquote>\n<p>例如：有的网络请求上，会希望只传递字符串</p>\n<p>1.URL中的参数，直接带上图片的传输</p>\n<p>2.银联的网络接口，把整个消费凭据生成一个数据格式，然后进行Base64的编码，编码完成后传给服务器</p>\n<p>特点：编码完成后的结果，只有64个字符。</p>\n<p>转换方法：</p>\n<blockquote>\n<p>1.将每三个字节分成一组，一共24个二进制位：3*8=24</p>\n<p>2.将这24个二进制位分成4组，每组有6个二进制位：24/4=6</p>\n<p>3.在每组前加两00，扩展成32个二进制位，即4个字节：4*(6+2)=32</p>\n<p>4.根据Base64索引表就可得到对应的符号值。</p>\n</blockquote>\n<p>Base64索引表</p>\n<p>下面来看看它的具体转换过程：</p>\n<p>加密的具体过程图</p>\n<p>苹果在iOS7之后自带Base64加密，具体方法如下：</p>\n<a id=\"more\"></a>\n<h1 id=\"2-MD5加密\"><a href=\"#2-MD5加密\" class=\"headerlink\" title=\"2.MD5加密\"></a>2.MD5加密</h1><blockquote>\n<p>MD5即Message-Digest Algorithm 5（信息-摘要算法5），用于确保信息传输完整一致。是计算机广泛使用的杂凑算法之一（又译摘要算法、哈希算法），主流编程语言普遍已有MD5实现。作用是让大容量信息在用数字签名软件签署私人密钥前被”压缩”成一种保密的格式（就是把一个任意长度的字节串变换成一定长的十六进制数字串）。</p>\n<p>MD5加密对输入信息生成唯一的128位散列值（32个字符），声称是不可逆的，但是目前可以通过以下网站解密<a href=\"http://www.cmd5.com\" target=\"_blank\" rel=\"external\">MD5解密网站</a> ，主要运用在数字签名、文件完整性验证以及口令加密等方面。</p>\n</blockquote>\n<p>先来看看基本的加密算法实现过程：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/974583-36ecd58f885b2b01.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"img\"></p>\n<p>不过在平常的开发中我们一般都会用到第三方：例如 <strong> Security 的NSString+Hash.h</strong> 等等，主要原因稍后会介绍。</p>\n<p>基本使用方法：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/974583-2d1695260849a0e8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"img\"></p>\n<p>因为MD5生成的简单字符串会到目前会被轻易的破解，所以我们需要对其进行改进。</p>\n<p>1.<strong>*加盐（Salt）*</strong>：在明文的固定位置插入随机串，然后再进行MD5</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/974583-54897bb397997310.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"img\"></p>\n<p>注：加的盐必须足够长，足够保密或者可以计入时间戳</p>\n<p>如果还不行的话可以使用辅助手段 IP记录   手机短信记录   操作异常或者比较敏感的操作等手法。</p>\n<p>2.<strong>*HMAC+MD5*</strong>：HMAC本来就是一种加密算法，再加上MD5，算得上双重保障</p>\n<p>Security第三方有此方法</p>\n<p>3.<strong>先加密，后乱序</strong>：先对明文进行MD5，然后对加密得到的MD5串的字符进行乱序，总之宗旨就是：黑客就算攻破了数据库，也无法解密出正确的明文</p>\n<blockquote>\n<p>使用MD5的好处：快速校验</p>\n</blockquote>\n<h1 id=\"3-对于重要数据，使用RSA进行数字签名，起到防篡改作用\"><a href=\"#3-对于重要数据，使用RSA进行数字签名，起到防篡改作用\" class=\"headerlink\" title=\"3. 对于重要数据，使用RSA进行数字签名，起到防篡改作用\"></a>3. 对于重要数据，使用RSA进行数字签名，起到防篡改作用</h1><h1 id=\"4-对于比较敏感的数据，如用户信息（登陆、注册等），客户端发送使用RSA加密，服务器返回使用DES-AES-加密\"><a href=\"#4-对于比较敏感的数据，如用户信息（登陆、注册等），客户端发送使用RSA加密，服务器返回使用DES-AES-加密\" class=\"headerlink\" title=\"4 .对于比较敏感的数据，如用户信息（登陆、注册等），客户端发送使用RSA加密，服务器返回使用DES(AES)加密\"></a>4 .对于比较敏感的数据，如用户信息（登陆、注册等），客户端发送使用RSA加密，服务器返回使用DES(AES)加密</h1><p>原因：客户端发送之所以使用RSA加密，是因为RSA解密需要知道服务器私钥，而服务器私钥一般盗取难度较大；</p>\n<h1 id=\"5-钥匙串（keychain）\"><a href=\"#5-钥匙串（keychain）\" class=\"headerlink\" title=\"5.钥匙串（keychain）\"></a>5.钥匙串（keychain）</h1><p>iOS 7.0.3版本后加入，使用256位AES加密</p>\n<blockquote>\n<p>keychain Services：（iOS密钥链服务）提供了针对用户设备上的密码、密钥、证书、笔记和自定义数据的安全存储解决方案。保存的信息不会因App被删除而丢失，在用户重新安装App后依然有效，数据还在，是目前在设备中保存关键数据的唯一安全的地方。</p>\n</blockquote>\n<p>那么，如何在应用里使用keychain呢？</p>\n<p>我们需要导入Security.framework ，keychain的操作接口声明在头文件SecItem.h里，直接使用SecItem.h里方法操作keychain，需要写的代码较为复杂，我们可以使用已经封装好了的工具类KeychainItemWrapper来对keychain进行操作。KeychainItemWrapper是apple官方例子“GenericKeychain”里一个访问keychain常用操作的封装类，在官网上下载了GenericKeychain项目后，<strong>只需要把“KeychainItemWrapper.h”和“KeychainItemWrapper.m”拷贝到我们项目，并导入Security.framework 。同时需要设置ARC（-fno-objc-arc）。</strong></p>\n<p>我们来看看使用方法：</p>\n<p>保存数据</p>\n<p>取出数据</p>\n<p>其他具体的使用方法，自己看API。</p>\n<p>第三方封装的有<strong>SSKeychain</strong>，使用方法更为简便。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/974583-6949590f265968a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"img\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/974583-a16cfe95dc2702ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"img\"></p>\n<h1 id=\"6-Cookie（小甜饼）\"><a href=\"#6-Cookie（小甜饼）\" class=\"headerlink\" title=\"6.Cookie（小甜饼）\"></a>6.Cookie（小甜饼）</h1><p>由服务器生成，发送给客户端，将cookie的key/value保存到某个目录的文本文件内。</p>\n<p>最典型的应用是判定注册用户是否已经登录，另一个重要的应用场合是“购物车”。</p>\n<p>简单使用方法：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/974583-ff4a1b563a0f2ddb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"img\"></p>\n<p>原文链接：<a href=\"http://www.jianshu.com/p/2beffa24e889\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/p/2beffa24e889</a></p>\n","excerpt":"<p>安全隐患：在iOS开发过程中，尽管在发送数据的过程中，密码进行了“二进制”的转换，但实际上密码还是明文，可以通过一些拦截软件被拦截（青花瓷等等），不能保证我们数据的安全性。</p>\n<p>加密选择：一般公司都会有一套自己的加密方案，按照公司接口文档的规定去加密</p>\n<p>平常用到的解决办法：</p>\n<h1 id=\"1-Base64加密\"><a href=\"#1-Base64加密\" class=\"headerlink\" title=\"1.Base64加密\"></a>1.Base64加密</h1><blockquote>\n<p>Base64加密因其算法和充当密钥的索引表都是公开的，所以不属于加密算法，它的本质是将“二进制”数据转换成字符串，方便使用HTTP协议、用于公开的代码加密、URL加密，防止数据明文传输。</p>\n</blockquote>\n<p>例如：有的网络请求上，会希望只传递字符串</p>\n<p>1.URL中的参数，直接带上图片的传输</p>\n<p>2.银联的网络接口，把整个消费凭据生成一个数据格式，然后进行Base64的编码，编码完成后传给服务器</p>\n<p>特点：编码完成后的结果，只有64个字符。</p>\n<p>转换方法：</p>\n<blockquote>\n<p>1.将每三个字节分成一组，一共24个二进制位：3*8=24</p>\n<p>2.将这24个二进制位分成4组，每组有6个二进制位：24/4=6</p>\n<p>3.在每组前加两00，扩展成32个二进制位，即4个字节：4*(6+2)=32</p>\n<p>4.根据Base64索引表就可得到对应的符号值。</p>\n</blockquote>\n<p>Base64索引表</p>\n<p>下面来看看它的具体转换过程：</p>\n<p>加密的具体过程图</p>\n<p>苹果在iOS7之后自带Base64加密，具体方法如下：</p>","more":"<h1 id=\"2-MD5加密\"><a href=\"#2-MD5加密\" class=\"headerlink\" title=\"2.MD5加密\"></a>2.MD5加密</h1><blockquote>\n<p>MD5即Message-Digest Algorithm 5（信息-摘要算法5），用于确保信息传输完整一致。是计算机广泛使用的杂凑算法之一（又译摘要算法、哈希算法），主流编程语言普遍已有MD5实现。作用是让大容量信息在用数字签名软件签署私人密钥前被”压缩”成一种保密的格式（就是把一个任意长度的字节串变换成一定长的十六进制数字串）。</p>\n<p>MD5加密对输入信息生成唯一的128位散列值（32个字符），声称是不可逆的，但是目前可以通过以下网站解密<a href=\"http://www.cmd5.com\">MD5解密网站</a> ，主要运用在数字签名、文件完整性验证以及口令加密等方面。</p>\n</blockquote>\n<p>先来看看基本的加密算法实现过程：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/974583-36ecd58f885b2b01.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"img\"></p>\n<p>不过在平常的开发中我们一般都会用到第三方：例如 <strong> Security 的NSString+Hash.h</strong> 等等，主要原因稍后会介绍。</p>\n<p>基本使用方法：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/974583-2d1695260849a0e8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"img\"></p>\n<p>因为MD5生成的简单字符串会到目前会被轻易的破解，所以我们需要对其进行改进。</p>\n<p>1.<strong>*加盐（Salt）*</strong>：在明文的固定位置插入随机串，然后再进行MD5</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/974583-54897bb397997310.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"img\"></p>\n<p>注：加的盐必须足够长，足够保密或者可以计入时间戳</p>\n<p>如果还不行的话可以使用辅助手段 IP记录   手机短信记录   操作异常或者比较敏感的操作等手法。</p>\n<p>2.<strong>*HMAC+MD5*</strong>：HMAC本来就是一种加密算法，再加上MD5，算得上双重保障</p>\n<p>Security第三方有此方法</p>\n<p>3.<strong>先加密，后乱序</strong>：先对明文进行MD5，然后对加密得到的MD5串的字符进行乱序，总之宗旨就是：黑客就算攻破了数据库，也无法解密出正确的明文</p>\n<blockquote>\n<p>使用MD5的好处：快速校验</p>\n</blockquote>\n<h1 id=\"3-对于重要数据，使用RSA进行数字签名，起到防篡改作用\"><a href=\"#3-对于重要数据，使用RSA进行数字签名，起到防篡改作用\" class=\"headerlink\" title=\"3. 对于重要数据，使用RSA进行数字签名，起到防篡改作用\"></a>3. 对于重要数据，使用RSA进行数字签名，起到防篡改作用</h1><h1 id=\"4-对于比较敏感的数据，如用户信息（登陆、注册等），客户端发送使用RSA加密，服务器返回使用DES-AES-加密\"><a href=\"#4-对于比较敏感的数据，如用户信息（登陆、注册等），客户端发送使用RSA加密，服务器返回使用DES-AES-加密\" class=\"headerlink\" title=\"4 .对于比较敏感的数据，如用户信息（登陆、注册等），客户端发送使用RSA加密，服务器返回使用DES(AES)加密\"></a>4 .对于比较敏感的数据，如用户信息（登陆、注册等），客户端发送使用RSA加密，服务器返回使用DES(AES)加密</h1><p>原因：客户端发送之所以使用RSA加密，是因为RSA解密需要知道服务器私钥，而服务器私钥一般盗取难度较大；</p>\n<h1 id=\"5-钥匙串（keychain）\"><a href=\"#5-钥匙串（keychain）\" class=\"headerlink\" title=\"5.钥匙串（keychain）\"></a>5.钥匙串（keychain）</h1><p>iOS 7.0.3版本后加入，使用256位AES加密</p>\n<blockquote>\n<p>keychain Services：（iOS密钥链服务）提供了针对用户设备上的密码、密钥、证书、笔记和自定义数据的安全存储解决方案。保存的信息不会因App被删除而丢失，在用户重新安装App后依然有效，数据还在，是目前在设备中保存关键数据的唯一安全的地方。</p>\n</blockquote>\n<p>那么，如何在应用里使用keychain呢？</p>\n<p>我们需要导入Security.framework ，keychain的操作接口声明在头文件SecItem.h里，直接使用SecItem.h里方法操作keychain，需要写的代码较为复杂，我们可以使用已经封装好了的工具类KeychainItemWrapper来对keychain进行操作。KeychainItemWrapper是apple官方例子“GenericKeychain”里一个访问keychain常用操作的封装类，在官网上下载了GenericKeychain项目后，<strong>只需要把“KeychainItemWrapper.h”和“KeychainItemWrapper.m”拷贝到我们项目，并导入Security.framework 。同时需要设置ARC（-fno-objc-arc）。</strong></p>\n<p>我们来看看使用方法：</p>\n<p>保存数据</p>\n<p>取出数据</p>\n<p>其他具体的使用方法，自己看API。</p>\n<p>第三方封装的有<strong>SSKeychain</strong>，使用方法更为简便。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/974583-6949590f265968a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"img\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/974583-a16cfe95dc2702ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"img\"></p>\n<h1 id=\"6-Cookie（小甜饼）\"><a href=\"#6-Cookie（小甜饼）\" class=\"headerlink\" title=\"6.Cookie（小甜饼）\"></a>6.Cookie（小甜饼）</h1><p>由服务器生成，发送给客户端，将cookie的key/value保存到某个目录的文本文件内。</p>\n<p>最典型的应用是判定注册用户是否已经登录，另一个重要的应用场合是“购物车”。</p>\n<p>简单使用方法：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/974583-ff4a1b563a0f2ddb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"img\"></p>\n<p>原文链接：<a href=\"http://www.jianshu.com/p/2beffa24e889\">http://www.jianshu.com/p/2beffa24e889</a></p>"},{"title":"OpenCV学习开发笔记(iOS9)","date":"2016-12-29T01:52:38.000Z","_content":"\n本文章采用的的开发环境为：\n1）Xcode 8.2\n2）OpenCV for iOS 3.2 \n\n# 前言\n最近公司项目进入了较为稳定的维护周期，考虑到后面很可能会进行需要生物特征识别的项目，提前学习下OpenCV，也在此和大家分享一下。\n\n\n# OpenCV介绍\nOpenCV ，是一个开源的跨平台计算机视觉和机器学习库，通俗点的说，就是他给计算机提供了一双眼睛，一双可以从图片中获取信息的眼镜，从而完成人脸识别、去红眼、追踪移动物体等等的图像相关的功能。更多具体的说明可参见 OpenCV 官网。\n\n## 模块\n\n下面是在官方文档中列出的最重要的模块。\n\ncore：简洁的核心模块，定义了基本的数据结构，包括稠密多维数组 Mat 和其他模块需要的基本函数。\nimgproc：图像处理模块，包括线性和非线性图像滤波、几何图像转换 (缩放、仿射与透视变换、一般性基于表的重映射)、颜色空间转换、直方图等等。\nvideo：视频分析模块，包括运动估计、背景消除、物体跟踪算法。\ncalib3d：包括基本的多视角几何算法、单体和立体相机的标定、对象姿态估计、双目立体匹配算法和元素的三维重建。\nfeatures2d：包含了显著特征检测算法、描述算子和算子匹配算法。\nobjdetect：物体检测和一些预定义的物体的检测 (如人脸、眼睛、杯子、人、汽车等)。\nml：多种机器学习算法，如 K 均值、支持向量机和神经网络。\nhighgui：一个简单易用的接口，提供视频捕捉、图像和视频编码等功能，还有简单的 UI 接口 (iOS 上可用的仅是其一个子集)。\ngpu：OpenCV 中不同模块的 GPU 加速算法 (iOS 上不可用)。\nocl：使用 OpenCL 实现的通用算法 (iOS 上不可用)。\n一些其它辅助模块，如 Python 绑定和用户贡献的算法。\n\n## 基础类和操作\n\nOpenCV 包含几百个类。为简便起见，我们只看几个基础的类和操作，进一步阅读请参考全部文档。过一遍这几个核心类应该足以对这个库的机理产生一些感觉认识。\n\ncv::Mat\n\ncv::Mat 是 OpenCV 的核心数据结构，用来表示任意 N 维矩阵。因为图像只是 2 维矩阵的一个特殊场景，所以也是使用 cv::Mat来表示的。也就是说，cv::Mat 将是你在 OpenCV 中用到最多的类。\n\n一个 cv::Mat 实例的作用就像是图像数据的头，其中包含着描述图像格式的信息。图像数据只是被引用，并能为多个 cv::Mat 实例共享。OpenCV 使用类似于 ARC 的引用计数方法，以保证当最后一个来自 cv::Mat 的引用也消失的时候，图像数据会被释放。图像数据本身是图像连续的行的数组 (对 N 维矩阵来说，这个数据是由连续的 N-1 维数据组成的数组)。使用 step[] 数组中包含的值，图像的任一像素地址都可通过下面的指针运算得到：\n\n```\nuchar *pixelPtr = cvMat.data + rowIndex * cvMat.step[0] + colIndex * cvMat.step[1]\n```\n每个像素的数据格式可以通过 type() 方法获得。除了常用的每通道 8 位无符号整数的灰度图 (1 通道，CV_8UC1) 和彩色图 (3 通道，CV_8UC3)，OpenCV 还支持很多不常用的格式，例如 CV_16SC3 (每像素 3 通道，每通道使用 16 位有符号整数)，甚至CV_64FC4 (每像素 4 通道，每通道使用 64 位浮点数)。\n\ncv::Algorithm\n\nAlgorithm 是 OpenCV 中实现的很多算法的抽象基类，包括将在我们的 demo 工程中用到的 FaceRecognizer。它提供的 API 与苹果的 Core Image 框架中的 CIFilter 有些相似之处。创建一个 Algorithm 的时候使用算法的名字来调用 Algorithm::create()，并且可以通过 get() 和 set()方法来获取和设置各个参数，这有点像是键值编码。另外，Algorithm 从底层就支持从/向 XML 或 YAML 文件加载/保存参数的功能。\n\n# 实战部分\n\n## 导入工程\n\n首先下载从官网[OpenCV官网](http://opencv.org/)下载的iOS支持库，我们新建一个工程。\n\n![搭建环境](http://oiu3ghos7.bkt.clouddn.com/14829768918916.jpg)\n\n导入 OpenCV 到 Xcode 的工程中还是比较简单的，从官网下载对应的 framework，直接丢到 Xcode 的工程中，从xcode7以后拖入的工程会自动添加到Building phase里面，检查一下。\n![](http://oiu3ghos7.bkt.clouddn.com/14829783173349.jpg)\n\n然后在你想用 OpenCV 的地方引入 OpenCV 的头文件：\n\n```objc\n#import <opencv2/opencv.hpp>\n\n```    \n\n或者直接在 PCH 文件中添加：  \n  \n```objc\n#ifdef __cplusplus\n#import <opencv2/opencv.hpp>\n#endif\n\n```    \n\n把使用到 OpenCV 中 C++方法的实现文件后缀名改成.mm，就可以开始使用 OpenCV 的方法了。\n\n### Objective-C++\n\n如前面所说，OpenCV 是一个 C++ 的 API，因此不能直接在 Swift 和 Objective-C 代码中使用，但能在 Objective-C++ 文件中使用。\n\nObjective-C++ 是 Objective-C 和 C++ 的混合物，让你可以在 Objective-C 类中使用 C++ 对象。clang 编译器会把所有后缀名为.mm 的文件都当做是 Objective-C++。一般来说，它会如你所期望的那样运行，但还是有一些使用 Objective-C++ 的注意事项。内存管理是你最应该格外注意的点，因为 ARC 只对 Objective-C 对象有效。当你使用一个 C++ 对象作为类属性的时候，其唯一有效的属性就是 assign。因此，你的 dealloc 函数应确保 C++ 对象被正确地释放了。\n\n第二重要的点就是，如果你在 Objective-C++ 头文件中引入了 C++ 头文件，当你在工程中使用该 Objective-C++ 文件的时候就泄露了 C++ 的依赖。任何引入你的 Objective-C++ 类的 Objective-C 类也会引入该 C++ 类，因此该 Objective-C 文件也要被声明为 Objective-C++ 的文件。这会像森林大火一样在工程中迅速蔓延。所以，应该把你引入 C++ 文件的地方都用 #ifdef __cplusplus包起来，并且只要可能，就尽量只在 .mm 实现文件中引入 C++ 头文件。\n\n\n\n看起来很简单，然而实际操作中还是有不少的问题。\n\n\n\n<!------MORE------->\n\n\n## 小热身\n\n由于OpenCV代码是基于C++编写的，因此，要在项目中运行c++代码，需要将实现文件名后缀由`.m`改成`.mm`，如下图所示。\n![](http://oiu3ghos7.bkt.clouddn.com/14829787278230.jpg)\n\n再次强调一次使用opencv的类名一定要改成.mm!\n\n\n说了那么多先测试一下吧!\n\n\n```objc\n#import <opencv2/opencv.hpp>\n#import <opencv2/imgproc/types_c.h>\n#import <opencv2/imgcodecs/ios.h>\n\n#import \"ViewController.h\"\n\n\n@interface ViewController ()\n{\n     cv::Mat cvImage;\n}\n\n@property (weak, nonatomic) IBOutlet UIImageView *imgView;\n\n\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    UIImage *image = [UIImage imageNamed:@\"learn.jpg\"];\n    \n    UIImageToMat(image, cvImage);\n    \n    if(!cvImage.empty()){\n        cv::Mat gray;\n        // 将图像转换为灰度显示\n        cv::cvtColor(cvImage,gray,CV_RGB2GRAY);\n        // 应用高斯滤波器去除小的边缘\n        cv::GaussianBlur(gray, gray, cv::Size(5,5), 1.2,1.2);\n        // 计算与画布边缘\n        cv::Mat edges;\n        cv::Canny(gray, edges, 0, 50);\n        // 使用白色填充\n        cvImage.setTo(cv::Scalar::all(225));\n        // 修改边缘颜色\n        cvImage.setTo(cv::Scalar(0,128,255,255),edges);\n        // 将Mat转换为Xcode的UIImageView显示\n        self.imgView.image = MatToUIImage(cvImage);\n    }\n}\n\n@end\n\n```\n\n\n原图\n![finn-w290](http://oiu3ghos7.bkt.clouddn.com/finn.jpg)\n\n运行在模拟器上的效果\n![运行效果](http://oiu3ghos7.bkt.clouddn.com/14829830035512.jpg)\n\n## Demo:人脸识别\n\nDemo：人脸检测与识别\n\n现在，我们对 OpenCV 及如何把它集成到我们的应用中有了大概认识，那让我们来做一个小 demo 应用：从 iPhone 的摄像头获取视频流，对它持续进行人脸检测，并在屏幕上标出来。当用户点击一个脸孔时，应用会尝试识别这个人。如果识别结果正确，用户必须点击 “Correct”。如果识别错误，用户必须选择正确的人名来纠正错误。我们的人脸识别器就会从错误中学习，变得越来越好。\n\n### 视频拍摄\n\n\nOpenCV 的 highgui 模块中有个类，CvVideoCamera，它把 iPhone 的摄像机抽象出来，让我们的 app 通过一个代理函数 - (void)processImage:(cv::Mat&)image 来获得视频流。CvVideoCamera 实例可像下面这样进行设置：\n\n```objc\nCvVideoCamera *videoCamera = [[CvVideoCamera alloc] initWithParentView:view];  \nvideoCamera.defaultAVCaptureDevicePosition = AVCaptureDevicePositionFront;  \nvideoCamera.defaultAVCaptureSessionPreset = AVCaptureSessionPreset640x480;  \nvideoCamera.defaultAVCaptureVideoOrientation = AVCaptureVideoOrientationPortrait;  \nvideoCamera.defaultFPS = 30;  \nvideoCamera.grayscaleMode = NO;  \nvideoCamera.delegate = self;\n```\n\n摄像头的帧率被设置为 30 帧每秒， 我们实现的 processImage 函数将每秒被调用 30 次。因为我们的 app 要持续不断地检测人脸，所以我们应该在这个函数里实现人脸的检测。要注意的是，如果对某一帧进行人脸检测的时间超过 1/30 秒，就会产生掉帧现象。\n\n### 人脸检测\n\n其实你并不需要使用 OpenCV 来做人脸检测，因为 Core Image 已经提供了 CIDetector 类。用它来做人脸检测已经相当好了，并且它已经被优化过，使用起来也很容易：\n\n```objc\nCIDetector *faceDetector = [CIDetector detectorOfType:CIDetectorTypeFace context:context options:@{CIDetectorAccuracy: CIDetectorAccuracyHigh}];\n\nNSArray *faces = [faceDetector featuresInImage:image];\n```\n\n从该图片中检测到的每一张面孔都在数组 faces 中保存着一个 CIFaceFeature 实例。这个实例中保存着这张面孔的所处的位置和宽高，除此之外，眼睛和嘴的位置也是可选的。\n\n另一方面，OpenCV 也提供了一套物体检测功能，经过训练后能够检测出任何你需要的物体。该库为多个场景自带了可以直接拿来用的检测参数，如人脸、眼睛、嘴、身体、上半身、下半身和笑脸。检测引擎由一些非常简单的检测器的级联组成。这些检测器被称为 Haar 特征检测器，它们各自具有不同的尺度和权重。在训练阶段，决策树会通过已知的正确和错误的图片进行优化。关于训练与检测过程的详情可参考此原始论文。当正确的特征级联及其尺度与权重通过训练确立以后，这些参数就可被加载并初始化级联分类器了：\n\n```objc\n/ 正面人脸检测器训练参数的文件路径\nNSString *faceCascadePath = [[NSBundle mainBundle] pathForResource:@&quot;haarcascade_frontalface_alt2&quot;  \n                                                   ofType:@&quot;xml&quot;];\n \nconst CFIndex CASCADE_NAME_LEN = 2048;  \nchar *CASCADE_NAME = (char *) malloc(CASCADE_NAME_LEN);  \nCFStringGetFileSystemRepresentation( (CFStringRef)faceCascadePath, CASCADE_NAME, CASCADE_NAME_LEN);\n \nCascadeClassifier faceDetector;  \nfaceDetector.load(CASCADE_NAME);\n```\n\n这些参数文件可在 OpenCV 发行包里的 data/haarcascades 文件夹中找到。\n\n在使用所需要的参数对人脸检测器进行初始化后，就可以用它进行人脸检测了：\n\n```objc\ncv::Mat img;  \nvector&lt;cv::Rect&gt; faceRects;  \ndouble scalingFactor = 1.1;  \nint minNeighbors = 2;  \nint flags = 0;  \ncv::Size minimumSize(30,30);  \nfaceDetector.detectMultiScale(img, faceRects,  \n                              scalingFactor, minNeighbors, flags\n                              cv::Size(30, 30) );\n```\n\n检测过程中，已训练好的分类器会用不同的尺度遍历输入图像的每一个像素，以检测不同大小的人脸。参数 scalingFactor 决定每次遍历分类器后尺度会变大多少倍。参数 minNeighbors 指定一个符合条件的人脸区域应该有多少个符合条件的邻居像素才被认为是一个可能的人脸区域；如果一个符合条件的人脸区域只移动了一个像素就不再触发分类器，那么这个区域非常可能并不是我们想要的结果。拥有少于 minNeighbors 个符合条件的邻居像素的人脸区域会被拒绝掉。如果 minNeighbors 被设置为 0，所有可能的人脸区域都会被返回回来。参数 flags 是 OpenCV 1.x 版本 API 的遗留物，应该始终把它设置为 0。最后，参数 minimumSize 指定我们所寻找的人脸区域大小的最小值。faceRects 向量中将会包含对 img 进行人脸识别获得的所有人脸区域。识别的人脸图像可以通过cv::Mat 的 () 运算符提取出来，调用方式很简单：cv::Mat faceImg = img(aFaceRect)。\n\n不管是使用 CIDetector 还是 OpenCV 的 CascadeClassifier，只要我们获得了至少一个人脸区域，我们就可以对图像中的人进行识别了。\n\n\n# 遇到问题\n这是第一次导入C++的库进工程中，所以还是摸索了一段时间。\n\n1. 第一次编译的时候遇到一个问题，编译器报了个警告是\n```\n#if defined(NO)\n#  warning Detected Apple 'NO' macro definition, it can cause build conflicts. Please, include this header before any Apple headers.\n#endif\n```\n\n按照提示说明，OpenCV的头文件应该在所有APPLE的头文件之前导入，不然会抛出异常，把import调到最前面即可。\n\n\n2. 为何在 PCH 文件中引入 OpenCV 的头文件我们需要多加`#ifdef __cpluseplus`这一部分呢？这是因为 PCH 文件是一个会被**所有的文件**引入的头文件，而我们又希望 `#import <opencv2/opencv.hpp>`这部分只会被一些 C++实现文件编译，所以我们加上`#ifdef __cpluseplus`来表示这是 `C++` 文件才会编译的，除了`#ifdef __cpluseplus`，还有`#ifdef __OBJC__`这样的宏来说明编译规则（按照 OC 文件编译），这样的宏多出现于一些会被多种类型的实现文件引用的头文件中。\n\n3. 另外注意另一个问题：如果一个头文件是C++类型的头文件，那么一定要保证所有`直接`或者`间接`引用这个头文件的实现文件都要为.mm或者.cpp，否则 Xcode 就不会把这个头文件当做 C++头文件来编译，就会出现最基本的`#include <iostream>`这种引用都会报出`file not found `这样的编译错误的问题。我在编译的过程中，某个C++头文件 A.h 被 B.h 引用，然后 B.h 又被 C.m 引用，虽然 B 的实现文件是 B.mm ，但是仍然报出了之前说的那个错误\n感谢 StackOberflow 让我找到了问题发生的原因。所以对于 C++ 头文件的引用一定要注意，但凡是引用了 A.h 的实现部分，都必须是.mm或者.cpp后缀名。（同时我们也可以知道，Xcode 是根据头文件被引用的情况来判定头文件的编译 类型的）。\n\n\n\n\n\n\n# 转换UIImage和cv::Mat\n\n在 OpenCV 中同常用 cv::Mat 表示图片，而 iOS 中则是 UIImage 来表示图片，但openCV的[官方教程](http://docs.opencv.org/2.4/doc/tutorials/ios/image_manipulation/image_manipulation.html#opencviosimagemanipulation)已经给出了方法。\n\n## UIImage to cv::Mat\n\n```objc\n    - (cv::Mat)cvMatFromUIImage:(UIImage *)image\n{\n  CGColorSpaceRef colorSpace = CGImageGetColorSpace(image.CGImage);\n  CGFloat cols = image.size.width;\n  CGFloat rows = image.size.height;\n\n  cv::Mat cvMat(rows, cols, CV_8UC4); // 8 bits per component, 4 channels (color channels + alpha)\n\n  CGContextRef contextRef = CGBitmapContextCreate(cvMat.data,                 // Pointer to  data\n                                                 cols,                       // Width of bitmap\n                                                 rows,                       // Height of bitmap\n                                                 8,                          // Bits per component\n                                                 cvMat.step[0],              // Bytes per row\n                                                 colorSpace,                 // Colorspace\n                                                 kCGImageAlphaNoneSkipLast |\n                                                 kCGBitmapByteOrderDefault); // Bitmap info flags\n\n  CGContextDrawImage(contextRef, CGRectMake(0, 0, cols, rows), image.CGImage);\n  CGContextRelease(contextRef);\n\n  return cvMat;\n}\n\n```\n\n\n## cv::Mat to UIImage \n\n```objc\n-(UIImage *)UIImageFromCVMat:(cv::Mat)cvMat\n{\n  NSData *data = [NSData dataWithBytes:cvMat.data length:cvMat.elemSize()*cvMat.total()];\n  CGColorSpaceRef colorSpace;\n\n  if (cvMat.elemSize() == 1) {//可以根据这个决定使用哪种\n      colorSpace = CGColorSpaceCreateDeviceGray();\n  } else {\n      colorSpace = CGColorSpaceCreateDeviceRGB();\n  }\n\n  CGDataProviderRef provider = CGDataProviderCreateWithCFData((__bridge CFDataRef)data);\n\n  // Creating CGImage from cv::Mat\n  CGImageRef imageRef = CGImageCreate(cvMat.cols,                                 //width\n                                     cvMat.rows,                                 //height\n                                     8,                                          //bits per component\n                                     8 * cvMat.elemSize(),                       //bits per pixel\n                                     cvMat.step[0],                            //bytesPerRow\n                                     colorSpace,                                 //colorspace\n                                     kCGImageAlphaNone|kCGBitmapByteOrderDefault,// bitmap info\n                                     provider,                                   //CGDataProviderRef\n                                     NULL,                                       //decode\n                                     false,                                      //should interpolate\n                                     kCGRenderingIntentDefault                   //intent\n                                     );\n\n\n  // Getting UIImage from CGImage\n  UIImage *finalImage = [UIImage imageWithCGImage:imageRef];\n  CGImageRelease(imageRef);\n  CGDataProviderRelease(provider);\n  CGColorSpaceRelease(colorSpace);\n\n  return finalImage;\n }\n \n ```\n \n\n\n\n","source":"_posts/OpenCV学习开发笔记(iOS9).md","raw":"---\ntitle: OpenCV学习开发笔记(iOS9)\npermalink: OpenCVLearning\ndate: 2016-12-29 09:52:38\ntags: [学习笔记, 人脸识别]\n\n---\n\n本文章采用的的开发环境为：\n1）Xcode 8.2\n2）OpenCV for iOS 3.2 \n\n# 前言\n最近公司项目进入了较为稳定的维护周期，考虑到后面很可能会进行需要生物特征识别的项目，提前学习下OpenCV，也在此和大家分享一下。\n\n\n# OpenCV介绍\nOpenCV ，是一个开源的跨平台计算机视觉和机器学习库，通俗点的说，就是他给计算机提供了一双眼睛，一双可以从图片中获取信息的眼镜，从而完成人脸识别、去红眼、追踪移动物体等等的图像相关的功能。更多具体的说明可参见 OpenCV 官网。\n\n## 模块\n\n下面是在官方文档中列出的最重要的模块。\n\ncore：简洁的核心模块，定义了基本的数据结构，包括稠密多维数组 Mat 和其他模块需要的基本函数。\nimgproc：图像处理模块，包括线性和非线性图像滤波、几何图像转换 (缩放、仿射与透视变换、一般性基于表的重映射)、颜色空间转换、直方图等等。\nvideo：视频分析模块，包括运动估计、背景消除、物体跟踪算法。\ncalib3d：包括基本的多视角几何算法、单体和立体相机的标定、对象姿态估计、双目立体匹配算法和元素的三维重建。\nfeatures2d：包含了显著特征检测算法、描述算子和算子匹配算法。\nobjdetect：物体检测和一些预定义的物体的检测 (如人脸、眼睛、杯子、人、汽车等)。\nml：多种机器学习算法，如 K 均值、支持向量机和神经网络。\nhighgui：一个简单易用的接口，提供视频捕捉、图像和视频编码等功能，还有简单的 UI 接口 (iOS 上可用的仅是其一个子集)。\ngpu：OpenCV 中不同模块的 GPU 加速算法 (iOS 上不可用)。\nocl：使用 OpenCL 实现的通用算法 (iOS 上不可用)。\n一些其它辅助模块，如 Python 绑定和用户贡献的算法。\n\n## 基础类和操作\n\nOpenCV 包含几百个类。为简便起见，我们只看几个基础的类和操作，进一步阅读请参考全部文档。过一遍这几个核心类应该足以对这个库的机理产生一些感觉认识。\n\ncv::Mat\n\ncv::Mat 是 OpenCV 的核心数据结构，用来表示任意 N 维矩阵。因为图像只是 2 维矩阵的一个特殊场景，所以也是使用 cv::Mat来表示的。也就是说，cv::Mat 将是你在 OpenCV 中用到最多的类。\n\n一个 cv::Mat 实例的作用就像是图像数据的头，其中包含着描述图像格式的信息。图像数据只是被引用，并能为多个 cv::Mat 实例共享。OpenCV 使用类似于 ARC 的引用计数方法，以保证当最后一个来自 cv::Mat 的引用也消失的时候，图像数据会被释放。图像数据本身是图像连续的行的数组 (对 N 维矩阵来说，这个数据是由连续的 N-1 维数据组成的数组)。使用 step[] 数组中包含的值，图像的任一像素地址都可通过下面的指针运算得到：\n\n```\nuchar *pixelPtr = cvMat.data + rowIndex * cvMat.step[0] + colIndex * cvMat.step[1]\n```\n每个像素的数据格式可以通过 type() 方法获得。除了常用的每通道 8 位无符号整数的灰度图 (1 通道，CV_8UC1) 和彩色图 (3 通道，CV_8UC3)，OpenCV 还支持很多不常用的格式，例如 CV_16SC3 (每像素 3 通道，每通道使用 16 位有符号整数)，甚至CV_64FC4 (每像素 4 通道，每通道使用 64 位浮点数)。\n\ncv::Algorithm\n\nAlgorithm 是 OpenCV 中实现的很多算法的抽象基类，包括将在我们的 demo 工程中用到的 FaceRecognizer。它提供的 API 与苹果的 Core Image 框架中的 CIFilter 有些相似之处。创建一个 Algorithm 的时候使用算法的名字来调用 Algorithm::create()，并且可以通过 get() 和 set()方法来获取和设置各个参数，这有点像是键值编码。另外，Algorithm 从底层就支持从/向 XML 或 YAML 文件加载/保存参数的功能。\n\n# 实战部分\n\n## 导入工程\n\n首先下载从官网[OpenCV官网](http://opencv.org/)下载的iOS支持库，我们新建一个工程。\n\n![搭建环境](http://oiu3ghos7.bkt.clouddn.com/14829768918916.jpg)\n\n导入 OpenCV 到 Xcode 的工程中还是比较简单的，从官网下载对应的 framework，直接丢到 Xcode 的工程中，从xcode7以后拖入的工程会自动添加到Building phase里面，检查一下。\n![](http://oiu3ghos7.bkt.clouddn.com/14829783173349.jpg)\n\n然后在你想用 OpenCV 的地方引入 OpenCV 的头文件：\n\n```objc\n#import <opencv2/opencv.hpp>\n\n```    \n\n或者直接在 PCH 文件中添加：  \n  \n```objc\n#ifdef __cplusplus\n#import <opencv2/opencv.hpp>\n#endif\n\n```    \n\n把使用到 OpenCV 中 C++方法的实现文件后缀名改成.mm，就可以开始使用 OpenCV 的方法了。\n\n### Objective-C++\n\n如前面所说，OpenCV 是一个 C++ 的 API，因此不能直接在 Swift 和 Objective-C 代码中使用，但能在 Objective-C++ 文件中使用。\n\nObjective-C++ 是 Objective-C 和 C++ 的混合物，让你可以在 Objective-C 类中使用 C++ 对象。clang 编译器会把所有后缀名为.mm 的文件都当做是 Objective-C++。一般来说，它会如你所期望的那样运行，但还是有一些使用 Objective-C++ 的注意事项。内存管理是你最应该格外注意的点，因为 ARC 只对 Objective-C 对象有效。当你使用一个 C++ 对象作为类属性的时候，其唯一有效的属性就是 assign。因此，你的 dealloc 函数应确保 C++ 对象被正确地释放了。\n\n第二重要的点就是，如果你在 Objective-C++ 头文件中引入了 C++ 头文件，当你在工程中使用该 Objective-C++ 文件的时候就泄露了 C++ 的依赖。任何引入你的 Objective-C++ 类的 Objective-C 类也会引入该 C++ 类，因此该 Objective-C 文件也要被声明为 Objective-C++ 的文件。这会像森林大火一样在工程中迅速蔓延。所以，应该把你引入 C++ 文件的地方都用 #ifdef __cplusplus包起来，并且只要可能，就尽量只在 .mm 实现文件中引入 C++ 头文件。\n\n\n\n看起来很简单，然而实际操作中还是有不少的问题。\n\n\n\n<!------MORE------->\n\n\n## 小热身\n\n由于OpenCV代码是基于C++编写的，因此，要在项目中运行c++代码，需要将实现文件名后缀由`.m`改成`.mm`，如下图所示。\n![](http://oiu3ghos7.bkt.clouddn.com/14829787278230.jpg)\n\n再次强调一次使用opencv的类名一定要改成.mm!\n\n\n说了那么多先测试一下吧!\n\n\n```objc\n#import <opencv2/opencv.hpp>\n#import <opencv2/imgproc/types_c.h>\n#import <opencv2/imgcodecs/ios.h>\n\n#import \"ViewController.h\"\n\n\n@interface ViewController ()\n{\n     cv::Mat cvImage;\n}\n\n@property (weak, nonatomic) IBOutlet UIImageView *imgView;\n\n\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    UIImage *image = [UIImage imageNamed:@\"learn.jpg\"];\n    \n    UIImageToMat(image, cvImage);\n    \n    if(!cvImage.empty()){\n        cv::Mat gray;\n        // 将图像转换为灰度显示\n        cv::cvtColor(cvImage,gray,CV_RGB2GRAY);\n        // 应用高斯滤波器去除小的边缘\n        cv::GaussianBlur(gray, gray, cv::Size(5,5), 1.2,1.2);\n        // 计算与画布边缘\n        cv::Mat edges;\n        cv::Canny(gray, edges, 0, 50);\n        // 使用白色填充\n        cvImage.setTo(cv::Scalar::all(225));\n        // 修改边缘颜色\n        cvImage.setTo(cv::Scalar(0,128,255,255),edges);\n        // 将Mat转换为Xcode的UIImageView显示\n        self.imgView.image = MatToUIImage(cvImage);\n    }\n}\n\n@end\n\n```\n\n\n原图\n![finn-w290](http://oiu3ghos7.bkt.clouddn.com/finn.jpg)\n\n运行在模拟器上的效果\n![运行效果](http://oiu3ghos7.bkt.clouddn.com/14829830035512.jpg)\n\n## Demo:人脸识别\n\nDemo：人脸检测与识别\n\n现在，我们对 OpenCV 及如何把它集成到我们的应用中有了大概认识，那让我们来做一个小 demo 应用：从 iPhone 的摄像头获取视频流，对它持续进行人脸检测，并在屏幕上标出来。当用户点击一个脸孔时，应用会尝试识别这个人。如果识别结果正确，用户必须点击 “Correct”。如果识别错误，用户必须选择正确的人名来纠正错误。我们的人脸识别器就会从错误中学习，变得越来越好。\n\n### 视频拍摄\n\n\nOpenCV 的 highgui 模块中有个类，CvVideoCamera，它把 iPhone 的摄像机抽象出来，让我们的 app 通过一个代理函数 - (void)processImage:(cv::Mat&)image 来获得视频流。CvVideoCamera 实例可像下面这样进行设置：\n\n```objc\nCvVideoCamera *videoCamera = [[CvVideoCamera alloc] initWithParentView:view];  \nvideoCamera.defaultAVCaptureDevicePosition = AVCaptureDevicePositionFront;  \nvideoCamera.defaultAVCaptureSessionPreset = AVCaptureSessionPreset640x480;  \nvideoCamera.defaultAVCaptureVideoOrientation = AVCaptureVideoOrientationPortrait;  \nvideoCamera.defaultFPS = 30;  \nvideoCamera.grayscaleMode = NO;  \nvideoCamera.delegate = self;\n```\n\n摄像头的帧率被设置为 30 帧每秒， 我们实现的 processImage 函数将每秒被调用 30 次。因为我们的 app 要持续不断地检测人脸，所以我们应该在这个函数里实现人脸的检测。要注意的是，如果对某一帧进行人脸检测的时间超过 1/30 秒，就会产生掉帧现象。\n\n### 人脸检测\n\n其实你并不需要使用 OpenCV 来做人脸检测，因为 Core Image 已经提供了 CIDetector 类。用它来做人脸检测已经相当好了，并且它已经被优化过，使用起来也很容易：\n\n```objc\nCIDetector *faceDetector = [CIDetector detectorOfType:CIDetectorTypeFace context:context options:@{CIDetectorAccuracy: CIDetectorAccuracyHigh}];\n\nNSArray *faces = [faceDetector featuresInImage:image];\n```\n\n从该图片中检测到的每一张面孔都在数组 faces 中保存着一个 CIFaceFeature 实例。这个实例中保存着这张面孔的所处的位置和宽高，除此之外，眼睛和嘴的位置也是可选的。\n\n另一方面，OpenCV 也提供了一套物体检测功能，经过训练后能够检测出任何你需要的物体。该库为多个场景自带了可以直接拿来用的检测参数，如人脸、眼睛、嘴、身体、上半身、下半身和笑脸。检测引擎由一些非常简单的检测器的级联组成。这些检测器被称为 Haar 特征检测器，它们各自具有不同的尺度和权重。在训练阶段，决策树会通过已知的正确和错误的图片进行优化。关于训练与检测过程的详情可参考此原始论文。当正确的特征级联及其尺度与权重通过训练确立以后，这些参数就可被加载并初始化级联分类器了：\n\n```objc\n/ 正面人脸检测器训练参数的文件路径\nNSString *faceCascadePath = [[NSBundle mainBundle] pathForResource:@&quot;haarcascade_frontalface_alt2&quot;  \n                                                   ofType:@&quot;xml&quot;];\n \nconst CFIndex CASCADE_NAME_LEN = 2048;  \nchar *CASCADE_NAME = (char *) malloc(CASCADE_NAME_LEN);  \nCFStringGetFileSystemRepresentation( (CFStringRef)faceCascadePath, CASCADE_NAME, CASCADE_NAME_LEN);\n \nCascadeClassifier faceDetector;  \nfaceDetector.load(CASCADE_NAME);\n```\n\n这些参数文件可在 OpenCV 发行包里的 data/haarcascades 文件夹中找到。\n\n在使用所需要的参数对人脸检测器进行初始化后，就可以用它进行人脸检测了：\n\n```objc\ncv::Mat img;  \nvector&lt;cv::Rect&gt; faceRects;  \ndouble scalingFactor = 1.1;  \nint minNeighbors = 2;  \nint flags = 0;  \ncv::Size minimumSize(30,30);  \nfaceDetector.detectMultiScale(img, faceRects,  \n                              scalingFactor, minNeighbors, flags\n                              cv::Size(30, 30) );\n```\n\n检测过程中，已训练好的分类器会用不同的尺度遍历输入图像的每一个像素，以检测不同大小的人脸。参数 scalingFactor 决定每次遍历分类器后尺度会变大多少倍。参数 minNeighbors 指定一个符合条件的人脸区域应该有多少个符合条件的邻居像素才被认为是一个可能的人脸区域；如果一个符合条件的人脸区域只移动了一个像素就不再触发分类器，那么这个区域非常可能并不是我们想要的结果。拥有少于 minNeighbors 个符合条件的邻居像素的人脸区域会被拒绝掉。如果 minNeighbors 被设置为 0，所有可能的人脸区域都会被返回回来。参数 flags 是 OpenCV 1.x 版本 API 的遗留物，应该始终把它设置为 0。最后，参数 minimumSize 指定我们所寻找的人脸区域大小的最小值。faceRects 向量中将会包含对 img 进行人脸识别获得的所有人脸区域。识别的人脸图像可以通过cv::Mat 的 () 运算符提取出来，调用方式很简单：cv::Mat faceImg = img(aFaceRect)。\n\n不管是使用 CIDetector 还是 OpenCV 的 CascadeClassifier，只要我们获得了至少一个人脸区域，我们就可以对图像中的人进行识别了。\n\n\n# 遇到问题\n这是第一次导入C++的库进工程中，所以还是摸索了一段时间。\n\n1. 第一次编译的时候遇到一个问题，编译器报了个警告是\n```\n#if defined(NO)\n#  warning Detected Apple 'NO' macro definition, it can cause build conflicts. Please, include this header before any Apple headers.\n#endif\n```\n\n按照提示说明，OpenCV的头文件应该在所有APPLE的头文件之前导入，不然会抛出异常，把import调到最前面即可。\n\n\n2. 为何在 PCH 文件中引入 OpenCV 的头文件我们需要多加`#ifdef __cpluseplus`这一部分呢？这是因为 PCH 文件是一个会被**所有的文件**引入的头文件，而我们又希望 `#import <opencv2/opencv.hpp>`这部分只会被一些 C++实现文件编译，所以我们加上`#ifdef __cpluseplus`来表示这是 `C++` 文件才会编译的，除了`#ifdef __cpluseplus`，还有`#ifdef __OBJC__`这样的宏来说明编译规则（按照 OC 文件编译），这样的宏多出现于一些会被多种类型的实现文件引用的头文件中。\n\n3. 另外注意另一个问题：如果一个头文件是C++类型的头文件，那么一定要保证所有`直接`或者`间接`引用这个头文件的实现文件都要为.mm或者.cpp，否则 Xcode 就不会把这个头文件当做 C++头文件来编译，就会出现最基本的`#include <iostream>`这种引用都会报出`file not found `这样的编译错误的问题。我在编译的过程中，某个C++头文件 A.h 被 B.h 引用，然后 B.h 又被 C.m 引用，虽然 B 的实现文件是 B.mm ，但是仍然报出了之前说的那个错误\n感谢 StackOberflow 让我找到了问题发生的原因。所以对于 C++ 头文件的引用一定要注意，但凡是引用了 A.h 的实现部分，都必须是.mm或者.cpp后缀名。（同时我们也可以知道，Xcode 是根据头文件被引用的情况来判定头文件的编译 类型的）。\n\n\n\n\n\n\n# 转换UIImage和cv::Mat\n\n在 OpenCV 中同常用 cv::Mat 表示图片，而 iOS 中则是 UIImage 来表示图片，但openCV的[官方教程](http://docs.opencv.org/2.4/doc/tutorials/ios/image_manipulation/image_manipulation.html#opencviosimagemanipulation)已经给出了方法。\n\n## UIImage to cv::Mat\n\n```objc\n    - (cv::Mat)cvMatFromUIImage:(UIImage *)image\n{\n  CGColorSpaceRef colorSpace = CGImageGetColorSpace(image.CGImage);\n  CGFloat cols = image.size.width;\n  CGFloat rows = image.size.height;\n\n  cv::Mat cvMat(rows, cols, CV_8UC4); // 8 bits per component, 4 channels (color channels + alpha)\n\n  CGContextRef contextRef = CGBitmapContextCreate(cvMat.data,                 // Pointer to  data\n                                                 cols,                       // Width of bitmap\n                                                 rows,                       // Height of bitmap\n                                                 8,                          // Bits per component\n                                                 cvMat.step[0],              // Bytes per row\n                                                 colorSpace,                 // Colorspace\n                                                 kCGImageAlphaNoneSkipLast |\n                                                 kCGBitmapByteOrderDefault); // Bitmap info flags\n\n  CGContextDrawImage(contextRef, CGRectMake(0, 0, cols, rows), image.CGImage);\n  CGContextRelease(contextRef);\n\n  return cvMat;\n}\n\n```\n\n\n## cv::Mat to UIImage \n\n```objc\n-(UIImage *)UIImageFromCVMat:(cv::Mat)cvMat\n{\n  NSData *data = [NSData dataWithBytes:cvMat.data length:cvMat.elemSize()*cvMat.total()];\n  CGColorSpaceRef colorSpace;\n\n  if (cvMat.elemSize() == 1) {//可以根据这个决定使用哪种\n      colorSpace = CGColorSpaceCreateDeviceGray();\n  } else {\n      colorSpace = CGColorSpaceCreateDeviceRGB();\n  }\n\n  CGDataProviderRef provider = CGDataProviderCreateWithCFData((__bridge CFDataRef)data);\n\n  // Creating CGImage from cv::Mat\n  CGImageRef imageRef = CGImageCreate(cvMat.cols,                                 //width\n                                     cvMat.rows,                                 //height\n                                     8,                                          //bits per component\n                                     8 * cvMat.elemSize(),                       //bits per pixel\n                                     cvMat.step[0],                            //bytesPerRow\n                                     colorSpace,                                 //colorspace\n                                     kCGImageAlphaNone|kCGBitmapByteOrderDefault,// bitmap info\n                                     provider,                                   //CGDataProviderRef\n                                     NULL,                                       //decode\n                                     false,                                      //should interpolate\n                                     kCGRenderingIntentDefault                   //intent\n                                     );\n\n\n  // Getting UIImage from CGImage\n  UIImage *finalImage = [UIImage imageWithCGImage:imageRef];\n  CGImageRelease(imageRef);\n  CGDataProviderRelease(provider);\n  CGColorSpaceRelease(colorSpace);\n\n  return finalImage;\n }\n \n ```\n \n\n\n\n","slug":"OpenCVLearning","published":1,"updated":"2017-01-03T08:19:14.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj04pzyxw000ts04efhvejw46","content":"<p>本文章采用的的开发环境为：<br>1）Xcode 8.2<br>2）OpenCV for iOS 3.2 </p>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>最近公司项目进入了较为稳定的维护周期，考虑到后面很可能会进行需要生物特征识别的项目，提前学习下OpenCV，也在此和大家分享一下。</p>\n<h1 id=\"OpenCV介绍\"><a href=\"#OpenCV介绍\" class=\"headerlink\" title=\"OpenCV介绍\"></a>OpenCV介绍</h1><p>OpenCV ，是一个开源的跨平台计算机视觉和机器学习库，通俗点的说，就是他给计算机提供了一双眼睛，一双可以从图片中获取信息的眼镜，从而完成人脸识别、去红眼、追踪移动物体等等的图像相关的功能。更多具体的说明可参见 OpenCV 官网。</p>\n<h2 id=\"模块\"><a href=\"#模块\" class=\"headerlink\" title=\"模块\"></a>模块</h2><p>下面是在官方文档中列出的最重要的模块。</p>\n<p>core：简洁的核心模块，定义了基本的数据结构，包括稠密多维数组 Mat 和其他模块需要的基本函数。<br>imgproc：图像处理模块，包括线性和非线性图像滤波、几何图像转换 (缩放、仿射与透视变换、一般性基于表的重映射)、颜色空间转换、直方图等等。<br>video：视频分析模块，包括运动估计、背景消除、物体跟踪算法。<br>calib3d：包括基本的多视角几何算法、单体和立体相机的标定、对象姿态估计、双目立体匹配算法和元素的三维重建。<br>features2d：包含了显著特征检测算法、描述算子和算子匹配算法。<br>objdetect：物体检测和一些预定义的物体的检测 (如人脸、眼睛、杯子、人、汽车等)。<br>ml：多种机器学习算法，如 K 均值、支持向量机和神经网络。<br>highgui：一个简单易用的接口，提供视频捕捉、图像和视频编码等功能，还有简单的 UI 接口 (iOS 上可用的仅是其一个子集)。<br>gpu：OpenCV 中不同模块的 GPU 加速算法 (iOS 上不可用)。<br>ocl：使用 OpenCL 实现的通用算法 (iOS 上不可用)。<br>一些其它辅助模块，如 Python 绑定和用户贡献的算法。</p>\n<h2 id=\"基础类和操作\"><a href=\"#基础类和操作\" class=\"headerlink\" title=\"基础类和操作\"></a>基础类和操作</h2><p>OpenCV 包含几百个类。为简便起见，我们只看几个基础的类和操作，进一步阅读请参考全部文档。过一遍这几个核心类应该足以对这个库的机理产生一些感觉认识。</p>\n<p>cv::Mat</p>\n<p>cv::Mat 是 OpenCV 的核心数据结构，用来表示任意 N 维矩阵。因为图像只是 2 维矩阵的一个特殊场景，所以也是使用 cv::Mat来表示的。也就是说，cv::Mat 将是你在 OpenCV 中用到最多的类。</p>\n<p>一个 cv::Mat 实例的作用就像是图像数据的头，其中包含着描述图像格式的信息。图像数据只是被引用，并能为多个 cv::Mat 实例共享。OpenCV 使用类似于 ARC 的引用计数方法，以保证当最后一个来自 cv::Mat 的引用也消失的时候，图像数据会被释放。图像数据本身是图像连续的行的数组 (对 N 维矩阵来说，这个数据是由连续的 N-1 维数据组成的数组)。使用 step[] 数组中包含的值，图像的任一像素地址都可通过下面的指针运算得到：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">uchar *pixelPtr = cvMat.data + rowIndex * cvMat.step[0] + colIndex * cvMat.step[1]</div></pre></td></tr></table></figure>\n<p>每个像素的数据格式可以通过 type() 方法获得。除了常用的每通道 8 位无符号整数的灰度图 (1 通道，CV_8UC1) 和彩色图 (3 通道，CV_8UC3)，OpenCV 还支持很多不常用的格式，例如 CV_16SC3 (每像素 3 通道，每通道使用 16 位有符号整数)，甚至CV_64FC4 (每像素 4 通道，每通道使用 64 位浮点数)。</p>\n<p>cv::Algorithm</p>\n<p>Algorithm 是 OpenCV 中实现的很多算法的抽象基类，包括将在我们的 demo 工程中用到的 FaceRecognizer。它提供的 API 与苹果的 Core Image 框架中的 CIFilter 有些相似之处。创建一个 Algorithm 的时候使用算法的名字来调用 Algorithm::create()，并且可以通过 get() 和 set()方法来获取和设置各个参数，这有点像是键值编码。另外，Algorithm 从底层就支持从/向 XML 或 YAML 文件加载/保存参数的功能。</p>\n<h1 id=\"实战部分\"><a href=\"#实战部分\" class=\"headerlink\" title=\"实战部分\"></a>实战部分</h1><h2 id=\"导入工程\"><a href=\"#导入工程\" class=\"headerlink\" title=\"导入工程\"></a>导入工程</h2><p>首先下载从官网<a href=\"http://opencv.org/\" target=\"_blank\" rel=\"external\">OpenCV官网</a>下载的iOS支持库，我们新建一个工程。</p>\n<p><img src=\"http://oiu3ghos7.bkt.clouddn.com/14829768918916.jpg\" alt=\"搭建环境\"></p>\n<p>导入 OpenCV 到 Xcode 的工程中还是比较简单的，从官网下载对应的 framework，直接丢到 Xcode 的工程中，从xcode7以后拖入的工程会自动添加到Building phase里面，检查一下。<br><img src=\"http://oiu3ghos7.bkt.clouddn.com/14829783173349.jpg\" alt=\"\"></p>\n<p>然后在你想用 OpenCV 的地方引入 OpenCV 的头文件：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;opencv2/opencv.hpp&gt;</span></span></div><div class=\"line\"></div><div class=\"line\">```    </div><div class=\"line\"></div><div class=\"line\">或者直接在 PCH 文件中添加：  </div><div class=\"line\">  </div><div class=\"line\">```objc</div><div class=\"line\"><span class=\"meta\">#ifdef __cplusplus</span></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;opencv2/opencv.hpp&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#endif</span></div><div class=\"line\"></div><div class=\"line\">```    </div><div class=\"line\"></div><div class=\"line\">把使用到 OpenCV 中 C++方法的实现文件后缀名改成.mm，就可以开始使用 OpenCV 的方法了。</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">### Objective-C++</span></div><div class=\"line\"></div><div class=\"line\">如前面所说，OpenCV 是一个 C++ 的 API，因此不能直接在 Swift 和 Objective-C 代码中使用，但能在 Objective-C++ 文件中使用。</div><div class=\"line\"></div><div class=\"line\">Objective-C++ 是 Objective-C 和 C++ 的混合物，让你可以在 Objective-C 类中使用 C++ 对象。clang 编译器会把所有后缀名为.mm 的文件都当做是 Objective-C++。一般来说，它会如你所期望的那样运行，但还是有一些使用 Objective-C++ 的注意事项。内存管理是你最应该格外注意的点，因为 ARC 只对 Objective-C 对象有效。当你使用一个 C++ 对象作为类属性的时候，其唯一有效的属性就是 <span class=\"keyword\">assign</span>。因此，你的 dealloc 函数应确保 C++ 对象被正确地释放了。</div><div class=\"line\"></div><div class=\"line\">第二重要的点就是，如果你在 Objective-C++ 头文件中引入了 C++ 头文件，当你在工程中使用该 Objective-C++ 文件的时候就泄露了 C++ 的依赖。任何引入你的 Objective-C++ 类的 Objective-C 类也会引入该 C++ 类，因此该 Objective-C 文件也要被声明为 Objective-C++ 的文件。这会像森林大火一样在工程中迅速蔓延。所以，应该把你引入 C++ 文件的地方都用 <span class=\"meta\">#ifdef __cplusplus包起来，并且只要可能，就尽量只在 .mm 实现文件中引入 C++ 头文件。</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">看起来很简单，然而实际操作中还是有不少的问题。</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">&lt;!------MORE-------&gt;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">## 小热身</span></div><div class=\"line\"></div><div class=\"line\">由于OpenCV代码是基于C++编写的，因此，要在项目中运行c++代码，需要将实现文件名后缀由`.m`改成`.mm`，如下图所示。</div><div class=\"line\">![](http:<span class=\"comment\">//oiu3ghos7.bkt.clouddn.com/14829787278230.jpg)</span></div><div class=\"line\"></div><div class=\"line\">再次强调一次使用opencv的类名一定要改成.mm!</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">说了那么多先测试一下吧!</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">```objc</div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;opencv2/opencv.hpp&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;opencv2/imgproc/types_c.h&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;opencv2/imgcodecs/ios.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"ViewController.h\"</span></span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">ViewController</span> ()</span></div><div class=\"line\">&#123;</div><div class=\"line\">     cv::Mat cvImage;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">weak</span>, <span class=\"keyword\">nonatomic</span>) <span class=\"keyword\">IBOutlet</span> <span class=\"built_in\">UIImageView</span> *imgView;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">ViewController</span></span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</div><div class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"built_in\">UIImage</span> *image = [<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"learn.jpg\"</span>];</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"built_in\">UIImageToMat</span>(image, cvImage);</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">if</span>(!cvImage.empty())&#123;</div><div class=\"line\">        cv::Mat gray;</div><div class=\"line\">        <span class=\"comment\">// 将图像转换为灰度显示</span></div><div class=\"line\">        cv::cvtColor(cvImage,gray,CV_RGB2GRAY);</div><div class=\"line\">        <span class=\"comment\">// 应用高斯滤波器去除小的边缘</span></div><div class=\"line\">        cv::GaussianBlur(gray, gray, cv::Size(<span class=\"number\">5</span>,<span class=\"number\">5</span>), <span class=\"number\">1.2</span>,<span class=\"number\">1.2</span>);</div><div class=\"line\">        <span class=\"comment\">// 计算与画布边缘</span></div><div class=\"line\">        cv::Mat edges;</div><div class=\"line\">        cv::Canny(gray, edges, <span class=\"number\">0</span>, <span class=\"number\">50</span>);</div><div class=\"line\">        <span class=\"comment\">// 使用白色填充</span></div><div class=\"line\">        cvImage.setTo(cv::Scalar::all(<span class=\"number\">225</span>));</div><div class=\"line\">        <span class=\"comment\">// 修改边缘颜色</span></div><div class=\"line\">        cvImage.setTo(cv::Scalar(<span class=\"number\">0</span>,<span class=\"number\">128</span>,<span class=\"number\">255</span>,<span class=\"number\">255</span>),edges);</div><div class=\"line\">        <span class=\"comment\">// 将Mat转换为Xcode的UIImageView显示</span></div><div class=\"line\">        <span class=\"keyword\">self</span>.imgView.image = MatToUIImage(cvImage);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p>原图<br><img src=\"http://oiu3ghos7.bkt.clouddn.com/finn.jpg\" alt=\"finn-w290\"></p>\n<p>运行在模拟器上的效果<br><img src=\"http://oiu3ghos7.bkt.clouddn.com/14829830035512.jpg\" alt=\"运行效果\"></p>\n<h2 id=\"Demo-人脸识别\"><a href=\"#Demo-人脸识别\" class=\"headerlink\" title=\"Demo:人脸识别\"></a>Demo:人脸识别</h2><p>Demo：人脸检测与识别</p>\n<p>现在，我们对 OpenCV 及如何把它集成到我们的应用中有了大概认识，那让我们来做一个小 demo 应用：从 iPhone 的摄像头获取视频流，对它持续进行人脸检测，并在屏幕上标出来。当用户点击一个脸孔时，应用会尝试识别这个人。如果识别结果正确，用户必须点击 “Correct”。如果识别错误，用户必须选择正确的人名来纠正错误。我们的人脸识别器就会从错误中学习，变得越来越好。</p>\n<h3 id=\"视频拍摄\"><a href=\"#视频拍摄\" class=\"headerlink\" title=\"视频拍摄\"></a>视频拍摄</h3><p>OpenCV 的 highgui 模块中有个类，CvVideoCamera，它把 iPhone 的摄像机抽象出来，让我们的 app 通过一个代理函数 - (void)processImage:(cv::Mat&amp;)image 来获得视频流。CvVideoCamera 实例可像下面这样进行设置：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">CvVideoCamera *videoCamera = [[CvVideoCamera alloc] initWithParentView:view];  </div><div class=\"line\">videoCamera.defaultAVCaptureDevicePosition = <span class=\"built_in\">AVCaptureDevicePositionFront</span>;  </div><div class=\"line\">videoCamera.defaultAVCaptureSessionPreset = <span class=\"built_in\">AVCaptureSessionPreset640x480</span>;  </div><div class=\"line\">videoCamera.defaultAVCaptureVideoOrientation = <span class=\"built_in\">AVCaptureVideoOrientationPortrait</span>;  </div><div class=\"line\">videoCamera.defaultFPS = <span class=\"number\">30</span>;  </div><div class=\"line\">videoCamera.grayscaleMode = <span class=\"literal\">NO</span>;  </div><div class=\"line\">videoCamera.delegate = <span class=\"keyword\">self</span>;</div></pre></td></tr></table></figure>\n<p>摄像头的帧率被设置为 30 帧每秒， 我们实现的 processImage 函数将每秒被调用 30 次。因为我们的 app 要持续不断地检测人脸，所以我们应该在这个函数里实现人脸的检测。要注意的是，如果对某一帧进行人脸检测的时间超过 1/30 秒，就会产生掉帧现象。</p>\n<h3 id=\"人脸检测\"><a href=\"#人脸检测\" class=\"headerlink\" title=\"人脸检测\"></a>人脸检测</h3><p>其实你并不需要使用 OpenCV 来做人脸检测，因为 Core Image 已经提供了 CIDetector 类。用它来做人脸检测已经相当好了，并且它已经被优化过，使用起来也很容易：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">CIDetector</span> *faceDetector = [<span class=\"built_in\">CIDetector</span> detectorOfType:<span class=\"built_in\">CIDetectorTypeFace</span> context:context options:@&#123;<span class=\"built_in\">CIDetectorAccuracy</span>: <span class=\"built_in\">CIDetectorAccuracyHigh</span>&#125;];</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">NSArray</span> *faces = [faceDetector featuresInImage:image];</div></pre></td></tr></table></figure>\n<p>从该图片中检测到的每一张面孔都在数组 faces 中保存着一个 CIFaceFeature 实例。这个实例中保存着这张面孔的所处的位置和宽高，除此之外，眼睛和嘴的位置也是可选的。</p>\n<p>另一方面，OpenCV 也提供了一套物体检测功能，经过训练后能够检测出任何你需要的物体。该库为多个场景自带了可以直接拿来用的检测参数，如人脸、眼睛、嘴、身体、上半身、下半身和笑脸。检测引擎由一些非常简单的检测器的级联组成。这些检测器被称为 Haar 特征检测器，它们各自具有不同的尺度和权重。在训练阶段，决策树会通过已知的正确和错误的图片进行优化。关于训练与检测过程的详情可参考此原始论文。当正确的特征级联及其尺度与权重通过训练确立以后，这些参数就可被加载并初始化级联分类器了：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">/ 正面人脸检测器训练参数的文件路径</div><div class=\"line\"><span class=\"built_in\">NSString</span> *faceCascadePath = [[<span class=\"built_in\">NSBundle</span> mainBundle] pathForResource:@&amp;quot;haarcascade_frontalface_alt2&amp;quot;  </div><div class=\"line\">                                                   ofType:@&amp;quot;xml&amp;quot;];</div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"built_in\">CFIndex</span> <span class=\"built_in\">CASCADE_NAME_LEN</span> = <span class=\"number\">2048</span>;  </div><div class=\"line\"><span class=\"keyword\">char</span> *<span class=\"built_in\">CASCADE_NAME</span> = (<span class=\"keyword\">char</span> *) malloc(<span class=\"built_in\">CASCADE_NAME_LEN</span>);  </div><div class=\"line\"><span class=\"built_in\">CFStringGetFileSystemRepresentation</span>( (<span class=\"built_in\">CFStringRef</span>)faceCascadePath, <span class=\"built_in\">CASCADE_NAME</span>, <span class=\"built_in\">CASCADE_NAME_LEN</span>);</div><div class=\"line\"> </div><div class=\"line\">CascadeClassifier faceDetector;  </div><div class=\"line\">faceDetector.load(<span class=\"built_in\">CASCADE_NAME</span>);</div></pre></td></tr></table></figure>\n<p>这些参数文件可在 OpenCV 发行包里的 data/haarcascades 文件夹中找到。</p>\n<p>在使用所需要的参数对人脸检测器进行初始化后，就可以用它进行人脸检测了：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">cv::Mat img;  </div><div class=\"line\">vector&amp;lt;cv::Rect&amp;gt; faceRects;  </div><div class=\"line\"><span class=\"keyword\">double</span> scalingFactor = <span class=\"number\">1.1</span>;  </div><div class=\"line\"><span class=\"keyword\">int</span> minNeighbors = <span class=\"number\">2</span>;  </div><div class=\"line\"><span class=\"keyword\">int</span> flags = <span class=\"number\">0</span>;  </div><div class=\"line\">cv::Size minimumSize(<span class=\"number\">30</span>,<span class=\"number\">30</span>);  </div><div class=\"line\">faceDetector.detectMultiScale(img, faceRects,  </div><div class=\"line\">                              scalingFactor, minNeighbors, flags</div><div class=\"line\">                              cv::Size(<span class=\"number\">30</span>, <span class=\"number\">30</span>) );</div></pre></td></tr></table></figure>\n<p>检测过程中，已训练好的分类器会用不同的尺度遍历输入图像的每一个像素，以检测不同大小的人脸。参数 scalingFactor 决定每次遍历分类器后尺度会变大多少倍。参数 minNeighbors 指定一个符合条件的人脸区域应该有多少个符合条件的邻居像素才被认为是一个可能的人脸区域；如果一个符合条件的人脸区域只移动了一个像素就不再触发分类器，那么这个区域非常可能并不是我们想要的结果。拥有少于 minNeighbors 个符合条件的邻居像素的人脸区域会被拒绝掉。如果 minNeighbors 被设置为 0，所有可能的人脸区域都会被返回回来。参数 flags 是 OpenCV 1.x 版本 API 的遗留物，应该始终把它设置为 0。最后，参数 minimumSize 指定我们所寻找的人脸区域大小的最小值。faceRects 向量中将会包含对 img 进行人脸识别获得的所有人脸区域。识别的人脸图像可以通过cv::Mat 的 () 运算符提取出来，调用方式很简单：cv::Mat faceImg = img(aFaceRect)。</p>\n<p>不管是使用 CIDetector 还是 OpenCV 的 CascadeClassifier，只要我们获得了至少一个人脸区域，我们就可以对图像中的人进行识别了。</p>\n<h1 id=\"遇到问题\"><a href=\"#遇到问题\" class=\"headerlink\" title=\"遇到问题\"></a>遇到问题</h1><p>这是第一次导入C++的库进工程中，所以还是摸索了一段时间。</p>\n<ol>\n<li>第一次编译的时候遇到一个问题，编译器报了个警告是<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">#if defined(NO)</div><div class=\"line\">#  warning Detected Apple &apos;NO&apos; macro definition, it can cause build conflicts. Please, include this header before any Apple headers.</div><div class=\"line\">#endif</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>按照提示说明，OpenCV的头文件应该在所有APPLE的头文件之前导入，不然会抛出异常，把import调到最前面即可。</p>\n<ol>\n<li><p>为何在 PCH 文件中引入 OpenCV 的头文件我们需要多加<code>#ifdef __cpluseplus</code>这一部分呢？这是因为 PCH 文件是一个会被<strong>所有的文件</strong>引入的头文件，而我们又希望 <code>#import &lt;opencv2/opencv.hpp&gt;</code>这部分只会被一些 C++实现文件编译，所以我们加上<code>#ifdef __cpluseplus</code>来表示这是 <code>C++</code> 文件才会编译的，除了<code>#ifdef __cpluseplus</code>，还有<code>#ifdef __OBJC__</code>这样的宏来说明编译规则（按照 OC 文件编译），这样的宏多出现于一些会被多种类型的实现文件引用的头文件中。</p>\n</li>\n<li><p>另外注意另一个问题：如果一个头文件是C++类型的头文件，那么一定要保证所有<code>直接</code>或者<code>间接</code>引用这个头文件的实现文件都要为.mm或者.cpp，否则 Xcode 就不会把这个头文件当做 C++头文件来编译，就会出现最基本的<code>#include &lt;iostream&gt;</code>这种引用都会报出<code>file not found</code>这样的编译错误的问题。我在编译的过程中，某个C++头文件 A.h 被 B.h 引用，然后 B.h 又被 C.m 引用，虽然 B 的实现文件是 B.mm ，但是仍然报出了之前说的那个错误<br>感谢 StackOberflow 让我找到了问题发生的原因。所以对于 C++ 头文件的引用一定要注意，但凡是引用了 A.h 的实现部分，都必须是.mm或者.cpp后缀名。（同时我们也可以知道，Xcode 是根据头文件被引用的情况来判定头文件的编译 类型的）。</p>\n</li>\n</ol>\n<h1 id=\"转换UIImage和cv-Mat\"><a href=\"#转换UIImage和cv-Mat\" class=\"headerlink\" title=\"转换UIImage和cv::Mat\"></a>转换UIImage和cv::Mat</h1><p>在 OpenCV 中同常用 cv::Mat 表示图片，而 iOS 中则是 UIImage 来表示图片，但openCV的<a href=\"http://docs.opencv.org/2.4/doc/tutorials/ios/image_manipulation/image_manipulation.html#opencviosimagemanipulation\" target=\"_blank\" rel=\"external\">官方教程</a>已经给出了方法。</p>\n<h2 id=\"UIImage-to-cv-Mat\"><a href=\"#UIImage-to-cv-Mat\" class=\"headerlink\" title=\"UIImage to cv::Mat\"></a>UIImage to cv::Mat</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">    - (cv::Mat)cvMatFromUIImage:(<span class=\"built_in\">UIImage</span> *)image</div><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"built_in\">CGColorSpaceRef</span> colorSpace = <span class=\"built_in\">CGImageGetColorSpace</span>(image.CGImage);</div><div class=\"line\">  <span class=\"built_in\">CGFloat</span> cols = image.size.width;</div><div class=\"line\">  <span class=\"built_in\">CGFloat</span> rows = image.size.height;</div><div class=\"line\"></div><div class=\"line\">  cv::Mat cvMat(rows, cols, CV_8UC4); <span class=\"comment\">// 8 bits per component, 4 channels (color channels + alpha)</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"built_in\">CGContextRef</span> contextRef = <span class=\"built_in\">CGBitmapContextCreate</span>(cvMat.data,                 <span class=\"comment\">// Pointer to  data</span></div><div class=\"line\">                                                 cols,                       <span class=\"comment\">// Width of bitmap</span></div><div class=\"line\">                                                 rows,                       <span class=\"comment\">// Height of bitmap</span></div><div class=\"line\">                                                 <span class=\"number\">8</span>,                          <span class=\"comment\">// Bits per component</span></div><div class=\"line\">                                                 cvMat.step[<span class=\"number\">0</span>],              <span class=\"comment\">// Bytes per row</span></div><div class=\"line\">                                                 colorSpace,                 <span class=\"comment\">// Colorspace</span></div><div class=\"line\">                                                 kCGImageAlphaNoneSkipLast |</div><div class=\"line\">                                                 kCGBitmapByteOrderDefault); <span class=\"comment\">// Bitmap info flags</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"built_in\">CGContextDrawImage</span>(contextRef, <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, cols, rows), image.CGImage);</div><div class=\"line\">  <span class=\"built_in\">CGContextRelease</span>(contextRef);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> cvMat;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"cv-Mat-to-UIImage\"><a href=\"#cv-Mat-to-UIImage\" class=\"headerlink\" title=\"cv::Mat to UIImage\"></a>cv::Mat to UIImage</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(<span class=\"built_in\">UIImage</span> *)<span class=\"built_in\">UIImageFromCVMat</span>:(cv::Mat)cvMat</div><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"built_in\">NSData</span> *data = [<span class=\"built_in\">NSData</span> dataWithBytes:cvMat.data length:cvMat.elemSize()*cvMat.total()];</div><div class=\"line\">  <span class=\"built_in\">CGColorSpaceRef</span> colorSpace;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">if</span> (cvMat.elemSize() == <span class=\"number\">1</span>) &#123;<span class=\"comment\">//可以根据这个决定使用哪种</span></div><div class=\"line\">      colorSpace = <span class=\"built_in\">CGColorSpaceCreateDeviceGray</span>();</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      colorSpace = <span class=\"built_in\">CGColorSpaceCreateDeviceRGB</span>();</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"built_in\">CGDataProviderRef</span> provider = <span class=\"built_in\">CGDataProviderCreateWithCFData</span>((__bridge <span class=\"built_in\">CFDataRef</span>)data);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// Creating CGImage from cv::Mat</span></div><div class=\"line\">  <span class=\"built_in\">CGImageRef</span> imageRef = <span class=\"built_in\">CGImageCreate</span>(cvMat.cols,                                 <span class=\"comment\">//width</span></div><div class=\"line\">                                     cvMat.rows,                                 <span class=\"comment\">//height</span></div><div class=\"line\">                                     <span class=\"number\">8</span>,                                          <span class=\"comment\">//bits per component</span></div><div class=\"line\">                                     <span class=\"number\">8</span> * cvMat.elemSize(),                       <span class=\"comment\">//bits per pixel</span></div><div class=\"line\">                                     cvMat.step[<span class=\"number\">0</span>],                            <span class=\"comment\">//bytesPerRow</span></div><div class=\"line\">                                     colorSpace,                                 <span class=\"comment\">//colorspace</span></div><div class=\"line\">                                     kCGImageAlphaNone|kCGBitmapByteOrderDefault,<span class=\"comment\">// bitmap info</span></div><div class=\"line\">                                     provider,                                   <span class=\"comment\">//CGDataProviderRef</span></div><div class=\"line\">                                     <span class=\"literal\">NULL</span>,                                       <span class=\"comment\">//decode</span></div><div class=\"line\">                                     <span class=\"literal\">false</span>,                                      <span class=\"comment\">//should interpolate</span></div><div class=\"line\">                                     kCGRenderingIntentDefault                   <span class=\"comment\">//intent</span></div><div class=\"line\">                                     );</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// Getting UIImage from CGImage</span></div><div class=\"line\">  <span class=\"built_in\">UIImage</span> *finalImage = [<span class=\"built_in\">UIImage</span> imageWithCGImage:imageRef];</div><div class=\"line\">  <span class=\"built_in\">CGImageRelease</span>(imageRef);</div><div class=\"line\">  <span class=\"built_in\">CGDataProviderRelease</span>(provider);</div><div class=\"line\">  <span class=\"built_in\">CGColorSpaceRelease</span>(colorSpace);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> finalImage;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n","excerpt":"","more":"<p>本文章采用的的开发环境为：<br>1）Xcode 8.2<br>2）OpenCV for iOS 3.2 </p>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>最近公司项目进入了较为稳定的维护周期，考虑到后面很可能会进行需要生物特征识别的项目，提前学习下OpenCV，也在此和大家分享一下。</p>\n<h1 id=\"OpenCV介绍\"><a href=\"#OpenCV介绍\" class=\"headerlink\" title=\"OpenCV介绍\"></a>OpenCV介绍</h1><p>OpenCV ，是一个开源的跨平台计算机视觉和机器学习库，通俗点的说，就是他给计算机提供了一双眼睛，一双可以从图片中获取信息的眼镜，从而完成人脸识别、去红眼、追踪移动物体等等的图像相关的功能。更多具体的说明可参见 OpenCV 官网。</p>\n<h2 id=\"模块\"><a href=\"#模块\" class=\"headerlink\" title=\"模块\"></a>模块</h2><p>下面是在官方文档中列出的最重要的模块。</p>\n<p>core：简洁的核心模块，定义了基本的数据结构，包括稠密多维数组 Mat 和其他模块需要的基本函数。<br>imgproc：图像处理模块，包括线性和非线性图像滤波、几何图像转换 (缩放、仿射与透视变换、一般性基于表的重映射)、颜色空间转换、直方图等等。<br>video：视频分析模块，包括运动估计、背景消除、物体跟踪算法。<br>calib3d：包括基本的多视角几何算法、单体和立体相机的标定、对象姿态估计、双目立体匹配算法和元素的三维重建。<br>features2d：包含了显著特征检测算法、描述算子和算子匹配算法。<br>objdetect：物体检测和一些预定义的物体的检测 (如人脸、眼睛、杯子、人、汽车等)。<br>ml：多种机器学习算法，如 K 均值、支持向量机和神经网络。<br>highgui：一个简单易用的接口，提供视频捕捉、图像和视频编码等功能，还有简单的 UI 接口 (iOS 上可用的仅是其一个子集)。<br>gpu：OpenCV 中不同模块的 GPU 加速算法 (iOS 上不可用)。<br>ocl：使用 OpenCL 实现的通用算法 (iOS 上不可用)。<br>一些其它辅助模块，如 Python 绑定和用户贡献的算法。</p>\n<h2 id=\"基础类和操作\"><a href=\"#基础类和操作\" class=\"headerlink\" title=\"基础类和操作\"></a>基础类和操作</h2><p>OpenCV 包含几百个类。为简便起见，我们只看几个基础的类和操作，进一步阅读请参考全部文档。过一遍这几个核心类应该足以对这个库的机理产生一些感觉认识。</p>\n<p>cv::Mat</p>\n<p>cv::Mat 是 OpenCV 的核心数据结构，用来表示任意 N 维矩阵。因为图像只是 2 维矩阵的一个特殊场景，所以也是使用 cv::Mat来表示的。也就是说，cv::Mat 将是你在 OpenCV 中用到最多的类。</p>\n<p>一个 cv::Mat 实例的作用就像是图像数据的头，其中包含着描述图像格式的信息。图像数据只是被引用，并能为多个 cv::Mat 实例共享。OpenCV 使用类似于 ARC 的引用计数方法，以保证当最后一个来自 cv::Mat 的引用也消失的时候，图像数据会被释放。图像数据本身是图像连续的行的数组 (对 N 维矩阵来说，这个数据是由连续的 N-1 维数据组成的数组)。使用 step[] 数组中包含的值，图像的任一像素地址都可通过下面的指针运算得到：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">uchar *pixelPtr = cvMat.data + rowIndex * cvMat.step[0] + colIndex * cvMat.step[1]</div></pre></td></tr></table></figure>\n<p>每个像素的数据格式可以通过 type() 方法获得。除了常用的每通道 8 位无符号整数的灰度图 (1 通道，CV_8UC1) 和彩色图 (3 通道，CV_8UC3)，OpenCV 还支持很多不常用的格式，例如 CV_16SC3 (每像素 3 通道，每通道使用 16 位有符号整数)，甚至CV_64FC4 (每像素 4 通道，每通道使用 64 位浮点数)。</p>\n<p>cv::Algorithm</p>\n<p>Algorithm 是 OpenCV 中实现的很多算法的抽象基类，包括将在我们的 demo 工程中用到的 FaceRecognizer。它提供的 API 与苹果的 Core Image 框架中的 CIFilter 有些相似之处。创建一个 Algorithm 的时候使用算法的名字来调用 Algorithm::create()，并且可以通过 get() 和 set()方法来获取和设置各个参数，这有点像是键值编码。另外，Algorithm 从底层就支持从/向 XML 或 YAML 文件加载/保存参数的功能。</p>\n<h1 id=\"实战部分\"><a href=\"#实战部分\" class=\"headerlink\" title=\"实战部分\"></a>实战部分</h1><h2 id=\"导入工程\"><a href=\"#导入工程\" class=\"headerlink\" title=\"导入工程\"></a>导入工程</h2><p>首先下载从官网<a href=\"http://opencv.org/\">OpenCV官网</a>下载的iOS支持库，我们新建一个工程。</p>\n<p><img src=\"http://oiu3ghos7.bkt.clouddn.com/14829768918916.jpg\" alt=\"搭建环境\"></p>\n<p>导入 OpenCV 到 Xcode 的工程中还是比较简单的，从官网下载对应的 framework，直接丢到 Xcode 的工程中，从xcode7以后拖入的工程会自动添加到Building phase里面，检查一下。<br><img src=\"http://oiu3ghos7.bkt.clouddn.com/14829783173349.jpg\" alt=\"\"></p>\n<p>然后在你想用 OpenCV 的地方引入 OpenCV 的头文件：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;opencv2/opencv.hpp&gt;</span></span></div><div class=\"line\"></div><div class=\"line\">```    </div><div class=\"line\"></div><div class=\"line\">或者直接在 PCH 文件中添加：  </div><div class=\"line\">  </div><div class=\"line\">```objc</div><div class=\"line\"><span class=\"meta\">#ifdef __cplusplus</span></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;opencv2/opencv.hpp&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#endif</span></div><div class=\"line\"></div><div class=\"line\">```    </div><div class=\"line\"></div><div class=\"line\">把使用到 OpenCV 中 C++方法的实现文件后缀名改成.mm，就可以开始使用 OpenCV 的方法了。</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">### Objective-C++</span></div><div class=\"line\"></div><div class=\"line\">如前面所说，OpenCV 是一个 C++ 的 API，因此不能直接在 Swift 和 Objective-C 代码中使用，但能在 Objective-C++ 文件中使用。</div><div class=\"line\"></div><div class=\"line\">Objective-C++ 是 Objective-C 和 C++ 的混合物，让你可以在 Objective-C 类中使用 C++ 对象。clang 编译器会把所有后缀名为.mm 的文件都当做是 Objective-C++。一般来说，它会如你所期望的那样运行，但还是有一些使用 Objective-C++ 的注意事项。内存管理是你最应该格外注意的点，因为 ARC 只对 Objective-C 对象有效。当你使用一个 C++ 对象作为类属性的时候，其唯一有效的属性就是 <span class=\"keyword\">assign</span>。因此，你的 dealloc 函数应确保 C++ 对象被正确地释放了。</div><div class=\"line\"></div><div class=\"line\">第二重要的点就是，如果你在 Objective-C++ 头文件中引入了 C++ 头文件，当你在工程中使用该 Objective-C++ 文件的时候就泄露了 C++ 的依赖。任何引入你的 Objective-C++ 类的 Objective-C 类也会引入该 C++ 类，因此该 Objective-C 文件也要被声明为 Objective-C++ 的文件。这会像森林大火一样在工程中迅速蔓延。所以，应该把你引入 C++ 文件的地方都用 <span class=\"meta\">#ifdef __cplusplus包起来，并且只要可能，就尽量只在 .mm 实现文件中引入 C++ 头文件。</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">看起来很简单，然而实际操作中还是有不少的问题。</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">&lt;!------MORE-------&gt;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">## 小热身</span></div><div class=\"line\"></div><div class=\"line\">由于OpenCV代码是基于C++编写的，因此，要在项目中运行c++代码，需要将实现文件名后缀由`.m`改成`.mm`，如下图所示。</div><div class=\"line\">![](http:<span class=\"comment\">//oiu3ghos7.bkt.clouddn.com/14829787278230.jpg)</span></div><div class=\"line\"></div><div class=\"line\">再次强调一次使用opencv的类名一定要改成.mm!</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">说了那么多先测试一下吧!</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">```objc</div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;opencv2/opencv.hpp&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;opencv2/imgproc/types_c.h&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;opencv2/imgcodecs/ios.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"ViewController.h\"</span></span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">ViewController</span> ()</span></div><div class=\"line\">&#123;</div><div class=\"line\">     cv::Mat cvImage;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">weak</span>, <span class=\"keyword\">nonatomic</span>) <span class=\"keyword\">IBOutlet</span> <span class=\"built_in\">UIImageView</span> *imgView;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">ViewController</span></span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</div><div class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"built_in\">UIImage</span> *image = [<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"learn.jpg\"</span>];</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"built_in\">UIImageToMat</span>(image, cvImage);</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">if</span>(!cvImage.empty())&#123;</div><div class=\"line\">        cv::Mat gray;</div><div class=\"line\">        <span class=\"comment\">// 将图像转换为灰度显示</span></div><div class=\"line\">        cv::cvtColor(cvImage,gray,CV_RGB2GRAY);</div><div class=\"line\">        <span class=\"comment\">// 应用高斯滤波器去除小的边缘</span></div><div class=\"line\">        cv::GaussianBlur(gray, gray, cv::Size(<span class=\"number\">5</span>,<span class=\"number\">5</span>), <span class=\"number\">1.2</span>,<span class=\"number\">1.2</span>);</div><div class=\"line\">        <span class=\"comment\">// 计算与画布边缘</span></div><div class=\"line\">        cv::Mat edges;</div><div class=\"line\">        cv::Canny(gray, edges, <span class=\"number\">0</span>, <span class=\"number\">50</span>);</div><div class=\"line\">        <span class=\"comment\">// 使用白色填充</span></div><div class=\"line\">        cvImage.setTo(cv::Scalar::all(<span class=\"number\">225</span>));</div><div class=\"line\">        <span class=\"comment\">// 修改边缘颜色</span></div><div class=\"line\">        cvImage.setTo(cv::Scalar(<span class=\"number\">0</span>,<span class=\"number\">128</span>,<span class=\"number\">255</span>,<span class=\"number\">255</span>),edges);</div><div class=\"line\">        <span class=\"comment\">// 将Mat转换为Xcode的UIImageView显示</span></div><div class=\"line\">        <span class=\"keyword\">self</span>.imgView.image = MatToUIImage(cvImage);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p>原图<br><img src=\"http://oiu3ghos7.bkt.clouddn.com/finn.jpg\" alt=\"finn-w290\"></p>\n<p>运行在模拟器上的效果<br><img src=\"http://oiu3ghos7.bkt.clouddn.com/14829830035512.jpg\" alt=\"运行效果\"></p>\n<h2 id=\"Demo-人脸识别\"><a href=\"#Demo-人脸识别\" class=\"headerlink\" title=\"Demo:人脸识别\"></a>Demo:人脸识别</h2><p>Demo：人脸检测与识别</p>\n<p>现在，我们对 OpenCV 及如何把它集成到我们的应用中有了大概认识，那让我们来做一个小 demo 应用：从 iPhone 的摄像头获取视频流，对它持续进行人脸检测，并在屏幕上标出来。当用户点击一个脸孔时，应用会尝试识别这个人。如果识别结果正确，用户必须点击 “Correct”。如果识别错误，用户必须选择正确的人名来纠正错误。我们的人脸识别器就会从错误中学习，变得越来越好。</p>\n<h3 id=\"视频拍摄\"><a href=\"#视频拍摄\" class=\"headerlink\" title=\"视频拍摄\"></a>视频拍摄</h3><p>OpenCV 的 highgui 模块中有个类，CvVideoCamera，它把 iPhone 的摄像机抽象出来，让我们的 app 通过一个代理函数 - (void)processImage:(cv::Mat&amp;)image 来获得视频流。CvVideoCamera 实例可像下面这样进行设置：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">CvVideoCamera *videoCamera = [[CvVideoCamera alloc] initWithParentView:view];  </div><div class=\"line\">videoCamera.defaultAVCaptureDevicePosition = <span class=\"built_in\">AVCaptureDevicePositionFront</span>;  </div><div class=\"line\">videoCamera.defaultAVCaptureSessionPreset = <span class=\"built_in\">AVCaptureSessionPreset640x480</span>;  </div><div class=\"line\">videoCamera.defaultAVCaptureVideoOrientation = <span class=\"built_in\">AVCaptureVideoOrientationPortrait</span>;  </div><div class=\"line\">videoCamera.defaultFPS = <span class=\"number\">30</span>;  </div><div class=\"line\">videoCamera.grayscaleMode = <span class=\"literal\">NO</span>;  </div><div class=\"line\">videoCamera.delegate = <span class=\"keyword\">self</span>;</div></pre></td></tr></table></figure>\n<p>摄像头的帧率被设置为 30 帧每秒， 我们实现的 processImage 函数将每秒被调用 30 次。因为我们的 app 要持续不断地检测人脸，所以我们应该在这个函数里实现人脸的检测。要注意的是，如果对某一帧进行人脸检测的时间超过 1/30 秒，就会产生掉帧现象。</p>\n<h3 id=\"人脸检测\"><a href=\"#人脸检测\" class=\"headerlink\" title=\"人脸检测\"></a>人脸检测</h3><p>其实你并不需要使用 OpenCV 来做人脸检测，因为 Core Image 已经提供了 CIDetector 类。用它来做人脸检测已经相当好了，并且它已经被优化过，使用起来也很容易：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">CIDetector</span> *faceDetector = [<span class=\"built_in\">CIDetector</span> detectorOfType:<span class=\"built_in\">CIDetectorTypeFace</span> context:context options:@&#123;<span class=\"built_in\">CIDetectorAccuracy</span>: <span class=\"built_in\">CIDetectorAccuracyHigh</span>&#125;];</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">NSArray</span> *faces = [faceDetector featuresInImage:image];</div></pre></td></tr></table></figure>\n<p>从该图片中检测到的每一张面孔都在数组 faces 中保存着一个 CIFaceFeature 实例。这个实例中保存着这张面孔的所处的位置和宽高，除此之外，眼睛和嘴的位置也是可选的。</p>\n<p>另一方面，OpenCV 也提供了一套物体检测功能，经过训练后能够检测出任何你需要的物体。该库为多个场景自带了可以直接拿来用的检测参数，如人脸、眼睛、嘴、身体、上半身、下半身和笑脸。检测引擎由一些非常简单的检测器的级联组成。这些检测器被称为 Haar 特征检测器，它们各自具有不同的尺度和权重。在训练阶段，决策树会通过已知的正确和错误的图片进行优化。关于训练与检测过程的详情可参考此原始论文。当正确的特征级联及其尺度与权重通过训练确立以后，这些参数就可被加载并初始化级联分类器了：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">/ 正面人脸检测器训练参数的文件路径</div><div class=\"line\"><span class=\"built_in\">NSString</span> *faceCascadePath = [[<span class=\"built_in\">NSBundle</span> mainBundle] pathForResource:@&amp;quot;haarcascade_frontalface_alt2&amp;quot;  </div><div class=\"line\">                                                   ofType:@&amp;quot;xml&amp;quot;];</div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"built_in\">CFIndex</span> <span class=\"built_in\">CASCADE_NAME_LEN</span> = <span class=\"number\">2048</span>;  </div><div class=\"line\"><span class=\"keyword\">char</span> *<span class=\"built_in\">CASCADE_NAME</span> = (<span class=\"keyword\">char</span> *) malloc(<span class=\"built_in\">CASCADE_NAME_LEN</span>);  </div><div class=\"line\"><span class=\"built_in\">CFStringGetFileSystemRepresentation</span>( (<span class=\"built_in\">CFStringRef</span>)faceCascadePath, <span class=\"built_in\">CASCADE_NAME</span>, <span class=\"built_in\">CASCADE_NAME_LEN</span>);</div><div class=\"line\"> </div><div class=\"line\">CascadeClassifier faceDetector;  </div><div class=\"line\">faceDetector.load(<span class=\"built_in\">CASCADE_NAME</span>);</div></pre></td></tr></table></figure>\n<p>这些参数文件可在 OpenCV 发行包里的 data/haarcascades 文件夹中找到。</p>\n<p>在使用所需要的参数对人脸检测器进行初始化后，就可以用它进行人脸检测了：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">cv::Mat img;  </div><div class=\"line\">vector&amp;lt;cv::Rect&amp;gt; faceRects;  </div><div class=\"line\"><span class=\"keyword\">double</span> scalingFactor = <span class=\"number\">1.1</span>;  </div><div class=\"line\"><span class=\"keyword\">int</span> minNeighbors = <span class=\"number\">2</span>;  </div><div class=\"line\"><span class=\"keyword\">int</span> flags = <span class=\"number\">0</span>;  </div><div class=\"line\">cv::Size minimumSize(<span class=\"number\">30</span>,<span class=\"number\">30</span>);  </div><div class=\"line\">faceDetector.detectMultiScale(img, faceRects,  </div><div class=\"line\">                              scalingFactor, minNeighbors, flags</div><div class=\"line\">                              cv::Size(<span class=\"number\">30</span>, <span class=\"number\">30</span>) );</div></pre></td></tr></table></figure>\n<p>检测过程中，已训练好的分类器会用不同的尺度遍历输入图像的每一个像素，以检测不同大小的人脸。参数 scalingFactor 决定每次遍历分类器后尺度会变大多少倍。参数 minNeighbors 指定一个符合条件的人脸区域应该有多少个符合条件的邻居像素才被认为是一个可能的人脸区域；如果一个符合条件的人脸区域只移动了一个像素就不再触发分类器，那么这个区域非常可能并不是我们想要的结果。拥有少于 minNeighbors 个符合条件的邻居像素的人脸区域会被拒绝掉。如果 minNeighbors 被设置为 0，所有可能的人脸区域都会被返回回来。参数 flags 是 OpenCV 1.x 版本 API 的遗留物，应该始终把它设置为 0。最后，参数 minimumSize 指定我们所寻找的人脸区域大小的最小值。faceRects 向量中将会包含对 img 进行人脸识别获得的所有人脸区域。识别的人脸图像可以通过cv::Mat 的 () 运算符提取出来，调用方式很简单：cv::Mat faceImg = img(aFaceRect)。</p>\n<p>不管是使用 CIDetector 还是 OpenCV 的 CascadeClassifier，只要我们获得了至少一个人脸区域，我们就可以对图像中的人进行识别了。</p>\n<h1 id=\"遇到问题\"><a href=\"#遇到问题\" class=\"headerlink\" title=\"遇到问题\"></a>遇到问题</h1><p>这是第一次导入C++的库进工程中，所以还是摸索了一段时间。</p>\n<ol>\n<li>第一次编译的时候遇到一个问题，编译器报了个警告是<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">#if defined(NO)</div><div class=\"line\">#  warning Detected Apple &apos;NO&apos; macro definition, it can cause build conflicts. Please, include this header before any Apple headers.</div><div class=\"line\">#endif</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>按照提示说明，OpenCV的头文件应该在所有APPLE的头文件之前导入，不然会抛出异常，把import调到最前面即可。</p>\n<ol>\n<li><p>为何在 PCH 文件中引入 OpenCV 的头文件我们需要多加<code>#ifdef __cpluseplus</code>这一部分呢？这是因为 PCH 文件是一个会被<strong>所有的文件</strong>引入的头文件，而我们又希望 <code>#import &lt;opencv2/opencv.hpp&gt;</code>这部分只会被一些 C++实现文件编译，所以我们加上<code>#ifdef __cpluseplus</code>来表示这是 <code>C++</code> 文件才会编译的，除了<code>#ifdef __cpluseplus</code>，还有<code>#ifdef __OBJC__</code>这样的宏来说明编译规则（按照 OC 文件编译），这样的宏多出现于一些会被多种类型的实现文件引用的头文件中。</p>\n</li>\n<li><p>另外注意另一个问题：如果一个头文件是C++类型的头文件，那么一定要保证所有<code>直接</code>或者<code>间接</code>引用这个头文件的实现文件都要为.mm或者.cpp，否则 Xcode 就不会把这个头文件当做 C++头文件来编译，就会出现最基本的<code>#include &lt;iostream&gt;</code>这种引用都会报出<code>file not found</code>这样的编译错误的问题。我在编译的过程中，某个C++头文件 A.h 被 B.h 引用，然后 B.h 又被 C.m 引用，虽然 B 的实现文件是 B.mm ，但是仍然报出了之前说的那个错误<br>感谢 StackOberflow 让我找到了问题发生的原因。所以对于 C++ 头文件的引用一定要注意，但凡是引用了 A.h 的实现部分，都必须是.mm或者.cpp后缀名。（同时我们也可以知道，Xcode 是根据头文件被引用的情况来判定头文件的编译 类型的）。</p>\n</li>\n</ol>\n<h1 id=\"转换UIImage和cv-Mat\"><a href=\"#转换UIImage和cv-Mat\" class=\"headerlink\" title=\"转换UIImage和cv::Mat\"></a>转换UIImage和cv::Mat</h1><p>在 OpenCV 中同常用 cv::Mat 表示图片，而 iOS 中则是 UIImage 来表示图片，但openCV的<a href=\"http://docs.opencv.org/2.4/doc/tutorials/ios/image_manipulation/image_manipulation.html#opencviosimagemanipulation\">官方教程</a>已经给出了方法。</p>\n<h2 id=\"UIImage-to-cv-Mat\"><a href=\"#UIImage-to-cv-Mat\" class=\"headerlink\" title=\"UIImage to cv::Mat\"></a>UIImage to cv::Mat</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">    - (cv::Mat)cvMatFromUIImage:(<span class=\"built_in\">UIImage</span> *)image</div><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"built_in\">CGColorSpaceRef</span> colorSpace = <span class=\"built_in\">CGImageGetColorSpace</span>(image.CGImage);</div><div class=\"line\">  <span class=\"built_in\">CGFloat</span> cols = image.size.width;</div><div class=\"line\">  <span class=\"built_in\">CGFloat</span> rows = image.size.height;</div><div class=\"line\"></div><div class=\"line\">  cv::Mat cvMat(rows, cols, CV_8UC4); <span class=\"comment\">// 8 bits per component, 4 channels (color channels + alpha)</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"built_in\">CGContextRef</span> contextRef = <span class=\"built_in\">CGBitmapContextCreate</span>(cvMat.data,                 <span class=\"comment\">// Pointer to  data</span></div><div class=\"line\">                                                 cols,                       <span class=\"comment\">// Width of bitmap</span></div><div class=\"line\">                                                 rows,                       <span class=\"comment\">// Height of bitmap</span></div><div class=\"line\">                                                 <span class=\"number\">8</span>,                          <span class=\"comment\">// Bits per component</span></div><div class=\"line\">                                                 cvMat.step[<span class=\"number\">0</span>],              <span class=\"comment\">// Bytes per row</span></div><div class=\"line\">                                                 colorSpace,                 <span class=\"comment\">// Colorspace</span></div><div class=\"line\">                                                 kCGImageAlphaNoneSkipLast |</div><div class=\"line\">                                                 kCGBitmapByteOrderDefault); <span class=\"comment\">// Bitmap info flags</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"built_in\">CGContextDrawImage</span>(contextRef, <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, cols, rows), image.CGImage);</div><div class=\"line\">  <span class=\"built_in\">CGContextRelease</span>(contextRef);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> cvMat;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"cv-Mat-to-UIImage\"><a href=\"#cv-Mat-to-UIImage\" class=\"headerlink\" title=\"cv::Mat to UIImage\"></a>cv::Mat to UIImage</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(<span class=\"built_in\">UIImage</span> *)<span class=\"built_in\">UIImageFromCVMat</span>:(cv::Mat)cvMat</div><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"built_in\">NSData</span> *data = [<span class=\"built_in\">NSData</span> dataWithBytes:cvMat.data length:cvMat.elemSize()*cvMat.total()];</div><div class=\"line\">  <span class=\"built_in\">CGColorSpaceRef</span> colorSpace;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">if</span> (cvMat.elemSize() == <span class=\"number\">1</span>) &#123;<span class=\"comment\">//可以根据这个决定使用哪种</span></div><div class=\"line\">      colorSpace = <span class=\"built_in\">CGColorSpaceCreateDeviceGray</span>();</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      colorSpace = <span class=\"built_in\">CGColorSpaceCreateDeviceRGB</span>();</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"built_in\">CGDataProviderRef</span> provider = <span class=\"built_in\">CGDataProviderCreateWithCFData</span>((__bridge <span class=\"built_in\">CFDataRef</span>)data);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// Creating CGImage from cv::Mat</span></div><div class=\"line\">  <span class=\"built_in\">CGImageRef</span> imageRef = <span class=\"built_in\">CGImageCreate</span>(cvMat.cols,                                 <span class=\"comment\">//width</span></div><div class=\"line\">                                     cvMat.rows,                                 <span class=\"comment\">//height</span></div><div class=\"line\">                                     <span class=\"number\">8</span>,                                          <span class=\"comment\">//bits per component</span></div><div class=\"line\">                                     <span class=\"number\">8</span> * cvMat.elemSize(),                       <span class=\"comment\">//bits per pixel</span></div><div class=\"line\">                                     cvMat.step[<span class=\"number\">0</span>],                            <span class=\"comment\">//bytesPerRow</span></div><div class=\"line\">                                     colorSpace,                                 <span class=\"comment\">//colorspace</span></div><div class=\"line\">                                     kCGImageAlphaNone|kCGBitmapByteOrderDefault,<span class=\"comment\">// bitmap info</span></div><div class=\"line\">                                     provider,                                   <span class=\"comment\">//CGDataProviderRef</span></div><div class=\"line\">                                     <span class=\"literal\">NULL</span>,                                       <span class=\"comment\">//decode</span></div><div class=\"line\">                                     <span class=\"literal\">false</span>,                                      <span class=\"comment\">//should interpolate</span></div><div class=\"line\">                                     kCGRenderingIntentDefault                   <span class=\"comment\">//intent</span></div><div class=\"line\">                                     );</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// Getting UIImage from CGImage</span></div><div class=\"line\">  <span class=\"built_in\">UIImage</span> *finalImage = [<span class=\"built_in\">UIImage</span> imageWithCGImage:imageRef];</div><div class=\"line\">  <span class=\"built_in\">CGImageRelease</span>(imageRef);</div><div class=\"line\">  <span class=\"built_in\">CGDataProviderRelease</span>(provider);</div><div class=\"line\">  <span class=\"built_in\">CGColorSpaceRelease</span>(colorSpace);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> finalImage;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n"},{"title":"iOS开发 之 运动GPS采样处理","id":"38","updated":"2016-09-28T06:28:02.000Z","date":"2016-09-23T05:29:52.000Z","_content":"\n\n\niOS提供了获取位置信息的类，CLLocationManager。\n通过它，我们可以轻松得到包含位置信息的对象CLLocation。\n\n但正常情况下在运动中，会不断得到CLLocation，而其中很多点都是无效的。\n如果不去掉，将导致里程，速度，配速等一系列数据误差非常大。\n\n查询了一下资料，国内这一块的资料的确比较少，\n这里我针对常见的误差情况，用最简单明了的方法，教你判断无效的GPS点。\n\n**一、静止不动**\n上一个GPS点的瞬时速度为零，当前点的瞬时速度也为0,那么当前点无效.\n瞬时速度就是CLLocation对象的属性speed。\n\n**二、GPS信号太差**\n信号是CLLocation的属性horizontalAccuracy，表示水平方向的误差值。\n当这个值大于70，我们认为信号太差。\n\n**三、无效移动**\n前后两个GPS点的距离，小于horizontalAccuracy * (0.5~0.66)，我们认为这个点是无效移动。\n\n**四、平均速度过大**\n如果当前点到上一个点的距离 / 当前点到上一个点的时间\n速度大于某一个值，则认为当前点无效\n比如跑步，博尔特最快是10.44m/s\n\n**五、采样频率**\n如果不想GPS点过于密集，可以用时间限制。\n如果当前点的时间到上一个点事件小于2s，则认为点无效。\n另外也可以用位置管理器的distanceFilter属性来设置。\n当distanceFilter = 30的时候，只有超过30m的移动，才会进入到位置更新的回调方法。\n这样做的好处是设备可以更加省电，CPU的占用更低，根据实际情况而定。\n\n总结了几种常见gps点的过滤方法，希望对大家有帮助。\n\n","source":"_posts/iOS开发-之-运动GPS采样处理.md","raw":"---\ntitle: iOS开发 之 运动GPS采样处理\npermalink: ioskai-fa-zhi-yun-dong-gpscai-yang-chu-li-2\nid: 38\nupdated: '2016-09-28 14:28:02'\ndate: 2016-09-23 13:29:52\ntags: GPS\n---\n\n\n\niOS提供了获取位置信息的类，CLLocationManager。\n通过它，我们可以轻松得到包含位置信息的对象CLLocation。\n\n但正常情况下在运动中，会不断得到CLLocation，而其中很多点都是无效的。\n如果不去掉，将导致里程，速度，配速等一系列数据误差非常大。\n\n查询了一下资料，国内这一块的资料的确比较少，\n这里我针对常见的误差情况，用最简单明了的方法，教你判断无效的GPS点。\n\n**一、静止不动**\n上一个GPS点的瞬时速度为零，当前点的瞬时速度也为0,那么当前点无效.\n瞬时速度就是CLLocation对象的属性speed。\n\n**二、GPS信号太差**\n信号是CLLocation的属性horizontalAccuracy，表示水平方向的误差值。\n当这个值大于70，我们认为信号太差。\n\n**三、无效移动**\n前后两个GPS点的距离，小于horizontalAccuracy * (0.5~0.66)，我们认为这个点是无效移动。\n\n**四、平均速度过大**\n如果当前点到上一个点的距离 / 当前点到上一个点的时间\n速度大于某一个值，则认为当前点无效\n比如跑步，博尔特最快是10.44m/s\n\n**五、采样频率**\n如果不想GPS点过于密集，可以用时间限制。\n如果当前点的时间到上一个点事件小于2s，则认为点无效。\n另外也可以用位置管理器的distanceFilter属性来设置。\n当distanceFilter = 30的时候，只有超过30m的移动，才会进入到位置更新的回调方法。\n这样做的好处是设备可以更加省电，CPU的占用更低，根据实际情况而定。\n\n总结了几种常见gps点的过滤方法，希望对大家有帮助。\n\n","slug":"ioskai-fa-zhi-yun-dong-gpscai-yang-chu-li-2","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cj04pzyxx000us04e6c0yfcc1","content":"<p>iOS提供了获取位置信息的类，CLLocationManager。<br>通过它，我们可以轻松得到包含位置信息的对象CLLocation。</p>\n<p>但正常情况下在运动中，会不断得到CLLocation，而其中很多点都是无效的。<br>如果不去掉，将导致里程，速度，配速等一系列数据误差非常大。</p>\n<p>查询了一下资料，国内这一块的资料的确比较少，<br>这里我针对常见的误差情况，用最简单明了的方法，教你判断无效的GPS点。</p>\n<p><strong>一、静止不动</strong><br>上一个GPS点的瞬时速度为零，当前点的瞬时速度也为0,那么当前点无效.<br>瞬时速度就是CLLocation对象的属性speed。</p>\n<p><strong>二、GPS信号太差</strong><br>信号是CLLocation的属性horizontalAccuracy，表示水平方向的误差值。<br>当这个值大于70，我们认为信号太差。</p>\n<p><strong>三、无效移动</strong><br>前后两个GPS点的距离，小于horizontalAccuracy * (0.5~0.66)，我们认为这个点是无效移动。</p>\n<p><strong>四、平均速度过大</strong><br>如果当前点到上一个点的距离 / 当前点到上一个点的时间<br>速度大于某一个值，则认为当前点无效<br>比如跑步，博尔特最快是10.44m/s</p>\n<p><strong>五、采样频率</strong><br>如果不想GPS点过于密集，可以用时间限制。<br>如果当前点的时间到上一个点事件小于2s，则认为点无效。<br>另外也可以用位置管理器的distanceFilter属性来设置。<br>当distanceFilter = 30的时候，只有超过30m的移动，才会进入到位置更新的回调方法。<br>这样做的好处是设备可以更加省电，CPU的占用更低，根据实际情况而定。</p>\n<p>总结了几种常见gps点的过滤方法，希望对大家有帮助。</p>\n","excerpt":"","more":"<p>iOS提供了获取位置信息的类，CLLocationManager。<br>通过它，我们可以轻松得到包含位置信息的对象CLLocation。</p>\n<p>但正常情况下在运动中，会不断得到CLLocation，而其中很多点都是无效的。<br>如果不去掉，将导致里程，速度，配速等一系列数据误差非常大。</p>\n<p>查询了一下资料，国内这一块的资料的确比较少，<br>这里我针对常见的误差情况，用最简单明了的方法，教你判断无效的GPS点。</p>\n<p><strong>一、静止不动</strong><br>上一个GPS点的瞬时速度为零，当前点的瞬时速度也为0,那么当前点无效.<br>瞬时速度就是CLLocation对象的属性speed。</p>\n<p><strong>二、GPS信号太差</strong><br>信号是CLLocation的属性horizontalAccuracy，表示水平方向的误差值。<br>当这个值大于70，我们认为信号太差。</p>\n<p><strong>三、无效移动</strong><br>前后两个GPS点的距离，小于horizontalAccuracy * (0.5~0.66)，我们认为这个点是无效移动。</p>\n<p><strong>四、平均速度过大</strong><br>如果当前点到上一个点的距离 / 当前点到上一个点的时间<br>速度大于某一个值，则认为当前点无效<br>比如跑步，博尔特最快是10.44m/s</p>\n<p><strong>五、采样频率</strong><br>如果不想GPS点过于密集，可以用时间限制。<br>如果当前点的时间到上一个点事件小于2s，则认为点无效。<br>另外也可以用位置管理器的distanceFilter属性来设置。<br>当distanceFilter = 30的时候，只有超过30m的移动，才会进入到位置更新的回调方法。<br>这样做的好处是设备可以更加省电，CPU的占用更低，根据实际情况而定。</p>\n<p>总结了几种常见gps点的过滤方法，希望对大家有帮助。</p>\n"},{"title":"willMoveToSuperView导致观察者无法释放bug","id":"35","updated":"2016-09-10T02:39:20.000Z","date":"2016-09-10T02:33:17.000Z","_content":"\n\n\n![obeserve无法释放](http://ww1.sinaimg.cn/large/801b780agw1f7oaf0t13bj20rt0hp44z.jpg)\n\n\n(void)willMoveToSuperview 默认不做任何事情；当接收者父视图将要改变的时候回来到该方法，其中newSuperview是将要被添加的视图，该参数可以为new，子类可以重写这方法来作为特定的实现。\n最近在开发公司项目的过程中，遇到了一个比较棘手的bug。\n同事在构造一个modal出来的Controller中，用到了某个三方库\n其中有用到KVO去监听某个属性的值。\n而且也在dealloc里面对观察者进行了销毁。\n\n但在点击关闭按钮销毁该界面的时候，程序先回到父控制器窗口，然后crash。\n查了许久原因未果。\n\n通过断点调试和查看函数调用栈发现\nobserveValueForKeyPath:这个方法一共来了两次\n进一步调试发现\n是- (void)willMoveToSuperview:(UIView *)newSuperview这个方法调用了两次，而增加观察者方法就写在其中。\n两次调用的时间分别是View视图将要显示前，和将要销毁前。\n\n查阅资料得知newSuperview可以为nil，也就是modal视图销毁时这个方法会进行第二次调用，即把视图添加到为nill的View上。\n\n进而在方法内部做了对参数的校验，解决问题。\n\n不过把观察者写在view里面始终是野路子，把逻辑操作都写在controller中才是正途。\n\n","source":"_posts/willMoveToSuperView导致观察者无法释放bug.md","raw":"---\ntitle: willMoveToSuperView导致观察者无法释放bug\ntags: 'bug归档'\npermalink: willmovetosuperviewdao-zhi-guan-cha-zhe-wu-fa-shi-fang-bug\nid: 35\nupdated: '2016-09-10 10:39:20'\ndate: 2016-09-10 10:33:17\n---\n\n\n\n![obeserve无法释放](http://ww1.sinaimg.cn/large/801b780agw1f7oaf0t13bj20rt0hp44z.jpg)\n\n\n(void)willMoveToSuperview 默认不做任何事情；当接收者父视图将要改变的时候回来到该方法，其中newSuperview是将要被添加的视图，该参数可以为new，子类可以重写这方法来作为特定的实现。\n最近在开发公司项目的过程中，遇到了一个比较棘手的bug。\n同事在构造一个modal出来的Controller中，用到了某个三方库\n其中有用到KVO去监听某个属性的值。\n而且也在dealloc里面对观察者进行了销毁。\n\n但在点击关闭按钮销毁该界面的时候，程序先回到父控制器窗口，然后crash。\n查了许久原因未果。\n\n通过断点调试和查看函数调用栈发现\nobserveValueForKeyPath:这个方法一共来了两次\n进一步调试发现\n是- (void)willMoveToSuperview:(UIView *)newSuperview这个方法调用了两次，而增加观察者方法就写在其中。\n两次调用的时间分别是View视图将要显示前，和将要销毁前。\n\n查阅资料得知newSuperview可以为nil，也就是modal视图销毁时这个方法会进行第二次调用，即把视图添加到为nill的View上。\n\n进而在方法内部做了对参数的校验，解决问题。\n\n不过把观察者写在view里面始终是野路子，把逻辑操作都写在controller中才是正途。\n\n","slug":"willmovetosuperviewdao-zhi-guan-cha-zhe-wu-fa-shi-fang-bug","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cj04pzyy0000xs04eq47m7e7c","content":"<p><img src=\"http://ww1.sinaimg.cn/large/801b780agw1f7oaf0t13bj20rt0hp44z.jpg\" alt=\"obeserve无法释放\"></p>\n<p>(void)willMoveToSuperview 默认不做任何事情；当接收者父视图将要改变的时候回来到该方法，其中newSuperview是将要被添加的视图，该参数可以为new，子类可以重写这方法来作为特定的实现。<br>最近在开发公司项目的过程中，遇到了一个比较棘手的bug。<br>同事在构造一个modal出来的Controller中，用到了某个三方库<br>其中有用到KVO去监听某个属性的值。<br>而且也在dealloc里面对观察者进行了销毁。</p>\n<p>但在点击关闭按钮销毁该界面的时候，程序先回到父控制器窗口，然后crash。<br>查了许久原因未果。</p>\n<p>通过断点调试和查看函数调用栈发现<br>observeValueForKeyPath:这个方法一共来了两次<br>进一步调试发现<br>是- (void)willMoveToSuperview:(UIView *)newSuperview这个方法调用了两次，而增加观察者方法就写在其中。<br>两次调用的时间分别是View视图将要显示前，和将要销毁前。</p>\n<p>查阅资料得知newSuperview可以为nil，也就是modal视图销毁时这个方法会进行第二次调用，即把视图添加到为nill的View上。</p>\n<p>进而在方法内部做了对参数的校验，解决问题。</p>\n<p>不过把观察者写在view里面始终是野路子，把逻辑操作都写在controller中才是正途。</p>\n","excerpt":"","more":"<p><img src=\"http://ww1.sinaimg.cn/large/801b780agw1f7oaf0t13bj20rt0hp44z.jpg\" alt=\"obeserve无法释放\"></p>\n<p>(void)willMoveToSuperview 默认不做任何事情；当接收者父视图将要改变的时候回来到该方法，其中newSuperview是将要被添加的视图，该参数可以为new，子类可以重写这方法来作为特定的实现。<br>最近在开发公司项目的过程中，遇到了一个比较棘手的bug。<br>同事在构造一个modal出来的Controller中，用到了某个三方库<br>其中有用到KVO去监听某个属性的值。<br>而且也在dealloc里面对观察者进行了销毁。</p>\n<p>但在点击关闭按钮销毁该界面的时候，程序先回到父控制器窗口，然后crash。<br>查了许久原因未果。</p>\n<p>通过断点调试和查看函数调用栈发现<br>observeValueForKeyPath:这个方法一共来了两次<br>进一步调试发现<br>是- (void)willMoveToSuperview:(UIView *)newSuperview这个方法调用了两次，而增加观察者方法就写在其中。<br>两次调用的时间分别是View视图将要显示前，和将要销毁前。</p>\n<p>查阅资料得知newSuperview可以为nil，也就是modal视图销毁时这个方法会进行第二次调用，即把视图添加到为nill的View上。</p>\n<p>进而在方法内部做了对参数的校验，解决问题。</p>\n<p>不过把观察者写在view里面始终是野路子，把逻辑操作都写在controller中才是正途。</p>\n"},{"title":"iOS控制器总结","id":"3","updated":"2016-06-27T16:44:44.000Z","date":"2016-06-07T03:32:50.000Z","_content":"\n\n\n\n![banner.jpg](https://ooo.0o0.ooo/2016/06/08/5757fb07bad17.jpg)\n\n以FirstViewController(FVC)的按钮button点击后跳转到SecondViewController(SVC)为例说明:\n\n# 方式一：Storyboard的segues方式\n鼠标点击按钮button然后按住control键拖拽到SVC页面，在弹出的segue页面中选择跳转模式即可\n\n\n\nsegues方式\n优点:操作方便,无代码生成,在storyboard中展示逻辑清晰\n\n缺点:页面较多时不方便查看,团队合作时可维护性差, 多人合作时不建议使用这种方式。\n\n# 方式二：选项卡UITabBarController控制器\n通过调用UITabBarController的addChildViewController方法添加子控制器，代码实例如下：\n\nUITabBarController *tabbarVC = [[ UITabBarController alloc ] init ];\n\nFirstViewController *FVC = [[FirstViewController ] init ];\n\nFVC.tabBarItem.title = @\"控制器1\";\n\nFVC.tabBarItem.image = [ UIImage imageNamed : @\"first.png\"];\n\nSecondViewController *SVC = [[SecondViewController ] init ];\n\nSVC.tabBarItem.title = @\"控制器2\";\n\nSVC. tabBarItem.image = [UIImage imageNamed : @\"new.png\"];\n\n// 添加子控制器（这些子控制器会自动添加到UITabBarController的 viewControllers 数组中）\n\n[tabbarVC addChildViewController :FVC];\n\n[tabbarVC addChildViewController :SVC];\n\n\n优点:代码量较少\n\n缺点:tabbar的ios原生样式不太好看,(不常用,目前不建议使用),如果要使用,建议自定义tabbar\n\n# 方式三：导航控制器UINavigationController\n// 在FVC的button的监听方法中调用:\n\n[self.navigationController pushViewController:newC animated:YES];//跳转到下一页面\n\n// 在SVC的方法中调用:\n\n[self.navigationController popViewControllerAnimated:YES];//返回上一页面\n\n//当有多次跳转发生并希望返回根控制器时,调用:\n\n[self .navigationController popToRootViewControllerAnimated: YES ];//返回根控制器,即最开始的页面\n\n\n# 方式四：利用 Modal 形式展示控制器\n\n\n// 在FVC中调用:\n\n[ self presentViewController:SVC animated: YES completion:nil];\n\n// 在SVC中调用:\n\n[ self dismissViewControllerAnimated: YES completion: nil ];\n\n# 方式五：直接更改 UIWindow 的 rootViewController\n\n\n\n\n总结：\nStoryboard方式适合个人开发小程序时使用,有团队合作或者项目较大时不建议使用\n\nUITabBarController因为目前系统的原生样式不太美观,不建议使用\n\n推荐使用UINavigationController和Modal,无明显缺点,而且目前大部分程序都使用这两种方式,只是看是否需要导航控制器而确定使用哪种方案\n\n","source":"_posts/iOS控制器总结.md","raw":"---\ntitle: iOS控制器总结\ntags: 'iOS'\npermalink: ioskong-zhi-qi-tiao-zhuan-zong-jie\nid: 3\nupdated: '2016-06-28 00:44:44'\ndate: 2016-06-07 11:32:50\n---\n\n\n\n\n![banner.jpg](https://ooo.0o0.ooo/2016/06/08/5757fb07bad17.jpg)\n\n以FirstViewController(FVC)的按钮button点击后跳转到SecondViewController(SVC)为例说明:\n\n# 方式一：Storyboard的segues方式\n鼠标点击按钮button然后按住control键拖拽到SVC页面，在弹出的segue页面中选择跳转模式即可\n\n\n\nsegues方式\n优点:操作方便,无代码生成,在storyboard中展示逻辑清晰\n\n缺点:页面较多时不方便查看,团队合作时可维护性差, 多人合作时不建议使用这种方式。\n\n# 方式二：选项卡UITabBarController控制器\n通过调用UITabBarController的addChildViewController方法添加子控制器，代码实例如下：\n\nUITabBarController *tabbarVC = [[ UITabBarController alloc ] init ];\n\nFirstViewController *FVC = [[FirstViewController ] init ];\n\nFVC.tabBarItem.title = @\"控制器1\";\n\nFVC.tabBarItem.image = [ UIImage imageNamed : @\"first.png\"];\n\nSecondViewController *SVC = [[SecondViewController ] init ];\n\nSVC.tabBarItem.title = @\"控制器2\";\n\nSVC. tabBarItem.image = [UIImage imageNamed : @\"new.png\"];\n\n// 添加子控制器（这些子控制器会自动添加到UITabBarController的 viewControllers 数组中）\n\n[tabbarVC addChildViewController :FVC];\n\n[tabbarVC addChildViewController :SVC];\n\n\n优点:代码量较少\n\n缺点:tabbar的ios原生样式不太好看,(不常用,目前不建议使用),如果要使用,建议自定义tabbar\n\n# 方式三：导航控制器UINavigationController\n// 在FVC的button的监听方法中调用:\n\n[self.navigationController pushViewController:newC animated:YES];//跳转到下一页面\n\n// 在SVC的方法中调用:\n\n[self.navigationController popViewControllerAnimated:YES];//返回上一页面\n\n//当有多次跳转发生并希望返回根控制器时,调用:\n\n[self .navigationController popToRootViewControllerAnimated: YES ];//返回根控制器,即最开始的页面\n\n\n# 方式四：利用 Modal 形式展示控制器\n\n\n// 在FVC中调用:\n\n[ self presentViewController:SVC animated: YES completion:nil];\n\n// 在SVC中调用:\n\n[ self dismissViewControllerAnimated: YES completion: nil ];\n\n# 方式五：直接更改 UIWindow 的 rootViewController\n\n\n\n\n总结：\nStoryboard方式适合个人开发小程序时使用,有团队合作或者项目较大时不建议使用\n\nUITabBarController因为目前系统的原生样式不太美观,不建议使用\n\n推荐使用UINavigationController和Modal,无明显缺点,而且目前大部分程序都使用这两种方式,只是看是否需要导航控制器而确定使用哪种方案\n\n","slug":"ioskong-zhi-qi-tiao-zhuan-zong-jie","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cj04pzyy2000zs04e0d51detr","content":"<p><img src=\"https://ooo.0o0.ooo/2016/06/08/5757fb07bad17.jpg\" alt=\"banner.jpg\"></p>\n<p>以FirstViewController(FVC)的按钮button点击后跳转到SecondViewController(SVC)为例说明:</p>\n<h1 id=\"方式一：Storyboard的segues方式\"><a href=\"#方式一：Storyboard的segues方式\" class=\"headerlink\" title=\"方式一：Storyboard的segues方式\"></a>方式一：Storyboard的segues方式</h1><p>鼠标点击按钮button然后按住control键拖拽到SVC页面，在弹出的segue页面中选择跳转模式即可</p>\n<p>segues方式<br>优点:操作方便,无代码生成,在storyboard中展示逻辑清晰</p>\n<p>缺点:页面较多时不方便查看,团队合作时可维护性差, 多人合作时不建议使用这种方式。</p>\n<h1 id=\"方式二：选项卡UITabBarController控制器\"><a href=\"#方式二：选项卡UITabBarController控制器\" class=\"headerlink\" title=\"方式二：选项卡UITabBarController控制器\"></a>方式二：选项卡UITabBarController控制器</h1><p>通过调用UITabBarController的addChildViewController方法添加子控制器，代码实例如下：</p>\n<p>UITabBarController *tabbarVC = [[ UITabBarController alloc ] init ];</p>\n<p>FirstViewController *FVC = [[FirstViewController ] init ];</p>\n<p>FVC.tabBarItem.title = @”控制器1”;</p>\n<p>FVC.tabBarItem.image = [ UIImage imageNamed : @”first.png”];</p>\n<p>SecondViewController *SVC = [[SecondViewController ] init ];</p>\n<p>SVC.tabBarItem.title = @”控制器2”;</p>\n<p>SVC. tabBarItem.image = [UIImage imageNamed : @”new.png”];</p>\n<p>// 添加子控制器（这些子控制器会自动添加到UITabBarController的 viewControllers 数组中）</p>\n<p>[tabbarVC addChildViewController :FVC];</p>\n<p>[tabbarVC addChildViewController :SVC];</p>\n<p>优点:代码量较少</p>\n<p>缺点:tabbar的ios原生样式不太好看,(不常用,目前不建议使用),如果要使用,建议自定义tabbar</p>\n<h1 id=\"方式三：导航控制器UINavigationController\"><a href=\"#方式三：导航控制器UINavigationController\" class=\"headerlink\" title=\"方式三：导航控制器UINavigationController\"></a>方式三：导航控制器UINavigationController</h1><p>// 在FVC的button的监听方法中调用:</p>\n<p>[self.navigationController pushViewController:newC animated:YES];//跳转到下一页面</p>\n<p>// 在SVC的方法中调用:</p>\n<p>[self.navigationController popViewControllerAnimated:YES];//返回上一页面</p>\n<p>//当有多次跳转发生并希望返回根控制器时,调用:</p>\n<p>[self .navigationController popToRootViewControllerAnimated: YES ];//返回根控制器,即最开始的页面</p>\n<h1 id=\"方式四：利用-Modal-形式展示控制器\"><a href=\"#方式四：利用-Modal-形式展示控制器\" class=\"headerlink\" title=\"方式四：利用 Modal 形式展示控制器\"></a>方式四：利用 Modal 形式展示控制器</h1><p>// 在FVC中调用:</p>\n<p>[ self presentViewController:SVC animated: YES completion:nil];</p>\n<p>// 在SVC中调用:</p>\n<p>[ self dismissViewControllerAnimated: YES completion: nil ];</p>\n<h1 id=\"方式五：直接更改-UIWindow-的-rootViewController\"><a href=\"#方式五：直接更改-UIWindow-的-rootViewController\" class=\"headerlink\" title=\"方式五：直接更改 UIWindow 的 rootViewController\"></a>方式五：直接更改 UIWindow 的 rootViewController</h1><p>总结：<br>Storyboard方式适合个人开发小程序时使用,有团队合作或者项目较大时不建议使用</p>\n<p>UITabBarController因为目前系统的原生样式不太美观,不建议使用</p>\n<p>推荐使用UINavigationController和Modal,无明显缺点,而且目前大部分程序都使用这两种方式,只是看是否需要导航控制器而确定使用哪种方案</p>\n","excerpt":"","more":"<p><img src=\"https://ooo.0o0.ooo/2016/06/08/5757fb07bad17.jpg\" alt=\"banner.jpg\"></p>\n<p>以FirstViewController(FVC)的按钮button点击后跳转到SecondViewController(SVC)为例说明:</p>\n<h1 id=\"方式一：Storyboard的segues方式\"><a href=\"#方式一：Storyboard的segues方式\" class=\"headerlink\" title=\"方式一：Storyboard的segues方式\"></a>方式一：Storyboard的segues方式</h1><p>鼠标点击按钮button然后按住control键拖拽到SVC页面，在弹出的segue页面中选择跳转模式即可</p>\n<p>segues方式<br>优点:操作方便,无代码生成,在storyboard中展示逻辑清晰</p>\n<p>缺点:页面较多时不方便查看,团队合作时可维护性差, 多人合作时不建议使用这种方式。</p>\n<h1 id=\"方式二：选项卡UITabBarController控制器\"><a href=\"#方式二：选项卡UITabBarController控制器\" class=\"headerlink\" title=\"方式二：选项卡UITabBarController控制器\"></a>方式二：选项卡UITabBarController控制器</h1><p>通过调用UITabBarController的addChildViewController方法添加子控制器，代码实例如下：</p>\n<p>UITabBarController *tabbarVC = [[ UITabBarController alloc ] init ];</p>\n<p>FirstViewController *FVC = [[FirstViewController ] init ];</p>\n<p>FVC.tabBarItem.title = @”控制器1”;</p>\n<p>FVC.tabBarItem.image = [ UIImage imageNamed : @”first.png”];</p>\n<p>SecondViewController *SVC = [[SecondViewController ] init ];</p>\n<p>SVC.tabBarItem.title = @”控制器2”;</p>\n<p>SVC. tabBarItem.image = [UIImage imageNamed : @”new.png”];</p>\n<p>// 添加子控制器（这些子控制器会自动添加到UITabBarController的 viewControllers 数组中）</p>\n<p>[tabbarVC addChildViewController :FVC];</p>\n<p>[tabbarVC addChildViewController :SVC];</p>\n<p>优点:代码量较少</p>\n<p>缺点:tabbar的ios原生样式不太好看,(不常用,目前不建议使用),如果要使用,建议自定义tabbar</p>\n<h1 id=\"方式三：导航控制器UINavigationController\"><a href=\"#方式三：导航控制器UINavigationController\" class=\"headerlink\" title=\"方式三：导航控制器UINavigationController\"></a>方式三：导航控制器UINavigationController</h1><p>// 在FVC的button的监听方法中调用:</p>\n<p>[self.navigationController pushViewController:newC animated:YES];//跳转到下一页面</p>\n<p>// 在SVC的方法中调用:</p>\n<p>[self.navigationController popViewControllerAnimated:YES];//返回上一页面</p>\n<p>//当有多次跳转发生并希望返回根控制器时,调用:</p>\n<p>[self .navigationController popToRootViewControllerAnimated: YES ];//返回根控制器,即最开始的页面</p>\n<h1 id=\"方式四：利用-Modal-形式展示控制器\"><a href=\"#方式四：利用-Modal-形式展示控制器\" class=\"headerlink\" title=\"方式四：利用 Modal 形式展示控制器\"></a>方式四：利用 Modal 形式展示控制器</h1><p>// 在FVC中调用:</p>\n<p>[ self presentViewController:SVC animated: YES completion:nil];</p>\n<p>// 在SVC中调用:</p>\n<p>[ self dismissViewControllerAnimated: YES completion: nil ];</p>\n<h1 id=\"方式五：直接更改-UIWindow-的-rootViewController\"><a href=\"#方式五：直接更改-UIWindow-的-rootViewController\" class=\"headerlink\" title=\"方式五：直接更改 UIWindow 的 rootViewController\"></a>方式五：直接更改 UIWindow 的 rootViewController</h1><p>总结：<br>Storyboard方式适合个人开发小程序时使用,有团队合作或者项目较大时不建议使用</p>\n<p>UITabBarController因为目前系统的原生样式不太美观,不建议使用</p>\n<p>推荐使用UINavigationController和Modal,无明显缺点,而且目前大部分程序都使用这两种方式,只是看是否需要导航控制器而确定使用哪种方案</p>\n"},{"title":"升级Ruby配置CocoaPods安装","id":"31","updated":"2016-08-07T05:25:25.000Z","date":"2016-08-07T05:05:29.000Z","_content":"\n\n\n这两天全新安装了系统，安装cocoapods时出现：\n\n> activesupport requires Ruby version >= 2.2.2\n\n检查下发现淘宝源的ruby版本是2.0.0，于是使用RVM更新了下Ruby。\n\n\n\n## 1、安装 RVM\n\nRVM:Ruby Version Manager,Ruby版本管理器，包括Ruby的版本管理和Gem库管理(gemset)\n\n> curl -L get.rvm.io | bash -s stable \n\n等待一段时间后就可以成功安装好 RVM。\n\n> source ~/.bashrc  \n>\n> source ~/.bash_profile  \n\n测试是否安装正常\n\n> rvm -v \n\n![13:03:18.jpg](http://upload-images.jianshu.io/upload_images/1727086-68742171c589c6ad.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 2、用RVM升级Ruby\n```\n查看当前ruby版本  \nruby -v  \n列出已知的ruby版本  \nrvm list known  \n\n<!------MORE------->\n\n\n安装ruby 2.2.2  \nrvm install 2.2.2  \n```\n\n\n安装完成之后ruby -v查看是否安装成功。\n终端输出\n```\n\nkidteaing-macmini:~ GeXiaodong$ ruby -v\nruby 2.2.2p95 (2015-04-13 revision 50295) [x86_64-darwin14]\n```\n\n到此已经完成ruby的升级\n\n","source":"_posts/升级Ruby配置CocoaPods安装.md","raw":"---\ntitle: 升级Ruby配置CocoaPods安装\npermalink: jie-jue-cocoapodan-zhuang-rubyban-ben-di-de-wen-ti\nid: 31\nupdated: '2016-08-07 13:25:25'\ndate: 2016-08-07 13:05:29\ntags:\n---\n\n\n\n这两天全新安装了系统，安装cocoapods时出现：\n\n> activesupport requires Ruby version >= 2.2.2\n\n检查下发现淘宝源的ruby版本是2.0.0，于是使用RVM更新了下Ruby。\n\n\n\n## 1、安装 RVM\n\nRVM:Ruby Version Manager,Ruby版本管理器，包括Ruby的版本管理和Gem库管理(gemset)\n\n> curl -L get.rvm.io | bash -s stable \n\n等待一段时间后就可以成功安装好 RVM。\n\n> source ~/.bashrc  \n>\n> source ~/.bash_profile  \n\n测试是否安装正常\n\n> rvm -v \n\n![13:03:18.jpg](http://upload-images.jianshu.io/upload_images/1727086-68742171c589c6ad.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 2、用RVM升级Ruby\n```\n查看当前ruby版本  \nruby -v  \n列出已知的ruby版本  \nrvm list known  \n\n<!------MORE------->\n\n\n安装ruby 2.2.2  \nrvm install 2.2.2  \n```\n\n\n安装完成之后ruby -v查看是否安装成功。\n终端输出\n```\n\nkidteaing-macmini:~ GeXiaodong$ ruby -v\nruby 2.2.2p95 (2015-04-13 revision 50295) [x86_64-darwin14]\n```\n\n到此已经完成ruby的升级\n\n","slug":"jie-jue-cocoapodan-zhuang-rubyban-ben-di-de-wen-ti","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cj04pzyy30012s04exvrnscrj","content":"<p>这两天全新安装了系统，安装cocoapods时出现：</p>\n<blockquote>\n<p>activesupport requires Ruby version &gt;= 2.2.2</p>\n</blockquote>\n<p>检查下发现淘宝源的ruby版本是2.0.0，于是使用RVM更新了下Ruby。</p>\n<h2 id=\"1、安装-RVM\"><a href=\"#1、安装-RVM\" class=\"headerlink\" title=\"1、安装 RVM\"></a>1、安装 RVM</h2><p>RVM:Ruby Version Manager,Ruby版本管理器，包括Ruby的版本管理和Gem库管理(gemset)</p>\n<blockquote>\n<p>curl -L get.rvm.io | bash -s stable </p>\n</blockquote>\n<p>等待一段时间后就可以成功安装好 RVM。</p>\n<blockquote>\n<p>source ~/.bashrc  </p>\n<p>source ~/.bash_profile  </p>\n</blockquote>\n<p>测试是否安装正常</p>\n<blockquote>\n<p>rvm -v </p>\n</blockquote>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1727086-68742171c589c6ad.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"13:03:18.jpg\"></p>\n<h2 id=\"2、用RVM升级Ruby\"><a href=\"#2、用RVM升级Ruby\" class=\"headerlink\" title=\"2、用RVM升级Ruby\"></a>2、用RVM升级Ruby</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">查看当前ruby版本  </div><div class=\"line\">ruby -v  </div><div class=\"line\">列出已知的ruby版本  </div><div class=\"line\">rvm list known  </div><div class=\"line\"></div><div class=\"line\">&lt;!------MORE-------&gt;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">安装ruby 2.2.2  </div><div class=\"line\">rvm install 2.2.2</div></pre></td></tr></table></figure>\n<p>安装完成之后ruby -v查看是否安装成功。<br>终端输出<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">kidteaing-macmini:~ GeXiaodong$ ruby -v</div><div class=\"line\">ruby 2.2.2p95 (2015-04-13 revision 50295) [x86_64-darwin14]</div></pre></td></tr></table></figure></p>\n<p>到此已经完成ruby的升级</p>\n","excerpt":"","more":"<p>这两天全新安装了系统，安装cocoapods时出现：</p>\n<blockquote>\n<p>activesupport requires Ruby version &gt;= 2.2.2</p>\n</blockquote>\n<p>检查下发现淘宝源的ruby版本是2.0.0，于是使用RVM更新了下Ruby。</p>\n<h2 id=\"1、安装-RVM\"><a href=\"#1、安装-RVM\" class=\"headerlink\" title=\"1、安装 RVM\"></a>1、安装 RVM</h2><p>RVM:Ruby Version Manager,Ruby版本管理器，包括Ruby的版本管理和Gem库管理(gemset)</p>\n<blockquote>\n<p>curl -L get.rvm.io | bash -s stable </p>\n</blockquote>\n<p>等待一段时间后就可以成功安装好 RVM。</p>\n<blockquote>\n<p>source ~/.bashrc  </p>\n<p>source ~/.bash_profile  </p>\n</blockquote>\n<p>测试是否安装正常</p>\n<blockquote>\n<p>rvm -v </p>\n</blockquote>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1727086-68742171c589c6ad.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"13:03:18.jpg\"></p>\n<h2 id=\"2、用RVM升级Ruby\"><a href=\"#2、用RVM升级Ruby\" class=\"headerlink\" title=\"2、用RVM升级Ruby\"></a>2、用RVM升级Ruby</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">查看当前ruby版本  </div><div class=\"line\">ruby -v  </div><div class=\"line\">列出已知的ruby版本  </div><div class=\"line\">rvm list known  </div><div class=\"line\"></div><div class=\"line\">&lt;!------MORE-------&gt;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">安装ruby 2.2.2  </div><div class=\"line\">rvm install 2.2.2</div></pre></td></tr></table></figure>\n<p>安装完成之后ruby -v查看是否安装成功。<br>终端输出<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">kidteaing-macmini:~ GeXiaodong$ ruby -v</div><div class=\"line\">ruby 2.2.2p95 (2015-04-13 revision 50295) [x86_64-darwin14]</div></pre></td></tr></table></figure></p>\n<p>到此已经完成ruby的升级</p>\n"},{"title":"xcode nib but the view outlet was not set 错误","id":"11","updated":"2016-07-13T07:01:20.000Z","date":"2016-06-11T14:48:50.000Z","_content":"\n\n\n\n\nxib 中, 没有对File's Owner 的Outlets view 进行绑定, 导致在父视图中插入子视图时出错, 在IB中拖拽Files' Owner到view, 添加绑定后, 运行成功!\n总结一下创建视图和绑定的步骤:\n1. 创建控制器. File->New File->Iphone OS->Cocoa Touch Class->UIViewController subclass;\n2. 创建xib. File->New File->Iphone OS->User Interface->View XIB\n3. 绑定controller和view. 用Interface Builder打开xxx.xib, 点击Files' Owner, 在Identity Inspector里面的Class Identity, 选择Step 1创建的控制器类, 接着拖拽File's Owner到View中, 选择Outlets->view.先选中file's owner(这个很重要)","source":"_posts/xcode-nib-but-the-view-outlet-was-not-set-错误.md","raw":"---\ntitle: xcode nib but the view outlet was not set 错误\npermalink: xcode-nib-but-the-view-outlet-was-not-set-cuo-wu\nid: 11\nupdated: '2016-07-13 15:01:20'\ndate: 2016-06-11 22:48:50\ntags:\n---\n\n\n\n\n\nxib 中, 没有对File's Owner 的Outlets view 进行绑定, 导致在父视图中插入子视图时出错, 在IB中拖拽Files' Owner到view, 添加绑定后, 运行成功!\n总结一下创建视图和绑定的步骤:\n1. 创建控制器. File->New File->Iphone OS->Cocoa Touch Class->UIViewController subclass;\n2. 创建xib. File->New File->Iphone OS->User Interface->View XIB\n3. 绑定controller和view. 用Interface Builder打开xxx.xib, 点击Files' Owner, 在Identity Inspector里面的Class Identity, 选择Step 1创建的控制器类, 接着拖拽File's Owner到View中, 选择Outlets->view.先选中file's owner(这个很重要)","slug":"xcode-nib-but-the-view-outlet-was-not-set-cuo-wu","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cj04pzyy40014s04e8tej1hfv","content":"<p>xib 中, 没有对File’s Owner 的Outlets view 进行绑定, 导致在父视图中插入子视图时出错, 在IB中拖拽Files’ Owner到view, 添加绑定后, 运行成功!<br>总结一下创建视图和绑定的步骤:</p>\n<ol>\n<li>创建控制器. File-&gt;New File-&gt;Iphone OS-&gt;Cocoa Touch Class-&gt;UIViewController subclass;</li>\n<li>创建xib. File-&gt;New File-&gt;Iphone OS-&gt;User Interface-&gt;View XIB</li>\n<li>绑定controller和view. 用Interface Builder打开xxx.xib, 点击Files’ Owner, 在Identity Inspector里面的Class Identity, 选择Step 1创建的控制器类, 接着拖拽File’s Owner到View中, 选择Outlets-&gt;view.先选中file’s owner(这个很重要)</li>\n</ol>\n","excerpt":"","more":"<p>xib 中, 没有对File’s Owner 的Outlets view 进行绑定, 导致在父视图中插入子视图时出错, 在IB中拖拽Files’ Owner到view, 添加绑定后, 运行成功!<br>总结一下创建视图和绑定的步骤:</p>\n<ol>\n<li>创建控制器. File-&gt;New File-&gt;Iphone OS-&gt;Cocoa Touch Class-&gt;UIViewController subclass;</li>\n<li>创建xib. File-&gt;New File-&gt;Iphone OS-&gt;User Interface-&gt;View XIB</li>\n<li>绑定controller和view. 用Interface Builder打开xxx.xib, 点击Files’ Owner, 在Identity Inspector里面的Class Identity, 选择Step 1创建的控制器类, 接着拖拽File’s Owner到View中, 选择Outlets-&gt;view.先选中file’s owner(这个很重要)</li>\n</ol>\n"},{"title":"iOS国际化(本地化)","date":"2017-01-03T01:52:38.000Z","_content":"\n# 前言\n\n语言本地化，又叫做语言国际化。是指根据用户操作系统的语言设置，自动将应用程序的语言设置为和用户操作系统语言一致的语言。往往一些应用程序需要提供给多个国家的人群使用，或者一个国家有多种语言，这就要求应用程序所展示的文字、图片等信息，能够让讲不同语言的用户读懂、看懂。进而提出为同一个应用程序适配多种语言，也即是国际化。语言国际化之所以又叫做语言本地化，这是站在每个用户的角度而言的，是指能够让用户本地、本土人群能够看懂的语言信息，顾名思义，语言本地化。其实语言本地化 == 语言国际化！\n本文将分如下7个主要章节一步一步讲解如何完全本地化一个App。\n\n- **配置需要国际化的语言（国际化的准备工作）**\n- **App名称本地化**\n- **代码中字符串本地化**\n- **多人开发情况下的字符串本地化**\n- **图片本地化（两种方式两种方式）**\n- **查看/切换本地语言**\n- **storyboard/xib本地化**\n\n# 配置需要国际化的语言\n\n配置需要国际化的语言，这也是国际化之前的准备工作，无论我们是国际化App名称、代码中的字符串、图片、还是storyboard和xib，都需要进行这一步的准备工作（一个项目中需要且仅需要配置一次）。\n\n- 选中project->Info->Localizations，然后点击\"+\"，添加需要国际化/本地化的语言，如下图（默认需要勾选Use Base Internationalization）：\n\nSnip20160616_15.png\n\n- 此处以添加法语为例，如下图：\n\n  ​\n\n  ​\n\n  Snip20160616_18.png\n\n- 弹出如下对话框，直接点击finish，如下图：\n\nSnip20160616_21.png\n\n- 同理，添加简体中文、繁体中文、韩语，最终结果如下图：\n\n  ​\n\n  ​\n\n  ​\n\n  Snip20160616_22.png\n\n`备注：` “zh-Hans”和“zh-Hant”是简体中文和繁体中文的缩写。这是标准的缩写。H可大写也可小写。\"en\"是英语的缩写。ko是韩语的缩写，fr是法语的缩写。其他语言请百度各国语言缩写即可查询。\n\n# （一）应用名称本地化/国际化\n\n应用名称本地化，是指同一个App的名称，在不同的语言环境下（也就是手机设备的语言设置）显示不同的名称。比如，微信在简体中文环境下App名称显示为“**微信**”，在英语环境下显示为“**weChat**”。下面就开始进行应用名称本地化。\n\n1. 选中Info.plist，按下键盘上的command + N，选择**Strings File**（iOS->Resource->Strings File）\n\nSnip20160616_10.png\n\n- 文件名字命名为**InfoPlist**，且**必须是这个名字**（因每个人电脑设置差异，此处本人电脑没有显示strings后缀名）:\n\nSnip20160616_11.png\n\n- 点击create后，Xcode左侧导航列表就会出现名为InfoPlist.strings的文件，如下图：\n\nSnip20160616_13.png\n\n- 选中InfoPlist.strings，在Xcode的File inspection（Xcode右侧文件检查器）中点击Localize，目的是选择我们需要本地化的语言，如下图：\n  `注意：`在点击Localize之前，一定要保证我们已经添加了需要本地化的语言，也就是上面**配置需要国际化的语言**那一步（步骤：project->Info->Localizations，然后点击\"+\"，添加需要国际化/本地化的语言）。\n\nSnip20160616_14.png\n\n- 点击Localize后，会弹出一个对话框，展开对话框列表，发现下拉列表所展示的语言正是我们在上面配置的需要国际化的语言，选择我们需要本地化的语言，然后点击对话框的Localize按钮，如下图：\n\nSnip20160617_10.png\n\nSnip20160617_12.png\n\n`注意：`如果我们没有在 PROJECT 中配置需要国际化的语言（project->Info->Localizations，然后点击\"+\"），上图下拉列表中将只会出现\"Base\"和\"English\"选项，English语言是系统默认的语言，其他需要国际化的语言（例如中文简体、法语）必须通过上面的**配置本地化语言**那一步手动添加。\n\n- 然后我们发现Xcode右侧的File inspection变成了下图的样式：\n\nSnip20160617_13.png\n\n- 接下来，勾选French、Chinese（zh-Hans）、Chinese（zh-Hant）、Korean，如下图：\n\nSnip20160617_14.png\n\n- 此时，Xcode左侧的InfoPlist.stirings左侧多了一个箭头，点击箭头可以展开，如下图所示：\n\nSnip20160617_15.png\n\n从上图可以看出，InfoPlist.strings文件下包含了English、French、Chinese（Simplified）、Chinese（Traditional）、Korean这五种语言的文件。\n原理：程序启动时，会根据操作系统设置的语言，自动加载InfoPlist.strings文件下对应的语言文件，然后显示应用程序的名字。\n\n- 接下来，我们分别用不同的语言给InfoPlist.strings下的文件设置对应的名字。\n\n（1）在InfoPlist.strings(english)中加入如下代码：\n\n```\n// Localizable App Name是App在英语环境环境下显示的名称\nCFBundleDisplayName = \"Localizable App Name\";\n```\n\n`备注：`CFBundleDisplayName可以使用双引号，也可以不使用双引号！\n\nSnip20160617_21.png\n\n（2）在InfoPlist.strings(French)中加入如下代码：\n\n```\nCFBundleDisplayName = \"Le nom de la localisation de l'App\";\n```\n\nSnip20160617_27.png\n\n（3）在InfoPlist.strings(Chinese(Simplified))中加入如下代码：\n\n```\nCFBundleDisplayName = \"国际化App名称\";\n```\n\nSnip20160617_32.png\n\n（4）在InfoPlist.strings(Chinese(Traditional))中加入如下代码：\n\n```\nCFBundleDisplayName = \"國際化App名稱\";\n```\n\nSnip20160617_30.png\n\n（5）在InfoPlist.strings(Korean)中加入如下代码：\n\n```\nCFBundleDisplayName = \"현지화 앱 명칭\";\n```\n\nSnip20160617_31.png\n\n修改模拟器语言环境为English。App名称如下图：\n\nSnip20160617_33.png\n\n修改模拟器语言环境为Chinese(Simplified)。App名称如下图：\n\nSnip20160618_4.png\n\n修改模拟器语言环境为Chinese(Traditional)。App名称如下图：\n\nSnip20160618_5.png\n\n修改模拟器语言环境为Franch。App名称如下图：\n\nSnip20160618_6.png\n\n修改模拟器语言环境为Korean。App名称如下图：\n\nSnip20160618_7.png\n\n`备注：`过去本地化App名称，需要在Info.plist文件中增加一个名为“Application has localized display name”的BOOL类型的Key，并且需要将其值设置为YES（如下图）。目的是让App支持本地化App名称。**但现在可以忽略这一步**。\n\nSnip20160618_8.png\n\n至此，本地化App名称已经演示完毕，其步骤就是：\n\n- 在Project的设置中通过点击\"+\"添加需要本地化的语言。\n- 然后在Xcode右侧的File inspection中点击Localize，选中需要本地化App名称的语言。\n- 最后在每个语言对应的文件中以key = value(CFBundleDisplayName = \"App名称\";);的形式设置App的名称。\n\n# （二）代码中字符串的本地化\n\n所谓字符串本地化，就是指App内的字符串在不同的语言环境下显示不同的内容。比如，\"主页\"这个字符串在中文语言环境下显示“主页”，在英语环境下显示“home”。下面就开始进行字符串本地化。\n其实字符本地化和App名称本地化过程如出一辙，只是创建的文件名成不一样（连同后缀一起，文件名必须是Localizable.strings），其他步骤完全相同。为了能够让大家彻底了解，此处还是会把步骤一一贴出来。\n\n- 和应用名称本地化一样，首先需要command + N，选择iOS -> Resource -> Strings File\n\n![img](http://upload-images.jianshu.io/upload_images/1055199-1fe1660ee2986990.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n- 文件名必须命名为**Localizable**\n  `备注`：因本人电脑取消隐藏文件后缀名，所以会自动补全.strings后缀名。\n\nSnip20160619_8.png\n\n- 文件创建成功，查看Xcode左侧导航列表，发现多了一个名为Localizable.strings的文件，如下图：\n\nSnip20160619_4.png\n\n- 选中Localizable.strings文件，在Xcode的File inspection中点击Localize，目的是选择我们需要本地化的语言（和本地化App名称同理），如下图：\n\n![img](http://upload-images.jianshu.io/upload_images/1055199-c2378ac118e3f496.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n- 依次选择English->Localize，如下图：\n\n![img](http://upload-images.jianshu.io/upload_images/1055199-0aba0931daecd274.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![img](http://upload-images.jianshu.io/upload_images/1055199-015545406751fd42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n- 然后我们发现Xcode右侧的File inspection变成了下图的样式：\n\n![img](http://upload-images.jianshu.io/upload_images/1055199-581527c3c2149e22.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n- 然后勾选French、Chinese（zh-Hans）、Chinese（zh-Hant）、Korean，如下图：\n\n![img](http://upload-images.jianshu.io/upload_images/1055199-154a9e311e6a8033.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n- 此时，Xcode左侧的Localizable.stirings左侧多了一个箭头，展开后，如下图所示：\n\nSnip20160619_6.png\n\n- 然后我们只需要在Localizable.strings下对应的文件中，分别以Key-Value的形式，为代码中每一个需要本地化的字符串赋值，如下图：\n\nSnip20160619_9.png\n\nSnip20160619_10.png\n\nSnip20160619_12.png\n\nSnip20160619_13.png\n\nSnip20160619_14.png\n\n- 本地化代码中的字符串，如下图：\n\nSnip20160619_15.png\n\n- 我们只需要使用Foundation框架自带的NSLocalizedString(key, comment)这个宏根据Key获取对应的字符串，然后赋值给代码中的字符串。\n\n```\n// NSLocalizedString(key, comment) 本质\n// NSlocalizeString 第一个参数是内容,根据第一个参数去对应语言的文件中取对应的字符串，第二个参数将会转化为字符串文件里的注释，可以传nil，也可以传空字符串@\"\"。\n#define NSLocalizedString(key, comment) [[NSBundle mainBundle] localizedStringForKey:(key) value:@\"\" table:nil]\n```\n\n- 不同语言环境下运行效果，如下图：\n- 英语环境下：\n\nSnip20160619_17.png\n\n- 法语环境下：\n\nSnip20160619_18.png\n\n- 简体中文环境下：\n\nSnip20160619_19.png\n\n- 繁体中文环境下：\n\nSnip20160619_20.png\n\n- 韩语环境下：\n\nSnip20160619_23.png\n\n如此一来，我们就实现了代码中字符串的本地化。\n\n### 技巧\n\n- 其实，我们不需要给Localizable.strings(English)文件添加Key-Value。原因如下：系统根据某个key去获取对应的字符串时，如果没有找到，那么就会以key作为value返回。所以如果我们在Localizable.strings(English)文件中没有添加 click = \"hit\";那么在english环境下btn最终显示的title会是click.\n- 切换语言无需在模拟器中设置，只需要在Xcode中进行如下设置： Edit->Scheme->Run->Arguments Passed On Launch ->-AppleLanguages (语言代码)。例如，我们模拟器此时虽然是韩语，如果通过上述步骤设置为zh-Hans，那么语言环境将会变为汉语，如下图：\n\nSnip20160619_26.png\n\nSnip20160619_28.png\n\n- 运行效果：\n\nSnip20160619_29.png\n\n- 如此一来，切换语言变得更加简单，无需在模拟器的设置中进行繁琐的语言切换。\n\n# （三）多人开发情况下的字符串本地化\n\n项目开发中，独立开发的还是少数。经常会有多人开发的情况，这种情况，如果多人同时操作本地化文件，极有可能会存在冲突。另一方面，我们又不希望自己的本地化文件受到对方的污染，也就是说，我们不希望对方操作我们的本地化文件。但是上面介绍的代码中字符串的本地化是使用的是默认的文件名\"Localizable\",因为启动程序时，系统将根据语言加载相应的文件得到其对应的字符串文件，这个字符串可以通过系统将NSLocalizedString中的宏生成名为“Localizable.strings”的文件。那么如何让系统加载我们自己命名的本地化文件而非系统默认的Localizable.strings呢？这就是 NSLocalizedStringFromTable(<#key#>, <#tbl#>, <#comment#>)的用处。\n也就是说，如果你的strings文件名字不是Localizable而是自定义的话，如VVS.strings，那么你就得使用NSLocalizedStringFromTable这个宏来读取本地化字符串。\n\n```\n// key：系统根据key取字符串\n// tbl：自定义strings文件的名字\n// comment：可以不传\n    NSLocalizedStringFromTable(<#key#>, <#tbl#>, <#comment#>)\n```\n\nSnip20160619_32.png\n\n```\n#import \"ViewController.h\"\n\n@interface ViewController ()\n@property (weak, nonatomic) IBOutlet UIButton *btn;\n\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    NSString *title = NSLocalizedStringFromTable(@\"click\", @\"VVS\", nil);\n    [self.btn setTitle:title forState:UIControlStateNormal];\n}\n\n@end\n```\n\n- 运行效果，如下图：\n\nSnip20160619_33.png\n\n如此一来，我们就可以挣脱别人的strings文件和系统默认的Localizable.strings文件，自己另起炉灶。\n\n# （四）图片本地化\n\n本地化图片，有两种方式，第一种方式和本地化代码中的字符串一样，通过NSLocalizedString(key,comment)来获取相应的字符串，然后根据这个字符串再获取图片。\n\n## 方式一\n\n```\nNSString *imageName = NSLocalizedString(@\"icon\", nil);\nUIImage *image = [UIImage imageNamed:imageName];\nself.imageView.image = image;\n```\n\n## 方式二\n\n首先需要添加需要本地化的语言，具体步骤参考第一章**配置需要国际化的语言**。因为我演示的demo中在本地化App名称时已经添加了需要国际化的语言。所以不需要再设置。\n\n- 将图片拖入工程中，例如“icon.png”，然后选中icon.png，展开Xcode右侧的file Inspection，点击Localize，如下图:\n\nSnip20160619_36.png\n\n- 然后，右击icon.png->show in Finder，我们发现在en.Iproj文件中多了一个名为icon.png的图片，如下图：\n\nSnip20160619_38.png\n\n- 当然，zh-Hans.Iproj文件夹下并没有图片，如下图：\n\nSnip20160619_39.png\n\n- 我们只需给zh-Hans.Iproj添加一个名字也为icon.png的图片。如下图：\n\nSnip20160619_40.png\n\n- 然后把zh-Hans.Iproj中的icon.png拖到Xcode中，如下图：\n\nSnip20160619_43.png\n\n- 然后发现，icon.png左边出现了一个可以展开的三角形。如下图：\n\nSnip20160619_44.png\n\n- 展开后发现里面包含两张图片，如下图：\n\nSnip20160619_45.png\n\n然后控制器中添加如下代码：\n\n```\n#import \"ViewController.h\"\n\n@interface ViewController ()\n@property (weak, nonatomic) IBOutlet UIImageView *imageView;\n\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    NSString *imageName = NSLocalizedString(@\"icon\", nil);\n    UIImage *image = [UIImage imageNamed:imageName];\n    self.imageView.image = image;\n}\n\n@end\n```\n\n- english环境下运行效果如下：\n\nSnip20160620_46.png\n\n- 中文环境改下运行效果如下：\n\nSnip20160620_47.png\n\n- 其他语言环境，例如法语、中文繁体、韩语，操作步骤完全和上面相同。都是在对应的.Iproj文件夹下添加同名的图片，然后把图片拖放到Xcode中，不再赘述。\n\n# （五）查看/切换本地语言\n\n原理：应用启动时，首先会读取NSUserDefaults中的key为AppleLanguages对应的value，该value是一个String数组，也就是说，我们访问这个名为AppleLanguages的key可以返回一个string数组，该数组存储着APP支持的语言列表，数组的第一项为APP当前默认的语言。\n\n```\n#import \"ViewController.h\"\n\n@interface ViewController ()\n\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    NSArray *languages = [[NSUserDefaults standardUserDefaults] valueForKey:@\"AppleLanguages\"];\n    NSString *currentLanguage = languages.firstObject;\n    NSLog(@\"模拟器当前语言：%@\",currentLanguage);\n}\n@end\n```\n\n-控制台打印结果：\n\nSnip20160620_1.png\n\n同理，既然我们可以通过AppleLanguages这个key从NSUserDefaults中取出语言数组，那么我们也可以给AppleLanguages这个key赋值来达到切换本地语言的效果，从此以后，我们就无需频繁的去模拟器的设置->通用->语言与地区 中切换语言。\n\n```\n#import \"ViewController.h\"\n\n@interface ViewController ()\n\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    // 切换语言前\n    NSArray *langArr1 = [[NSUserDefaults standardUserDefaults] valueForKey:@\"AppleLanguages\"];\n    NSString *language1 = langArr1.firstObject;\n    NSLog(@\"模拟器语言切换之前：%@\",language1);\n\n    // 切换语言\n    NSArray *lans = @[@\"en\"];\n    [[NSUserDefaults standardUserDefaults] setObject:lans forKey:@\"AppleLanguages\"];\n\n    // 切换语言后\n    NSArray *langArr2 = [[NSUserDefaults standardUserDefaults] valueForKey:@\"AppleLanguages\"];\n    NSString *language2 = langArr2.firstObject;\n    NSLog(@\"模拟器语言切换之后：%@\",language2);\n}\n@end\n```\n\nSnip20160620_2.png\n\n- 回想一下，我在上面的**技巧**一节中提过：切换语言无需在模拟器中设置，只需要在Xcode中进行如下设置： Edit->Scheme->Run->Arguments Passed On Launch ->-AppleLanguages (语言代码)。其实本质上就是给NSUserDefaults中名为AppleLanguages的key赋值。\n\n","source":"_posts/iOS国际化(本地化).md","raw":"---\ntitle: iOS国际化(本地化)\npermalink: localization\ndate: 2017-01-03 09:52:38\ntags: 学习笔记\n---\n\n# 前言\n\n语言本地化，又叫做语言国际化。是指根据用户操作系统的语言设置，自动将应用程序的语言设置为和用户操作系统语言一致的语言。往往一些应用程序需要提供给多个国家的人群使用，或者一个国家有多种语言，这就要求应用程序所展示的文字、图片等信息，能够让讲不同语言的用户读懂、看懂。进而提出为同一个应用程序适配多种语言，也即是国际化。语言国际化之所以又叫做语言本地化，这是站在每个用户的角度而言的，是指能够让用户本地、本土人群能够看懂的语言信息，顾名思义，语言本地化。其实语言本地化 == 语言国际化！\n本文将分如下7个主要章节一步一步讲解如何完全本地化一个App。\n\n- **配置需要国际化的语言（国际化的准备工作）**\n- **App名称本地化**\n- **代码中字符串本地化**\n- **多人开发情况下的字符串本地化**\n- **图片本地化（两种方式两种方式）**\n- **查看/切换本地语言**\n- **storyboard/xib本地化**\n\n# 配置需要国际化的语言\n\n配置需要国际化的语言，这也是国际化之前的准备工作，无论我们是国际化App名称、代码中的字符串、图片、还是storyboard和xib，都需要进行这一步的准备工作（一个项目中需要且仅需要配置一次）。\n\n- 选中project->Info->Localizations，然后点击\"+\"，添加需要国际化/本地化的语言，如下图（默认需要勾选Use Base Internationalization）：\n\nSnip20160616_15.png\n\n- 此处以添加法语为例，如下图：\n\n  ​\n\n  ​\n\n  Snip20160616_18.png\n\n- 弹出如下对话框，直接点击finish，如下图：\n\nSnip20160616_21.png\n\n- 同理，添加简体中文、繁体中文、韩语，最终结果如下图：\n\n  ​\n\n  ​\n\n  ​\n\n  Snip20160616_22.png\n\n`备注：` “zh-Hans”和“zh-Hant”是简体中文和繁体中文的缩写。这是标准的缩写。H可大写也可小写。\"en\"是英语的缩写。ko是韩语的缩写，fr是法语的缩写。其他语言请百度各国语言缩写即可查询。\n\n# （一）应用名称本地化/国际化\n\n应用名称本地化，是指同一个App的名称，在不同的语言环境下（也就是手机设备的语言设置）显示不同的名称。比如，微信在简体中文环境下App名称显示为“**微信**”，在英语环境下显示为“**weChat**”。下面就开始进行应用名称本地化。\n\n1. 选中Info.plist，按下键盘上的command + N，选择**Strings File**（iOS->Resource->Strings File）\n\nSnip20160616_10.png\n\n- 文件名字命名为**InfoPlist**，且**必须是这个名字**（因每个人电脑设置差异，此处本人电脑没有显示strings后缀名）:\n\nSnip20160616_11.png\n\n- 点击create后，Xcode左侧导航列表就会出现名为InfoPlist.strings的文件，如下图：\n\nSnip20160616_13.png\n\n- 选中InfoPlist.strings，在Xcode的File inspection（Xcode右侧文件检查器）中点击Localize，目的是选择我们需要本地化的语言，如下图：\n  `注意：`在点击Localize之前，一定要保证我们已经添加了需要本地化的语言，也就是上面**配置需要国际化的语言**那一步（步骤：project->Info->Localizations，然后点击\"+\"，添加需要国际化/本地化的语言）。\n\nSnip20160616_14.png\n\n- 点击Localize后，会弹出一个对话框，展开对话框列表，发现下拉列表所展示的语言正是我们在上面配置的需要国际化的语言，选择我们需要本地化的语言，然后点击对话框的Localize按钮，如下图：\n\nSnip20160617_10.png\n\nSnip20160617_12.png\n\n`注意：`如果我们没有在 PROJECT 中配置需要国际化的语言（project->Info->Localizations，然后点击\"+\"），上图下拉列表中将只会出现\"Base\"和\"English\"选项，English语言是系统默认的语言，其他需要国际化的语言（例如中文简体、法语）必须通过上面的**配置本地化语言**那一步手动添加。\n\n- 然后我们发现Xcode右侧的File inspection变成了下图的样式：\n\nSnip20160617_13.png\n\n- 接下来，勾选French、Chinese（zh-Hans）、Chinese（zh-Hant）、Korean，如下图：\n\nSnip20160617_14.png\n\n- 此时，Xcode左侧的InfoPlist.stirings左侧多了一个箭头，点击箭头可以展开，如下图所示：\n\nSnip20160617_15.png\n\n从上图可以看出，InfoPlist.strings文件下包含了English、French、Chinese（Simplified）、Chinese（Traditional）、Korean这五种语言的文件。\n原理：程序启动时，会根据操作系统设置的语言，自动加载InfoPlist.strings文件下对应的语言文件，然后显示应用程序的名字。\n\n- 接下来，我们分别用不同的语言给InfoPlist.strings下的文件设置对应的名字。\n\n（1）在InfoPlist.strings(english)中加入如下代码：\n\n```\n// Localizable App Name是App在英语环境环境下显示的名称\nCFBundleDisplayName = \"Localizable App Name\";\n```\n\n`备注：`CFBundleDisplayName可以使用双引号，也可以不使用双引号！\n\nSnip20160617_21.png\n\n（2）在InfoPlist.strings(French)中加入如下代码：\n\n```\nCFBundleDisplayName = \"Le nom de la localisation de l'App\";\n```\n\nSnip20160617_27.png\n\n（3）在InfoPlist.strings(Chinese(Simplified))中加入如下代码：\n\n```\nCFBundleDisplayName = \"国际化App名称\";\n```\n\nSnip20160617_32.png\n\n（4）在InfoPlist.strings(Chinese(Traditional))中加入如下代码：\n\n```\nCFBundleDisplayName = \"國際化App名稱\";\n```\n\nSnip20160617_30.png\n\n（5）在InfoPlist.strings(Korean)中加入如下代码：\n\n```\nCFBundleDisplayName = \"현지화 앱 명칭\";\n```\n\nSnip20160617_31.png\n\n修改模拟器语言环境为English。App名称如下图：\n\nSnip20160617_33.png\n\n修改模拟器语言环境为Chinese(Simplified)。App名称如下图：\n\nSnip20160618_4.png\n\n修改模拟器语言环境为Chinese(Traditional)。App名称如下图：\n\nSnip20160618_5.png\n\n修改模拟器语言环境为Franch。App名称如下图：\n\nSnip20160618_6.png\n\n修改模拟器语言环境为Korean。App名称如下图：\n\nSnip20160618_7.png\n\n`备注：`过去本地化App名称，需要在Info.plist文件中增加一个名为“Application has localized display name”的BOOL类型的Key，并且需要将其值设置为YES（如下图）。目的是让App支持本地化App名称。**但现在可以忽略这一步**。\n\nSnip20160618_8.png\n\n至此，本地化App名称已经演示完毕，其步骤就是：\n\n- 在Project的设置中通过点击\"+\"添加需要本地化的语言。\n- 然后在Xcode右侧的File inspection中点击Localize，选中需要本地化App名称的语言。\n- 最后在每个语言对应的文件中以key = value(CFBundleDisplayName = \"App名称\";);的形式设置App的名称。\n\n# （二）代码中字符串的本地化\n\n所谓字符串本地化，就是指App内的字符串在不同的语言环境下显示不同的内容。比如，\"主页\"这个字符串在中文语言环境下显示“主页”，在英语环境下显示“home”。下面就开始进行字符串本地化。\n其实字符本地化和App名称本地化过程如出一辙，只是创建的文件名成不一样（连同后缀一起，文件名必须是Localizable.strings），其他步骤完全相同。为了能够让大家彻底了解，此处还是会把步骤一一贴出来。\n\n- 和应用名称本地化一样，首先需要command + N，选择iOS -> Resource -> Strings File\n\n![img](http://upload-images.jianshu.io/upload_images/1055199-1fe1660ee2986990.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n- 文件名必须命名为**Localizable**\n  `备注`：因本人电脑取消隐藏文件后缀名，所以会自动补全.strings后缀名。\n\nSnip20160619_8.png\n\n- 文件创建成功，查看Xcode左侧导航列表，发现多了一个名为Localizable.strings的文件，如下图：\n\nSnip20160619_4.png\n\n- 选中Localizable.strings文件，在Xcode的File inspection中点击Localize，目的是选择我们需要本地化的语言（和本地化App名称同理），如下图：\n\n![img](http://upload-images.jianshu.io/upload_images/1055199-c2378ac118e3f496.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n- 依次选择English->Localize，如下图：\n\n![img](http://upload-images.jianshu.io/upload_images/1055199-0aba0931daecd274.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![img](http://upload-images.jianshu.io/upload_images/1055199-015545406751fd42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n- 然后我们发现Xcode右侧的File inspection变成了下图的样式：\n\n![img](http://upload-images.jianshu.io/upload_images/1055199-581527c3c2149e22.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n- 然后勾选French、Chinese（zh-Hans）、Chinese（zh-Hant）、Korean，如下图：\n\n![img](http://upload-images.jianshu.io/upload_images/1055199-154a9e311e6a8033.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n- 此时，Xcode左侧的Localizable.stirings左侧多了一个箭头，展开后，如下图所示：\n\nSnip20160619_6.png\n\n- 然后我们只需要在Localizable.strings下对应的文件中，分别以Key-Value的形式，为代码中每一个需要本地化的字符串赋值，如下图：\n\nSnip20160619_9.png\n\nSnip20160619_10.png\n\nSnip20160619_12.png\n\nSnip20160619_13.png\n\nSnip20160619_14.png\n\n- 本地化代码中的字符串，如下图：\n\nSnip20160619_15.png\n\n- 我们只需要使用Foundation框架自带的NSLocalizedString(key, comment)这个宏根据Key获取对应的字符串，然后赋值给代码中的字符串。\n\n```\n// NSLocalizedString(key, comment) 本质\n// NSlocalizeString 第一个参数是内容,根据第一个参数去对应语言的文件中取对应的字符串，第二个参数将会转化为字符串文件里的注释，可以传nil，也可以传空字符串@\"\"。\n#define NSLocalizedString(key, comment) [[NSBundle mainBundle] localizedStringForKey:(key) value:@\"\" table:nil]\n```\n\n- 不同语言环境下运行效果，如下图：\n- 英语环境下：\n\nSnip20160619_17.png\n\n- 法语环境下：\n\nSnip20160619_18.png\n\n- 简体中文环境下：\n\nSnip20160619_19.png\n\n- 繁体中文环境下：\n\nSnip20160619_20.png\n\n- 韩语环境下：\n\nSnip20160619_23.png\n\n如此一来，我们就实现了代码中字符串的本地化。\n\n### 技巧\n\n- 其实，我们不需要给Localizable.strings(English)文件添加Key-Value。原因如下：系统根据某个key去获取对应的字符串时，如果没有找到，那么就会以key作为value返回。所以如果我们在Localizable.strings(English)文件中没有添加 click = \"hit\";那么在english环境下btn最终显示的title会是click.\n- 切换语言无需在模拟器中设置，只需要在Xcode中进行如下设置： Edit->Scheme->Run->Arguments Passed On Launch ->-AppleLanguages (语言代码)。例如，我们模拟器此时虽然是韩语，如果通过上述步骤设置为zh-Hans，那么语言环境将会变为汉语，如下图：\n\nSnip20160619_26.png\n\nSnip20160619_28.png\n\n- 运行效果：\n\nSnip20160619_29.png\n\n- 如此一来，切换语言变得更加简单，无需在模拟器的设置中进行繁琐的语言切换。\n\n# （三）多人开发情况下的字符串本地化\n\n项目开发中，独立开发的还是少数。经常会有多人开发的情况，这种情况，如果多人同时操作本地化文件，极有可能会存在冲突。另一方面，我们又不希望自己的本地化文件受到对方的污染，也就是说，我们不希望对方操作我们的本地化文件。但是上面介绍的代码中字符串的本地化是使用的是默认的文件名\"Localizable\",因为启动程序时，系统将根据语言加载相应的文件得到其对应的字符串文件，这个字符串可以通过系统将NSLocalizedString中的宏生成名为“Localizable.strings”的文件。那么如何让系统加载我们自己命名的本地化文件而非系统默认的Localizable.strings呢？这就是 NSLocalizedStringFromTable(<#key#>, <#tbl#>, <#comment#>)的用处。\n也就是说，如果你的strings文件名字不是Localizable而是自定义的话，如VVS.strings，那么你就得使用NSLocalizedStringFromTable这个宏来读取本地化字符串。\n\n```\n// key：系统根据key取字符串\n// tbl：自定义strings文件的名字\n// comment：可以不传\n    NSLocalizedStringFromTable(<#key#>, <#tbl#>, <#comment#>)\n```\n\nSnip20160619_32.png\n\n```\n#import \"ViewController.h\"\n\n@interface ViewController ()\n@property (weak, nonatomic) IBOutlet UIButton *btn;\n\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    NSString *title = NSLocalizedStringFromTable(@\"click\", @\"VVS\", nil);\n    [self.btn setTitle:title forState:UIControlStateNormal];\n}\n\n@end\n```\n\n- 运行效果，如下图：\n\nSnip20160619_33.png\n\n如此一来，我们就可以挣脱别人的strings文件和系统默认的Localizable.strings文件，自己另起炉灶。\n\n# （四）图片本地化\n\n本地化图片，有两种方式，第一种方式和本地化代码中的字符串一样，通过NSLocalizedString(key,comment)来获取相应的字符串，然后根据这个字符串再获取图片。\n\n## 方式一\n\n```\nNSString *imageName = NSLocalizedString(@\"icon\", nil);\nUIImage *image = [UIImage imageNamed:imageName];\nself.imageView.image = image;\n```\n\n## 方式二\n\n首先需要添加需要本地化的语言，具体步骤参考第一章**配置需要国际化的语言**。因为我演示的demo中在本地化App名称时已经添加了需要国际化的语言。所以不需要再设置。\n\n- 将图片拖入工程中，例如“icon.png”，然后选中icon.png，展开Xcode右侧的file Inspection，点击Localize，如下图:\n\nSnip20160619_36.png\n\n- 然后，右击icon.png->show in Finder，我们发现在en.Iproj文件中多了一个名为icon.png的图片，如下图：\n\nSnip20160619_38.png\n\n- 当然，zh-Hans.Iproj文件夹下并没有图片，如下图：\n\nSnip20160619_39.png\n\n- 我们只需给zh-Hans.Iproj添加一个名字也为icon.png的图片。如下图：\n\nSnip20160619_40.png\n\n- 然后把zh-Hans.Iproj中的icon.png拖到Xcode中，如下图：\n\nSnip20160619_43.png\n\n- 然后发现，icon.png左边出现了一个可以展开的三角形。如下图：\n\nSnip20160619_44.png\n\n- 展开后发现里面包含两张图片，如下图：\n\nSnip20160619_45.png\n\n然后控制器中添加如下代码：\n\n```\n#import \"ViewController.h\"\n\n@interface ViewController ()\n@property (weak, nonatomic) IBOutlet UIImageView *imageView;\n\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    NSString *imageName = NSLocalizedString(@\"icon\", nil);\n    UIImage *image = [UIImage imageNamed:imageName];\n    self.imageView.image = image;\n}\n\n@end\n```\n\n- english环境下运行效果如下：\n\nSnip20160620_46.png\n\n- 中文环境改下运行效果如下：\n\nSnip20160620_47.png\n\n- 其他语言环境，例如法语、中文繁体、韩语，操作步骤完全和上面相同。都是在对应的.Iproj文件夹下添加同名的图片，然后把图片拖放到Xcode中，不再赘述。\n\n# （五）查看/切换本地语言\n\n原理：应用启动时，首先会读取NSUserDefaults中的key为AppleLanguages对应的value，该value是一个String数组，也就是说，我们访问这个名为AppleLanguages的key可以返回一个string数组，该数组存储着APP支持的语言列表，数组的第一项为APP当前默认的语言。\n\n```\n#import \"ViewController.h\"\n\n@interface ViewController ()\n\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    NSArray *languages = [[NSUserDefaults standardUserDefaults] valueForKey:@\"AppleLanguages\"];\n    NSString *currentLanguage = languages.firstObject;\n    NSLog(@\"模拟器当前语言：%@\",currentLanguage);\n}\n@end\n```\n\n-控制台打印结果：\n\nSnip20160620_1.png\n\n同理，既然我们可以通过AppleLanguages这个key从NSUserDefaults中取出语言数组，那么我们也可以给AppleLanguages这个key赋值来达到切换本地语言的效果，从此以后，我们就无需频繁的去模拟器的设置->通用->语言与地区 中切换语言。\n\n```\n#import \"ViewController.h\"\n\n@interface ViewController ()\n\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    // 切换语言前\n    NSArray *langArr1 = [[NSUserDefaults standardUserDefaults] valueForKey:@\"AppleLanguages\"];\n    NSString *language1 = langArr1.firstObject;\n    NSLog(@\"模拟器语言切换之前：%@\",language1);\n\n    // 切换语言\n    NSArray *lans = @[@\"en\"];\n    [[NSUserDefaults standardUserDefaults] setObject:lans forKey:@\"AppleLanguages\"];\n\n    // 切换语言后\n    NSArray *langArr2 = [[NSUserDefaults standardUserDefaults] valueForKey:@\"AppleLanguages\"];\n    NSString *language2 = langArr2.firstObject;\n    NSLog(@\"模拟器语言切换之后：%@\",language2);\n}\n@end\n```\n\nSnip20160620_2.png\n\n- 回想一下，我在上面的**技巧**一节中提过：切换语言无需在模拟器中设置，只需要在Xcode中进行如下设置： Edit->Scheme->Run->Arguments Passed On Launch ->-AppleLanguages (语言代码)。其实本质上就是给NSUserDefaults中名为AppleLanguages的key赋值。\n\n","slug":"localization","published":1,"updated":"2017-03-11T03:57:00.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj04pzyy70017s04ely8kbg6a","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>语言本地化，又叫做语言国际化。是指根据用户操作系统的语言设置，自动将应用程序的语言设置为和用户操作系统语言一致的语言。往往一些应用程序需要提供给多个国家的人群使用，或者一个国家有多种语言，这就要求应用程序所展示的文字、图片等信息，能够让讲不同语言的用户读懂、看懂。进而提出为同一个应用程序适配多种语言，也即是国际化。语言国际化之所以又叫做语言本地化，这是站在每个用户的角度而言的，是指能够让用户本地、本土人群能够看懂的语言信息，顾名思义，语言本地化。其实语言本地化 == 语言国际化！<br>本文将分如下7个主要章节一步一步讲解如何完全本地化一个App。</p>\n<ul>\n<li><strong>配置需要国际化的语言（国际化的准备工作）</strong></li>\n<li><strong>App名称本地化</strong></li>\n<li><strong>代码中字符串本地化</strong></li>\n<li><strong>多人开发情况下的字符串本地化</strong></li>\n<li><strong>图片本地化（两种方式两种方式）</strong></li>\n<li><strong>查看/切换本地语言</strong></li>\n<li><strong>storyboard/xib本地化</strong></li>\n</ul>\n<h1 id=\"配置需要国际化的语言\"><a href=\"#配置需要国际化的语言\" class=\"headerlink\" title=\"配置需要国际化的语言\"></a>配置需要国际化的语言</h1><p>配置需要国际化的语言，这也是国际化之前的准备工作，无论我们是国际化App名称、代码中的字符串、图片、还是storyboard和xib，都需要进行这一步的准备工作（一个项目中需要且仅需要配置一次）。</p>\n<ul>\n<li>选中project-&gt;Info-&gt;Localizations，然后点击”+”，添加需要国际化/本地化的语言，如下图（默认需要勾选Use Base Internationalization）：</li>\n</ul>\n<p>Snip20160616_15.png</p>\n<ul>\n<li><p>此处以添加法语为例，如下图：</p>\n<p>​</p>\n<p>​</p>\n<p>Snip20160616_18.png</p>\n</li>\n<li><p>弹出如下对话框，直接点击finish，如下图：</p>\n</li>\n</ul>\n<p>Snip20160616_21.png</p>\n<ul>\n<li><p>同理，添加简体中文、繁体中文、韩语，最终结果如下图：</p>\n<p>​</p>\n<p>​</p>\n<p>​</p>\n<p>Snip20160616_22.png</p>\n</li>\n</ul>\n<p><code>备注：</code> “zh-Hans”和“zh-Hant”是简体中文和繁体中文的缩写。这是标准的缩写。H可大写也可小写。”en”是英语的缩写。ko是韩语的缩写，fr是法语的缩写。其他语言请百度各国语言缩写即可查询。</p>\n<h1 id=\"（一）应用名称本地化-国际化\"><a href=\"#（一）应用名称本地化-国际化\" class=\"headerlink\" title=\"（一）应用名称本地化/国际化\"></a>（一）应用名称本地化/国际化</h1><p>应用名称本地化，是指同一个App的名称，在不同的语言环境下（也就是手机设备的语言设置）显示不同的名称。比如，微信在简体中文环境下App名称显示为“<strong>微信</strong>”，在英语环境下显示为“<strong>weChat</strong>”。下面就开始进行应用名称本地化。</p>\n<ol>\n<li>选中Info.plist，按下键盘上的command + N，选择<strong>Strings File</strong>（iOS-&gt;Resource-&gt;Strings File）</li>\n</ol>\n<p>Snip20160616_10.png</p>\n<ul>\n<li>文件名字命名为<strong>InfoPlist</strong>，且<strong>必须是这个名字</strong>（因每个人电脑设置差异，此处本人电脑没有显示strings后缀名）:</li>\n</ul>\n<p>Snip20160616_11.png</p>\n<ul>\n<li>点击create后，Xcode左侧导航列表就会出现名为InfoPlist.strings的文件，如下图：</li>\n</ul>\n<p>Snip20160616_13.png</p>\n<ul>\n<li>选中InfoPlist.strings，在Xcode的File inspection（Xcode右侧文件检查器）中点击Localize，目的是选择我们需要本地化的语言，如下图：<br><code>注意：</code>在点击Localize之前，一定要保证我们已经添加了需要本地化的语言，也就是上面<strong>配置需要国际化的语言</strong>那一步（步骤：project-&gt;Info-&gt;Localizations，然后点击”+”，添加需要国际化/本地化的语言）。</li>\n</ul>\n<p>Snip20160616_14.png</p>\n<ul>\n<li>点击Localize后，会弹出一个对话框，展开对话框列表，发现下拉列表所展示的语言正是我们在上面配置的需要国际化的语言，选择我们需要本地化的语言，然后点击对话框的Localize按钮，如下图：</li>\n</ul>\n<p>Snip20160617_10.png</p>\n<p>Snip20160617_12.png</p>\n<p><code>注意：</code>如果我们没有在 PROJECT 中配置需要国际化的语言（project-&gt;Info-&gt;Localizations，然后点击”+”），上图下拉列表中将只会出现”Base”和”English”选项，English语言是系统默认的语言，其他需要国际化的语言（例如中文简体、法语）必须通过上面的<strong>配置本地化语言</strong>那一步手动添加。</p>\n<ul>\n<li>然后我们发现Xcode右侧的File inspection变成了下图的样式：</li>\n</ul>\n<p>Snip20160617_13.png</p>\n<ul>\n<li>接下来，勾选French、Chinese（zh-Hans）、Chinese（zh-Hant）、Korean，如下图：</li>\n</ul>\n<p>Snip20160617_14.png</p>\n<ul>\n<li>此时，Xcode左侧的InfoPlist.stirings左侧多了一个箭头，点击箭头可以展开，如下图所示：</li>\n</ul>\n<p>Snip20160617_15.png</p>\n<p>从上图可以看出，InfoPlist.strings文件下包含了English、French、Chinese（Simplified）、Chinese（Traditional）、Korean这五种语言的文件。<br>原理：程序启动时，会根据操作系统设置的语言，自动加载InfoPlist.strings文件下对应的语言文件，然后显示应用程序的名字。</p>\n<ul>\n<li>接下来，我们分别用不同的语言给InfoPlist.strings下的文件设置对应的名字。</li>\n</ul>\n<p>（1）在InfoPlist.strings(english)中加入如下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">// Localizable App Name是App在英语环境环境下显示的名称</div><div class=\"line\">CFBundleDisplayName = &quot;Localizable App Name&quot;;</div></pre></td></tr></table></figure>\n<p><code>备注：</code>CFBundleDisplayName可以使用双引号，也可以不使用双引号！</p>\n<p>Snip20160617_21.png</p>\n<p>（2）在InfoPlist.strings(French)中加入如下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">CFBundleDisplayName = &quot;Le nom de la localisation de l&apos;App&quot;;</div></pre></td></tr></table></figure>\n<p>Snip20160617_27.png</p>\n<p>（3）在InfoPlist.strings(Chinese(Simplified))中加入如下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">CFBundleDisplayName = &quot;国际化App名称&quot;;</div></pre></td></tr></table></figure>\n<p>Snip20160617_32.png</p>\n<p>（4）在InfoPlist.strings(Chinese(Traditional))中加入如下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">CFBundleDisplayName = &quot;國際化App名稱&quot;;</div></pre></td></tr></table></figure>\n<p>Snip20160617_30.png</p>\n<p>（5）在InfoPlist.strings(Korean)中加入如下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">CFBundleDisplayName = &quot;현지화 앱 명칭&quot;;</div></pre></td></tr></table></figure>\n<p>Snip20160617_31.png</p>\n<p>修改模拟器语言环境为English。App名称如下图：</p>\n<p>Snip20160617_33.png</p>\n<p>修改模拟器语言环境为Chinese(Simplified)。App名称如下图：</p>\n<p>Snip20160618_4.png</p>\n<p>修改模拟器语言环境为Chinese(Traditional)。App名称如下图：</p>\n<p>Snip20160618_5.png</p>\n<p>修改模拟器语言环境为Franch。App名称如下图：</p>\n<p>Snip20160618_6.png</p>\n<p>修改模拟器语言环境为Korean。App名称如下图：</p>\n<p>Snip20160618_7.png</p>\n<p><code>备注：</code>过去本地化App名称，需要在Info.plist文件中增加一个名为“Application has localized display name”的BOOL类型的Key，并且需要将其值设置为YES（如下图）。目的是让App支持本地化App名称。<strong>但现在可以忽略这一步</strong>。</p>\n<p>Snip20160618_8.png</p>\n<p>至此，本地化App名称已经演示完毕，其步骤就是：</p>\n<ul>\n<li>在Project的设置中通过点击”+”添加需要本地化的语言。</li>\n<li>然后在Xcode右侧的File inspection中点击Localize，选中需要本地化App名称的语言。</li>\n<li>最后在每个语言对应的文件中以key = value(CFBundleDisplayName = “App名称”;);的形式设置App的名称。</li>\n</ul>\n<h1 id=\"（二）代码中字符串的本地化\"><a href=\"#（二）代码中字符串的本地化\" class=\"headerlink\" title=\"（二）代码中字符串的本地化\"></a>（二）代码中字符串的本地化</h1><p>所谓字符串本地化，就是指App内的字符串在不同的语言环境下显示不同的内容。比如，”主页”这个字符串在中文语言环境下显示“主页”，在英语环境下显示“home”。下面就开始进行字符串本地化。<br>其实字符本地化和App名称本地化过程如出一辙，只是创建的文件名成不一样（连同后缀一起，文件名必须是Localizable.strings），其他步骤完全相同。为了能够让大家彻底了解，此处还是会把步骤一一贴出来。</p>\n<ul>\n<li>和应用名称本地化一样，首先需要command + N，选择iOS -&gt; Resource -&gt; Strings File</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1055199-1fe1660ee2986990.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"img\"></p>\n<ul>\n<li>文件名必须命名为<strong>Localizable</strong><br><code>备注</code>：因本人电脑取消隐藏文件后缀名，所以会自动补全.strings后缀名。</li>\n</ul>\n<p>Snip20160619_8.png</p>\n<ul>\n<li>文件创建成功，查看Xcode左侧导航列表，发现多了一个名为Localizable.strings的文件，如下图：</li>\n</ul>\n<p>Snip20160619_4.png</p>\n<ul>\n<li>选中Localizable.strings文件，在Xcode的File inspection中点击Localize，目的是选择我们需要本地化的语言（和本地化App名称同理），如下图：</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1055199-c2378ac118e3f496.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"img\"></p>\n<ul>\n<li>依次选择English-&gt;Localize，如下图：</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1055199-0aba0931daecd274.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"img\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1055199-015545406751fd42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"img\"></p>\n<ul>\n<li>然后我们发现Xcode右侧的File inspection变成了下图的样式：</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1055199-581527c3c2149e22.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"img\"></p>\n<ul>\n<li>然后勾选French、Chinese（zh-Hans）、Chinese（zh-Hant）、Korean，如下图：</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1055199-154a9e311e6a8033.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"img\"></p>\n<ul>\n<li>此时，Xcode左侧的Localizable.stirings左侧多了一个箭头，展开后，如下图所示：</li>\n</ul>\n<p>Snip20160619_6.png</p>\n<ul>\n<li>然后我们只需要在Localizable.strings下对应的文件中，分别以Key-Value的形式，为代码中每一个需要本地化的字符串赋值，如下图：</li>\n</ul>\n<p>Snip20160619_9.png</p>\n<p>Snip20160619_10.png</p>\n<p>Snip20160619_12.png</p>\n<p>Snip20160619_13.png</p>\n<p>Snip20160619_14.png</p>\n<ul>\n<li>本地化代码中的字符串，如下图：</li>\n</ul>\n<p>Snip20160619_15.png</p>\n<ul>\n<li>我们只需要使用Foundation框架自带的NSLocalizedString(key, comment)这个宏根据Key获取对应的字符串，然后赋值给代码中的字符串。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">// NSLocalizedString(key, comment) 本质</div><div class=\"line\">// NSlocalizeString 第一个参数是内容,根据第一个参数去对应语言的文件中取对应的字符串，第二个参数将会转化为字符串文件里的注释，可以传nil，也可以传空字符串@&quot;&quot;。</div><div class=\"line\">#define NSLocalizedString(key, comment) [[NSBundle mainBundle] localizedStringForKey:(key) value:@&quot;&quot; table:nil]</div></pre></td></tr></table></figure>\n<ul>\n<li>不同语言环境下运行效果，如下图：</li>\n<li>英语环境下：</li>\n</ul>\n<p>Snip20160619_17.png</p>\n<ul>\n<li>法语环境下：</li>\n</ul>\n<p>Snip20160619_18.png</p>\n<ul>\n<li>简体中文环境下：</li>\n</ul>\n<p>Snip20160619_19.png</p>\n<ul>\n<li>繁体中文环境下：</li>\n</ul>\n<p>Snip20160619_20.png</p>\n<ul>\n<li>韩语环境下：</li>\n</ul>\n<p>Snip20160619_23.png</p>\n<p>如此一来，我们就实现了代码中字符串的本地化。</p>\n<h3 id=\"技巧\"><a href=\"#技巧\" class=\"headerlink\" title=\"技巧\"></a>技巧</h3><ul>\n<li>其实，我们不需要给Localizable.strings(English)文件添加Key-Value。原因如下：系统根据某个key去获取对应的字符串时，如果没有找到，那么就会以key作为value返回。所以如果我们在Localizable.strings(English)文件中没有添加 click = “hit”;那么在english环境下btn最终显示的title会是click.</li>\n<li>切换语言无需在模拟器中设置，只需要在Xcode中进行如下设置： Edit-&gt;Scheme-&gt;Run-&gt;Arguments Passed On Launch -&gt;-AppleLanguages (语言代码)。例如，我们模拟器此时虽然是韩语，如果通过上述步骤设置为zh-Hans，那么语言环境将会变为汉语，如下图：</li>\n</ul>\n<p>Snip20160619_26.png</p>\n<p>Snip20160619_28.png</p>\n<ul>\n<li>运行效果：</li>\n</ul>\n<p>Snip20160619_29.png</p>\n<ul>\n<li>如此一来，切换语言变得更加简单，无需在模拟器的设置中进行繁琐的语言切换。</li>\n</ul>\n<h1 id=\"（三）多人开发情况下的字符串本地化\"><a href=\"#（三）多人开发情况下的字符串本地化\" class=\"headerlink\" title=\"（三）多人开发情况下的字符串本地化\"></a>（三）多人开发情况下的字符串本地化</h1><p>项目开发中，独立开发的还是少数。经常会有多人开发的情况，这种情况，如果多人同时操作本地化文件，极有可能会存在冲突。另一方面，我们又不希望自己的本地化文件受到对方的污染，也就是说，我们不希望对方操作我们的本地化文件。但是上面介绍的代码中字符串的本地化是使用的是默认的文件名”Localizable”,因为启动程序时，系统将根据语言加载相应的文件得到其对应的字符串文件，这个字符串可以通过系统将NSLocalizedString中的宏生成名为“Localizable.strings”的文件。那么如何让系统加载我们自己命名的本地化文件而非系统默认的Localizable.strings呢？这就是 NSLocalizedStringFromTable(&lt;#key#&gt;, &lt;#tbl#&gt;, &lt;#comment#&gt;)的用处。<br>也就是说，如果你的strings文件名字不是Localizable而是自定义的话，如VVS.strings，那么你就得使用NSLocalizedStringFromTable这个宏来读取本地化字符串。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">// key：系统根据key取字符串</div><div class=\"line\">// tbl：自定义strings文件的名字</div><div class=\"line\">// comment：可以不传</div><div class=\"line\">    NSLocalizedStringFromTable(&lt;#key#&gt;, &lt;#tbl#&gt;, &lt;#comment#&gt;)</div></pre></td></tr></table></figure>\n<p>Snip20160619_32.png</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &quot;ViewController.h&quot;</div><div class=\"line\"></div><div class=\"line\">@interface ViewController ()</div><div class=\"line\">@property (weak, nonatomic) IBOutlet UIButton *btn;</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation ViewController</div><div class=\"line\"></div><div class=\"line\">- (void)viewDidLoad &#123;</div><div class=\"line\">    [super viewDidLoad];</div><div class=\"line\"></div><div class=\"line\">    NSString *title = NSLocalizedStringFromTable(@&quot;click&quot;, @&quot;VVS&quot;, nil);</div><div class=\"line\">    [self.btn setTitle:title forState:UIControlStateNormal];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<ul>\n<li>运行效果，如下图：</li>\n</ul>\n<p>Snip20160619_33.png</p>\n<p>如此一来，我们就可以挣脱别人的strings文件和系统默认的Localizable.strings文件，自己另起炉灶。</p>\n<h1 id=\"（四）图片本地化\"><a href=\"#（四）图片本地化\" class=\"headerlink\" title=\"（四）图片本地化\"></a>（四）图片本地化</h1><p>本地化图片，有两种方式，第一种方式和本地化代码中的字符串一样，通过NSLocalizedString(key,comment)来获取相应的字符串，然后根据这个字符串再获取图片。</p>\n<h2 id=\"方式一\"><a href=\"#方式一\" class=\"headerlink\" title=\"方式一\"></a>方式一</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">NSString *imageName = NSLocalizedString(@&quot;icon&quot;, nil);</div><div class=\"line\">UIImage *image = [UIImage imageNamed:imageName];</div><div class=\"line\">self.imageView.image = image;</div></pre></td></tr></table></figure>\n<h2 id=\"方式二\"><a href=\"#方式二\" class=\"headerlink\" title=\"方式二\"></a>方式二</h2><p>首先需要添加需要本地化的语言，具体步骤参考第一章<strong>配置需要国际化的语言</strong>。因为我演示的demo中在本地化App名称时已经添加了需要国际化的语言。所以不需要再设置。</p>\n<ul>\n<li>将图片拖入工程中，例如“icon.png”，然后选中icon.png，展开Xcode右侧的file Inspection，点击Localize，如下图:</li>\n</ul>\n<p>Snip20160619_36.png</p>\n<ul>\n<li>然后，右击icon.png-&gt;show in Finder，我们发现在en.Iproj文件中多了一个名为icon.png的图片，如下图：</li>\n</ul>\n<p>Snip20160619_38.png</p>\n<ul>\n<li>当然，zh-Hans.Iproj文件夹下并没有图片，如下图：</li>\n</ul>\n<p>Snip20160619_39.png</p>\n<ul>\n<li>我们只需给zh-Hans.Iproj添加一个名字也为icon.png的图片。如下图：</li>\n</ul>\n<p>Snip20160619_40.png</p>\n<ul>\n<li>然后把zh-Hans.Iproj中的icon.png拖到Xcode中，如下图：</li>\n</ul>\n<p>Snip20160619_43.png</p>\n<ul>\n<li>然后发现，icon.png左边出现了一个可以展开的三角形。如下图：</li>\n</ul>\n<p>Snip20160619_44.png</p>\n<ul>\n<li>展开后发现里面包含两张图片，如下图：</li>\n</ul>\n<p>Snip20160619_45.png</p>\n<p>然后控制器中添加如下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &quot;ViewController.h&quot;</div><div class=\"line\"></div><div class=\"line\">@interface ViewController ()</div><div class=\"line\">@property (weak, nonatomic) IBOutlet UIImageView *imageView;</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation ViewController</div><div class=\"line\"></div><div class=\"line\">- (void)viewDidLoad &#123;</div><div class=\"line\">    [super viewDidLoad];</div><div class=\"line\"></div><div class=\"line\">    NSString *imageName = NSLocalizedString(@&quot;icon&quot;, nil);</div><div class=\"line\">    UIImage *image = [UIImage imageNamed:imageName];</div><div class=\"line\">    self.imageView.image = image;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<ul>\n<li>english环境下运行效果如下：</li>\n</ul>\n<p>Snip20160620_46.png</p>\n<ul>\n<li>中文环境改下运行效果如下：</li>\n</ul>\n<p>Snip20160620_47.png</p>\n<ul>\n<li>其他语言环境，例如法语、中文繁体、韩语，操作步骤完全和上面相同。都是在对应的.Iproj文件夹下添加同名的图片，然后把图片拖放到Xcode中，不再赘述。</li>\n</ul>\n<h1 id=\"（五）查看-切换本地语言\"><a href=\"#（五）查看-切换本地语言\" class=\"headerlink\" title=\"（五）查看/切换本地语言\"></a>（五）查看/切换本地语言</h1><p>原理：应用启动时，首先会读取NSUserDefaults中的key为AppleLanguages对应的value，该value是一个String数组，也就是说，我们访问这个名为AppleLanguages的key可以返回一个string数组，该数组存储着APP支持的语言列表，数组的第一项为APP当前默认的语言。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &quot;ViewController.h&quot;</div><div class=\"line\"></div><div class=\"line\">@interface ViewController ()</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation ViewController</div><div class=\"line\"></div><div class=\"line\">- (void)viewDidLoad &#123;</div><div class=\"line\">    [super viewDidLoad];</div><div class=\"line\"></div><div class=\"line\">    NSArray *languages = [[NSUserDefaults standardUserDefaults] valueForKey:@&quot;AppleLanguages&quot;];</div><div class=\"line\">    NSString *currentLanguage = languages.firstObject;</div><div class=\"line\">    NSLog(@&quot;模拟器当前语言：%@&quot;,currentLanguage);</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>-控制台打印结果：</p>\n<p>Snip20160620_1.png</p>\n<p>同理，既然我们可以通过AppleLanguages这个key从NSUserDefaults中取出语言数组，那么我们也可以给AppleLanguages这个key赋值来达到切换本地语言的效果，从此以后，我们就无需频繁的去模拟器的设置-&gt;通用-&gt;语言与地区 中切换语言。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &quot;ViewController.h&quot;</div><div class=\"line\"></div><div class=\"line\">@interface ViewController ()</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation ViewController</div><div class=\"line\"></div><div class=\"line\">- (void)viewDidLoad &#123;</div><div class=\"line\">    [super viewDidLoad];</div><div class=\"line\"></div><div class=\"line\">    // 切换语言前</div><div class=\"line\">    NSArray *langArr1 = [[NSUserDefaults standardUserDefaults] valueForKey:@&quot;AppleLanguages&quot;];</div><div class=\"line\">    NSString *language1 = langArr1.firstObject;</div><div class=\"line\">    NSLog(@&quot;模拟器语言切换之前：%@&quot;,language1);</div><div class=\"line\"></div><div class=\"line\">    // 切换语言</div><div class=\"line\">    NSArray *lans = @[@&quot;en&quot;];</div><div class=\"line\">    [[NSUserDefaults standardUserDefaults] setObject:lans forKey:@&quot;AppleLanguages&quot;];</div><div class=\"line\"></div><div class=\"line\">    // 切换语言后</div><div class=\"line\">    NSArray *langArr2 = [[NSUserDefaults standardUserDefaults] valueForKey:@&quot;AppleLanguages&quot;];</div><div class=\"line\">    NSString *language2 = langArr2.firstObject;</div><div class=\"line\">    NSLog(@&quot;模拟器语言切换之后：%@&quot;,language2);</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>Snip20160620_2.png</p>\n<ul>\n<li>回想一下，我在上面的<strong>技巧</strong>一节中提过：切换语言无需在模拟器中设置，只需要在Xcode中进行如下设置： Edit-&gt;Scheme-&gt;Run-&gt;Arguments Passed On Launch -&gt;-AppleLanguages (语言代码)。其实本质上就是给NSUserDefaults中名为AppleLanguages的key赋值。</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>语言本地化，又叫做语言国际化。是指根据用户操作系统的语言设置，自动将应用程序的语言设置为和用户操作系统语言一致的语言。往往一些应用程序需要提供给多个国家的人群使用，或者一个国家有多种语言，这就要求应用程序所展示的文字、图片等信息，能够让讲不同语言的用户读懂、看懂。进而提出为同一个应用程序适配多种语言，也即是国际化。语言国际化之所以又叫做语言本地化，这是站在每个用户的角度而言的，是指能够让用户本地、本土人群能够看懂的语言信息，顾名思义，语言本地化。其实语言本地化 == 语言国际化！<br>本文将分如下7个主要章节一步一步讲解如何完全本地化一个App。</p>\n<ul>\n<li><strong>配置需要国际化的语言（国际化的准备工作）</strong></li>\n<li><strong>App名称本地化</strong></li>\n<li><strong>代码中字符串本地化</strong></li>\n<li><strong>多人开发情况下的字符串本地化</strong></li>\n<li><strong>图片本地化（两种方式两种方式）</strong></li>\n<li><strong>查看/切换本地语言</strong></li>\n<li><strong>storyboard/xib本地化</strong></li>\n</ul>\n<h1 id=\"配置需要国际化的语言\"><a href=\"#配置需要国际化的语言\" class=\"headerlink\" title=\"配置需要国际化的语言\"></a>配置需要国际化的语言</h1><p>配置需要国际化的语言，这也是国际化之前的准备工作，无论我们是国际化App名称、代码中的字符串、图片、还是storyboard和xib，都需要进行这一步的准备工作（一个项目中需要且仅需要配置一次）。</p>\n<ul>\n<li>选中project-&gt;Info-&gt;Localizations，然后点击”+”，添加需要国际化/本地化的语言，如下图（默认需要勾选Use Base Internationalization）：</li>\n</ul>\n<p>Snip20160616_15.png</p>\n<ul>\n<li><p>此处以添加法语为例，如下图：</p>\n<p>​</p>\n<p>​</p>\n<p>Snip20160616_18.png</p>\n</li>\n<li><p>弹出如下对话框，直接点击finish，如下图：</p>\n</li>\n</ul>\n<p>Snip20160616_21.png</p>\n<ul>\n<li><p>同理，添加简体中文、繁体中文、韩语，最终结果如下图：</p>\n<p>​</p>\n<p>​</p>\n<p>​</p>\n<p>Snip20160616_22.png</p>\n</li>\n</ul>\n<p><code>备注：</code> “zh-Hans”和“zh-Hant”是简体中文和繁体中文的缩写。这是标准的缩写。H可大写也可小写。”en”是英语的缩写。ko是韩语的缩写，fr是法语的缩写。其他语言请百度各国语言缩写即可查询。</p>\n<h1 id=\"（一）应用名称本地化-国际化\"><a href=\"#（一）应用名称本地化-国际化\" class=\"headerlink\" title=\"（一）应用名称本地化/国际化\"></a>（一）应用名称本地化/国际化</h1><p>应用名称本地化，是指同一个App的名称，在不同的语言环境下（也就是手机设备的语言设置）显示不同的名称。比如，微信在简体中文环境下App名称显示为“<strong>微信</strong>”，在英语环境下显示为“<strong>weChat</strong>”。下面就开始进行应用名称本地化。</p>\n<ol>\n<li>选中Info.plist，按下键盘上的command + N，选择<strong>Strings File</strong>（iOS-&gt;Resource-&gt;Strings File）</li>\n</ol>\n<p>Snip20160616_10.png</p>\n<ul>\n<li>文件名字命名为<strong>InfoPlist</strong>，且<strong>必须是这个名字</strong>（因每个人电脑设置差异，此处本人电脑没有显示strings后缀名）:</li>\n</ul>\n<p>Snip20160616_11.png</p>\n<ul>\n<li>点击create后，Xcode左侧导航列表就会出现名为InfoPlist.strings的文件，如下图：</li>\n</ul>\n<p>Snip20160616_13.png</p>\n<ul>\n<li>选中InfoPlist.strings，在Xcode的File inspection（Xcode右侧文件检查器）中点击Localize，目的是选择我们需要本地化的语言，如下图：<br><code>注意：</code>在点击Localize之前，一定要保证我们已经添加了需要本地化的语言，也就是上面<strong>配置需要国际化的语言</strong>那一步（步骤：project-&gt;Info-&gt;Localizations，然后点击”+”，添加需要国际化/本地化的语言）。</li>\n</ul>\n<p>Snip20160616_14.png</p>\n<ul>\n<li>点击Localize后，会弹出一个对话框，展开对话框列表，发现下拉列表所展示的语言正是我们在上面配置的需要国际化的语言，选择我们需要本地化的语言，然后点击对话框的Localize按钮，如下图：</li>\n</ul>\n<p>Snip20160617_10.png</p>\n<p>Snip20160617_12.png</p>\n<p><code>注意：</code>如果我们没有在 PROJECT 中配置需要国际化的语言（project-&gt;Info-&gt;Localizations，然后点击”+”），上图下拉列表中将只会出现”Base”和”English”选项，English语言是系统默认的语言，其他需要国际化的语言（例如中文简体、法语）必须通过上面的<strong>配置本地化语言</strong>那一步手动添加。</p>\n<ul>\n<li>然后我们发现Xcode右侧的File inspection变成了下图的样式：</li>\n</ul>\n<p>Snip20160617_13.png</p>\n<ul>\n<li>接下来，勾选French、Chinese（zh-Hans）、Chinese（zh-Hant）、Korean，如下图：</li>\n</ul>\n<p>Snip20160617_14.png</p>\n<ul>\n<li>此时，Xcode左侧的InfoPlist.stirings左侧多了一个箭头，点击箭头可以展开，如下图所示：</li>\n</ul>\n<p>Snip20160617_15.png</p>\n<p>从上图可以看出，InfoPlist.strings文件下包含了English、French、Chinese（Simplified）、Chinese（Traditional）、Korean这五种语言的文件。<br>原理：程序启动时，会根据操作系统设置的语言，自动加载InfoPlist.strings文件下对应的语言文件，然后显示应用程序的名字。</p>\n<ul>\n<li>接下来，我们分别用不同的语言给InfoPlist.strings下的文件设置对应的名字。</li>\n</ul>\n<p>（1）在InfoPlist.strings(english)中加入如下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">// Localizable App Name是App在英语环境环境下显示的名称</div><div class=\"line\">CFBundleDisplayName = &quot;Localizable App Name&quot;;</div></pre></td></tr></table></figure>\n<p><code>备注：</code>CFBundleDisplayName可以使用双引号，也可以不使用双引号！</p>\n<p>Snip20160617_21.png</p>\n<p>（2）在InfoPlist.strings(French)中加入如下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">CFBundleDisplayName = &quot;Le nom de la localisation de l&apos;App&quot;;</div></pre></td></tr></table></figure>\n<p>Snip20160617_27.png</p>\n<p>（3）在InfoPlist.strings(Chinese(Simplified))中加入如下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">CFBundleDisplayName = &quot;国际化App名称&quot;;</div></pre></td></tr></table></figure>\n<p>Snip20160617_32.png</p>\n<p>（4）在InfoPlist.strings(Chinese(Traditional))中加入如下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">CFBundleDisplayName = &quot;國際化App名稱&quot;;</div></pre></td></tr></table></figure>\n<p>Snip20160617_30.png</p>\n<p>（5）在InfoPlist.strings(Korean)中加入如下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">CFBundleDisplayName = &quot;현지화 앱 명칭&quot;;</div></pre></td></tr></table></figure>\n<p>Snip20160617_31.png</p>\n<p>修改模拟器语言环境为English。App名称如下图：</p>\n<p>Snip20160617_33.png</p>\n<p>修改模拟器语言环境为Chinese(Simplified)。App名称如下图：</p>\n<p>Snip20160618_4.png</p>\n<p>修改模拟器语言环境为Chinese(Traditional)。App名称如下图：</p>\n<p>Snip20160618_5.png</p>\n<p>修改模拟器语言环境为Franch。App名称如下图：</p>\n<p>Snip20160618_6.png</p>\n<p>修改模拟器语言环境为Korean。App名称如下图：</p>\n<p>Snip20160618_7.png</p>\n<p><code>备注：</code>过去本地化App名称，需要在Info.plist文件中增加一个名为“Application has localized display name”的BOOL类型的Key，并且需要将其值设置为YES（如下图）。目的是让App支持本地化App名称。<strong>但现在可以忽略这一步</strong>。</p>\n<p>Snip20160618_8.png</p>\n<p>至此，本地化App名称已经演示完毕，其步骤就是：</p>\n<ul>\n<li>在Project的设置中通过点击”+”添加需要本地化的语言。</li>\n<li>然后在Xcode右侧的File inspection中点击Localize，选中需要本地化App名称的语言。</li>\n<li>最后在每个语言对应的文件中以key = value(CFBundleDisplayName = “App名称”;);的形式设置App的名称。</li>\n</ul>\n<h1 id=\"（二）代码中字符串的本地化\"><a href=\"#（二）代码中字符串的本地化\" class=\"headerlink\" title=\"（二）代码中字符串的本地化\"></a>（二）代码中字符串的本地化</h1><p>所谓字符串本地化，就是指App内的字符串在不同的语言环境下显示不同的内容。比如，”主页”这个字符串在中文语言环境下显示“主页”，在英语环境下显示“home”。下面就开始进行字符串本地化。<br>其实字符本地化和App名称本地化过程如出一辙，只是创建的文件名成不一样（连同后缀一起，文件名必须是Localizable.strings），其他步骤完全相同。为了能够让大家彻底了解，此处还是会把步骤一一贴出来。</p>\n<ul>\n<li>和应用名称本地化一样，首先需要command + N，选择iOS -&gt; Resource -&gt; Strings File</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1055199-1fe1660ee2986990.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"img\"></p>\n<ul>\n<li>文件名必须命名为<strong>Localizable</strong><br><code>备注</code>：因本人电脑取消隐藏文件后缀名，所以会自动补全.strings后缀名。</li>\n</ul>\n<p>Snip20160619_8.png</p>\n<ul>\n<li>文件创建成功，查看Xcode左侧导航列表，发现多了一个名为Localizable.strings的文件，如下图：</li>\n</ul>\n<p>Snip20160619_4.png</p>\n<ul>\n<li>选中Localizable.strings文件，在Xcode的File inspection中点击Localize，目的是选择我们需要本地化的语言（和本地化App名称同理），如下图：</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1055199-c2378ac118e3f496.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"img\"></p>\n<ul>\n<li>依次选择English-&gt;Localize，如下图：</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1055199-0aba0931daecd274.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"img\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1055199-015545406751fd42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"img\"></p>\n<ul>\n<li>然后我们发现Xcode右侧的File inspection变成了下图的样式：</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1055199-581527c3c2149e22.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"img\"></p>\n<ul>\n<li>然后勾选French、Chinese（zh-Hans）、Chinese（zh-Hant）、Korean，如下图：</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1055199-154a9e311e6a8033.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"img\"></p>\n<ul>\n<li>此时，Xcode左侧的Localizable.stirings左侧多了一个箭头，展开后，如下图所示：</li>\n</ul>\n<p>Snip20160619_6.png</p>\n<ul>\n<li>然后我们只需要在Localizable.strings下对应的文件中，分别以Key-Value的形式，为代码中每一个需要本地化的字符串赋值，如下图：</li>\n</ul>\n<p>Snip20160619_9.png</p>\n<p>Snip20160619_10.png</p>\n<p>Snip20160619_12.png</p>\n<p>Snip20160619_13.png</p>\n<p>Snip20160619_14.png</p>\n<ul>\n<li>本地化代码中的字符串，如下图：</li>\n</ul>\n<p>Snip20160619_15.png</p>\n<ul>\n<li>我们只需要使用Foundation框架自带的NSLocalizedString(key, comment)这个宏根据Key获取对应的字符串，然后赋值给代码中的字符串。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">// NSLocalizedString(key, comment) 本质</div><div class=\"line\">// NSlocalizeString 第一个参数是内容,根据第一个参数去对应语言的文件中取对应的字符串，第二个参数将会转化为字符串文件里的注释，可以传nil，也可以传空字符串@&quot;&quot;。</div><div class=\"line\">#define NSLocalizedString(key, comment) [[NSBundle mainBundle] localizedStringForKey:(key) value:@&quot;&quot; table:nil]</div></pre></td></tr></table></figure>\n<ul>\n<li>不同语言环境下运行效果，如下图：</li>\n<li>英语环境下：</li>\n</ul>\n<p>Snip20160619_17.png</p>\n<ul>\n<li>法语环境下：</li>\n</ul>\n<p>Snip20160619_18.png</p>\n<ul>\n<li>简体中文环境下：</li>\n</ul>\n<p>Snip20160619_19.png</p>\n<ul>\n<li>繁体中文环境下：</li>\n</ul>\n<p>Snip20160619_20.png</p>\n<ul>\n<li>韩语环境下：</li>\n</ul>\n<p>Snip20160619_23.png</p>\n<p>如此一来，我们就实现了代码中字符串的本地化。</p>\n<h3 id=\"技巧\"><a href=\"#技巧\" class=\"headerlink\" title=\"技巧\"></a>技巧</h3><ul>\n<li>其实，我们不需要给Localizable.strings(English)文件添加Key-Value。原因如下：系统根据某个key去获取对应的字符串时，如果没有找到，那么就会以key作为value返回。所以如果我们在Localizable.strings(English)文件中没有添加 click = “hit”;那么在english环境下btn最终显示的title会是click.</li>\n<li>切换语言无需在模拟器中设置，只需要在Xcode中进行如下设置： Edit-&gt;Scheme-&gt;Run-&gt;Arguments Passed On Launch -&gt;-AppleLanguages (语言代码)。例如，我们模拟器此时虽然是韩语，如果通过上述步骤设置为zh-Hans，那么语言环境将会变为汉语，如下图：</li>\n</ul>\n<p>Snip20160619_26.png</p>\n<p>Snip20160619_28.png</p>\n<ul>\n<li>运行效果：</li>\n</ul>\n<p>Snip20160619_29.png</p>\n<ul>\n<li>如此一来，切换语言变得更加简单，无需在模拟器的设置中进行繁琐的语言切换。</li>\n</ul>\n<h1 id=\"（三）多人开发情况下的字符串本地化\"><a href=\"#（三）多人开发情况下的字符串本地化\" class=\"headerlink\" title=\"（三）多人开发情况下的字符串本地化\"></a>（三）多人开发情况下的字符串本地化</h1><p>项目开发中，独立开发的还是少数。经常会有多人开发的情况，这种情况，如果多人同时操作本地化文件，极有可能会存在冲突。另一方面，我们又不希望自己的本地化文件受到对方的污染，也就是说，我们不希望对方操作我们的本地化文件。但是上面介绍的代码中字符串的本地化是使用的是默认的文件名”Localizable”,因为启动程序时，系统将根据语言加载相应的文件得到其对应的字符串文件，这个字符串可以通过系统将NSLocalizedString中的宏生成名为“Localizable.strings”的文件。那么如何让系统加载我们自己命名的本地化文件而非系统默认的Localizable.strings呢？这就是 NSLocalizedStringFromTable(&lt;#key#&gt;, &lt;#tbl#&gt;, &lt;#comment#&gt;)的用处。<br>也就是说，如果你的strings文件名字不是Localizable而是自定义的话，如VVS.strings，那么你就得使用NSLocalizedStringFromTable这个宏来读取本地化字符串。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">// key：系统根据key取字符串</div><div class=\"line\">// tbl：自定义strings文件的名字</div><div class=\"line\">// comment：可以不传</div><div class=\"line\">    NSLocalizedStringFromTable(&lt;#key#&gt;, &lt;#tbl#&gt;, &lt;#comment#&gt;)</div></pre></td></tr></table></figure>\n<p>Snip20160619_32.png</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &quot;ViewController.h&quot;</div><div class=\"line\"></div><div class=\"line\">@interface ViewController ()</div><div class=\"line\">@property (weak, nonatomic) IBOutlet UIButton *btn;</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation ViewController</div><div class=\"line\"></div><div class=\"line\">- (void)viewDidLoad &#123;</div><div class=\"line\">    [super viewDidLoad];</div><div class=\"line\"></div><div class=\"line\">    NSString *title = NSLocalizedStringFromTable(@&quot;click&quot;, @&quot;VVS&quot;, nil);</div><div class=\"line\">    [self.btn setTitle:title forState:UIControlStateNormal];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<ul>\n<li>运行效果，如下图：</li>\n</ul>\n<p>Snip20160619_33.png</p>\n<p>如此一来，我们就可以挣脱别人的strings文件和系统默认的Localizable.strings文件，自己另起炉灶。</p>\n<h1 id=\"（四）图片本地化\"><a href=\"#（四）图片本地化\" class=\"headerlink\" title=\"（四）图片本地化\"></a>（四）图片本地化</h1><p>本地化图片，有两种方式，第一种方式和本地化代码中的字符串一样，通过NSLocalizedString(key,comment)来获取相应的字符串，然后根据这个字符串再获取图片。</p>\n<h2 id=\"方式一\"><a href=\"#方式一\" class=\"headerlink\" title=\"方式一\"></a>方式一</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">NSString *imageName = NSLocalizedString(@&quot;icon&quot;, nil);</div><div class=\"line\">UIImage *image = [UIImage imageNamed:imageName];</div><div class=\"line\">self.imageView.image = image;</div></pre></td></tr></table></figure>\n<h2 id=\"方式二\"><a href=\"#方式二\" class=\"headerlink\" title=\"方式二\"></a>方式二</h2><p>首先需要添加需要本地化的语言，具体步骤参考第一章<strong>配置需要国际化的语言</strong>。因为我演示的demo中在本地化App名称时已经添加了需要国际化的语言。所以不需要再设置。</p>\n<ul>\n<li>将图片拖入工程中，例如“icon.png”，然后选中icon.png，展开Xcode右侧的file Inspection，点击Localize，如下图:</li>\n</ul>\n<p>Snip20160619_36.png</p>\n<ul>\n<li>然后，右击icon.png-&gt;show in Finder，我们发现在en.Iproj文件中多了一个名为icon.png的图片，如下图：</li>\n</ul>\n<p>Snip20160619_38.png</p>\n<ul>\n<li>当然，zh-Hans.Iproj文件夹下并没有图片，如下图：</li>\n</ul>\n<p>Snip20160619_39.png</p>\n<ul>\n<li>我们只需给zh-Hans.Iproj添加一个名字也为icon.png的图片。如下图：</li>\n</ul>\n<p>Snip20160619_40.png</p>\n<ul>\n<li>然后把zh-Hans.Iproj中的icon.png拖到Xcode中，如下图：</li>\n</ul>\n<p>Snip20160619_43.png</p>\n<ul>\n<li>然后发现，icon.png左边出现了一个可以展开的三角形。如下图：</li>\n</ul>\n<p>Snip20160619_44.png</p>\n<ul>\n<li>展开后发现里面包含两张图片，如下图：</li>\n</ul>\n<p>Snip20160619_45.png</p>\n<p>然后控制器中添加如下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &quot;ViewController.h&quot;</div><div class=\"line\"></div><div class=\"line\">@interface ViewController ()</div><div class=\"line\">@property (weak, nonatomic) IBOutlet UIImageView *imageView;</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation ViewController</div><div class=\"line\"></div><div class=\"line\">- (void)viewDidLoad &#123;</div><div class=\"line\">    [super viewDidLoad];</div><div class=\"line\"></div><div class=\"line\">    NSString *imageName = NSLocalizedString(@&quot;icon&quot;, nil);</div><div class=\"line\">    UIImage *image = [UIImage imageNamed:imageName];</div><div class=\"line\">    self.imageView.image = image;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<ul>\n<li>english环境下运行效果如下：</li>\n</ul>\n<p>Snip20160620_46.png</p>\n<ul>\n<li>中文环境改下运行效果如下：</li>\n</ul>\n<p>Snip20160620_47.png</p>\n<ul>\n<li>其他语言环境，例如法语、中文繁体、韩语，操作步骤完全和上面相同。都是在对应的.Iproj文件夹下添加同名的图片，然后把图片拖放到Xcode中，不再赘述。</li>\n</ul>\n<h1 id=\"（五）查看-切换本地语言\"><a href=\"#（五）查看-切换本地语言\" class=\"headerlink\" title=\"（五）查看/切换本地语言\"></a>（五）查看/切换本地语言</h1><p>原理：应用启动时，首先会读取NSUserDefaults中的key为AppleLanguages对应的value，该value是一个String数组，也就是说，我们访问这个名为AppleLanguages的key可以返回一个string数组，该数组存储着APP支持的语言列表，数组的第一项为APP当前默认的语言。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &quot;ViewController.h&quot;</div><div class=\"line\"></div><div class=\"line\">@interface ViewController ()</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation ViewController</div><div class=\"line\"></div><div class=\"line\">- (void)viewDidLoad &#123;</div><div class=\"line\">    [super viewDidLoad];</div><div class=\"line\"></div><div class=\"line\">    NSArray *languages = [[NSUserDefaults standardUserDefaults] valueForKey:@&quot;AppleLanguages&quot;];</div><div class=\"line\">    NSString *currentLanguage = languages.firstObject;</div><div class=\"line\">    NSLog(@&quot;模拟器当前语言：%@&quot;,currentLanguage);</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>-控制台打印结果：</p>\n<p>Snip20160620_1.png</p>\n<p>同理，既然我们可以通过AppleLanguages这个key从NSUserDefaults中取出语言数组，那么我们也可以给AppleLanguages这个key赋值来达到切换本地语言的效果，从此以后，我们就无需频繁的去模拟器的设置-&gt;通用-&gt;语言与地区 中切换语言。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &quot;ViewController.h&quot;</div><div class=\"line\"></div><div class=\"line\">@interface ViewController ()</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation ViewController</div><div class=\"line\"></div><div class=\"line\">- (void)viewDidLoad &#123;</div><div class=\"line\">    [super viewDidLoad];</div><div class=\"line\"></div><div class=\"line\">    // 切换语言前</div><div class=\"line\">    NSArray *langArr1 = [[NSUserDefaults standardUserDefaults] valueForKey:@&quot;AppleLanguages&quot;];</div><div class=\"line\">    NSString *language1 = langArr1.firstObject;</div><div class=\"line\">    NSLog(@&quot;模拟器语言切换之前：%@&quot;,language1);</div><div class=\"line\"></div><div class=\"line\">    // 切换语言</div><div class=\"line\">    NSArray *lans = @[@&quot;en&quot;];</div><div class=\"line\">    [[NSUserDefaults standardUserDefaults] setObject:lans forKey:@&quot;AppleLanguages&quot;];</div><div class=\"line\"></div><div class=\"line\">    // 切换语言后</div><div class=\"line\">    NSArray *langArr2 = [[NSUserDefaults standardUserDefaults] valueForKey:@&quot;AppleLanguages&quot;];</div><div class=\"line\">    NSString *language2 = langArr2.firstObject;</div><div class=\"line\">    NSLog(@&quot;模拟器语言切换之后：%@&quot;,language2);</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>Snip20160620_2.png</p>\n<ul>\n<li>回想一下，我在上面的<strong>技巧</strong>一节中提过：切换语言无需在模拟器中设置，只需要在Xcode中进行如下设置： Edit-&gt;Scheme-&gt;Run-&gt;Arguments Passed On Launch -&gt;-AppleLanguages (语言代码)。其实本质上就是给NSUserDefaults中名为AppleLanguages的key赋值。</li>\n</ul>\n"},{"title":"响应者链条传递事件","id":"37","updated":"2016-09-12T05:16:19.000Z","date":"2016-09-12T05:15:11.000Z","_content":"\n\n\n开篇先说点废话吧，最近整个人都很烦躁，也许跟天气有关吧，也很久没有静下来写一些东西了，最近也一直忙着新项目，也很纠接新项目应该采用什么样的结构去写才好迭代、维护。最终按自己的一写想法采用了Controller View ViewHander的模式（有点类似MVVM），因为这个Demo按照这个想法来写的所以这里简单说下，就不过多的讨论这个了，回到主题上UIResponder来，没有说之前我们先看一个图我们开发中经常遇到的：\n\n![](http://ww2.sinaimg.cn/large/65e4f1e6gw1f7qq6xkecej20af0ik75x.jpg)\n\n很简单就是在UITableViewCell 放了一个UIButton 那我们怎么样接收这个Button的点击事件? 你第一时间可能会想到Delegate,Block？的确它们都可以实现我们的需求，Delegate我们要多写点代码，Block 如果我们的事件逻辑复杂点就会再赋值时写很多代码，当然你可以用一个简单的Block把处理的业务代封装成方法，再这个调用这方法，也可以把代码弄的简洁点，最重要我一定要考虑**循环引用**的问题。那我们能不能用UIResponder 传递这个事件呢，在我们想要的地方捕获这个事件呢? 我们先来看看iOS 事件是怎么传递的我们看个图：\n\n<!------MORE------->\n\n![](http://ww4.sinaimg.cn/large/65e4f1e6gw1f7qq6j34v9j20eu04g0st.jpg)\n\n如上图，iOS中事件传递首先从App(UIApplication)开始，接着传递到Window(UIWindow)，在接着往下传递到View之前，Window会将事件交给GestureRecognizer，如果在此期间，GestureRecognizer识别了传递过来的事件，则该事件将不会继续传递到View去，而是像我们之前说的那样交给Target(ViewController)进行处理。（注：详细原理可以自己进行搜索学习）我们大致知道事件产生最先识别是的 AppDelegate，然后一层层往下找看事件发生那个view上，直到找个这个view,然后看个view 能不能响应这个事件。那我们现在再说说响应者链先看个张图：\n\n![](http://ww1.sinaimg.cn/large/65e4f1e6gw1f7qq6ipf1hj20jy09t75c.jpg)\n\n我知道了当事触摸事件发生，通过一层层找到的这个View ,找到这个View 后先判断这个view能不能响应这个事件，如果不能那就继续找nextResponder我们看上面图可以看出如果一个View有SuperView 那么这个View的nextResponder 就是他的SuperView，如果没有SuperView 那么它的nextResponder 就是他所在ViewController 然后就这样一直找下去，直到找到或抛出异常。\n我们了解这机制后那我们怎么把这个UIButton Click 事件传递出来呢，我们先来给UIResponder 添加一个我们自定义的事件，我就让它传递我们这个事件出去。\n\n```\n#import \"UIResponder+Router.h\"\n\n@implementation UIResponder (Router)\n // eventName 只是作个标记，当我们需要在一个页面传递个事件时我们可以进区分，userInfo 为了省劲就没有封装，你可以针对性再封装下\n- (void)routerEventWithName:(NSString *)eventName userInfo:(NSDictionary *)userInfo {\n      [[self nextResponder] routerEventWithName:eventName userInfo:userInfo];\n }\n @end\n```\n\n那我们怎么进行传递呢，那就是我们手动的去让响应者链传递这个事件\n我们先看下工程的代码文件：\n**View**\n\n```\n#import \"TestView.h\"\n#import \"TestViewTableDataSource.h\"\n\n@implementation TestView {\n    UITableView *_tableView;\n}\n\n - (instancetype)initWithController:(SBBaseViewController *)controller {\n   self = [super initWithController:controller];\n   if (self) {\n    [self setup];\n    }\n     return self;\n }\n\n - (void)setup {\n\n    _tableView = [[UITableView alloc] initWithFrame:CGRectZero style:UITableViewStylePlain];\n    _tableView.delegate = self;\n    _tableView.rowHeight = 60;\n    _tableView.translatesAutoresizingMaskIntoConstraints = NO;\n    [_tableView registerClass:[TestViewTableCell class] forCellReuseIdentifier:@\"cell\"];\n    [self addSubview:_tableView];\n    [self addConstraints:[NSLayoutConstraint constraintsWithVisualFormat:@\"H:|-0-[_tableView]-0-|\" options:0 metrics:nil views:NSDictionaryOfVariableBindings(_tableView)]];\n    [self addConstraints:[NSLayoutConstraint constraintsWithVisualFormat:@\"V:|-0-[_tableView]-0-|\" options:0 metrics:nil views:NSDictionaryOfVariableBindings(_tableView)]];\n```\n\n}\n\n```\n- (void)setHandler:(SBBaseHandler *)handler {\n    [super setHandler:handler];\n    // 把tableViewDataSource 分离出去\n    TestViewTableDataSource *tableViewDataSoure = [[TestViewTableDataSource alloc] initWithTableView:_tableView];\n\n    _tableView.dataSource = tableViewDataSoure;\n    self.handler.tableDataSource = tableViewDataSoure;\n}\n\n- (void)didLoad {\n    [self.handler loadData];\n}\n```\n\n**Controller**\n\n```\n#import \"TestViewController.h\"\n#import \"TestView.h\"\n#import \"TestViewHandler.h\"\n\n@interface TestViewController ()\n\n@end\n\n@implementation TestViewController\n\n- (void)loadView {\n    [super loadView];\n    TestView *view = [[TestView alloc]initWithController:self];\n    TestViewHandler *handler = [[TestViewHandler alloc] init];\n    view.handler = handler;\n    self.view = view;\n}\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    // Do any additional setup after loading the view.\n    self.title = @\"UIResponderEx\";\n}\n\n- (void)didReceiveMemoryWarning {\n    [super didReceiveMemoryWarning];\n    // Dispose of any resources that can be recreated.\n }\n@end\n```\n\n**Handler**\n\n```\n#import \"TestViewHandler.h\"\n\n@implementation TestViewHandler\n\n- (void)loadData {\n    NSMutableArray *datasource = [NSMutableArray arrayWithCapacity:10];\n    for (int i = 0; i< 10; ++i) {\n        [datasource addObject:[NSString stringWithFormat:@\"Row number is %d\",i]];\n    }\n    self.tableDataSource.dataSouce = [datasource copy];\n}\n\n@end\n```\n\n**TableDataSource**\n\n```\n#import \"SBBaseTableDataSource.h\"\n\n@interface TestViewTableDataSource : SBBaseTableDataSource\n\n@end\n// 这里为了省劲就没有用单独文件去写，最好还是建两个新文件去比较好\n@interface TestViewTableCell : UITableViewCell\n\n@end\n```\n\n------\n\n```\n#import \"TestViewTableDataSource.h\"\n#import \"UIResponder+Router.h\"\n\n@implementation TestViewTableDataSource\n\n- (id)initWithTableView:(UITableView *)tableView {\n    self = [super initWithTableView:tableView];\n    if (self) {\n\n    }\n\n    return self;\n}\n\n  - (void)setDataSouce:(NSArray *)dataSouce {\n    [super setDataSouce:dataSouce];\n    [self.tableView reloadData];\n}\n\n- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView {\n\n    return 1;\n\n}\n\n- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section {\n\n    return self.dataSouce.count;\n}\n\n- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath {\n    TestViewTableCell *cell = [tableView dequeueReusableCellWithIdentifier:@\"cell\"];\n    cell.textLabel.text = self.dataSouce[indexPath.row];\n\n    return cell;\n}\n\n@end\n\n@implementation TestViewTableCell\n\n- (instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier {\n    self = [super initWithStyle:style reuseIdentifier:reuseIdentifier];\n    if (self) {\n       [self setup];\n    }\n    return self;\n}\n\n- (void)setup {\n    UIButton *showNumberButton = [UIButton buttonWithType:UIButtonTypeCustom];\n    [showNumberButton setTitle:@\"Show row number\" forState:UIControlStateNormal];\n    showNumberButton.backgroundColor = [UIColor purpleColor];\n    showNumberButton.layer.cornerRadius = 4;\n    showNumberButton.layer.masksToBounds = YES;\n    showNumberButton.translatesAutoresizingMaskIntoConstraints = NO;\n   [showNumberButton addTarget:self action:@selector(showNumberButtonClick:) forControlEvents:UIControlEventTouchUpInside];\n    [self.contentView addSubview:showNumberButton];\n\n    [self.contentView addConstraints:[NSLayoutConstraint constraintsWithVisualFormat:@\"H:[showNumberButton(180)]-20-|\" options:0 metrics:nil views:NSDictionaryOfVariableBindings(showNumberButton)]];\n    [self.contentView addConstraint:[NSLayoutConstraint constraintWithItem:showNumberButton attribute:NSLayoutAttributeCenterY relatedBy:NSLayoutRelationEqual toItem:self.contentView attribute:NSLayoutAttributeCenterY multiplier:1.0 constant:0]];\n}\n   //关键代码就在这里, 我们在button click 事件中我再让传递一个事件给响应者链，让响应者链传出去\n- (void)showNumberButtonClick:(id)sender {\n    // 我们在这个Click事件中去手动让响应者传递一个事件\n    [self.nextResponder routerEventWithName:@\"showNumber\" userInfo:@{@\"object\":self.textLabel.text}];\n}\n@end\n```\n\n主要的代码差不多就是这些了，至于他们的基类都是自己封装好一部分，还不怎么完善都是一些自己的想法。就不贴代码稍后把这个Demo放出来。有兴趣的可以下下来看看，如果有我好的想法请联系我：[lsb332@163.com](mailto:lsb332@163.com)\n我们先来看看在View 中捕获下事件，在.m 文件我们导入UIResponder+Router.h头文件 然后实现我们自定义的方法\n\n```\n#import \"UIResponder+Router.h\"\n#pragma UIResponder(Router)\n- (void)routerEventWithName:(NSString *)eventName userInfo:(NSDictionary *)userInfo {\n   UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:@\"View中捕获\" message:userInfo[@\"object\"] delegate:nil cancelButtonTitle:@\"OK\" otherButtonTitles: nil];\n   [alertView show];\n}\n```\n\n** 手动传递事件的代码TableDataSource 已经贴出来过了这里就不贴了**\n我们看下结果：\n\n![](http://ww2.sinaimg.cn/large/65e4f1e6gw1f7qq7f1kxyj20af0ih3zq.jpg)\n\n我们再来看看在UIViewController 捕获，代码就不贴了看下结果好了:\n\n![](http://ww1.sinaimg.cn/large/65e4f1e6gw1f7qq7rh5foj20af0ij75k.jpg)\n\n## 总结\n\n**最重要的思想就是在响应事件方法我们再主动的传递给响应者链一个事件，然后我们合适的地方去响应这个事件**\n这个也是抛砖引玉的，自己理解的还很肤浅的，现在写出来也算是自己学习的一个笔记吧，这个处理方法也是自己在集成环信中发现的，自己去摸索学习下。\nDemo地址 [https://github.com/lsb332/UIResponderEX](https://github.com/lsb332/UIResponderEX)\n在这里再说一下自己项目结构，为了减轻UIViewController 重量实行真正的MVC 把View分出来了，从而使ViewController 只负责view 的显示 ，称除等。因为我们项目经常会用到TableView 为了不使View太重再次把这个分离去，使TableView的dataSource 在TableViewSource文件中去实现，然后又给View 建了一个Handler  用来处理业务逻辑，网络请求等，然后又把handler 继承一个网络求的类，这样可就可以处理的网络的请求了，如果handler 处理完数据后可以通过Block 回调给View 或者直接把数据传递给TableViewSource 就可以直接刷新数据，不用再回调给View。这里只是简单的说一下，有兴趣的可以工程里看看，还处在起步结段，如果觉得成熟了再写一篇文章说说吧。\n\n文／lsb332（简书作者）\n原文链接：http://www.jianshu.com/p/8fef9171c322\n\n","source":"_posts/响应者链条传递事件.md","raw":"---\ntitle: 响应者链条传递事件\ntags: '转载'\npermalink: xiang-ying-zhe-lian-tiao-chuan-di-shi-jian\nid: 37\nupdated: '2016-09-12 13:16:19'\ndate: 2016-09-12 13:15:11\n---\n\n\n\n开篇先说点废话吧，最近整个人都很烦躁，也许跟天气有关吧，也很久没有静下来写一些东西了，最近也一直忙着新项目，也很纠接新项目应该采用什么样的结构去写才好迭代、维护。最终按自己的一写想法采用了Controller View ViewHander的模式（有点类似MVVM），因为这个Demo按照这个想法来写的所以这里简单说下，就不过多的讨论这个了，回到主题上UIResponder来，没有说之前我们先看一个图我们开发中经常遇到的：\n\n![](http://ww2.sinaimg.cn/large/65e4f1e6gw1f7qq6xkecej20af0ik75x.jpg)\n\n很简单就是在UITableViewCell 放了一个UIButton 那我们怎么样接收这个Button的点击事件? 你第一时间可能会想到Delegate,Block？的确它们都可以实现我们的需求，Delegate我们要多写点代码，Block 如果我们的事件逻辑复杂点就会再赋值时写很多代码，当然你可以用一个简单的Block把处理的业务代封装成方法，再这个调用这方法，也可以把代码弄的简洁点，最重要我一定要考虑**循环引用**的问题。那我们能不能用UIResponder 传递这个事件呢，在我们想要的地方捕获这个事件呢? 我们先来看看iOS 事件是怎么传递的我们看个图：\n\n<!------MORE------->\n\n![](http://ww4.sinaimg.cn/large/65e4f1e6gw1f7qq6j34v9j20eu04g0st.jpg)\n\n如上图，iOS中事件传递首先从App(UIApplication)开始，接着传递到Window(UIWindow)，在接着往下传递到View之前，Window会将事件交给GestureRecognizer，如果在此期间，GestureRecognizer识别了传递过来的事件，则该事件将不会继续传递到View去，而是像我们之前说的那样交给Target(ViewController)进行处理。（注：详细原理可以自己进行搜索学习）我们大致知道事件产生最先识别是的 AppDelegate，然后一层层往下找看事件发生那个view上，直到找个这个view,然后看个view 能不能响应这个事件。那我们现在再说说响应者链先看个张图：\n\n![](http://ww1.sinaimg.cn/large/65e4f1e6gw1f7qq6ipf1hj20jy09t75c.jpg)\n\n我知道了当事触摸事件发生，通过一层层找到的这个View ,找到这个View 后先判断这个view能不能响应这个事件，如果不能那就继续找nextResponder我们看上面图可以看出如果一个View有SuperView 那么这个View的nextResponder 就是他的SuperView，如果没有SuperView 那么它的nextResponder 就是他所在ViewController 然后就这样一直找下去，直到找到或抛出异常。\n我们了解这机制后那我们怎么把这个UIButton Click 事件传递出来呢，我们先来给UIResponder 添加一个我们自定义的事件，我就让它传递我们这个事件出去。\n\n```\n#import \"UIResponder+Router.h\"\n\n@implementation UIResponder (Router)\n // eventName 只是作个标记，当我们需要在一个页面传递个事件时我们可以进区分，userInfo 为了省劲就没有封装，你可以针对性再封装下\n- (void)routerEventWithName:(NSString *)eventName userInfo:(NSDictionary *)userInfo {\n      [[self nextResponder] routerEventWithName:eventName userInfo:userInfo];\n }\n @end\n```\n\n那我们怎么进行传递呢，那就是我们手动的去让响应者链传递这个事件\n我们先看下工程的代码文件：\n**View**\n\n```\n#import \"TestView.h\"\n#import \"TestViewTableDataSource.h\"\n\n@implementation TestView {\n    UITableView *_tableView;\n}\n\n - (instancetype)initWithController:(SBBaseViewController *)controller {\n   self = [super initWithController:controller];\n   if (self) {\n    [self setup];\n    }\n     return self;\n }\n\n - (void)setup {\n\n    _tableView = [[UITableView alloc] initWithFrame:CGRectZero style:UITableViewStylePlain];\n    _tableView.delegate = self;\n    _tableView.rowHeight = 60;\n    _tableView.translatesAutoresizingMaskIntoConstraints = NO;\n    [_tableView registerClass:[TestViewTableCell class] forCellReuseIdentifier:@\"cell\"];\n    [self addSubview:_tableView];\n    [self addConstraints:[NSLayoutConstraint constraintsWithVisualFormat:@\"H:|-0-[_tableView]-0-|\" options:0 metrics:nil views:NSDictionaryOfVariableBindings(_tableView)]];\n    [self addConstraints:[NSLayoutConstraint constraintsWithVisualFormat:@\"V:|-0-[_tableView]-0-|\" options:0 metrics:nil views:NSDictionaryOfVariableBindings(_tableView)]];\n```\n\n}\n\n```\n- (void)setHandler:(SBBaseHandler *)handler {\n    [super setHandler:handler];\n    // 把tableViewDataSource 分离出去\n    TestViewTableDataSource *tableViewDataSoure = [[TestViewTableDataSource alloc] initWithTableView:_tableView];\n\n    _tableView.dataSource = tableViewDataSoure;\n    self.handler.tableDataSource = tableViewDataSoure;\n}\n\n- (void)didLoad {\n    [self.handler loadData];\n}\n```\n\n**Controller**\n\n```\n#import \"TestViewController.h\"\n#import \"TestView.h\"\n#import \"TestViewHandler.h\"\n\n@interface TestViewController ()\n\n@end\n\n@implementation TestViewController\n\n- (void)loadView {\n    [super loadView];\n    TestView *view = [[TestView alloc]initWithController:self];\n    TestViewHandler *handler = [[TestViewHandler alloc] init];\n    view.handler = handler;\n    self.view = view;\n}\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    // Do any additional setup after loading the view.\n    self.title = @\"UIResponderEx\";\n}\n\n- (void)didReceiveMemoryWarning {\n    [super didReceiveMemoryWarning];\n    // Dispose of any resources that can be recreated.\n }\n@end\n```\n\n**Handler**\n\n```\n#import \"TestViewHandler.h\"\n\n@implementation TestViewHandler\n\n- (void)loadData {\n    NSMutableArray *datasource = [NSMutableArray arrayWithCapacity:10];\n    for (int i = 0; i< 10; ++i) {\n        [datasource addObject:[NSString stringWithFormat:@\"Row number is %d\",i]];\n    }\n    self.tableDataSource.dataSouce = [datasource copy];\n}\n\n@end\n```\n\n**TableDataSource**\n\n```\n#import \"SBBaseTableDataSource.h\"\n\n@interface TestViewTableDataSource : SBBaseTableDataSource\n\n@end\n// 这里为了省劲就没有用单独文件去写，最好还是建两个新文件去比较好\n@interface TestViewTableCell : UITableViewCell\n\n@end\n```\n\n------\n\n```\n#import \"TestViewTableDataSource.h\"\n#import \"UIResponder+Router.h\"\n\n@implementation TestViewTableDataSource\n\n- (id)initWithTableView:(UITableView *)tableView {\n    self = [super initWithTableView:tableView];\n    if (self) {\n\n    }\n\n    return self;\n}\n\n  - (void)setDataSouce:(NSArray *)dataSouce {\n    [super setDataSouce:dataSouce];\n    [self.tableView reloadData];\n}\n\n- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView {\n\n    return 1;\n\n}\n\n- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section {\n\n    return self.dataSouce.count;\n}\n\n- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath {\n    TestViewTableCell *cell = [tableView dequeueReusableCellWithIdentifier:@\"cell\"];\n    cell.textLabel.text = self.dataSouce[indexPath.row];\n\n    return cell;\n}\n\n@end\n\n@implementation TestViewTableCell\n\n- (instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier {\n    self = [super initWithStyle:style reuseIdentifier:reuseIdentifier];\n    if (self) {\n       [self setup];\n    }\n    return self;\n}\n\n- (void)setup {\n    UIButton *showNumberButton = [UIButton buttonWithType:UIButtonTypeCustom];\n    [showNumberButton setTitle:@\"Show row number\" forState:UIControlStateNormal];\n    showNumberButton.backgroundColor = [UIColor purpleColor];\n    showNumberButton.layer.cornerRadius = 4;\n    showNumberButton.layer.masksToBounds = YES;\n    showNumberButton.translatesAutoresizingMaskIntoConstraints = NO;\n   [showNumberButton addTarget:self action:@selector(showNumberButtonClick:) forControlEvents:UIControlEventTouchUpInside];\n    [self.contentView addSubview:showNumberButton];\n\n    [self.contentView addConstraints:[NSLayoutConstraint constraintsWithVisualFormat:@\"H:[showNumberButton(180)]-20-|\" options:0 metrics:nil views:NSDictionaryOfVariableBindings(showNumberButton)]];\n    [self.contentView addConstraint:[NSLayoutConstraint constraintWithItem:showNumberButton attribute:NSLayoutAttributeCenterY relatedBy:NSLayoutRelationEqual toItem:self.contentView attribute:NSLayoutAttributeCenterY multiplier:1.0 constant:0]];\n}\n   //关键代码就在这里, 我们在button click 事件中我再让传递一个事件给响应者链，让响应者链传出去\n- (void)showNumberButtonClick:(id)sender {\n    // 我们在这个Click事件中去手动让响应者传递一个事件\n    [self.nextResponder routerEventWithName:@\"showNumber\" userInfo:@{@\"object\":self.textLabel.text}];\n}\n@end\n```\n\n主要的代码差不多就是这些了，至于他们的基类都是自己封装好一部分，还不怎么完善都是一些自己的想法。就不贴代码稍后把这个Demo放出来。有兴趣的可以下下来看看，如果有我好的想法请联系我：[lsb332@163.com](mailto:lsb332@163.com)\n我们先来看看在View 中捕获下事件，在.m 文件我们导入UIResponder+Router.h头文件 然后实现我们自定义的方法\n\n```\n#import \"UIResponder+Router.h\"\n#pragma UIResponder(Router)\n- (void)routerEventWithName:(NSString *)eventName userInfo:(NSDictionary *)userInfo {\n   UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:@\"View中捕获\" message:userInfo[@\"object\"] delegate:nil cancelButtonTitle:@\"OK\" otherButtonTitles: nil];\n   [alertView show];\n}\n```\n\n** 手动传递事件的代码TableDataSource 已经贴出来过了这里就不贴了**\n我们看下结果：\n\n![](http://ww2.sinaimg.cn/large/65e4f1e6gw1f7qq7f1kxyj20af0ih3zq.jpg)\n\n我们再来看看在UIViewController 捕获，代码就不贴了看下结果好了:\n\n![](http://ww1.sinaimg.cn/large/65e4f1e6gw1f7qq7rh5foj20af0ij75k.jpg)\n\n## 总结\n\n**最重要的思想就是在响应事件方法我们再主动的传递给响应者链一个事件，然后我们合适的地方去响应这个事件**\n这个也是抛砖引玉的，自己理解的还很肤浅的，现在写出来也算是自己学习的一个笔记吧，这个处理方法也是自己在集成环信中发现的，自己去摸索学习下。\nDemo地址 [https://github.com/lsb332/UIResponderEX](https://github.com/lsb332/UIResponderEX)\n在这里再说一下自己项目结构，为了减轻UIViewController 重量实行真正的MVC 把View分出来了，从而使ViewController 只负责view 的显示 ，称除等。因为我们项目经常会用到TableView 为了不使View太重再次把这个分离去，使TableView的dataSource 在TableViewSource文件中去实现，然后又给View 建了一个Handler  用来处理业务逻辑，网络请求等，然后又把handler 继承一个网络求的类，这样可就可以处理的网络的请求了，如果handler 处理完数据后可以通过Block 回调给View 或者直接把数据传递给TableViewSource 就可以直接刷新数据，不用再回调给View。这里只是简单的说一下，有兴趣的可以工程里看看，还处在起步结段，如果觉得成熟了再写一篇文章说说吧。\n\n文／lsb332（简书作者）\n原文链接：http://www.jianshu.com/p/8fef9171c322\n\n","slug":"xiang-ying-zhe-lian-tiao-chuan-di-shi-jian","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cj04pzyy90019s04egf8a9h2t","content":"<p>开篇先说点废话吧，最近整个人都很烦躁，也许跟天气有关吧，也很久没有静下来写一些东西了，最近也一直忙着新项目，也很纠接新项目应该采用什么样的结构去写才好迭代、维护。最终按自己的一写想法采用了Controller View ViewHander的模式（有点类似MVVM），因为这个Demo按照这个想法来写的所以这里简单说下，就不过多的讨论这个了，回到主题上UIResponder来，没有说之前我们先看一个图我们开发中经常遇到的：</p>\n<p><img src=\"http://ww2.sinaimg.cn/large/65e4f1e6gw1f7qq6xkecej20af0ik75x.jpg\" alt=\"\"></p>\n<p>很简单就是在UITableViewCell 放了一个UIButton 那我们怎么样接收这个Button的点击事件? 你第一时间可能会想到Delegate,Block？的确它们都可以实现我们的需求，Delegate我们要多写点代码，Block 如果我们的事件逻辑复杂点就会再赋值时写很多代码，当然你可以用一个简单的Block把处理的业务代封装成方法，再这个调用这方法，也可以把代码弄的简洁点，最重要我一定要考虑<strong>循环引用</strong>的问题。那我们能不能用UIResponder 传递这个事件呢，在我们想要的地方捕获这个事件呢? 我们先来看看iOS 事件是怎么传递的我们看个图：</p>\n<a id=\"more\"></a>\n<p><img src=\"http://ww4.sinaimg.cn/large/65e4f1e6gw1f7qq6j34v9j20eu04g0st.jpg\" alt=\"\"></p>\n<p>如上图，iOS中事件传递首先从App(UIApplication)开始，接着传递到Window(UIWindow)，在接着往下传递到View之前，Window会将事件交给GestureRecognizer，如果在此期间，GestureRecognizer识别了传递过来的事件，则该事件将不会继续传递到View去，而是像我们之前说的那样交给Target(ViewController)进行处理。（注：详细原理可以自己进行搜索学习）我们大致知道事件产生最先识别是的 AppDelegate，然后一层层往下找看事件发生那个view上，直到找个这个view,然后看个view 能不能响应这个事件。那我们现在再说说响应者链先看个张图：</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/65e4f1e6gw1f7qq6ipf1hj20jy09t75c.jpg\" alt=\"\"></p>\n<p>我知道了当事触摸事件发生，通过一层层找到的这个View ,找到这个View 后先判断这个view能不能响应这个事件，如果不能那就继续找nextResponder我们看上面图可以看出如果一个View有SuperView 那么这个View的nextResponder 就是他的SuperView，如果没有SuperView 那么它的nextResponder 就是他所在ViewController 然后就这样一直找下去，直到找到或抛出异常。<br>我们了解这机制后那我们怎么把这个UIButton Click 事件传递出来呢，我们先来给UIResponder 添加一个我们自定义的事件，我就让它传递我们这个事件出去。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &quot;UIResponder+Router.h&quot;</div><div class=\"line\"></div><div class=\"line\">@implementation UIResponder (Router)</div><div class=\"line\"> // eventName 只是作个标记，当我们需要在一个页面传递个事件时我们可以进区分，userInfo 为了省劲就没有封装，你可以针对性再封装下</div><div class=\"line\">- (void)routerEventWithName:(NSString *)eventName userInfo:(NSDictionary *)userInfo &#123;</div><div class=\"line\">      [[self nextResponder] routerEventWithName:eventName userInfo:userInfo];</div><div class=\"line\"> &#125;</div><div class=\"line\"> @end</div></pre></td></tr></table></figure>\n<p>那我们怎么进行传递呢，那就是我们手动的去让响应者链传递这个事件<br>我们先看下工程的代码文件：<br><strong>View</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &quot;TestView.h&quot;</div><div class=\"line\">#import &quot;TestViewTableDataSource.h&quot;</div><div class=\"line\"></div><div class=\"line\">@implementation TestView &#123;</div><div class=\"line\">    UITableView *_tableView;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"> - (instancetype)initWithController:(SBBaseViewController *)controller &#123;</div><div class=\"line\">   self = [super initWithController:controller];</div><div class=\"line\">   if (self) &#123;</div><div class=\"line\">    [self setup];</div><div class=\"line\">    &#125;</div><div class=\"line\">     return self;</div><div class=\"line\"> &#125;</div><div class=\"line\"></div><div class=\"line\"> - (void)setup &#123;</div><div class=\"line\"></div><div class=\"line\">    _tableView = [[UITableView alloc] initWithFrame:CGRectZero style:UITableViewStylePlain];</div><div class=\"line\">    _tableView.delegate = self;</div><div class=\"line\">    _tableView.rowHeight = 60;</div><div class=\"line\">    _tableView.translatesAutoresizingMaskIntoConstraints = NO;</div><div class=\"line\">    [_tableView registerClass:[TestViewTableCell class] forCellReuseIdentifier:@&quot;cell&quot;];</div><div class=\"line\">    [self addSubview:_tableView];</div><div class=\"line\">    [self addConstraints:[NSLayoutConstraint constraintsWithVisualFormat:@&quot;H:|-0-[_tableView]-0-|&quot; options:0 metrics:nil views:NSDictionaryOfVariableBindings(_tableView)]];</div><div class=\"line\">    [self addConstraints:[NSLayoutConstraint constraintsWithVisualFormat:@&quot;V:|-0-[_tableView]-0-|&quot; options:0 metrics:nil views:NSDictionaryOfVariableBindings(_tableView)]];</div></pre></td></tr></table></figure>\n<p>}</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)setHandler:(SBBaseHandler *)handler &#123;</div><div class=\"line\">    [super setHandler:handler];</div><div class=\"line\">    // 把tableViewDataSource 分离出去</div><div class=\"line\">    TestViewTableDataSource *tableViewDataSoure = [[TestViewTableDataSource alloc] initWithTableView:_tableView];</div><div class=\"line\"></div><div class=\"line\">    _tableView.dataSource = tableViewDataSoure;</div><div class=\"line\">    self.handler.tableDataSource = tableViewDataSoure;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)didLoad &#123;</div><div class=\"line\">    [self.handler loadData];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>Controller</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &quot;TestViewController.h&quot;</div><div class=\"line\">#import &quot;TestView.h&quot;</div><div class=\"line\">#import &quot;TestViewHandler.h&quot;</div><div class=\"line\"></div><div class=\"line\">@interface TestViewController ()</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation TestViewController</div><div class=\"line\"></div><div class=\"line\">- (void)loadView &#123;</div><div class=\"line\">    [super loadView];</div><div class=\"line\">    TestView *view = [[TestView alloc]initWithController:self];</div><div class=\"line\">    TestViewHandler *handler = [[TestViewHandler alloc] init];</div><div class=\"line\">    view.handler = handler;</div><div class=\"line\">    self.view = view;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)viewDidLoad &#123;</div><div class=\"line\">    [super viewDidLoad];</div><div class=\"line\">    // Do any additional setup after loading the view.</div><div class=\"line\">    self.title = @&quot;UIResponderEx&quot;;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)didReceiveMemoryWarning &#123;</div><div class=\"line\">    [super didReceiveMemoryWarning];</div><div class=\"line\">    // Dispose of any resources that can be recreated.</div><div class=\"line\"> &#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p><strong>Handler</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &quot;TestViewHandler.h&quot;</div><div class=\"line\"></div><div class=\"line\">@implementation TestViewHandler</div><div class=\"line\"></div><div class=\"line\">- (void)loadData &#123;</div><div class=\"line\">    NSMutableArray *datasource = [NSMutableArray arrayWithCapacity:10];</div><div class=\"line\">    for (int i = 0; i&lt; 10; ++i) &#123;</div><div class=\"line\">        [datasource addObject:[NSString stringWithFormat:@&quot;Row number is %d&quot;,i]];</div><div class=\"line\">    &#125;</div><div class=\"line\">    self.tableDataSource.dataSouce = [datasource copy];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p><strong>TableDataSource</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &quot;SBBaseTableDataSource.h&quot;</div><div class=\"line\"></div><div class=\"line\">@interface TestViewTableDataSource : SBBaseTableDataSource</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\">// 这里为了省劲就没有用单独文件去写，最好还是建两个新文件去比较好</div><div class=\"line\">@interface TestViewTableCell : UITableViewCell</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<hr>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &quot;TestViewTableDataSource.h&quot;</div><div class=\"line\">#import &quot;UIResponder+Router.h&quot;</div><div class=\"line\"></div><div class=\"line\">@implementation TestViewTableDataSource</div><div class=\"line\"></div><div class=\"line\">- (id)initWithTableView:(UITableView *)tableView &#123;</div><div class=\"line\">    self = [super initWithTableView:tableView];</div><div class=\"line\">    if (self) &#123;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return self;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">  - (void)setDataSouce:(NSArray *)dataSouce &#123;</div><div class=\"line\">    [super setDataSouce:dataSouce];</div><div class=\"line\">    [self.tableView reloadData];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView &#123;</div><div class=\"line\"></div><div class=\"line\">    return 1;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section &#123;</div><div class=\"line\"></div><div class=\"line\">    return self.dataSouce.count;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123;</div><div class=\"line\">    TestViewTableCell *cell = [tableView dequeueReusableCellWithIdentifier:@&quot;cell&quot;];</div><div class=\"line\">    cell.textLabel.text = self.dataSouce[indexPath.row];</div><div class=\"line\"></div><div class=\"line\">    return cell;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation TestViewTableCell</div><div class=\"line\"></div><div class=\"line\">- (instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier &#123;</div><div class=\"line\">    self = [super initWithStyle:style reuseIdentifier:reuseIdentifier];</div><div class=\"line\">    if (self) &#123;</div><div class=\"line\">       [self setup];</div><div class=\"line\">    &#125;</div><div class=\"line\">    return self;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)setup &#123;</div><div class=\"line\">    UIButton *showNumberButton = [UIButton buttonWithType:UIButtonTypeCustom];</div><div class=\"line\">    [showNumberButton setTitle:@&quot;Show row number&quot; forState:UIControlStateNormal];</div><div class=\"line\">    showNumberButton.backgroundColor = [UIColor purpleColor];</div><div class=\"line\">    showNumberButton.layer.cornerRadius = 4;</div><div class=\"line\">    showNumberButton.layer.masksToBounds = YES;</div><div class=\"line\">    showNumberButton.translatesAutoresizingMaskIntoConstraints = NO;</div><div class=\"line\">   [showNumberButton addTarget:self action:@selector(showNumberButtonClick:) forControlEvents:UIControlEventTouchUpInside];</div><div class=\"line\">    [self.contentView addSubview:showNumberButton];</div><div class=\"line\"></div><div class=\"line\">    [self.contentView addConstraints:[NSLayoutConstraint constraintsWithVisualFormat:@&quot;H:[showNumberButton(180)]-20-|&quot; options:0 metrics:nil views:NSDictionaryOfVariableBindings(showNumberButton)]];</div><div class=\"line\">    [self.contentView addConstraint:[NSLayoutConstraint constraintWithItem:showNumberButton attribute:NSLayoutAttributeCenterY relatedBy:NSLayoutRelationEqual toItem:self.contentView attribute:NSLayoutAttributeCenterY multiplier:1.0 constant:0]];</div><div class=\"line\">&#125;</div><div class=\"line\">   //关键代码就在这里, 我们在button click 事件中我再让传递一个事件给响应者链，让响应者链传出去</div><div class=\"line\">- (void)showNumberButtonClick:(id)sender &#123;</div><div class=\"line\">    // 我们在这个Click事件中去手动让响应者传递一个事件</div><div class=\"line\">    [self.nextResponder routerEventWithName:@&quot;showNumber&quot; userInfo:@&#123;@&quot;object&quot;:self.textLabel.text&#125;];</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>主要的代码差不多就是这些了，至于他们的基类都是自己封装好一部分，还不怎么完善都是一些自己的想法。就不贴代码稍后把这个Demo放出来。有兴趣的可以下下来看看，如果有我好的想法请联系我：<a href=\"mailto:lsb332@163.com\" target=\"_blank\" rel=\"external\">lsb332@163.com</a><br>我们先来看看在View 中捕获下事件，在.m 文件我们导入UIResponder+Router.h头文件 然后实现我们自定义的方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &quot;UIResponder+Router.h&quot;</div><div class=\"line\">#pragma UIResponder(Router)</div><div class=\"line\">- (void)routerEventWithName:(NSString *)eventName userInfo:(NSDictionary *)userInfo &#123;</div><div class=\"line\">   UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:@&quot;View中捕获&quot; message:userInfo[@&quot;object&quot;] delegate:nil cancelButtonTitle:@&quot;OK&quot; otherButtonTitles: nil];</div><div class=\"line\">   [alertView show];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong> 手动传递事件的代码TableDataSource 已经贴出来过了这里就不贴了</strong><br>我们看下结果：</p>\n<p><img src=\"http://ww2.sinaimg.cn/large/65e4f1e6gw1f7qq7f1kxyj20af0ih3zq.jpg\" alt=\"\"></p>\n<p>我们再来看看在UIViewController 捕获，代码就不贴了看下结果好了:</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/65e4f1e6gw1f7qq7rh5foj20af0ij75k.jpg\" alt=\"\"></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p><strong>最重要的思想就是在响应事件方法我们再主动的传递给响应者链一个事件，然后我们合适的地方去响应这个事件</strong><br>这个也是抛砖引玉的，自己理解的还很肤浅的，现在写出来也算是自己学习的一个笔记吧，这个处理方法也是自己在集成环信中发现的，自己去摸索学习下。<br>Demo地址 <a href=\"https://github.com/lsb332/UIResponderEX\" target=\"_blank\" rel=\"external\">https://github.com/lsb332/UIResponderEX</a><br>在这里再说一下自己项目结构，为了减轻UIViewController 重量实行真正的MVC 把View分出来了，从而使ViewController 只负责view 的显示 ，称除等。因为我们项目经常会用到TableView 为了不使View太重再次把这个分离去，使TableView的dataSource 在TableViewSource文件中去实现，然后又给View 建了一个Handler  用来处理业务逻辑，网络请求等，然后又把handler 继承一个网络求的类，这样可就可以处理的网络的请求了，如果handler 处理完数据后可以通过Block 回调给View 或者直接把数据传递给TableViewSource 就可以直接刷新数据，不用再回调给View。这里只是简单的说一下，有兴趣的可以工程里看看，还处在起步结段，如果觉得成熟了再写一篇文章说说吧。</p>\n<p>文／lsb332（简书作者）<br>原文链接：<a href=\"http://www.jianshu.com/p/8fef9171c322\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/p/8fef9171c322</a></p>\n","excerpt":"<p>开篇先说点废话吧，最近整个人都很烦躁，也许跟天气有关吧，也很久没有静下来写一些东西了，最近也一直忙着新项目，也很纠接新项目应该采用什么样的结构去写才好迭代、维护。最终按自己的一写想法采用了Controller View ViewHander的模式（有点类似MVVM），因为这个Demo按照这个想法来写的所以这里简单说下，就不过多的讨论这个了，回到主题上UIResponder来，没有说之前我们先看一个图我们开发中经常遇到的：</p>\n<p><img src=\"http://ww2.sinaimg.cn/large/65e4f1e6gw1f7qq6xkecej20af0ik75x.jpg\" alt=\"\"></p>\n<p>很简单就是在UITableViewCell 放了一个UIButton 那我们怎么样接收这个Button的点击事件? 你第一时间可能会想到Delegate,Block？的确它们都可以实现我们的需求，Delegate我们要多写点代码，Block 如果我们的事件逻辑复杂点就会再赋值时写很多代码，当然你可以用一个简单的Block把处理的业务代封装成方法，再这个调用这方法，也可以把代码弄的简洁点，最重要我一定要考虑<strong>循环引用</strong>的问题。那我们能不能用UIResponder 传递这个事件呢，在我们想要的地方捕获这个事件呢? 我们先来看看iOS 事件是怎么传递的我们看个图：</p>","more":"<p><img src=\"http://ww4.sinaimg.cn/large/65e4f1e6gw1f7qq6j34v9j20eu04g0st.jpg\" alt=\"\"></p>\n<p>如上图，iOS中事件传递首先从App(UIApplication)开始，接着传递到Window(UIWindow)，在接着往下传递到View之前，Window会将事件交给GestureRecognizer，如果在此期间，GestureRecognizer识别了传递过来的事件，则该事件将不会继续传递到View去，而是像我们之前说的那样交给Target(ViewController)进行处理。（注：详细原理可以自己进行搜索学习）我们大致知道事件产生最先识别是的 AppDelegate，然后一层层往下找看事件发生那个view上，直到找个这个view,然后看个view 能不能响应这个事件。那我们现在再说说响应者链先看个张图：</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/65e4f1e6gw1f7qq6ipf1hj20jy09t75c.jpg\" alt=\"\"></p>\n<p>我知道了当事触摸事件发生，通过一层层找到的这个View ,找到这个View 后先判断这个view能不能响应这个事件，如果不能那就继续找nextResponder我们看上面图可以看出如果一个View有SuperView 那么这个View的nextResponder 就是他的SuperView，如果没有SuperView 那么它的nextResponder 就是他所在ViewController 然后就这样一直找下去，直到找到或抛出异常。<br>我们了解这机制后那我们怎么把这个UIButton Click 事件传递出来呢，我们先来给UIResponder 添加一个我们自定义的事件，我就让它传递我们这个事件出去。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &quot;UIResponder+Router.h&quot;</div><div class=\"line\"></div><div class=\"line\">@implementation UIResponder (Router)</div><div class=\"line\"> // eventName 只是作个标记，当我们需要在一个页面传递个事件时我们可以进区分，userInfo 为了省劲就没有封装，你可以针对性再封装下</div><div class=\"line\">- (void)routerEventWithName:(NSString *)eventName userInfo:(NSDictionary *)userInfo &#123;</div><div class=\"line\">      [[self nextResponder] routerEventWithName:eventName userInfo:userInfo];</div><div class=\"line\"> &#125;</div><div class=\"line\"> @end</div></pre></td></tr></table></figure>\n<p>那我们怎么进行传递呢，那就是我们手动的去让响应者链传递这个事件<br>我们先看下工程的代码文件：<br><strong>View</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &quot;TestView.h&quot;</div><div class=\"line\">#import &quot;TestViewTableDataSource.h&quot;</div><div class=\"line\"></div><div class=\"line\">@implementation TestView &#123;</div><div class=\"line\">    UITableView *_tableView;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"> - (instancetype)initWithController:(SBBaseViewController *)controller &#123;</div><div class=\"line\">   self = [super initWithController:controller];</div><div class=\"line\">   if (self) &#123;</div><div class=\"line\">    [self setup];</div><div class=\"line\">    &#125;</div><div class=\"line\">     return self;</div><div class=\"line\"> &#125;</div><div class=\"line\"></div><div class=\"line\"> - (void)setup &#123;</div><div class=\"line\"></div><div class=\"line\">    _tableView = [[UITableView alloc] initWithFrame:CGRectZero style:UITableViewStylePlain];</div><div class=\"line\">    _tableView.delegate = self;</div><div class=\"line\">    _tableView.rowHeight = 60;</div><div class=\"line\">    _tableView.translatesAutoresizingMaskIntoConstraints = NO;</div><div class=\"line\">    [_tableView registerClass:[TestViewTableCell class] forCellReuseIdentifier:@&quot;cell&quot;];</div><div class=\"line\">    [self addSubview:_tableView];</div><div class=\"line\">    [self addConstraints:[NSLayoutConstraint constraintsWithVisualFormat:@&quot;H:|-0-[_tableView]-0-|&quot; options:0 metrics:nil views:NSDictionaryOfVariableBindings(_tableView)]];</div><div class=\"line\">    [self addConstraints:[NSLayoutConstraint constraintsWithVisualFormat:@&quot;V:|-0-[_tableView]-0-|&quot; options:0 metrics:nil views:NSDictionaryOfVariableBindings(_tableView)]];</div></pre></td></tr></table></figure>\n<p>}</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)setHandler:(SBBaseHandler *)handler &#123;</div><div class=\"line\">    [super setHandler:handler];</div><div class=\"line\">    // 把tableViewDataSource 分离出去</div><div class=\"line\">    TestViewTableDataSource *tableViewDataSoure = [[TestViewTableDataSource alloc] initWithTableView:_tableView];</div><div class=\"line\"></div><div class=\"line\">    _tableView.dataSource = tableViewDataSoure;</div><div class=\"line\">    self.handler.tableDataSource = tableViewDataSoure;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)didLoad &#123;</div><div class=\"line\">    [self.handler loadData];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>Controller</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &quot;TestViewController.h&quot;</div><div class=\"line\">#import &quot;TestView.h&quot;</div><div class=\"line\">#import &quot;TestViewHandler.h&quot;</div><div class=\"line\"></div><div class=\"line\">@interface TestViewController ()</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation TestViewController</div><div class=\"line\"></div><div class=\"line\">- (void)loadView &#123;</div><div class=\"line\">    [super loadView];</div><div class=\"line\">    TestView *view = [[TestView alloc]initWithController:self];</div><div class=\"line\">    TestViewHandler *handler = [[TestViewHandler alloc] init];</div><div class=\"line\">    view.handler = handler;</div><div class=\"line\">    self.view = view;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)viewDidLoad &#123;</div><div class=\"line\">    [super viewDidLoad];</div><div class=\"line\">    // Do any additional setup after loading the view.</div><div class=\"line\">    self.title = @&quot;UIResponderEx&quot;;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)didReceiveMemoryWarning &#123;</div><div class=\"line\">    [super didReceiveMemoryWarning];</div><div class=\"line\">    // Dispose of any resources that can be recreated.</div><div class=\"line\"> &#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p><strong>Handler</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &quot;TestViewHandler.h&quot;</div><div class=\"line\"></div><div class=\"line\">@implementation TestViewHandler</div><div class=\"line\"></div><div class=\"line\">- (void)loadData &#123;</div><div class=\"line\">    NSMutableArray *datasource = [NSMutableArray arrayWithCapacity:10];</div><div class=\"line\">    for (int i = 0; i&lt; 10; ++i) &#123;</div><div class=\"line\">        [datasource addObject:[NSString stringWithFormat:@&quot;Row number is %d&quot;,i]];</div><div class=\"line\">    &#125;</div><div class=\"line\">    self.tableDataSource.dataSouce = [datasource copy];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p><strong>TableDataSource</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &quot;SBBaseTableDataSource.h&quot;</div><div class=\"line\"></div><div class=\"line\">@interface TestViewTableDataSource : SBBaseTableDataSource</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\">// 这里为了省劲就没有用单独文件去写，最好还是建两个新文件去比较好</div><div class=\"line\">@interface TestViewTableCell : UITableViewCell</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<hr>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &quot;TestViewTableDataSource.h&quot;</div><div class=\"line\">#import &quot;UIResponder+Router.h&quot;</div><div class=\"line\"></div><div class=\"line\">@implementation TestViewTableDataSource</div><div class=\"line\"></div><div class=\"line\">- (id)initWithTableView:(UITableView *)tableView &#123;</div><div class=\"line\">    self = [super initWithTableView:tableView];</div><div class=\"line\">    if (self) &#123;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return self;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">  - (void)setDataSouce:(NSArray *)dataSouce &#123;</div><div class=\"line\">    [super setDataSouce:dataSouce];</div><div class=\"line\">    [self.tableView reloadData];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView &#123;</div><div class=\"line\"></div><div class=\"line\">    return 1;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section &#123;</div><div class=\"line\"></div><div class=\"line\">    return self.dataSouce.count;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123;</div><div class=\"line\">    TestViewTableCell *cell = [tableView dequeueReusableCellWithIdentifier:@&quot;cell&quot;];</div><div class=\"line\">    cell.textLabel.text = self.dataSouce[indexPath.row];</div><div class=\"line\"></div><div class=\"line\">    return cell;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation TestViewTableCell</div><div class=\"line\"></div><div class=\"line\">- (instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier &#123;</div><div class=\"line\">    self = [super initWithStyle:style reuseIdentifier:reuseIdentifier];</div><div class=\"line\">    if (self) &#123;</div><div class=\"line\">       [self setup];</div><div class=\"line\">    &#125;</div><div class=\"line\">    return self;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)setup &#123;</div><div class=\"line\">    UIButton *showNumberButton = [UIButton buttonWithType:UIButtonTypeCustom];</div><div class=\"line\">    [showNumberButton setTitle:@&quot;Show row number&quot; forState:UIControlStateNormal];</div><div class=\"line\">    showNumberButton.backgroundColor = [UIColor purpleColor];</div><div class=\"line\">    showNumberButton.layer.cornerRadius = 4;</div><div class=\"line\">    showNumberButton.layer.masksToBounds = YES;</div><div class=\"line\">    showNumberButton.translatesAutoresizingMaskIntoConstraints = NO;</div><div class=\"line\">   [showNumberButton addTarget:self action:@selector(showNumberButtonClick:) forControlEvents:UIControlEventTouchUpInside];</div><div class=\"line\">    [self.contentView addSubview:showNumberButton];</div><div class=\"line\"></div><div class=\"line\">    [self.contentView addConstraints:[NSLayoutConstraint constraintsWithVisualFormat:@&quot;H:[showNumberButton(180)]-20-|&quot; options:0 metrics:nil views:NSDictionaryOfVariableBindings(showNumberButton)]];</div><div class=\"line\">    [self.contentView addConstraint:[NSLayoutConstraint constraintWithItem:showNumberButton attribute:NSLayoutAttributeCenterY relatedBy:NSLayoutRelationEqual toItem:self.contentView attribute:NSLayoutAttributeCenterY multiplier:1.0 constant:0]];</div><div class=\"line\">&#125;</div><div class=\"line\">   //关键代码就在这里, 我们在button click 事件中我再让传递一个事件给响应者链，让响应者链传出去</div><div class=\"line\">- (void)showNumberButtonClick:(id)sender &#123;</div><div class=\"line\">    // 我们在这个Click事件中去手动让响应者传递一个事件</div><div class=\"line\">    [self.nextResponder routerEventWithName:@&quot;showNumber&quot; userInfo:@&#123;@&quot;object&quot;:self.textLabel.text&#125;];</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>主要的代码差不多就是这些了，至于他们的基类都是自己封装好一部分，还不怎么完善都是一些自己的想法。就不贴代码稍后把这个Demo放出来。有兴趣的可以下下来看看，如果有我好的想法请联系我：<a href=\"mailto:lsb332@163.com\">lsb332@163.com</a><br>我们先来看看在View 中捕获下事件，在.m 文件我们导入UIResponder+Router.h头文件 然后实现我们自定义的方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &quot;UIResponder+Router.h&quot;</div><div class=\"line\">#pragma UIResponder(Router)</div><div class=\"line\">- (void)routerEventWithName:(NSString *)eventName userInfo:(NSDictionary *)userInfo &#123;</div><div class=\"line\">   UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:@&quot;View中捕获&quot; message:userInfo[@&quot;object&quot;] delegate:nil cancelButtonTitle:@&quot;OK&quot; otherButtonTitles: nil];</div><div class=\"line\">   [alertView show];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong> 手动传递事件的代码TableDataSource 已经贴出来过了这里就不贴了</strong><br>我们看下结果：</p>\n<p><img src=\"http://ww2.sinaimg.cn/large/65e4f1e6gw1f7qq7f1kxyj20af0ih3zq.jpg\" alt=\"\"></p>\n<p>我们再来看看在UIViewController 捕获，代码就不贴了看下结果好了:</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/65e4f1e6gw1f7qq7rh5foj20af0ij75k.jpg\" alt=\"\"></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p><strong>最重要的思想就是在响应事件方法我们再主动的传递给响应者链一个事件，然后我们合适的地方去响应这个事件</strong><br>这个也是抛砖引玉的，自己理解的还很肤浅的，现在写出来也算是自己学习的一个笔记吧，这个处理方法也是自己在集成环信中发现的，自己去摸索学习下。<br>Demo地址 <a href=\"https://github.com/lsb332/UIResponderEX\">https://github.com/lsb332/UIResponderEX</a><br>在这里再说一下自己项目结构，为了减轻UIViewController 重量实行真正的MVC 把View分出来了，从而使ViewController 只负责view 的显示 ，称除等。因为我们项目经常会用到TableView 为了不使View太重再次把这个分离去，使TableView的dataSource 在TableViewSource文件中去实现，然后又给View 建了一个Handler  用来处理业务逻辑，网络请求等，然后又把handler 继承一个网络求的类，这样可就可以处理的网络的请求了，如果handler 处理完数据后可以通过Block 回调给View 或者直接把数据传递给TableViewSource 就可以直接刷新数据，不用再回调给View。这里只是简单的说一下，有兴趣的可以工程里看看，还处在起步结段，如果觉得成熟了再写一篇文章说说吧。</p>\n<p>文／lsb332（简书作者）<br>原文链接：<a href=\"http://www.jianshu.com/p/8fef9171c322\">http://www.jianshu.com/p/8fef9171c322</a></p>"},{"title":"基于Google I/O 大会，寻求人工智能的意义","id":"2","updated":"2016-06-27T16:45:28.000Z","date":"2016-05-26T01:13:40.000Z","_content":"\n\n\n\n![](http://images.ifanr.cn/wp-content/uploads/2015/05/Google-IO-e1432542727858.jpg)\n如今科技圈都在谈人工智能。好像突然之间有一股莫名的力量，从图像识别，到虚拟助手聊天机器人。最近，在 Google 的 I/O 大会上，AI 成为了讨论的前沿科技和中心，参会的 7,000 名开发者和媒体都期望 Google 成为未来的巅峰。Google CEO Sundar Pichai 没有打消人们的热情，最后在 AI 部分结束时，他直接引用了《星际迷航》中的台词：“以前以为不可能的事情，事实上会变为可能。”\n\nAI 在我们日常生活中发挥的作用越来越重要，但是关于 AI 的发展最有趣的方面是我们对它是干什么的知之甚少。如果 AI 真的能够改变世界，我们首先要做的是看一下它的定义，Google I/O 大会之外，我们还能从哪里了更好地了解它呢？\n\n当我采访别人 “你会如何定义 AI” 时，他们这样回答：\n\n“这个问题，你最好去采访一下别人吧。”\n\n“我不太确定，我还没有使用 AI 处理过事情。”\n\n“不好意思，你去采访下别人吧，祝你好运。”\n\n“对不起，我在打电话。”\n\n“我对 AI 不太了解。”\n\n“它是机器学习。”\n\n“我不清楚，你问别人吧。”\n\n“我在雅虎工作……”\n\n但是，并不是所有人对 AI 都一无所知。票务大师的一名领导 Dan Cernoch 说到，他认为真正的 AI 就像电脑复制了人类大脑中的功能，但是距离实现这一目标还有很远的距离。Cernoch 说人们称之为 AI 的产品实质上是 “机器学习”。很多人把机器学习类的产品统称为 AI。我们稍后再做详细解释。\n\n另一个人这样说：“AI 是指机器开始变得比他们预设的程序更加智能。” 除了可以反馈人们之前给它灌输的知识外，AI 还可以有个人的见解。它可以自己了解事情，不仅仅是被告知如何去做。\n\n我们发现很难找到关于 AI 的定义，于是找到了 Google 的高级研究研究员 Greg Corrado，寻求专家的建议。Greg Corrado 解释道：“人工智能是让机器更加智能的艺术和科学。” 但是这个定义太宽泛了，他很快就聚焦到机器学习上，他认为机器学习是 AI 最大的增长领域。Corrado 说：“我们不是直接编写程序让计算机变得更加聪明，我们编写程序，让计算机自己学习。”\n\n解释机器学习这个抽象概念最好的方法是通过具体的案例，Corrado 从图像识别开始介绍。你可以向计算机提供大量已经识别出的图像，然后教计算机识别特定事物的图像。举例来说，向计算机提供很多猫的照片，计算机可以学习如何识别含有猫的新图像。\n\n计算机通过所谓的 “神经网络” 识别图像，Corrado 说 “神经网络” 是仿照人类的大脑设计的，大脑中数十亿的神经都会根据信息作出决策，但是所有的神经一起工作的话可以处理高级的思维任务。“智能是指这些数十亿个单个神经出现了协同一致的行为。”\n\n人工智能也有神经。在介绍神经网络时，Corrado 说：“我们在每个功能之上创建新的功能，然后他们会学会共同协作处理任务。”\n\n我们再回到刚才提到的图像识别案例，Corrado 解释道，这些人工神经会扫描每个图像的小像素块，并对此进行判断。“它都是白色的吗? 它都是黑色的吗？它有边界吗？哪里边界点？” 大量的人工神经可以扫描图像，并且将他们的结论传递给另外的神经，机器会根据已有的数据做出自己的决策。最终，神经网络可以决定图像是一张面孔、一辆汽车或者是一辆卡车。\n\n机器学习和图像识别的工作原理相似。这种原理同样适用于语言翻译，它们使用相同的方法通过分析语音推断出文字。当它识别出文字之后，它就可以通过翻译程序进行翻译。Corrado 说 “它会在音频流里寻求信号，然后进行猜测，翻译这个词时该输出什么？”\n\n当谈到使用机器学习预定电影票时，Corrado 解释道其中的部分工作不是 AI 做的。“当你创建整个产品时，有各种各样的子系统，例如，当你在当地电影院查看电影播放时间时，你想要获得的是对新的直接的、完美的检索。你可以写一个程序帮你做到这一点，但是没有必要试着学习如何以一种更软的方式进行处理。机器学习最适合用在这种有很多直观步骤的地方。”\n\nGoogle 基于 AI 的产品不会进行自我创造，至少现在不会。\n\n","source":"_posts/基于Google-I-O-大会，寻求人工智能的意义.md","raw":"---\ntitle: 基于Google I/O 大会，寻求人工智能的意义\ntags: '互联网'\npermalink: ce-shi\nid: 2\nupdated: '2016-06-28 00:45:28'\ndate: 2016-05-26 09:13:40\n---\n\n\n\n\n![](http://images.ifanr.cn/wp-content/uploads/2015/05/Google-IO-e1432542727858.jpg)\n如今科技圈都在谈人工智能。好像突然之间有一股莫名的力量，从图像识别，到虚拟助手聊天机器人。最近，在 Google 的 I/O 大会上，AI 成为了讨论的前沿科技和中心，参会的 7,000 名开发者和媒体都期望 Google 成为未来的巅峰。Google CEO Sundar Pichai 没有打消人们的热情，最后在 AI 部分结束时，他直接引用了《星际迷航》中的台词：“以前以为不可能的事情，事实上会变为可能。”\n\nAI 在我们日常生活中发挥的作用越来越重要，但是关于 AI 的发展最有趣的方面是我们对它是干什么的知之甚少。如果 AI 真的能够改变世界，我们首先要做的是看一下它的定义，Google I/O 大会之外，我们还能从哪里了更好地了解它呢？\n\n当我采访别人 “你会如何定义 AI” 时，他们这样回答：\n\n“这个问题，你最好去采访一下别人吧。”\n\n“我不太确定，我还没有使用 AI 处理过事情。”\n\n“不好意思，你去采访下别人吧，祝你好运。”\n\n“对不起，我在打电话。”\n\n“我对 AI 不太了解。”\n\n“它是机器学习。”\n\n“我不清楚，你问别人吧。”\n\n“我在雅虎工作……”\n\n但是，并不是所有人对 AI 都一无所知。票务大师的一名领导 Dan Cernoch 说到，他认为真正的 AI 就像电脑复制了人类大脑中的功能，但是距离实现这一目标还有很远的距离。Cernoch 说人们称之为 AI 的产品实质上是 “机器学习”。很多人把机器学习类的产品统称为 AI。我们稍后再做详细解释。\n\n另一个人这样说：“AI 是指机器开始变得比他们预设的程序更加智能。” 除了可以反馈人们之前给它灌输的知识外，AI 还可以有个人的见解。它可以自己了解事情，不仅仅是被告知如何去做。\n\n我们发现很难找到关于 AI 的定义，于是找到了 Google 的高级研究研究员 Greg Corrado，寻求专家的建议。Greg Corrado 解释道：“人工智能是让机器更加智能的艺术和科学。” 但是这个定义太宽泛了，他很快就聚焦到机器学习上，他认为机器学习是 AI 最大的增长领域。Corrado 说：“我们不是直接编写程序让计算机变得更加聪明，我们编写程序，让计算机自己学习。”\n\n解释机器学习这个抽象概念最好的方法是通过具体的案例，Corrado 从图像识别开始介绍。你可以向计算机提供大量已经识别出的图像，然后教计算机识别特定事物的图像。举例来说，向计算机提供很多猫的照片，计算机可以学习如何识别含有猫的新图像。\n\n计算机通过所谓的 “神经网络” 识别图像，Corrado 说 “神经网络” 是仿照人类的大脑设计的，大脑中数十亿的神经都会根据信息作出决策，但是所有的神经一起工作的话可以处理高级的思维任务。“智能是指这些数十亿个单个神经出现了协同一致的行为。”\n\n人工智能也有神经。在介绍神经网络时，Corrado 说：“我们在每个功能之上创建新的功能，然后他们会学会共同协作处理任务。”\n\n我们再回到刚才提到的图像识别案例，Corrado 解释道，这些人工神经会扫描每个图像的小像素块，并对此进行判断。“它都是白色的吗? 它都是黑色的吗？它有边界吗？哪里边界点？” 大量的人工神经可以扫描图像，并且将他们的结论传递给另外的神经，机器会根据已有的数据做出自己的决策。最终，神经网络可以决定图像是一张面孔、一辆汽车或者是一辆卡车。\n\n机器学习和图像识别的工作原理相似。这种原理同样适用于语言翻译，它们使用相同的方法通过分析语音推断出文字。当它识别出文字之后，它就可以通过翻译程序进行翻译。Corrado 说 “它会在音频流里寻求信号，然后进行猜测，翻译这个词时该输出什么？”\n\n当谈到使用机器学习预定电影票时，Corrado 解释道其中的部分工作不是 AI 做的。“当你创建整个产品时，有各种各样的子系统，例如，当你在当地电影院查看电影播放时间时，你想要获得的是对新的直接的、完美的检索。你可以写一个程序帮你做到这一点，但是没有必要试着学习如何以一种更软的方式进行处理。机器学习最适合用在这种有很多直观步骤的地方。”\n\nGoogle 基于 AI 的产品不会进行自我创造，至少现在不会。\n\n","slug":"ce-shi","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cj04pzyyd001bs04e2vezxkz2","content":"<p><img src=\"http://images.ifanr.cn/wp-content/uploads/2015/05/Google-IO-e1432542727858.jpg\" alt=\"\"><br>如今科技圈都在谈人工智能。好像突然之间有一股莫名的力量，从图像识别，到虚拟助手聊天机器人。最近，在 Google 的 I/O 大会上，AI 成为了讨论的前沿科技和中心，参会的 7,000 名开发者和媒体都期望 Google 成为未来的巅峰。Google CEO Sundar Pichai 没有打消人们的热情，最后在 AI 部分结束时，他直接引用了《星际迷航》中的台词：“以前以为不可能的事情，事实上会变为可能。”</p>\n<p>AI 在我们日常生活中发挥的作用越来越重要，但是关于 AI 的发展最有趣的方面是我们对它是干什么的知之甚少。如果 AI 真的能够改变世界，我们首先要做的是看一下它的定义，Google I/O 大会之外，我们还能从哪里了更好地了解它呢？</p>\n<p>当我采访别人 “你会如何定义 AI” 时，他们这样回答：</p>\n<p>“这个问题，你最好去采访一下别人吧。”</p>\n<p>“我不太确定，我还没有使用 AI 处理过事情。”</p>\n<p>“不好意思，你去采访下别人吧，祝你好运。”</p>\n<p>“对不起，我在打电话。”</p>\n<p>“我对 AI 不太了解。”</p>\n<p>“它是机器学习。”</p>\n<p>“我不清楚，你问别人吧。”</p>\n<p>“我在雅虎工作……”</p>\n<p>但是，并不是所有人对 AI 都一无所知。票务大师的一名领导 Dan Cernoch 说到，他认为真正的 AI 就像电脑复制了人类大脑中的功能，但是距离实现这一目标还有很远的距离。Cernoch 说人们称之为 AI 的产品实质上是 “机器学习”。很多人把机器学习类的产品统称为 AI。我们稍后再做详细解释。</p>\n<p>另一个人这样说：“AI 是指机器开始变得比他们预设的程序更加智能。” 除了可以反馈人们之前给它灌输的知识外，AI 还可以有个人的见解。它可以自己了解事情，不仅仅是被告知如何去做。</p>\n<p>我们发现很难找到关于 AI 的定义，于是找到了 Google 的高级研究研究员 Greg Corrado，寻求专家的建议。Greg Corrado 解释道：“人工智能是让机器更加智能的艺术和科学。” 但是这个定义太宽泛了，他很快就聚焦到机器学习上，他认为机器学习是 AI 最大的增长领域。Corrado 说：“我们不是直接编写程序让计算机变得更加聪明，我们编写程序，让计算机自己学习。”</p>\n<p>解释机器学习这个抽象概念最好的方法是通过具体的案例，Corrado 从图像识别开始介绍。你可以向计算机提供大量已经识别出的图像，然后教计算机识别特定事物的图像。举例来说，向计算机提供很多猫的照片，计算机可以学习如何识别含有猫的新图像。</p>\n<p>计算机通过所谓的 “神经网络” 识别图像，Corrado 说 “神经网络” 是仿照人类的大脑设计的，大脑中数十亿的神经都会根据信息作出决策，但是所有的神经一起工作的话可以处理高级的思维任务。“智能是指这些数十亿个单个神经出现了协同一致的行为。”</p>\n<p>人工智能也有神经。在介绍神经网络时，Corrado 说：“我们在每个功能之上创建新的功能，然后他们会学会共同协作处理任务。”</p>\n<p>我们再回到刚才提到的图像识别案例，Corrado 解释道，这些人工神经会扫描每个图像的小像素块，并对此进行判断。“它都是白色的吗? 它都是黑色的吗？它有边界吗？哪里边界点？” 大量的人工神经可以扫描图像，并且将他们的结论传递给另外的神经，机器会根据已有的数据做出自己的决策。最终，神经网络可以决定图像是一张面孔、一辆汽车或者是一辆卡车。</p>\n<p>机器学习和图像识别的工作原理相似。这种原理同样适用于语言翻译，它们使用相同的方法通过分析语音推断出文字。当它识别出文字之后，它就可以通过翻译程序进行翻译。Corrado 说 “它会在音频流里寻求信号，然后进行猜测，翻译这个词时该输出什么？”</p>\n<p>当谈到使用机器学习预定电影票时，Corrado 解释道其中的部分工作不是 AI 做的。“当你创建整个产品时，有各种各样的子系统，例如，当你在当地电影院查看电影播放时间时，你想要获得的是对新的直接的、完美的检索。你可以写一个程序帮你做到这一点，但是没有必要试着学习如何以一种更软的方式进行处理。机器学习最适合用在这种有很多直观步骤的地方。”</p>\n<p>Google 基于 AI 的产品不会进行自我创造，至少现在不会。</p>\n","excerpt":"","more":"<p><img src=\"http://images.ifanr.cn/wp-content/uploads/2015/05/Google-IO-e1432542727858.jpg\" alt=\"\"><br>如今科技圈都在谈人工智能。好像突然之间有一股莫名的力量，从图像识别，到虚拟助手聊天机器人。最近，在 Google 的 I/O 大会上，AI 成为了讨论的前沿科技和中心，参会的 7,000 名开发者和媒体都期望 Google 成为未来的巅峰。Google CEO Sundar Pichai 没有打消人们的热情，最后在 AI 部分结束时，他直接引用了《星际迷航》中的台词：“以前以为不可能的事情，事实上会变为可能。”</p>\n<p>AI 在我们日常生活中发挥的作用越来越重要，但是关于 AI 的发展最有趣的方面是我们对它是干什么的知之甚少。如果 AI 真的能够改变世界，我们首先要做的是看一下它的定义，Google I/O 大会之外，我们还能从哪里了更好地了解它呢？</p>\n<p>当我采访别人 “你会如何定义 AI” 时，他们这样回答：</p>\n<p>“这个问题，你最好去采访一下别人吧。”</p>\n<p>“我不太确定，我还没有使用 AI 处理过事情。”</p>\n<p>“不好意思，你去采访下别人吧，祝你好运。”</p>\n<p>“对不起，我在打电话。”</p>\n<p>“我对 AI 不太了解。”</p>\n<p>“它是机器学习。”</p>\n<p>“我不清楚，你问别人吧。”</p>\n<p>“我在雅虎工作……”</p>\n<p>但是，并不是所有人对 AI 都一无所知。票务大师的一名领导 Dan Cernoch 说到，他认为真正的 AI 就像电脑复制了人类大脑中的功能，但是距离实现这一目标还有很远的距离。Cernoch 说人们称之为 AI 的产品实质上是 “机器学习”。很多人把机器学习类的产品统称为 AI。我们稍后再做详细解释。</p>\n<p>另一个人这样说：“AI 是指机器开始变得比他们预设的程序更加智能。” 除了可以反馈人们之前给它灌输的知识外，AI 还可以有个人的见解。它可以自己了解事情，不仅仅是被告知如何去做。</p>\n<p>我们发现很难找到关于 AI 的定义，于是找到了 Google 的高级研究研究员 Greg Corrado，寻求专家的建议。Greg Corrado 解释道：“人工智能是让机器更加智能的艺术和科学。” 但是这个定义太宽泛了，他很快就聚焦到机器学习上，他认为机器学习是 AI 最大的增长领域。Corrado 说：“我们不是直接编写程序让计算机变得更加聪明，我们编写程序，让计算机自己学习。”</p>\n<p>解释机器学习这个抽象概念最好的方法是通过具体的案例，Corrado 从图像识别开始介绍。你可以向计算机提供大量已经识别出的图像，然后教计算机识别特定事物的图像。举例来说，向计算机提供很多猫的照片，计算机可以学习如何识别含有猫的新图像。</p>\n<p>计算机通过所谓的 “神经网络” 识别图像，Corrado 说 “神经网络” 是仿照人类的大脑设计的，大脑中数十亿的神经都会根据信息作出决策，但是所有的神经一起工作的话可以处理高级的思维任务。“智能是指这些数十亿个单个神经出现了协同一致的行为。”</p>\n<p>人工智能也有神经。在介绍神经网络时，Corrado 说：“我们在每个功能之上创建新的功能，然后他们会学会共同协作处理任务。”</p>\n<p>我们再回到刚才提到的图像识别案例，Corrado 解释道，这些人工神经会扫描每个图像的小像素块，并对此进行判断。“它都是白色的吗? 它都是黑色的吗？它有边界吗？哪里边界点？” 大量的人工神经可以扫描图像，并且将他们的结论传递给另外的神经，机器会根据已有的数据做出自己的决策。最终，神经网络可以决定图像是一张面孔、一辆汽车或者是一辆卡车。</p>\n<p>机器学习和图像识别的工作原理相似。这种原理同样适用于语言翻译，它们使用相同的方法通过分析语音推断出文字。当它识别出文字之后，它就可以通过翻译程序进行翻译。Corrado 说 “它会在音频流里寻求信号，然后进行猜测，翻译这个词时该输出什么？”</p>\n<p>当谈到使用机器学习预定电影票时，Corrado 解释道其中的部分工作不是 AI 做的。“当你创建整个产品时，有各种各样的子系统，例如，当你在当地电影院查看电影播放时间时，你想要获得的是对新的直接的、完美的检索。你可以写一个程序帮你做到这一点，但是没有必要试着学习如何以一种更软的方式进行处理。机器学习最适合用在这种有很多直观步骤的地方。”</p>\n<p>Google 基于 AI 的产品不会进行自我创造，至少现在不会。</p>\n"},{"title":"基于 ijkplayer 的iOS视频直播推流仿写","id":"27","updated":"2016-08-10T16:05:29.000Z","date":"2016-07-07T03:39:36.000Z","_content":"\n\n\n视频直播，可以分为 采集，前处理，编码，传输, 服务器处理，解码，渲染\n\n采集: iOS系统因为软硬件种类不多, 硬件适配性比较好, 所以比较简单. 而Android端市面上机型众多, 要做些机型的适配工作.PC端是最麻烦的, 各种奇葩摄像头驱动.所以现在很多的中小型直播平台, 都放弃了PC的直播, 更有一些直播平台只做iOS端的视频直播.\n\n前处理: 美颜算法,视频的模糊效果, 水印等都是在这个环节做. 目前iOS端最著名开源框架的毫无疑问就是GPUImage.其中内置了125种渲染效果, 还支持各种脚本自定义. 我高仿的喵播的美颜效果也是基于GPUImage的.\n\n编码: 重难点在于要在分辨率，帧率，码率，GOP等参数设计上找到最佳平衡点。iOS8之后, Apple开放了VideoToolbox.framework, 可以直接进行硬编解码, 这也是为什么现在大多数直播平台最低只支持到iOS8的原因之一. iOS端硬件兼容性比较好, 可以直接采取硬编码. 而Android得硬编码又是一大坑.\n\n传输: 这块一般都是交给CDN服务商. CDN只提供带宽和服务器之间的传输, 发送端和接收端的网络连接抖动缓存还是要自己实现的.目前国内最大的CDN服务商应该是网宿.\n\n服务器处理: 需要在服务器做一些流处理工作, 让推送上来的流适配各个平台各种不同的协议, 比如:RTMP,HLS,FLV...\n\n解码和渲染: 也就即音视频的播放. 解码毫无疑问也必须要硬解码. iOS端兼容较好, Android依然大坑.这块的难点在于音画同步, 目前很多直播平台这块是硬伤.国内比较好的开源项目应该是B站开源的ijkplayer . 斗鱼就是基于ijkplayer 的, 本项目也是基于ijkplayer 的.\n\n技术坑 : 降噪, 音频解码器, 蓝牙适配, 回声消除, 信令控制, 登录, 鉴权, 权限管理, 状态管理, 应用消息, 消息推送, 礼物系统, 即时聊天, 支付系统, 统计系统, 数据库, 缓存, 分布式文件存储, 消息队列, 运维系统等等大小不一的坑等你来填!!!\n\n\n<!------MORE------->\n\n\n资金坑 : 以带宽为例, 2万人同时在线, 手机码率在600KB, 每个月的带宽费用至少在30万左右. 根据欢聚时代(YY)15年四季度财务报, 他们的带宽成本为人民币1.611亿元, 折合每月5000万+. 人力成本+渠道支出和其他支出就不详谈了.\n\n社会坑: 还得每时每刻与各种黑暗势力斗争, 包括色情, 广告, 刷小号, 刷充值, 告侵权, DDos...\n\n\n前期准备\n项目主要是基于ijkplayer 的. 最好是打包成framework. 原本我准备写一个打包教程, 不过后来在简书上发现了一篇特别详细的打包blog, 分享给大家: [http://www.jianshu.com/p/1f06b27b3ac0](http://)\n\nProfile : 个人中心, 这里面只有一个ProfileController. 因为总写重复代码, 都写吐了, 这儿有兴趣的自己写一下吧, So easy...\n\nNetwork : 关于网络连接的工具类. 关于网络的实时监控, 网络状态的切换, 网络请求的工具类都在这里面.\n\nOther : 全局的常量. 当然你也可以在里面将文件结构更加细化.\n\nHome : 包含最新主播, 最热直播, 关注的直播, 礼物排行榜等模块. 还有最重要的视频直播也在这里面了.\n\nShowTime :见名知意. 视频直播的前处理, 智能美颜和H264硬编码等都在这里面.\n\nMain : UITabBarController和UINavigationController的配置\n\nToos : 这儿命名有点不规范, 这里面放置的都是项目用到的分类\n\nLogin : 登录模块\n\nResource : 项目用到的资源文件\n\n项目详解\ntip1: 判读网络类型.\n\n在观看直播的时候, 我们通常都是用WiFi或者3/4G(土豪级别的), 一般用户在进行网络切换的时候, 我们都要给出友善的提示, 告诉TA: 您的网络状态切换到了XX状态. 假设用户从WiFi切换到4G, 你的应用也没个提醒, 导致TA的流量归零甚至欠了运营商一屁股的钱, 我想你的APP的用户体验也就归零或者为负了.\n我们可以使用苹果的Reachability结合下面的代码实时监听网络状态的改变\n```\ntypedef NS_ENUM(NSUInteger, NetworkStates) {\n    NetworkStatesNone, // 没有网络\n    NetworkStates2G, // 2G\n    NetworkStates3G, // 3G\n    NetworkStates4G, // 4G\n    NetworkStatesWIFI // WIFI\n};\n// 判断网络类型\n+ (NetworkStates)getNetworkStates\n  {\n    NSArray *subviews = [[[[UIApplication sharedApplication] valueForKeyPath:@\"statusBar\"] valueForKeyPath:@\"foregroundView\"] subviews];\n    // 保存网络状态\n    NetworkStates states = NetworkStatesNone;\n    for (id child in subviews) {\n        if ([child isKindOfClass:NSClassFromString(@\"UIStatusBarDataNetworkItemView\")]) {\n            //获取到状态栏码\n            int networkType = [[child valueForKeyPath:@\"dataNetworkType\"] intValue];\n            switch (networkType) {\n                case 0:\n                   //无网模式\n                    states = NetworkStatesNone;\n                    break;\n                case 1:\n                    states = NetworkStates2G;\n                    break;\n                case 2:\n                    states = NetworkStates3G;\n                    break;\n                case 3:\n                    states = NetworkStates4G;\n                    break;\n                case 5:\n                {\n                    states = NetworkStatesWIFI;\n                }\n                    break;\n                default:\n                    break;\n            }\n        }\n    }\n    //根据状态选择\n    return states;\n  }\n  tip2: 登录模块\n```\n如果你多运行几次就会发现, 登录模块背景中播放的视频是2个视频每次随机播放一个的.并且是无限重复的, 也就是说只要你一直呆着登录界面, 就会单视频循环播放当前的视频. 这儿的登录只是几个按钮, 没有具体的登录逻辑, 随便点哪一个按钮都可以进入首页.\n我们需要监听视频, 是否播放完成.\n```\n// 监听视频是否播放完成\n  [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(didFinish) name:IJKMPMoviePlayerPlaybackDidFinishNotification object:nil];\n如果播放完成了, 让IJKFFMoviePlayerController再次play即可\n\n- (void)didFinish\n  {\n    // 播放完之后, 继续重播\n    [self.player play];\n  }\n  tip3: 首页\n```\n首页\n\n这种效果相信很多人都看到过或者做过.我简单说一下我的做法(不一定是最佳的, 只是提供一个思路)\n\n一个父控制器HomeViewController+三个子控制器(最热/最新/关注. 每个控制器各自管理自己的业务逻辑, 高内聚低耦合). 重写HomeViewController的loadView, 将self.view替换成UIScrollView. 将三个子控制器的view添加到UIScrollView上即可. 其他的效果实现, 请参照我的代码, 都有详细的中文注释.\ntip4: 直播(面向观众端)\n这个是整个项目的重点之一了.这种直播的布局, 应该是比较主流的了. 我下载的好多直播类APP都是这个项目布局, 包括YY也是这种界面布局.这个里面涉及的东西比较多了, 三言两语真说不清.\n\n简单说一下已经实现的效果:\nA: 主播的直播\nB: 关联主播的视频直播, 默认是只有界面, 没有声音的. 点击该视图可以切换到此主播\nC: 下拉切换另一个主播, 这个功能是很常见的. 做法是直播控制器是一个UICollectionViewController, 只有一个cell, 且cell.frame就是self.collectionViewb.bounds. 我们进入直播控制器的时候, 其实是传进去一个关联主播数组, 每次下拉的时候, 就加载数组里面的主播\nD. 查看观众席的观众详情\nE. 查看主播详情\nF. 足迹: 粒子动画, 后面详解\nG. 弹幕: 点击最下方的工具栏第一个按钮可以开启/关闭弹幕, 后面详解\n...\ntip5: 粒子动画实现游客足迹\n粒子动画的layer是添加到播放器的view上面的. 下面代码有详细的注释\n```\nCAEmitterLayer *emitterLayer = [CAEmitterLayer layer];\n// 发射器在xy平面的中心位置\nemitterLayer.emitterPosition = CGPointMake(self.moviePlayer.view.frame.size.width-50,self.moviePlayer.view.frame.size.height-50);\n// 发射器的尺寸大小\nemitterLayer.emitterSize = CGSizeMake(20, 20);\n// 渲染模式\nemitterLayer.renderMode = kCAEmitterLayerUnordered;\n// 开启三维效果\n//    _emitterLayer.preservesDepth = YES;\nNSMutableArray *array = [NSMutableArray array];\n// 创建粒子\nfor (int i = 0; i<10; i++) {\n    // 发射单元\n    CAEmitterCell *stepCell = [CAEmitterCell emitterCell];\n    // 粒子的创建速率，默认为1/s\n    stepCell.birthRate = 1;\n    // 粒子存活时间\n    stepCell.lifetime = arc4random_uniform(4) + 1;\n    // 粒子的生存时间容差\n    stepCell.lifetimeRange = 1.5;\n    // 颜色\n    // fire.color=[[UIColor colorWithRed:0.8 green:0.4 blue:0.2 alpha:0.1]CGColor];\n    UIImage *image = [UIImage imageNamed:[NSString stringWithFormat:@\"good%d_30x30\", i]];\n    // 粒子显示的内容\n    stepCell.contents = (id)[image CGImage];\n    // 粒子的名字\n    //            [fire setName:@\"step%d\", i];\n    // 粒子的运动速度\n    stepCell.velocity = arc4random_uniform(100) + 100;\n    // 粒子速度的容差\n    stepCell.velocityRange = 80;\n    // 粒子在xy平面的发射角度\n    stepCell.emissionLongitude = M_PI+M_PI_2;;\n    // 粒子发射角度的容差\n    stepCell.emissionRange = M_PI_2/6;\n    // 缩放比例\n    stepCell.scale = 0.3;\n    [array addObject:stepCell];\n}\n\nemitterLayer.emitterCells = array;\n[self.moviePlayer.view.layer insertSublayer:emitterLayer below:self.catEarView.layer];\ntip6: 弹幕\n弹幕使用的也是一个第三方轮子BarrageRenderer . 这个开源项目的文档都是中文的, 用法也是很简单的.\n\n基本配置\n\n_renderer = [[BarrageRenderer alloc] init];\n// 设置弹幕的显示区域. 基于父控件的.\n_renderer.canvasMargin = UIEdgeInsetsMake(ALinScreenHeight * 0.3, 10, 10, 10);\n[self.contentView addSubview:_renderer.view];\n弹幕配置\n\n#pragma mark - 弹幕描述符生产方法\n/// 生成精灵描述 - 过场文字弹幕\n- (BarrageDescriptor *)walkTextSpriteDescriptorWithDirection:(NSInteger)direction\n  {\n    BarrageDescriptor * descriptor = [[BarrageDescriptor alloc]init];\n    descriptor.spriteName = NSStringFromClass([BarrageWalkTextSprite class]);\n    descriptor.params[@\"text\"] = self.danMuText[arc4random_uniform((uint32_t)self.danMuText.count)];\n    descriptor.params[@\"textColor\"] = Color(arc4random_uniform(256), arc4random_uniform(256), arc4random_uniform(256));\n    descriptor.params[@\"speed\"] = @(100 * (double)random()/RAND_MAX+50);\n    descriptor.params[@\"direction\"] = @(direction);\n    descriptor.params[@\"clickAction\"] = ^{\n        UIAlertView *alertView = [[UIAlertView alloc]initWithTitle:@\"提示\" message:@\"弹幕被点击\" delegate:nil cancelButtonTitle:@\"取消\" otherButtonTitles:nil];\n        [alertView show];\n    };\n    return descriptor;\n  }\n  最后一步, 千万要记得start\n\n[_renderer start];\n```\n\ntip7: 智能美颜效果\n现在的直播平台, 美颜是标配. 不然绝大多数的主播都是没法看的.美颜算法需要用到GPU编程, 需要懂图像处理的人. 图像处理这一块我不是很熟悉, 相关的文献也是看得云里雾里的. 所以, 依然使用开源的轮子: GPUImage . 这个开源框架有近1.3W+star(7月5日数据), 真不是盖的, 内置125种滤镜效果, 没有你想不到, 只有你不会用. 我的项目中都有详细的用法, 还是很简单的. 在这里摘抄一份其.h文件的注释. 一方面方便大家修改我项目中的美颜效果, 另一方面也是做个备份.(具体出处我真忘了, 如果有人找到了源地址链接, 可以联系我加上)\n\n```\n#import \"GLProgram.h\"\n\n// Base classes\n#import \"GPUImageOpenGLESContext.h\"\n#import \"GPUImageOutput.h\"\n#import \"GPUImageView.h\"\n#import \"GPUImageVideoCamera.h\"\n#import \"GPUImageStillCamera.h\"\n#import \"GPUImageMovie.h\"\n#import \"GPUImagePicture.h\"\n#import \"GPUImageRawDataInput.h\"\n#import \"GPUImageRawDataOutput.h\"\n#import \"GPUImageMovieWriter.h\"\n#import \"GPUImageFilterPipeline.h\"\n#import \"GPUImageTextureOutput.h\"\n#import \"GPUImageFilterGroup.h\"\n#import \"GPUImageTextureInput.h\"\n#import \"GPUImageUIElement.h\"\n#import \"GPUImageBuffer.h\"\n\n// Filters\n#import \"GPUImageFilter.h\"\n#import \"GPUImageTwoInputFilter.h\"\n\n\n#pragma mark - 调整颜色 Handle Color\n\n#import \"GPUImageBrightnessFilter.h\"                //亮度\n#import \"GPUImageExposureFilter.h\"                  //曝光\n#import \"GPUImageContrastFilter.h\"                  //对比度\n#import \"GPUImageSaturationFilter.h\"                //饱和度\n#import \"GPUImageGammaFilter.h\"                     //伽马线\n#import \"GPUImageColorInvertFilter.h\"               //反色\n#import \"GPUImageSepiaFilter.h\"                     //褐色（怀旧）\n#import \"GPUImageLevelsFilter.h\"                    //色阶\n#import \"GPUImageGrayscaleFilter.h\"                 //灰度\n#import \"GPUImageHistogramFilter.h\"                 //色彩直方图，显示在图片上\n#import \"GPUImageHistogramGenerator.h\"              //色彩直方图\n#import \"GPUImageRGBFilter.h\"                       //RGB\n#import \"GPUImageToneCurveFilter.h\"                 //色调曲线\n#import \"GPUImageMonochromeFilter.h\"                //单色\n#import \"GPUImageOpacityFilter.h\"                   //不透明度\n#import \"GPUImageHighlightShadowFilter.h\"           //提亮阴影\n#import \"GPUImageFalseColorFilter.h\"                //色彩替换（替换亮部和暗部色彩）\n#import \"GPUImageHueFilter.h\"                       //色度\n#import \"GPUImageChromaKeyFilter.h\"                 //色度键\n#import \"GPUImageWhiteBalanceFilter.h\"              //白平横\n#import \"GPUImageAverageColor.h\"                    //像素平均色值\n#import \"GPUImageSolidColorGenerator.h\"             //纯色\n#import \"GPUImageLuminosity.h\"                      //亮度平均\n#import \"GPUImageAverageLuminanceThresholdFilter.h\" //像素色值亮度平均，图像黑白（有类似漫画效果）\n\n#import \"GPUImageLookupFilter.h\"                    //lookup 色彩调整\n#import \"GPUImageAmatorkaFilter.h\"                  //Amatorka lookup\n#import \"GPUImageMissEtikateFilter.h\"               //MissEtikate lookup\n#import \"GPUImageSoftEleganceFilter.h\"              //SoftElegance lookup\n\n\n\n\n#pragma mark - 图像处理 Handle Image\n\n#import \"GPUImageCrosshairGenerator.h\"              //十字\n#import \"GPUImageLineGenerator.h\"                   //线条\n\n#import \"GPUImageTransformFilter.h\"                 //形状变化\n#import \"GPUImageCropFilter.h\"                      //剪裁\n#import \"GPUImageSharpenFilter.h\"                   //锐化\n#import \"GPUImageUnsharpMaskFilter.h\"               //反遮罩锐化\n\n#import \"GPUImageFastBlurFilter.h\"                  //模糊\n#import \"GPUImageGaussianBlurFilter.h\"              //高斯模糊\n#import \"GPUImageGaussianSelectiveBlurFilter.h\"     //高斯模糊，选择部分清晰\n#import \"GPUImageBoxBlurFilter.h\"                   //盒状模糊\n#import \"GPUImageTiltShiftFilter.h\"                 //条纹模糊，中间清晰，上下两端模糊\n#import \"GPUImageMedianFilter.h\"                    //中间值，有种稍微模糊边缘的效果\n#import \"GPUImageBilateralFilter.h\"                 //双边模糊\n#import \"GPUImageErosionFilter.h\"                   //侵蚀边缘模糊，变黑白\n#import \"GPUImageRGBErosionFilter.h\"                //RGB侵蚀边缘模糊，有色彩\n#import \"GPUImageDilationFilter.h\"                  //扩展边缘模糊，变黑白\n#import \"GPUImageRGBDilationFilter.h\"               //RGB扩展边缘模糊，有色彩\n#import \"GPUImageOpeningFilter.h\"                   //黑白色调模糊\n#import \"GPUImageRGBOpeningFilter.h\"                //彩色模糊\n#import \"GPUImageClosingFilter.h\"                   //黑白色调模糊，暗色会被提亮\n#import \"GPUImageRGBClosingFilter.h\"                //彩色模糊，暗色会被提亮\n#import \"GPUImageLanczosResamplingFilter.h\"         //Lanczos重取样，模糊效果\n#import \"GPUImageNonMaximumSuppressionFilter.h\"     //非最大抑制，只显示亮度最高的像素，其他为黑\n#import \"GPUImageThresholdedNonMaximumSuppressionFilter.h\" //与上相比，像素丢失更多\n\n#import \"GPUImageSobelEdgeDetectionFilter.h\"        //Sobel边缘检测算法(白边，黑内容，有点漫画的反色效果)\n#import \"GPUImageCannyEdgeDetectionFilter.h\"        //Canny边缘检测算法（比上更强烈的黑白对比度）\n#import \"GPUImageThresholdEdgeDetectionFilter.h\"    //阈值边缘检测（效果与上差别不大）\n#import \"GPUImagePrewittEdgeDetectionFilter.h\"      //普瑞维特(Prewitt)边缘检测(效果与Sobel差不多，貌似更平滑)\n#import \"GPUImageXYDerivativeFilter.h\"              //XYDerivative边缘检测，画面以蓝色为主，绿色为边缘，带彩色\n#import \"GPUImageHarrisCornerDetectionFilter.h\"     //Harris角点检测，会有绿色小十字显示在图片角点处\n#import \"GPUImageNobleCornerDetectionFilter.h\"      //Noble角点检测，检测点更多\n#import \"GPUImageShiTomasiFeatureDetectionFilter.h\" //ShiTomasi角点检测，与上差别不大\n#import \"GPUImageMotionDetector.h\"                  //动作检测\n#import \"GPUImageHoughTransformLineDetector.h\"      //线条检测\n#import \"GPUImageParallelCoordinateLineTransformFilter.h\" //平行线检测\n\n#import \"GPUImageLocalBinaryPatternFilter.h\"        //图像黑白化，并有大量噪点\n\n#import \"GPUImageLowPassFilter.h\"                   //用于图像加亮\n#import \"GPUImageHighPassFilter.h\"                  //图像低于某值时显示为黑\n\n\n#pragma mark - 视觉效果 Visual Effect\n\n#import \"GPUImageSketchFilter.h\"                    //素描\n#import \"GPUImageThresholdSketchFilter.h\"           //阀值素描，形成有噪点的素描\n#import \"GPUImageToonFilter.h\"                      //卡通效果（黑色粗线描边）\n#import \"GPUImageSmoothToonFilter.h\"                //相比上面的效果更细腻，上面是粗旷的画风\n#import \"GPUImageKuwaharaFilter.h\"                  //桑原(Kuwahara)滤波,水粉画的模糊效果；处理时间比较长，慎用\n\n#import \"GPUImageMosaicFilter.h\"                    //黑白马赛克\n#import \"GPUImagePixellateFilter.h\"                 //像素化\n#import \"GPUImagePolarPixellateFilter.h\"            //同心圆像素化\n#import \"GPUImageCrosshatchFilter.h\"                //交叉线阴影，形成黑白网状画面\n#import \"GPUImageColorPackingFilter.h\"              //色彩丢失，模糊（类似监控摄像效果）\n\n#import \"GPUImageVignetteFilter.h\"                  //晕影，形成黑色圆形边缘，突出中间图像的效果\n#import \"GPUImageSwirlFilter.h\"                     //漩涡，中间形成卷曲的画面\n#import \"GPUImageBulgeDistortionFilter.h\"           //凸起失真，鱼眼效果\n#import \"GPUImagePinchDistortionFilter.h\"           //收缩失真，凹面镜\n#import \"GPUImageStretchDistortionFilter.h\"         //伸展失真，哈哈镜\n#import \"GPUImageGlassSphereFilter.h\"               //水晶球效果\n#import \"GPUImageSphereRefractionFilter.h\"          //球形折射，图形倒立\n\n#import \"GPUImagePosterizeFilter.h\"                 //色调分离，形成噪点效果\n#import \"GPUImageCGAColorspaceFilter.h\"             //CGA色彩滤镜，形成黑、浅蓝、紫色块的画面\n#import \"GPUImagePerlinNoiseFilter.h\"               //柏林噪点，花边噪点\n#import \"GPUImage3x3ConvolutionFilter.h\"            //3x3卷积，高亮大色块变黑，加亮边缘、线条等\n#import \"GPUImageEmbossFilter.h\"                    //浮雕效果，带有点3d的感觉\n#import \"GPUImagePolkaDotFilter.h\"                  //像素圆点花样\n#import \"GPUImageHalftoneFilter.h\"                  //点染,图像黑白化，由黑点构成原图的大致图形\n\n\n#pragma mark - 混合模式 Blend\n\n#import \"GPUImageMultiplyBlendFilter.h\"             //通常用于创建阴影和深度效果\n#import \"GPUImageNormalBlendFilter.h\"               //正常\n#import \"GPUImageAlphaBlendFilter.h\"                //透明混合,通常用于在背景上应用前景的透明度\n#import \"GPUImageDissolveBlendFilter.h\"             //溶解\n#import \"GPUImageOverlayBlendFilter.h\"              //叠加,通常用于创建阴影效果\n#import \"GPUImageDarkenBlendFilter.h\"               //加深混合,通常用于重叠类型\n#import \"GPUImageLightenBlendFilter.h\"              //减淡混合,通常用于重叠类型\n#import \"GPUImageSourceOverBlendFilter.h\"           //源混合\n#import \"GPUImageColorBurnBlendFilter.h\"            //色彩加深混合\n#import \"GPUImageColorDodgeBlendFilter.h\"           //色彩减淡混合\n#import \"GPUImageScreenBlendFilter.h\"               //屏幕包裹,通常用于创建亮点和镜头眩光\n#import \"GPUImageExclusionBlendFilter.h\"            //排除混合\n#import \"GPUImageDifferenceBlendFilter.h\"           //差异混合,通常用于创建更多变动的颜色\n#import \"GPUImageSubtractBlendFilter.h\"             //差值混合,通常用于创建两个图像之间的动画变暗模糊效果\n#import \"GPUImageHardLightBlendFilter.h\"            //强光混合,通常用于创建阴影效果\n#import \"GPUImageSoftLightBlendFilter.h\"            //柔光混合\n#import \"GPUImageChromaKeyBlendFilter.h\"            //色度键混合\n#import \"GPUImageMaskFilter.h\"                      //遮罩混合\n#import \"GPUImageHazeFilter.h\"                      //朦胧加暗\n#import \"GPUImageLuminanceThresholdFilter.h\"        //亮度阈\n#import \"GPUImageAdaptiveThresholdFilter.h\"         //自适应阈值\n#import \"GPUImageAddBlendFilter.h\"                  //通常用于创建两个图像之间的动画变亮模糊效果\n#import \"GPUImageDivideBlendFilter.h\"               //通常用于创建两个图像之间的动画变暗模糊效果\n\n\n#pragma mark - 尚不清楚\n#import \"GPUImageJFAVoroniFilter.h\"\n#import \"GPUImageVoroniConsumerFilter.h\"\ntip8: H264硬编码\n如果使用ijkplayer 使用硬解码, 一句代码即可.\n\n// 开启硬解码\n[option setPlayerOptionValue:@\"1\" forKey:@\"videotoolbox\"];\n\n```\n硬编码的应用场景: 我们要将主播的视频数据传送给服务器\n\n通过摄像头来采集图像，然后将采集到的图像，通过硬编码的方式进行编码，最后编码后的数据将其组合成H264的码流通过网络传播。\n摄像头采集图像, iOS系统提供了AVCaptureSession来采集摄像头的图像数据. 项目中我是直接使用 GPUImage 中的GPUImageVideoCamera, 直接设置GPUImageVideoCamera的代理即可, 在其代理方法- (void)willOutputSampleBuffer:(CMSampleBufferRef)sampleBuffer;进行数据编码即可.\n\n切记一点: 不管是系统自带的AVCaptureSession还是GPUImageVideoCamera采集到的数据都是未经过编码的CMSampleBuffer.\n然后将采集到的数据, 用iOS开放的VideoToolbox进行硬编码. 关于VideoToolbox硬编解码网上很多教程, 当然最好是看Apple的官方文档, 如果只是硬编码, 看我的项目即可.\n\n关键的编码函数(来自YOLO直播负责人的开源项目 BeautifyFaceDemo )\n\n```\n\nvoid didCompressH264(void *outputCallbackRefCon, void *sourceFrameRefCon, OSStatus status, VTEncodeInfoFlags infoFlags,\n                     CMSampleBufferRef sampleBuffer )\n{\n    if (status != 0) return;\n    // 采集的未编码数据是否准备好\n    if (!CMSampleBufferDataIsReady(sampleBuffer))\n    {\n        NSLog(@\"didCompressH264 data is not ready \");\n        return;\n    }\n    ALinH264Encoder* encoder = (__bridge ALinH264Encoder*)outputCallbackRefCon;\n    \n    bool keyframe = !CFDictionaryContainsKey((CFArrayGetValueAtIndex(CMSampleBufferGetSampleAttachmentsArray(sampleBuffer, true), 0)), kCMSampleAttachmentKey_NotSync);\n    \n    if (keyframe) // 关键帧\n    {\n        CMFormatDescriptionRef format = CMSampleBufferGetFormatDescription(sampleBuffer);\n        size_t sparameterSetSize, sparameterSetCount;\n        const uint8_t *sparameterSet;\n        OSStatus statusCode = CMVideoFormatDescriptionGetH264ParameterSetAtIndex(format, 0, &sparameterSet, &sparameterSetSize, &sparameterSetCount, 0 );\n        if (statusCode == noErr)\n        {\n            size_t pparameterSetSize, pparameterSetCount;\n            const uint8_t *pparameterSet;\n            OSStatus statusCode = CMVideoFormatDescriptionGetH264ParameterSetAtIndex(format, 1, &pparameterSet, &pparameterSetSize, &pparameterSetCount, 0 );\n            if (statusCode == noErr)\n            {\n                encoder->sps = [NSData dataWithBytes:sparameterSet length:sparameterSetSize];\n                encoder->pps = [NSData dataWithBytes:pparameterSet length:pparameterSetSize];\n                NSLog(@\"sps:%@ , pps:%@\", encoder->sps, encoder->pps);\n            }\n        }\n    }\n    \n    CMBlockBufferRef dataBuffer = CMSampleBufferGetDataBuffer(sampleBuffer);\n    size_t length, totalLength;\n    char *dataPointer;\n    OSStatus statusCodeRet = CMBlockBufferGetDataPointer(dataBuffer, 0, &length, &totalLength, &dataPointer);\n    if (statusCodeRet == noErr) {\n    \n        size_t bufferOffset = 0;\n        static const int AVCCHeaderLength = 4;\n        while (bufferOffset < totalLength - AVCCHeaderLength)\n        {\n            uint32_t NALUnitLength = 0;\n            memcpy(&NALUnitLength, dataPointer + bufferOffset, AVCCHeaderLength);\n            NALUnitLength = CFSwapInt32BigToHost(NALUnitLength);\n            NSData *data = [[NSData alloc] initWithBytes:(dataPointer + bufferOffset + AVCCHeaderLength) length:NALUnitLength];\n            bufferOffset += AVCCHeaderLength + NALUnitLength;\n            NSLog(@\"sendData-->> %@ %lu\", data, bufferOffset);\n        }\n    \n    }\n\n```\n\n\n\n","source":"_posts/基于-ijkplayer-的iOS视频直播推流仿写.md","raw":"---\ntitle: 基于 ijkplayer 的iOS视频直播推流仿写\ntags: ' - 转载'\npermalink: osshi-pin-zhi-bo-fang\nid: 27\nupdated: '2016-08-11 00:05:29'\ndate: 2016-07-07 11:39:36\n---\n\n\n\n视频直播，可以分为 采集，前处理，编码，传输, 服务器处理，解码，渲染\n\n采集: iOS系统因为软硬件种类不多, 硬件适配性比较好, 所以比较简单. 而Android端市面上机型众多, 要做些机型的适配工作.PC端是最麻烦的, 各种奇葩摄像头驱动.所以现在很多的中小型直播平台, 都放弃了PC的直播, 更有一些直播平台只做iOS端的视频直播.\n\n前处理: 美颜算法,视频的模糊效果, 水印等都是在这个环节做. 目前iOS端最著名开源框架的毫无疑问就是GPUImage.其中内置了125种渲染效果, 还支持各种脚本自定义. 我高仿的喵播的美颜效果也是基于GPUImage的.\n\n编码: 重难点在于要在分辨率，帧率，码率，GOP等参数设计上找到最佳平衡点。iOS8之后, Apple开放了VideoToolbox.framework, 可以直接进行硬编解码, 这也是为什么现在大多数直播平台最低只支持到iOS8的原因之一. iOS端硬件兼容性比较好, 可以直接采取硬编码. 而Android得硬编码又是一大坑.\n\n传输: 这块一般都是交给CDN服务商. CDN只提供带宽和服务器之间的传输, 发送端和接收端的网络连接抖动缓存还是要自己实现的.目前国内最大的CDN服务商应该是网宿.\n\n服务器处理: 需要在服务器做一些流处理工作, 让推送上来的流适配各个平台各种不同的协议, 比如:RTMP,HLS,FLV...\n\n解码和渲染: 也就即音视频的播放. 解码毫无疑问也必须要硬解码. iOS端兼容较好, Android依然大坑.这块的难点在于音画同步, 目前很多直播平台这块是硬伤.国内比较好的开源项目应该是B站开源的ijkplayer . 斗鱼就是基于ijkplayer 的, 本项目也是基于ijkplayer 的.\n\n技术坑 : 降噪, 音频解码器, 蓝牙适配, 回声消除, 信令控制, 登录, 鉴权, 权限管理, 状态管理, 应用消息, 消息推送, 礼物系统, 即时聊天, 支付系统, 统计系统, 数据库, 缓存, 分布式文件存储, 消息队列, 运维系统等等大小不一的坑等你来填!!!\n\n\n<!------MORE------->\n\n\n资金坑 : 以带宽为例, 2万人同时在线, 手机码率在600KB, 每个月的带宽费用至少在30万左右. 根据欢聚时代(YY)15年四季度财务报, 他们的带宽成本为人民币1.611亿元, 折合每月5000万+. 人力成本+渠道支出和其他支出就不详谈了.\n\n社会坑: 还得每时每刻与各种黑暗势力斗争, 包括色情, 广告, 刷小号, 刷充值, 告侵权, DDos...\n\n\n前期准备\n项目主要是基于ijkplayer 的. 最好是打包成framework. 原本我准备写一个打包教程, 不过后来在简书上发现了一篇特别详细的打包blog, 分享给大家: [http://www.jianshu.com/p/1f06b27b3ac0](http://)\n\nProfile : 个人中心, 这里面只有一个ProfileController. 因为总写重复代码, 都写吐了, 这儿有兴趣的自己写一下吧, So easy...\n\nNetwork : 关于网络连接的工具类. 关于网络的实时监控, 网络状态的切换, 网络请求的工具类都在这里面.\n\nOther : 全局的常量. 当然你也可以在里面将文件结构更加细化.\n\nHome : 包含最新主播, 最热直播, 关注的直播, 礼物排行榜等模块. 还有最重要的视频直播也在这里面了.\n\nShowTime :见名知意. 视频直播的前处理, 智能美颜和H264硬编码等都在这里面.\n\nMain : UITabBarController和UINavigationController的配置\n\nToos : 这儿命名有点不规范, 这里面放置的都是项目用到的分类\n\nLogin : 登录模块\n\nResource : 项目用到的资源文件\n\n项目详解\ntip1: 判读网络类型.\n\n在观看直播的时候, 我们通常都是用WiFi或者3/4G(土豪级别的), 一般用户在进行网络切换的时候, 我们都要给出友善的提示, 告诉TA: 您的网络状态切换到了XX状态. 假设用户从WiFi切换到4G, 你的应用也没个提醒, 导致TA的流量归零甚至欠了运营商一屁股的钱, 我想你的APP的用户体验也就归零或者为负了.\n我们可以使用苹果的Reachability结合下面的代码实时监听网络状态的改变\n```\ntypedef NS_ENUM(NSUInteger, NetworkStates) {\n    NetworkStatesNone, // 没有网络\n    NetworkStates2G, // 2G\n    NetworkStates3G, // 3G\n    NetworkStates4G, // 4G\n    NetworkStatesWIFI // WIFI\n};\n// 判断网络类型\n+ (NetworkStates)getNetworkStates\n  {\n    NSArray *subviews = [[[[UIApplication sharedApplication] valueForKeyPath:@\"statusBar\"] valueForKeyPath:@\"foregroundView\"] subviews];\n    // 保存网络状态\n    NetworkStates states = NetworkStatesNone;\n    for (id child in subviews) {\n        if ([child isKindOfClass:NSClassFromString(@\"UIStatusBarDataNetworkItemView\")]) {\n            //获取到状态栏码\n            int networkType = [[child valueForKeyPath:@\"dataNetworkType\"] intValue];\n            switch (networkType) {\n                case 0:\n                   //无网模式\n                    states = NetworkStatesNone;\n                    break;\n                case 1:\n                    states = NetworkStates2G;\n                    break;\n                case 2:\n                    states = NetworkStates3G;\n                    break;\n                case 3:\n                    states = NetworkStates4G;\n                    break;\n                case 5:\n                {\n                    states = NetworkStatesWIFI;\n                }\n                    break;\n                default:\n                    break;\n            }\n        }\n    }\n    //根据状态选择\n    return states;\n  }\n  tip2: 登录模块\n```\n如果你多运行几次就会发现, 登录模块背景中播放的视频是2个视频每次随机播放一个的.并且是无限重复的, 也就是说只要你一直呆着登录界面, 就会单视频循环播放当前的视频. 这儿的登录只是几个按钮, 没有具体的登录逻辑, 随便点哪一个按钮都可以进入首页.\n我们需要监听视频, 是否播放完成.\n```\n// 监听视频是否播放完成\n  [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(didFinish) name:IJKMPMoviePlayerPlaybackDidFinishNotification object:nil];\n如果播放完成了, 让IJKFFMoviePlayerController再次play即可\n\n- (void)didFinish\n  {\n    // 播放完之后, 继续重播\n    [self.player play];\n  }\n  tip3: 首页\n```\n首页\n\n这种效果相信很多人都看到过或者做过.我简单说一下我的做法(不一定是最佳的, 只是提供一个思路)\n\n一个父控制器HomeViewController+三个子控制器(最热/最新/关注. 每个控制器各自管理自己的业务逻辑, 高内聚低耦合). 重写HomeViewController的loadView, 将self.view替换成UIScrollView. 将三个子控制器的view添加到UIScrollView上即可. 其他的效果实现, 请参照我的代码, 都有详细的中文注释.\ntip4: 直播(面向观众端)\n这个是整个项目的重点之一了.这种直播的布局, 应该是比较主流的了. 我下载的好多直播类APP都是这个项目布局, 包括YY也是这种界面布局.这个里面涉及的东西比较多了, 三言两语真说不清.\n\n简单说一下已经实现的效果:\nA: 主播的直播\nB: 关联主播的视频直播, 默认是只有界面, 没有声音的. 点击该视图可以切换到此主播\nC: 下拉切换另一个主播, 这个功能是很常见的. 做法是直播控制器是一个UICollectionViewController, 只有一个cell, 且cell.frame就是self.collectionViewb.bounds. 我们进入直播控制器的时候, 其实是传进去一个关联主播数组, 每次下拉的时候, 就加载数组里面的主播\nD. 查看观众席的观众详情\nE. 查看主播详情\nF. 足迹: 粒子动画, 后面详解\nG. 弹幕: 点击最下方的工具栏第一个按钮可以开启/关闭弹幕, 后面详解\n...\ntip5: 粒子动画实现游客足迹\n粒子动画的layer是添加到播放器的view上面的. 下面代码有详细的注释\n```\nCAEmitterLayer *emitterLayer = [CAEmitterLayer layer];\n// 发射器在xy平面的中心位置\nemitterLayer.emitterPosition = CGPointMake(self.moviePlayer.view.frame.size.width-50,self.moviePlayer.view.frame.size.height-50);\n// 发射器的尺寸大小\nemitterLayer.emitterSize = CGSizeMake(20, 20);\n// 渲染模式\nemitterLayer.renderMode = kCAEmitterLayerUnordered;\n// 开启三维效果\n//    _emitterLayer.preservesDepth = YES;\nNSMutableArray *array = [NSMutableArray array];\n// 创建粒子\nfor (int i = 0; i<10; i++) {\n    // 发射单元\n    CAEmitterCell *stepCell = [CAEmitterCell emitterCell];\n    // 粒子的创建速率，默认为1/s\n    stepCell.birthRate = 1;\n    // 粒子存活时间\n    stepCell.lifetime = arc4random_uniform(4) + 1;\n    // 粒子的生存时间容差\n    stepCell.lifetimeRange = 1.5;\n    // 颜色\n    // fire.color=[[UIColor colorWithRed:0.8 green:0.4 blue:0.2 alpha:0.1]CGColor];\n    UIImage *image = [UIImage imageNamed:[NSString stringWithFormat:@\"good%d_30x30\", i]];\n    // 粒子显示的内容\n    stepCell.contents = (id)[image CGImage];\n    // 粒子的名字\n    //            [fire setName:@\"step%d\", i];\n    // 粒子的运动速度\n    stepCell.velocity = arc4random_uniform(100) + 100;\n    // 粒子速度的容差\n    stepCell.velocityRange = 80;\n    // 粒子在xy平面的发射角度\n    stepCell.emissionLongitude = M_PI+M_PI_2;;\n    // 粒子发射角度的容差\n    stepCell.emissionRange = M_PI_2/6;\n    // 缩放比例\n    stepCell.scale = 0.3;\n    [array addObject:stepCell];\n}\n\nemitterLayer.emitterCells = array;\n[self.moviePlayer.view.layer insertSublayer:emitterLayer below:self.catEarView.layer];\ntip6: 弹幕\n弹幕使用的也是一个第三方轮子BarrageRenderer . 这个开源项目的文档都是中文的, 用法也是很简单的.\n\n基本配置\n\n_renderer = [[BarrageRenderer alloc] init];\n// 设置弹幕的显示区域. 基于父控件的.\n_renderer.canvasMargin = UIEdgeInsetsMake(ALinScreenHeight * 0.3, 10, 10, 10);\n[self.contentView addSubview:_renderer.view];\n弹幕配置\n\n#pragma mark - 弹幕描述符生产方法\n/// 生成精灵描述 - 过场文字弹幕\n- (BarrageDescriptor *)walkTextSpriteDescriptorWithDirection:(NSInteger)direction\n  {\n    BarrageDescriptor * descriptor = [[BarrageDescriptor alloc]init];\n    descriptor.spriteName = NSStringFromClass([BarrageWalkTextSprite class]);\n    descriptor.params[@\"text\"] = self.danMuText[arc4random_uniform((uint32_t)self.danMuText.count)];\n    descriptor.params[@\"textColor\"] = Color(arc4random_uniform(256), arc4random_uniform(256), arc4random_uniform(256));\n    descriptor.params[@\"speed\"] = @(100 * (double)random()/RAND_MAX+50);\n    descriptor.params[@\"direction\"] = @(direction);\n    descriptor.params[@\"clickAction\"] = ^{\n        UIAlertView *alertView = [[UIAlertView alloc]initWithTitle:@\"提示\" message:@\"弹幕被点击\" delegate:nil cancelButtonTitle:@\"取消\" otherButtonTitles:nil];\n        [alertView show];\n    };\n    return descriptor;\n  }\n  最后一步, 千万要记得start\n\n[_renderer start];\n```\n\ntip7: 智能美颜效果\n现在的直播平台, 美颜是标配. 不然绝大多数的主播都是没法看的.美颜算法需要用到GPU编程, 需要懂图像处理的人. 图像处理这一块我不是很熟悉, 相关的文献也是看得云里雾里的. 所以, 依然使用开源的轮子: GPUImage . 这个开源框架有近1.3W+star(7月5日数据), 真不是盖的, 内置125种滤镜效果, 没有你想不到, 只有你不会用. 我的项目中都有详细的用法, 还是很简单的. 在这里摘抄一份其.h文件的注释. 一方面方便大家修改我项目中的美颜效果, 另一方面也是做个备份.(具体出处我真忘了, 如果有人找到了源地址链接, 可以联系我加上)\n\n```\n#import \"GLProgram.h\"\n\n// Base classes\n#import \"GPUImageOpenGLESContext.h\"\n#import \"GPUImageOutput.h\"\n#import \"GPUImageView.h\"\n#import \"GPUImageVideoCamera.h\"\n#import \"GPUImageStillCamera.h\"\n#import \"GPUImageMovie.h\"\n#import \"GPUImagePicture.h\"\n#import \"GPUImageRawDataInput.h\"\n#import \"GPUImageRawDataOutput.h\"\n#import \"GPUImageMovieWriter.h\"\n#import \"GPUImageFilterPipeline.h\"\n#import \"GPUImageTextureOutput.h\"\n#import \"GPUImageFilterGroup.h\"\n#import \"GPUImageTextureInput.h\"\n#import \"GPUImageUIElement.h\"\n#import \"GPUImageBuffer.h\"\n\n// Filters\n#import \"GPUImageFilter.h\"\n#import \"GPUImageTwoInputFilter.h\"\n\n\n#pragma mark - 调整颜色 Handle Color\n\n#import \"GPUImageBrightnessFilter.h\"                //亮度\n#import \"GPUImageExposureFilter.h\"                  //曝光\n#import \"GPUImageContrastFilter.h\"                  //对比度\n#import \"GPUImageSaturationFilter.h\"                //饱和度\n#import \"GPUImageGammaFilter.h\"                     //伽马线\n#import \"GPUImageColorInvertFilter.h\"               //反色\n#import \"GPUImageSepiaFilter.h\"                     //褐色（怀旧）\n#import \"GPUImageLevelsFilter.h\"                    //色阶\n#import \"GPUImageGrayscaleFilter.h\"                 //灰度\n#import \"GPUImageHistogramFilter.h\"                 //色彩直方图，显示在图片上\n#import \"GPUImageHistogramGenerator.h\"              //色彩直方图\n#import \"GPUImageRGBFilter.h\"                       //RGB\n#import \"GPUImageToneCurveFilter.h\"                 //色调曲线\n#import \"GPUImageMonochromeFilter.h\"                //单色\n#import \"GPUImageOpacityFilter.h\"                   //不透明度\n#import \"GPUImageHighlightShadowFilter.h\"           //提亮阴影\n#import \"GPUImageFalseColorFilter.h\"                //色彩替换（替换亮部和暗部色彩）\n#import \"GPUImageHueFilter.h\"                       //色度\n#import \"GPUImageChromaKeyFilter.h\"                 //色度键\n#import \"GPUImageWhiteBalanceFilter.h\"              //白平横\n#import \"GPUImageAverageColor.h\"                    //像素平均色值\n#import \"GPUImageSolidColorGenerator.h\"             //纯色\n#import \"GPUImageLuminosity.h\"                      //亮度平均\n#import \"GPUImageAverageLuminanceThresholdFilter.h\" //像素色值亮度平均，图像黑白（有类似漫画效果）\n\n#import \"GPUImageLookupFilter.h\"                    //lookup 色彩调整\n#import \"GPUImageAmatorkaFilter.h\"                  //Amatorka lookup\n#import \"GPUImageMissEtikateFilter.h\"               //MissEtikate lookup\n#import \"GPUImageSoftEleganceFilter.h\"              //SoftElegance lookup\n\n\n\n\n#pragma mark - 图像处理 Handle Image\n\n#import \"GPUImageCrosshairGenerator.h\"              //十字\n#import \"GPUImageLineGenerator.h\"                   //线条\n\n#import \"GPUImageTransformFilter.h\"                 //形状变化\n#import \"GPUImageCropFilter.h\"                      //剪裁\n#import \"GPUImageSharpenFilter.h\"                   //锐化\n#import \"GPUImageUnsharpMaskFilter.h\"               //反遮罩锐化\n\n#import \"GPUImageFastBlurFilter.h\"                  //模糊\n#import \"GPUImageGaussianBlurFilter.h\"              //高斯模糊\n#import \"GPUImageGaussianSelectiveBlurFilter.h\"     //高斯模糊，选择部分清晰\n#import \"GPUImageBoxBlurFilter.h\"                   //盒状模糊\n#import \"GPUImageTiltShiftFilter.h\"                 //条纹模糊，中间清晰，上下两端模糊\n#import \"GPUImageMedianFilter.h\"                    //中间值，有种稍微模糊边缘的效果\n#import \"GPUImageBilateralFilter.h\"                 //双边模糊\n#import \"GPUImageErosionFilter.h\"                   //侵蚀边缘模糊，变黑白\n#import \"GPUImageRGBErosionFilter.h\"                //RGB侵蚀边缘模糊，有色彩\n#import \"GPUImageDilationFilter.h\"                  //扩展边缘模糊，变黑白\n#import \"GPUImageRGBDilationFilter.h\"               //RGB扩展边缘模糊，有色彩\n#import \"GPUImageOpeningFilter.h\"                   //黑白色调模糊\n#import \"GPUImageRGBOpeningFilter.h\"                //彩色模糊\n#import \"GPUImageClosingFilter.h\"                   //黑白色调模糊，暗色会被提亮\n#import \"GPUImageRGBClosingFilter.h\"                //彩色模糊，暗色会被提亮\n#import \"GPUImageLanczosResamplingFilter.h\"         //Lanczos重取样，模糊效果\n#import \"GPUImageNonMaximumSuppressionFilter.h\"     //非最大抑制，只显示亮度最高的像素，其他为黑\n#import \"GPUImageThresholdedNonMaximumSuppressionFilter.h\" //与上相比，像素丢失更多\n\n#import \"GPUImageSobelEdgeDetectionFilter.h\"        //Sobel边缘检测算法(白边，黑内容，有点漫画的反色效果)\n#import \"GPUImageCannyEdgeDetectionFilter.h\"        //Canny边缘检测算法（比上更强烈的黑白对比度）\n#import \"GPUImageThresholdEdgeDetectionFilter.h\"    //阈值边缘检测（效果与上差别不大）\n#import \"GPUImagePrewittEdgeDetectionFilter.h\"      //普瑞维特(Prewitt)边缘检测(效果与Sobel差不多，貌似更平滑)\n#import \"GPUImageXYDerivativeFilter.h\"              //XYDerivative边缘检测，画面以蓝色为主，绿色为边缘，带彩色\n#import \"GPUImageHarrisCornerDetectionFilter.h\"     //Harris角点检测，会有绿色小十字显示在图片角点处\n#import \"GPUImageNobleCornerDetectionFilter.h\"      //Noble角点检测，检测点更多\n#import \"GPUImageShiTomasiFeatureDetectionFilter.h\" //ShiTomasi角点检测，与上差别不大\n#import \"GPUImageMotionDetector.h\"                  //动作检测\n#import \"GPUImageHoughTransformLineDetector.h\"      //线条检测\n#import \"GPUImageParallelCoordinateLineTransformFilter.h\" //平行线检测\n\n#import \"GPUImageLocalBinaryPatternFilter.h\"        //图像黑白化，并有大量噪点\n\n#import \"GPUImageLowPassFilter.h\"                   //用于图像加亮\n#import \"GPUImageHighPassFilter.h\"                  //图像低于某值时显示为黑\n\n\n#pragma mark - 视觉效果 Visual Effect\n\n#import \"GPUImageSketchFilter.h\"                    //素描\n#import \"GPUImageThresholdSketchFilter.h\"           //阀值素描，形成有噪点的素描\n#import \"GPUImageToonFilter.h\"                      //卡通效果（黑色粗线描边）\n#import \"GPUImageSmoothToonFilter.h\"                //相比上面的效果更细腻，上面是粗旷的画风\n#import \"GPUImageKuwaharaFilter.h\"                  //桑原(Kuwahara)滤波,水粉画的模糊效果；处理时间比较长，慎用\n\n#import \"GPUImageMosaicFilter.h\"                    //黑白马赛克\n#import \"GPUImagePixellateFilter.h\"                 //像素化\n#import \"GPUImagePolarPixellateFilter.h\"            //同心圆像素化\n#import \"GPUImageCrosshatchFilter.h\"                //交叉线阴影，形成黑白网状画面\n#import \"GPUImageColorPackingFilter.h\"              //色彩丢失，模糊（类似监控摄像效果）\n\n#import \"GPUImageVignetteFilter.h\"                  //晕影，形成黑色圆形边缘，突出中间图像的效果\n#import \"GPUImageSwirlFilter.h\"                     //漩涡，中间形成卷曲的画面\n#import \"GPUImageBulgeDistortionFilter.h\"           //凸起失真，鱼眼效果\n#import \"GPUImagePinchDistortionFilter.h\"           //收缩失真，凹面镜\n#import \"GPUImageStretchDistortionFilter.h\"         //伸展失真，哈哈镜\n#import \"GPUImageGlassSphereFilter.h\"               //水晶球效果\n#import \"GPUImageSphereRefractionFilter.h\"          //球形折射，图形倒立\n\n#import \"GPUImagePosterizeFilter.h\"                 //色调分离，形成噪点效果\n#import \"GPUImageCGAColorspaceFilter.h\"             //CGA色彩滤镜，形成黑、浅蓝、紫色块的画面\n#import \"GPUImagePerlinNoiseFilter.h\"               //柏林噪点，花边噪点\n#import \"GPUImage3x3ConvolutionFilter.h\"            //3x3卷积，高亮大色块变黑，加亮边缘、线条等\n#import \"GPUImageEmbossFilter.h\"                    //浮雕效果，带有点3d的感觉\n#import \"GPUImagePolkaDotFilter.h\"                  //像素圆点花样\n#import \"GPUImageHalftoneFilter.h\"                  //点染,图像黑白化，由黑点构成原图的大致图形\n\n\n#pragma mark - 混合模式 Blend\n\n#import \"GPUImageMultiplyBlendFilter.h\"             //通常用于创建阴影和深度效果\n#import \"GPUImageNormalBlendFilter.h\"               //正常\n#import \"GPUImageAlphaBlendFilter.h\"                //透明混合,通常用于在背景上应用前景的透明度\n#import \"GPUImageDissolveBlendFilter.h\"             //溶解\n#import \"GPUImageOverlayBlendFilter.h\"              //叠加,通常用于创建阴影效果\n#import \"GPUImageDarkenBlendFilter.h\"               //加深混合,通常用于重叠类型\n#import \"GPUImageLightenBlendFilter.h\"              //减淡混合,通常用于重叠类型\n#import \"GPUImageSourceOverBlendFilter.h\"           //源混合\n#import \"GPUImageColorBurnBlendFilter.h\"            //色彩加深混合\n#import \"GPUImageColorDodgeBlendFilter.h\"           //色彩减淡混合\n#import \"GPUImageScreenBlendFilter.h\"               //屏幕包裹,通常用于创建亮点和镜头眩光\n#import \"GPUImageExclusionBlendFilter.h\"            //排除混合\n#import \"GPUImageDifferenceBlendFilter.h\"           //差异混合,通常用于创建更多变动的颜色\n#import \"GPUImageSubtractBlendFilter.h\"             //差值混合,通常用于创建两个图像之间的动画变暗模糊效果\n#import \"GPUImageHardLightBlendFilter.h\"            //强光混合,通常用于创建阴影效果\n#import \"GPUImageSoftLightBlendFilter.h\"            //柔光混合\n#import \"GPUImageChromaKeyBlendFilter.h\"            //色度键混合\n#import \"GPUImageMaskFilter.h\"                      //遮罩混合\n#import \"GPUImageHazeFilter.h\"                      //朦胧加暗\n#import \"GPUImageLuminanceThresholdFilter.h\"        //亮度阈\n#import \"GPUImageAdaptiveThresholdFilter.h\"         //自适应阈值\n#import \"GPUImageAddBlendFilter.h\"                  //通常用于创建两个图像之间的动画变亮模糊效果\n#import \"GPUImageDivideBlendFilter.h\"               //通常用于创建两个图像之间的动画变暗模糊效果\n\n\n#pragma mark - 尚不清楚\n#import \"GPUImageJFAVoroniFilter.h\"\n#import \"GPUImageVoroniConsumerFilter.h\"\ntip8: H264硬编码\n如果使用ijkplayer 使用硬解码, 一句代码即可.\n\n// 开启硬解码\n[option setPlayerOptionValue:@\"1\" forKey:@\"videotoolbox\"];\n\n```\n硬编码的应用场景: 我们要将主播的视频数据传送给服务器\n\n通过摄像头来采集图像，然后将采集到的图像，通过硬编码的方式进行编码，最后编码后的数据将其组合成H264的码流通过网络传播。\n摄像头采集图像, iOS系统提供了AVCaptureSession来采集摄像头的图像数据. 项目中我是直接使用 GPUImage 中的GPUImageVideoCamera, 直接设置GPUImageVideoCamera的代理即可, 在其代理方法- (void)willOutputSampleBuffer:(CMSampleBufferRef)sampleBuffer;进行数据编码即可.\n\n切记一点: 不管是系统自带的AVCaptureSession还是GPUImageVideoCamera采集到的数据都是未经过编码的CMSampleBuffer.\n然后将采集到的数据, 用iOS开放的VideoToolbox进行硬编码. 关于VideoToolbox硬编解码网上很多教程, 当然最好是看Apple的官方文档, 如果只是硬编码, 看我的项目即可.\n\n关键的编码函数(来自YOLO直播负责人的开源项目 BeautifyFaceDemo )\n\n```\n\nvoid didCompressH264(void *outputCallbackRefCon, void *sourceFrameRefCon, OSStatus status, VTEncodeInfoFlags infoFlags,\n                     CMSampleBufferRef sampleBuffer )\n{\n    if (status != 0) return;\n    // 采集的未编码数据是否准备好\n    if (!CMSampleBufferDataIsReady(sampleBuffer))\n    {\n        NSLog(@\"didCompressH264 data is not ready \");\n        return;\n    }\n    ALinH264Encoder* encoder = (__bridge ALinH264Encoder*)outputCallbackRefCon;\n    \n    bool keyframe = !CFDictionaryContainsKey((CFArrayGetValueAtIndex(CMSampleBufferGetSampleAttachmentsArray(sampleBuffer, true), 0)), kCMSampleAttachmentKey_NotSync);\n    \n    if (keyframe) // 关键帧\n    {\n        CMFormatDescriptionRef format = CMSampleBufferGetFormatDescription(sampleBuffer);\n        size_t sparameterSetSize, sparameterSetCount;\n        const uint8_t *sparameterSet;\n        OSStatus statusCode = CMVideoFormatDescriptionGetH264ParameterSetAtIndex(format, 0, &sparameterSet, &sparameterSetSize, &sparameterSetCount, 0 );\n        if (statusCode == noErr)\n        {\n            size_t pparameterSetSize, pparameterSetCount;\n            const uint8_t *pparameterSet;\n            OSStatus statusCode = CMVideoFormatDescriptionGetH264ParameterSetAtIndex(format, 1, &pparameterSet, &pparameterSetSize, &pparameterSetCount, 0 );\n            if (statusCode == noErr)\n            {\n                encoder->sps = [NSData dataWithBytes:sparameterSet length:sparameterSetSize];\n                encoder->pps = [NSData dataWithBytes:pparameterSet length:pparameterSetSize];\n                NSLog(@\"sps:%@ , pps:%@\", encoder->sps, encoder->pps);\n            }\n        }\n    }\n    \n    CMBlockBufferRef dataBuffer = CMSampleBufferGetDataBuffer(sampleBuffer);\n    size_t length, totalLength;\n    char *dataPointer;\n    OSStatus statusCodeRet = CMBlockBufferGetDataPointer(dataBuffer, 0, &length, &totalLength, &dataPointer);\n    if (statusCodeRet == noErr) {\n    \n        size_t bufferOffset = 0;\n        static const int AVCCHeaderLength = 4;\n        while (bufferOffset < totalLength - AVCCHeaderLength)\n        {\n            uint32_t NALUnitLength = 0;\n            memcpy(&NALUnitLength, dataPointer + bufferOffset, AVCCHeaderLength);\n            NALUnitLength = CFSwapInt32BigToHost(NALUnitLength);\n            NSData *data = [[NSData alloc] initWithBytes:(dataPointer + bufferOffset + AVCCHeaderLength) length:NALUnitLength];\n            bufferOffset += AVCCHeaderLength + NALUnitLength;\n            NSLog(@\"sendData-->> %@ %lu\", data, bufferOffset);\n        }\n    \n    }\n\n```\n\n\n\n","slug":"osshi-pin-zhi-bo-fang","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cj04pzyyf001ds04euho7mpva","content":"<p>视频直播，可以分为 采集，前处理，编码，传输, 服务器处理，解码，渲染</p>\n<p>采集: iOS系统因为软硬件种类不多, 硬件适配性比较好, 所以比较简单. 而Android端市面上机型众多, 要做些机型的适配工作.PC端是最麻烦的, 各种奇葩摄像头驱动.所以现在很多的中小型直播平台, 都放弃了PC的直播, 更有一些直播平台只做iOS端的视频直播.</p>\n<p>前处理: 美颜算法,视频的模糊效果, 水印等都是在这个环节做. 目前iOS端最著名开源框架的毫无疑问就是GPUImage.其中内置了125种渲染效果, 还支持各种脚本自定义. 我高仿的喵播的美颜效果也是基于GPUImage的.</p>\n<p>编码: 重难点在于要在分辨率，帧率，码率，GOP等参数设计上找到最佳平衡点。iOS8之后, Apple开放了VideoToolbox.framework, 可以直接进行硬编解码, 这也是为什么现在大多数直播平台最低只支持到iOS8的原因之一. iOS端硬件兼容性比较好, 可以直接采取硬编码. 而Android得硬编码又是一大坑.</p>\n<p>传输: 这块一般都是交给CDN服务商. CDN只提供带宽和服务器之间的传输, 发送端和接收端的网络连接抖动缓存还是要自己实现的.目前国内最大的CDN服务商应该是网宿.</p>\n<p>服务器处理: 需要在服务器做一些流处理工作, 让推送上来的流适配各个平台各种不同的协议, 比如:RTMP,HLS,FLV…</p>\n<p>解码和渲染: 也就即音视频的播放. 解码毫无疑问也必须要硬解码. iOS端兼容较好, Android依然大坑.这块的难点在于音画同步, 目前很多直播平台这块是硬伤.国内比较好的开源项目应该是B站开源的ijkplayer . 斗鱼就是基于ijkplayer 的, 本项目也是基于ijkplayer 的.</p>\n<p>技术坑 : 降噪, 音频解码器, 蓝牙适配, 回声消除, 信令控制, 登录, 鉴权, 权限管理, 状态管理, 应用消息, 消息推送, 礼物系统, 即时聊天, 支付系统, 统计系统, 数据库, 缓存, 分布式文件存储, 消息队列, 运维系统等等大小不一的坑等你来填!!!</p>\n<a id=\"more\"></a>\n<p>资金坑 : 以带宽为例, 2万人同时在线, 手机码率在600KB, 每个月的带宽费用至少在30万左右. 根据欢聚时代(YY)15年四季度财务报, 他们的带宽成本为人民币1.611亿元, 折合每月5000万+. 人力成本+渠道支出和其他支出就不详谈了.</p>\n<p>社会坑: 还得每时每刻与各种黑暗势力斗争, 包括色情, 广告, 刷小号, 刷充值, 告侵权, DDos…</p>\n<p>前期准备<br>项目主要是基于ijkplayer 的. 最好是打包成framework. 原本我准备写一个打包教程, 不过后来在简书上发现了一篇特别详细的打包blog, 分享给大家: <a href=\"http://\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/p/1f06b27b3ac0</a></p>\n<p>Profile : 个人中心, 这里面只有一个ProfileController. 因为总写重复代码, 都写吐了, 这儿有兴趣的自己写一下吧, So easy…</p>\n<p>Network : 关于网络连接的工具类. 关于网络的实时监控, 网络状态的切换, 网络请求的工具类都在这里面.</p>\n<p>Other : 全局的常量. 当然你也可以在里面将文件结构更加细化.</p>\n<p>Home : 包含最新主播, 最热直播, 关注的直播, 礼物排行榜等模块. 还有最重要的视频直播也在这里面了.</p>\n<p>ShowTime :见名知意. 视频直播的前处理, 智能美颜和H264硬编码等都在这里面.</p>\n<p>Main : UITabBarController和UINavigationController的配置</p>\n<p>Toos : 这儿命名有点不规范, 这里面放置的都是项目用到的分类</p>\n<p>Login : 登录模块</p>\n<p>Resource : 项目用到的资源文件</p>\n<p>项目详解<br>tip1: 判读网络类型.</p>\n<p>在观看直播的时候, 我们通常都是用WiFi或者3/4G(土豪级别的), 一般用户在进行网络切换的时候, 我们都要给出友善的提示, 告诉TA: 您的网络状态切换到了XX状态. 假设用户从WiFi切换到4G, 你的应用也没个提醒, 导致TA的流量归零甚至欠了运营商一屁股的钱, 我想你的APP的用户体验也就归零或者为负了.<br>我们可以使用苹果的Reachability结合下面的代码实时监听网络状态的改变<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\">typedef NS_ENUM(NSUInteger, NetworkStates) &#123;</div><div class=\"line\">    NetworkStatesNone, // 没有网络</div><div class=\"line\">    NetworkStates2G, // 2G</div><div class=\"line\">    NetworkStates3G, // 3G</div><div class=\"line\">    NetworkStates4G, // 4G</div><div class=\"line\">    NetworkStatesWIFI // WIFI</div><div class=\"line\">&#125;;</div><div class=\"line\">// 判断网络类型</div><div class=\"line\">+ (NetworkStates)getNetworkStates</div><div class=\"line\">  &#123;</div><div class=\"line\">    NSArray *subviews = [[[[UIApplication sharedApplication] valueForKeyPath:@&quot;statusBar&quot;] valueForKeyPath:@&quot;foregroundView&quot;] subviews];</div><div class=\"line\">    // 保存网络状态</div><div class=\"line\">    NetworkStates states = NetworkStatesNone;</div><div class=\"line\">    for (id child in subviews) &#123;</div><div class=\"line\">        if ([child isKindOfClass:NSClassFromString(@&quot;UIStatusBarDataNetworkItemView&quot;)]) &#123;</div><div class=\"line\">            //获取到状态栏码</div><div class=\"line\">            int networkType = [[child valueForKeyPath:@&quot;dataNetworkType&quot;] intValue];</div><div class=\"line\">            switch (networkType) &#123;</div><div class=\"line\">                case 0:</div><div class=\"line\">                   //无网模式</div><div class=\"line\">                    states = NetworkStatesNone;</div><div class=\"line\">                    break;</div><div class=\"line\">                case 1:</div><div class=\"line\">                    states = NetworkStates2G;</div><div class=\"line\">                    break;</div><div class=\"line\">                case 2:</div><div class=\"line\">                    states = NetworkStates3G;</div><div class=\"line\">                    break;</div><div class=\"line\">                case 3:</div><div class=\"line\">                    states = NetworkStates4G;</div><div class=\"line\">                    break;</div><div class=\"line\">                case 5:</div><div class=\"line\">                &#123;</div><div class=\"line\">                    states = NetworkStatesWIFI;</div><div class=\"line\">                &#125;</div><div class=\"line\">                    break;</div><div class=\"line\">                default:</div><div class=\"line\">                    break;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    //根据状态选择</div><div class=\"line\">    return states;</div><div class=\"line\">  &#125;</div><div class=\"line\">  tip2: 登录模块</div></pre></td></tr></table></figure></p>\n<p>如果你多运行几次就会发现, 登录模块背景中播放的视频是2个视频每次随机播放一个的.并且是无限重复的, 也就是说只要你一直呆着登录界面, 就会单视频循环播放当前的视频. 这儿的登录只是几个按钮, 没有具体的登录逻辑, 随便点哪一个按钮都可以进入首页.<br>我们需要监听视频, 是否播放完成.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 监听视频是否播放完成</div><div class=\"line\">  [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(didFinish) name:IJKMPMoviePlayerPlaybackDidFinishNotification object:nil];</div><div class=\"line\">如果播放完成了, 让IJKFFMoviePlayerController再次play即可</div><div class=\"line\"></div><div class=\"line\">- (void)didFinish</div><div class=\"line\">  &#123;</div><div class=\"line\">    // 播放完之后, 继续重播</div><div class=\"line\">    [self.player play];</div><div class=\"line\">  &#125;</div><div class=\"line\">  tip3: 首页</div></pre></td></tr></table></figure></p>\n<p>首页</p>\n<p>这种效果相信很多人都看到过或者做过.我简单说一下我的做法(不一定是最佳的, 只是提供一个思路)</p>\n<p>一个父控制器HomeViewController+三个子控制器(最热/最新/关注. 每个控制器各自管理自己的业务逻辑, 高内聚低耦合). 重写HomeViewController的loadView, 将self.view替换成UIScrollView. 将三个子控制器的view添加到UIScrollView上即可. 其他的效果实现, 请参照我的代码, 都有详细的中文注释.<br>tip4: 直播(面向观众端)<br>这个是整个项目的重点之一了.这种直播的布局, 应该是比较主流的了. 我下载的好多直播类APP都是这个项目布局, 包括YY也是这种界面布局.这个里面涉及的东西比较多了, 三言两语真说不清.</p>\n<p>简单说一下已经实现的效果:<br>A: 主播的直播<br>B: 关联主播的视频直播, 默认是只有界面, 没有声音的. 点击该视图可以切换到此主播<br>C: 下拉切换另一个主播, 这个功能是很常见的. 做法是直播控制器是一个UICollectionViewController, 只有一个cell, 且cell.frame就是self.collectionViewb.bounds. 我们进入直播控制器的时候, 其实是传进去一个关联主播数组, 每次下拉的时候, 就加载数组里面的主播<br>D. 查看观众席的观众详情<br>E. 查看主播详情<br>F. 足迹: 粒子动画, 后面详解<br>G. 弹幕: 点击最下方的工具栏第一个按钮可以开启/关闭弹幕, 后面详解<br>…<br>tip5: 粒子动画实现游客足迹<br>粒子动画的layer是添加到播放器的view上面的. 下面代码有详细的注释<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div></pre></td><td class=\"code\"><pre><div class=\"line\">CAEmitterLayer *emitterLayer = [CAEmitterLayer layer];</div><div class=\"line\">// 发射器在xy平面的中心位置</div><div class=\"line\">emitterLayer.emitterPosition = CGPointMake(self.moviePlayer.view.frame.size.width-50,self.moviePlayer.view.frame.size.height-50);</div><div class=\"line\">// 发射器的尺寸大小</div><div class=\"line\">emitterLayer.emitterSize = CGSizeMake(20, 20);</div><div class=\"line\">// 渲染模式</div><div class=\"line\">emitterLayer.renderMode = kCAEmitterLayerUnordered;</div><div class=\"line\">// 开启三维效果</div><div class=\"line\">//    _emitterLayer.preservesDepth = YES;</div><div class=\"line\">NSMutableArray *array = [NSMutableArray array];</div><div class=\"line\">// 创建粒子</div><div class=\"line\">for (int i = 0; i&lt;10; i++) &#123;</div><div class=\"line\">    // 发射单元</div><div class=\"line\">    CAEmitterCell *stepCell = [CAEmitterCell emitterCell];</div><div class=\"line\">    // 粒子的创建速率，默认为1/s</div><div class=\"line\">    stepCell.birthRate = 1;</div><div class=\"line\">    // 粒子存活时间</div><div class=\"line\">    stepCell.lifetime = arc4random_uniform(4) + 1;</div><div class=\"line\">    // 粒子的生存时间容差</div><div class=\"line\">    stepCell.lifetimeRange = 1.5;</div><div class=\"line\">    // 颜色</div><div class=\"line\">    // fire.color=[[UIColor colorWithRed:0.8 green:0.4 blue:0.2 alpha:0.1]CGColor];</div><div class=\"line\">    UIImage *image = [UIImage imageNamed:[NSString stringWithFormat:@&quot;good%d_30x30&quot;, i]];</div><div class=\"line\">    // 粒子显示的内容</div><div class=\"line\">    stepCell.contents = (id)[image CGImage];</div><div class=\"line\">    // 粒子的名字</div><div class=\"line\">    //            [fire setName:@&quot;step%d&quot;, i];</div><div class=\"line\">    // 粒子的运动速度</div><div class=\"line\">    stepCell.velocity = arc4random_uniform(100) + 100;</div><div class=\"line\">    // 粒子速度的容差</div><div class=\"line\">    stepCell.velocityRange = 80;</div><div class=\"line\">    // 粒子在xy平面的发射角度</div><div class=\"line\">    stepCell.emissionLongitude = M_PI+M_PI_2;;</div><div class=\"line\">    // 粒子发射角度的容差</div><div class=\"line\">    stepCell.emissionRange = M_PI_2/6;</div><div class=\"line\">    // 缩放比例</div><div class=\"line\">    stepCell.scale = 0.3;</div><div class=\"line\">    [array addObject:stepCell];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">emitterLayer.emitterCells = array;</div><div class=\"line\">[self.moviePlayer.view.layer insertSublayer:emitterLayer below:self.catEarView.layer];</div><div class=\"line\">tip6: 弹幕</div><div class=\"line\">弹幕使用的也是一个第三方轮子BarrageRenderer . 这个开源项目的文档都是中文的, 用法也是很简单的.</div><div class=\"line\"></div><div class=\"line\">基本配置</div><div class=\"line\"></div><div class=\"line\">_renderer = [[BarrageRenderer alloc] init];</div><div class=\"line\">// 设置弹幕的显示区域. 基于父控件的.</div><div class=\"line\">_renderer.canvasMargin = UIEdgeInsetsMake(ALinScreenHeight * 0.3, 10, 10, 10);</div><div class=\"line\">[self.contentView addSubview:_renderer.view];</div><div class=\"line\">弹幕配置</div><div class=\"line\"></div><div class=\"line\">#pragma mark - 弹幕描述符生产方法</div><div class=\"line\">/// 生成精灵描述 - 过场文字弹幕</div><div class=\"line\">- (BarrageDescriptor *)walkTextSpriteDescriptorWithDirection:(NSInteger)direction</div><div class=\"line\">  &#123;</div><div class=\"line\">    BarrageDescriptor * descriptor = [[BarrageDescriptor alloc]init];</div><div class=\"line\">    descriptor.spriteName = NSStringFromClass([BarrageWalkTextSprite class]);</div><div class=\"line\">    descriptor.params[@&quot;text&quot;] = self.danMuText[arc4random_uniform((uint32_t)self.danMuText.count)];</div><div class=\"line\">    descriptor.params[@&quot;textColor&quot;] = Color(arc4random_uniform(256), arc4random_uniform(256), arc4random_uniform(256));</div><div class=\"line\">    descriptor.params[@&quot;speed&quot;] = @(100 * (double)random()/RAND_MAX+50);</div><div class=\"line\">    descriptor.params[@&quot;direction&quot;] = @(direction);</div><div class=\"line\">    descriptor.params[@&quot;clickAction&quot;] = ^&#123;</div><div class=\"line\">        UIAlertView *alertView = [[UIAlertView alloc]initWithTitle:@&quot;提示&quot; message:@&quot;弹幕被点击&quot; delegate:nil cancelButtonTitle:@&quot;取消&quot; otherButtonTitles:nil];</div><div class=\"line\">        [alertView show];</div><div class=\"line\">    &#125;;</div><div class=\"line\">    return descriptor;</div><div class=\"line\">  &#125;</div><div class=\"line\">  最后一步, 千万要记得start</div><div class=\"line\"></div><div class=\"line\">[_renderer start];</div></pre></td></tr></table></figure></p>\n<p>tip7: 智能美颜效果<br>现在的直播平台, 美颜是标配. 不然绝大多数的主播都是没法看的.美颜算法需要用到GPU编程, 需要懂图像处理的人. 图像处理这一块我不是很熟悉, 相关的文献也是看得云里雾里的. 所以, 依然使用开源的轮子: GPUImage . 这个开源框架有近1.3W+star(7月5日数据), 真不是盖的, 内置125种滤镜效果, 没有你想不到, 只有你不会用. 我的项目中都有详细的用法, 还是很简单的. 在这里摘抄一份其.h文件的注释. 一方面方便大家修改我项目中的美颜效果, 另一方面也是做个备份.(具体出处我真忘了, 如果有人找到了源地址链接, 可以联系我加上)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &quot;GLProgram.h&quot;</div><div class=\"line\"></div><div class=\"line\">// Base classes</div><div class=\"line\">#import &quot;GPUImageOpenGLESContext.h&quot;</div><div class=\"line\">#import &quot;GPUImageOutput.h&quot;</div><div class=\"line\">#import &quot;GPUImageView.h&quot;</div><div class=\"line\">#import &quot;GPUImageVideoCamera.h&quot;</div><div class=\"line\">#import &quot;GPUImageStillCamera.h&quot;</div><div class=\"line\">#import &quot;GPUImageMovie.h&quot;</div><div class=\"line\">#import &quot;GPUImagePicture.h&quot;</div><div class=\"line\">#import &quot;GPUImageRawDataInput.h&quot;</div><div class=\"line\">#import &quot;GPUImageRawDataOutput.h&quot;</div><div class=\"line\">#import &quot;GPUImageMovieWriter.h&quot;</div><div class=\"line\">#import &quot;GPUImageFilterPipeline.h&quot;</div><div class=\"line\">#import &quot;GPUImageTextureOutput.h&quot;</div><div class=\"line\">#import &quot;GPUImageFilterGroup.h&quot;</div><div class=\"line\">#import &quot;GPUImageTextureInput.h&quot;</div><div class=\"line\">#import &quot;GPUImageUIElement.h&quot;</div><div class=\"line\">#import &quot;GPUImageBuffer.h&quot;</div><div class=\"line\"></div><div class=\"line\">// Filters</div><div class=\"line\">#import &quot;GPUImageFilter.h&quot;</div><div class=\"line\">#import &quot;GPUImageTwoInputFilter.h&quot;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">#pragma mark - 调整颜色 Handle Color</div><div class=\"line\"></div><div class=\"line\">#import &quot;GPUImageBrightnessFilter.h&quot;                //亮度</div><div class=\"line\">#import &quot;GPUImageExposureFilter.h&quot;                  //曝光</div><div class=\"line\">#import &quot;GPUImageContrastFilter.h&quot;                  //对比度</div><div class=\"line\">#import &quot;GPUImageSaturationFilter.h&quot;                //饱和度</div><div class=\"line\">#import &quot;GPUImageGammaFilter.h&quot;                     //伽马线</div><div class=\"line\">#import &quot;GPUImageColorInvertFilter.h&quot;               //反色</div><div class=\"line\">#import &quot;GPUImageSepiaFilter.h&quot;                     //褐色（怀旧）</div><div class=\"line\">#import &quot;GPUImageLevelsFilter.h&quot;                    //色阶</div><div class=\"line\">#import &quot;GPUImageGrayscaleFilter.h&quot;                 //灰度</div><div class=\"line\">#import &quot;GPUImageHistogramFilter.h&quot;                 //色彩直方图，显示在图片上</div><div class=\"line\">#import &quot;GPUImageHistogramGenerator.h&quot;              //色彩直方图</div><div class=\"line\">#import &quot;GPUImageRGBFilter.h&quot;                       //RGB</div><div class=\"line\">#import &quot;GPUImageToneCurveFilter.h&quot;                 //色调曲线</div><div class=\"line\">#import &quot;GPUImageMonochromeFilter.h&quot;                //单色</div><div class=\"line\">#import &quot;GPUImageOpacityFilter.h&quot;                   //不透明度</div><div class=\"line\">#import &quot;GPUImageHighlightShadowFilter.h&quot;           //提亮阴影</div><div class=\"line\">#import &quot;GPUImageFalseColorFilter.h&quot;                //色彩替换（替换亮部和暗部色彩）</div><div class=\"line\">#import &quot;GPUImageHueFilter.h&quot;                       //色度</div><div class=\"line\">#import &quot;GPUImageChromaKeyFilter.h&quot;                 //色度键</div><div class=\"line\">#import &quot;GPUImageWhiteBalanceFilter.h&quot;              //白平横</div><div class=\"line\">#import &quot;GPUImageAverageColor.h&quot;                    //像素平均色值</div><div class=\"line\">#import &quot;GPUImageSolidColorGenerator.h&quot;             //纯色</div><div class=\"line\">#import &quot;GPUImageLuminosity.h&quot;                      //亮度平均</div><div class=\"line\">#import &quot;GPUImageAverageLuminanceThresholdFilter.h&quot; //像素色值亮度平均，图像黑白（有类似漫画效果）</div><div class=\"line\"></div><div class=\"line\">#import &quot;GPUImageLookupFilter.h&quot;                    //lookup 色彩调整</div><div class=\"line\">#import &quot;GPUImageAmatorkaFilter.h&quot;                  //Amatorka lookup</div><div class=\"line\">#import &quot;GPUImageMissEtikateFilter.h&quot;               //MissEtikate lookup</div><div class=\"line\">#import &quot;GPUImageSoftEleganceFilter.h&quot;              //SoftElegance lookup</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">#pragma mark - 图像处理 Handle Image</div><div class=\"line\"></div><div class=\"line\">#import &quot;GPUImageCrosshairGenerator.h&quot;              //十字</div><div class=\"line\">#import &quot;GPUImageLineGenerator.h&quot;                   //线条</div><div class=\"line\"></div><div class=\"line\">#import &quot;GPUImageTransformFilter.h&quot;                 //形状变化</div><div class=\"line\">#import &quot;GPUImageCropFilter.h&quot;                      //剪裁</div><div class=\"line\">#import &quot;GPUImageSharpenFilter.h&quot;                   //锐化</div><div class=\"line\">#import &quot;GPUImageUnsharpMaskFilter.h&quot;               //反遮罩锐化</div><div class=\"line\"></div><div class=\"line\">#import &quot;GPUImageFastBlurFilter.h&quot;                  //模糊</div><div class=\"line\">#import &quot;GPUImageGaussianBlurFilter.h&quot;              //高斯模糊</div><div class=\"line\">#import &quot;GPUImageGaussianSelectiveBlurFilter.h&quot;     //高斯模糊，选择部分清晰</div><div class=\"line\">#import &quot;GPUImageBoxBlurFilter.h&quot;                   //盒状模糊</div><div class=\"line\">#import &quot;GPUImageTiltShiftFilter.h&quot;                 //条纹模糊，中间清晰，上下两端模糊</div><div class=\"line\">#import &quot;GPUImageMedianFilter.h&quot;                    //中间值，有种稍微模糊边缘的效果</div><div class=\"line\">#import &quot;GPUImageBilateralFilter.h&quot;                 //双边模糊</div><div class=\"line\">#import &quot;GPUImageErosionFilter.h&quot;                   //侵蚀边缘模糊，变黑白</div><div class=\"line\">#import &quot;GPUImageRGBErosionFilter.h&quot;                //RGB侵蚀边缘模糊，有色彩</div><div class=\"line\">#import &quot;GPUImageDilationFilter.h&quot;                  //扩展边缘模糊，变黑白</div><div class=\"line\">#import &quot;GPUImageRGBDilationFilter.h&quot;               //RGB扩展边缘模糊，有色彩</div><div class=\"line\">#import &quot;GPUImageOpeningFilter.h&quot;                   //黑白色调模糊</div><div class=\"line\">#import &quot;GPUImageRGBOpeningFilter.h&quot;                //彩色模糊</div><div class=\"line\">#import &quot;GPUImageClosingFilter.h&quot;                   //黑白色调模糊，暗色会被提亮</div><div class=\"line\">#import &quot;GPUImageRGBClosingFilter.h&quot;                //彩色模糊，暗色会被提亮</div><div class=\"line\">#import &quot;GPUImageLanczosResamplingFilter.h&quot;         //Lanczos重取样，模糊效果</div><div class=\"line\">#import &quot;GPUImageNonMaximumSuppressionFilter.h&quot;     //非最大抑制，只显示亮度最高的像素，其他为黑</div><div class=\"line\">#import &quot;GPUImageThresholdedNonMaximumSuppressionFilter.h&quot; //与上相比，像素丢失更多</div><div class=\"line\"></div><div class=\"line\">#import &quot;GPUImageSobelEdgeDetectionFilter.h&quot;        //Sobel边缘检测算法(白边，黑内容，有点漫画的反色效果)</div><div class=\"line\">#import &quot;GPUImageCannyEdgeDetectionFilter.h&quot;        //Canny边缘检测算法（比上更强烈的黑白对比度）</div><div class=\"line\">#import &quot;GPUImageThresholdEdgeDetectionFilter.h&quot;    //阈值边缘检测（效果与上差别不大）</div><div class=\"line\">#import &quot;GPUImagePrewittEdgeDetectionFilter.h&quot;      //普瑞维特(Prewitt)边缘检测(效果与Sobel差不多，貌似更平滑)</div><div class=\"line\">#import &quot;GPUImageXYDerivativeFilter.h&quot;              //XYDerivative边缘检测，画面以蓝色为主，绿色为边缘，带彩色</div><div class=\"line\">#import &quot;GPUImageHarrisCornerDetectionFilter.h&quot;     //Harris角点检测，会有绿色小十字显示在图片角点处</div><div class=\"line\">#import &quot;GPUImageNobleCornerDetectionFilter.h&quot;      //Noble角点检测，检测点更多</div><div class=\"line\">#import &quot;GPUImageShiTomasiFeatureDetectionFilter.h&quot; //ShiTomasi角点检测，与上差别不大</div><div class=\"line\">#import &quot;GPUImageMotionDetector.h&quot;                  //动作检测</div><div class=\"line\">#import &quot;GPUImageHoughTransformLineDetector.h&quot;      //线条检测</div><div class=\"line\">#import &quot;GPUImageParallelCoordinateLineTransformFilter.h&quot; //平行线检测</div><div class=\"line\"></div><div class=\"line\">#import &quot;GPUImageLocalBinaryPatternFilter.h&quot;        //图像黑白化，并有大量噪点</div><div class=\"line\"></div><div class=\"line\">#import &quot;GPUImageLowPassFilter.h&quot;                   //用于图像加亮</div><div class=\"line\">#import &quot;GPUImageHighPassFilter.h&quot;                  //图像低于某值时显示为黑</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">#pragma mark - 视觉效果 Visual Effect</div><div class=\"line\"></div><div class=\"line\">#import &quot;GPUImageSketchFilter.h&quot;                    //素描</div><div class=\"line\">#import &quot;GPUImageThresholdSketchFilter.h&quot;           //阀值素描，形成有噪点的素描</div><div class=\"line\">#import &quot;GPUImageToonFilter.h&quot;                      //卡通效果（黑色粗线描边）</div><div class=\"line\">#import &quot;GPUImageSmoothToonFilter.h&quot;                //相比上面的效果更细腻，上面是粗旷的画风</div><div class=\"line\">#import &quot;GPUImageKuwaharaFilter.h&quot;                  //桑原(Kuwahara)滤波,水粉画的模糊效果；处理时间比较长，慎用</div><div class=\"line\"></div><div class=\"line\">#import &quot;GPUImageMosaicFilter.h&quot;                    //黑白马赛克</div><div class=\"line\">#import &quot;GPUImagePixellateFilter.h&quot;                 //像素化</div><div class=\"line\">#import &quot;GPUImagePolarPixellateFilter.h&quot;            //同心圆像素化</div><div class=\"line\">#import &quot;GPUImageCrosshatchFilter.h&quot;                //交叉线阴影，形成黑白网状画面</div><div class=\"line\">#import &quot;GPUImageColorPackingFilter.h&quot;              //色彩丢失，模糊（类似监控摄像效果）</div><div class=\"line\"></div><div class=\"line\">#import &quot;GPUImageVignetteFilter.h&quot;                  //晕影，形成黑色圆形边缘，突出中间图像的效果</div><div class=\"line\">#import &quot;GPUImageSwirlFilter.h&quot;                     //漩涡，中间形成卷曲的画面</div><div class=\"line\">#import &quot;GPUImageBulgeDistortionFilter.h&quot;           //凸起失真，鱼眼效果</div><div class=\"line\">#import &quot;GPUImagePinchDistortionFilter.h&quot;           //收缩失真，凹面镜</div><div class=\"line\">#import &quot;GPUImageStretchDistortionFilter.h&quot;         //伸展失真，哈哈镜</div><div class=\"line\">#import &quot;GPUImageGlassSphereFilter.h&quot;               //水晶球效果</div><div class=\"line\">#import &quot;GPUImageSphereRefractionFilter.h&quot;          //球形折射，图形倒立</div><div class=\"line\"></div><div class=\"line\">#import &quot;GPUImagePosterizeFilter.h&quot;                 //色调分离，形成噪点效果</div><div class=\"line\">#import &quot;GPUImageCGAColorspaceFilter.h&quot;             //CGA色彩滤镜，形成黑、浅蓝、紫色块的画面</div><div class=\"line\">#import &quot;GPUImagePerlinNoiseFilter.h&quot;               //柏林噪点，花边噪点</div><div class=\"line\">#import &quot;GPUImage3x3ConvolutionFilter.h&quot;            //3x3卷积，高亮大色块变黑，加亮边缘、线条等</div><div class=\"line\">#import &quot;GPUImageEmbossFilter.h&quot;                    //浮雕效果，带有点3d的感觉</div><div class=\"line\">#import &quot;GPUImagePolkaDotFilter.h&quot;                  //像素圆点花样</div><div class=\"line\">#import &quot;GPUImageHalftoneFilter.h&quot;                  //点染,图像黑白化，由黑点构成原图的大致图形</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">#pragma mark - 混合模式 Blend</div><div class=\"line\"></div><div class=\"line\">#import &quot;GPUImageMultiplyBlendFilter.h&quot;             //通常用于创建阴影和深度效果</div><div class=\"line\">#import &quot;GPUImageNormalBlendFilter.h&quot;               //正常</div><div class=\"line\">#import &quot;GPUImageAlphaBlendFilter.h&quot;                //透明混合,通常用于在背景上应用前景的透明度</div><div class=\"line\">#import &quot;GPUImageDissolveBlendFilter.h&quot;             //溶解</div><div class=\"line\">#import &quot;GPUImageOverlayBlendFilter.h&quot;              //叠加,通常用于创建阴影效果</div><div class=\"line\">#import &quot;GPUImageDarkenBlendFilter.h&quot;               //加深混合,通常用于重叠类型</div><div class=\"line\">#import &quot;GPUImageLightenBlendFilter.h&quot;              //减淡混合,通常用于重叠类型</div><div class=\"line\">#import &quot;GPUImageSourceOverBlendFilter.h&quot;           //源混合</div><div class=\"line\">#import &quot;GPUImageColorBurnBlendFilter.h&quot;            //色彩加深混合</div><div class=\"line\">#import &quot;GPUImageColorDodgeBlendFilter.h&quot;           //色彩减淡混合</div><div class=\"line\">#import &quot;GPUImageScreenBlendFilter.h&quot;               //屏幕包裹,通常用于创建亮点和镜头眩光</div><div class=\"line\">#import &quot;GPUImageExclusionBlendFilter.h&quot;            //排除混合</div><div class=\"line\">#import &quot;GPUImageDifferenceBlendFilter.h&quot;           //差异混合,通常用于创建更多变动的颜色</div><div class=\"line\">#import &quot;GPUImageSubtractBlendFilter.h&quot;             //差值混合,通常用于创建两个图像之间的动画变暗模糊效果</div><div class=\"line\">#import &quot;GPUImageHardLightBlendFilter.h&quot;            //强光混合,通常用于创建阴影效果</div><div class=\"line\">#import &quot;GPUImageSoftLightBlendFilter.h&quot;            //柔光混合</div><div class=\"line\">#import &quot;GPUImageChromaKeyBlendFilter.h&quot;            //色度键混合</div><div class=\"line\">#import &quot;GPUImageMaskFilter.h&quot;                      //遮罩混合</div><div class=\"line\">#import &quot;GPUImageHazeFilter.h&quot;                      //朦胧加暗</div><div class=\"line\">#import &quot;GPUImageLuminanceThresholdFilter.h&quot;        //亮度阈</div><div class=\"line\">#import &quot;GPUImageAdaptiveThresholdFilter.h&quot;         //自适应阈值</div><div class=\"line\">#import &quot;GPUImageAddBlendFilter.h&quot;                  //通常用于创建两个图像之间的动画变亮模糊效果</div><div class=\"line\">#import &quot;GPUImageDivideBlendFilter.h&quot;               //通常用于创建两个图像之间的动画变暗模糊效果</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">#pragma mark - 尚不清楚</div><div class=\"line\">#import &quot;GPUImageJFAVoroniFilter.h&quot;</div><div class=\"line\">#import &quot;GPUImageVoroniConsumerFilter.h&quot;</div><div class=\"line\">tip8: H264硬编码</div><div class=\"line\">如果使用ijkplayer 使用硬解码, 一句代码即可.</div><div class=\"line\"></div><div class=\"line\">// 开启硬解码</div><div class=\"line\">[option setPlayerOptionValue:@&quot;1&quot; forKey:@&quot;videotoolbox&quot;];</div></pre></td></tr></table></figure>\n<p>硬编码的应用场景: 我们要将主播的视频数据传送给服务器</p>\n<p>通过摄像头来采集图像，然后将采集到的图像，通过硬编码的方式进行编码，最后编码后的数据将其组合成H264的码流通过网络传播。<br>摄像头采集图像, iOS系统提供了AVCaptureSession来采集摄像头的图像数据. 项目中我是直接使用 GPUImage 中的GPUImageVideoCamera, 直接设置GPUImageVideoCamera的代理即可, 在其代理方法- (void)willOutputSampleBuffer:(CMSampleBufferRef)sampleBuffer;进行数据编码即可.</p>\n<p>切记一点: 不管是系统自带的AVCaptureSession还是GPUImageVideoCamera采集到的数据都是未经过编码的CMSampleBuffer.<br>然后将采集到的数据, 用iOS开放的VideoToolbox进行硬编码. 关于VideoToolbox硬编解码网上很多教程, 当然最好是看Apple的官方文档, 如果只是硬编码, 看我的项目即可.</p>\n<p>关键的编码函数(来自YOLO直播负责人的开源项目 BeautifyFaceDemo )</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">void didCompressH264(void *outputCallbackRefCon, void *sourceFrameRefCon, OSStatus status, VTEncodeInfoFlags infoFlags,</div><div class=\"line\">                     CMSampleBufferRef sampleBuffer )</div><div class=\"line\">&#123;</div><div class=\"line\">    if (status != 0) return;</div><div class=\"line\">    // 采集的未编码数据是否准备好</div><div class=\"line\">    if (!CMSampleBufferDataIsReady(sampleBuffer))</div><div class=\"line\">    &#123;</div><div class=\"line\">        NSLog(@&quot;didCompressH264 data is not ready &quot;);</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    ALinH264Encoder* encoder = (__bridge ALinH264Encoder*)outputCallbackRefCon;</div><div class=\"line\">    </div><div class=\"line\">    bool keyframe = !CFDictionaryContainsKey((CFArrayGetValueAtIndex(CMSampleBufferGetSampleAttachmentsArray(sampleBuffer, true), 0)), kCMSampleAttachmentKey_NotSync);</div><div class=\"line\">    </div><div class=\"line\">    if (keyframe) // 关键帧</div><div class=\"line\">    &#123;</div><div class=\"line\">        CMFormatDescriptionRef format = CMSampleBufferGetFormatDescription(sampleBuffer);</div><div class=\"line\">        size_t sparameterSetSize, sparameterSetCount;</div><div class=\"line\">        const uint8_t *sparameterSet;</div><div class=\"line\">        OSStatus statusCode = CMVideoFormatDescriptionGetH264ParameterSetAtIndex(format, 0, &amp;sparameterSet, &amp;sparameterSetSize, &amp;sparameterSetCount, 0 );</div><div class=\"line\">        if (statusCode == noErr)</div><div class=\"line\">        &#123;</div><div class=\"line\">            size_t pparameterSetSize, pparameterSetCount;</div><div class=\"line\">            const uint8_t *pparameterSet;</div><div class=\"line\">            OSStatus statusCode = CMVideoFormatDescriptionGetH264ParameterSetAtIndex(format, 1, &amp;pparameterSet, &amp;pparameterSetSize, &amp;pparameterSetCount, 0 );</div><div class=\"line\">            if (statusCode == noErr)</div><div class=\"line\">            &#123;</div><div class=\"line\">                encoder-&gt;sps = [NSData dataWithBytes:sparameterSet length:sparameterSetSize];</div><div class=\"line\">                encoder-&gt;pps = [NSData dataWithBytes:pparameterSet length:pparameterSetSize];</div><div class=\"line\">                NSLog(@&quot;sps:%@ , pps:%@&quot;, encoder-&gt;sps, encoder-&gt;pps);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    CMBlockBufferRef dataBuffer = CMSampleBufferGetDataBuffer(sampleBuffer);</div><div class=\"line\">    size_t length, totalLength;</div><div class=\"line\">    char *dataPointer;</div><div class=\"line\">    OSStatus statusCodeRet = CMBlockBufferGetDataPointer(dataBuffer, 0, &amp;length, &amp;totalLength, &amp;dataPointer);</div><div class=\"line\">    if (statusCodeRet == noErr) &#123;</div><div class=\"line\">    </div><div class=\"line\">        size_t bufferOffset = 0;</div><div class=\"line\">        static const int AVCCHeaderLength = 4;</div><div class=\"line\">        while (bufferOffset &lt; totalLength - AVCCHeaderLength)</div><div class=\"line\">        &#123;</div><div class=\"line\">            uint32_t NALUnitLength = 0;</div><div class=\"line\">            memcpy(&amp;NALUnitLength, dataPointer + bufferOffset, AVCCHeaderLength);</div><div class=\"line\">            NALUnitLength = CFSwapInt32BigToHost(NALUnitLength);</div><div class=\"line\">            NSData *data = [[NSData alloc] initWithBytes:(dataPointer + bufferOffset + AVCCHeaderLength) length:NALUnitLength];</div><div class=\"line\">            bufferOffset += AVCCHeaderLength + NALUnitLength;</div><div class=\"line\">            NSLog(@&quot;sendData--&gt;&gt; %@ %lu&quot;, data, bufferOffset);</div><div class=\"line\">        &#125;</div><div class=\"line\">    </div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n","excerpt":"<p>视频直播，可以分为 采集，前处理，编码，传输, 服务器处理，解码，渲染</p>\n<p>采集: iOS系统因为软硬件种类不多, 硬件适配性比较好, 所以比较简单. 而Android端市面上机型众多, 要做些机型的适配工作.PC端是最麻烦的, 各种奇葩摄像头驱动.所以现在很多的中小型直播平台, 都放弃了PC的直播, 更有一些直播平台只做iOS端的视频直播.</p>\n<p>前处理: 美颜算法,视频的模糊效果, 水印等都是在这个环节做. 目前iOS端最著名开源框架的毫无疑问就是GPUImage.其中内置了125种渲染效果, 还支持各种脚本自定义. 我高仿的喵播的美颜效果也是基于GPUImage的.</p>\n<p>编码: 重难点在于要在分辨率，帧率，码率，GOP等参数设计上找到最佳平衡点。iOS8之后, Apple开放了VideoToolbox.framework, 可以直接进行硬编解码, 这也是为什么现在大多数直播平台最低只支持到iOS8的原因之一. iOS端硬件兼容性比较好, 可以直接采取硬编码. 而Android得硬编码又是一大坑.</p>\n<p>传输: 这块一般都是交给CDN服务商. CDN只提供带宽和服务器之间的传输, 发送端和接收端的网络连接抖动缓存还是要自己实现的.目前国内最大的CDN服务商应该是网宿.</p>\n<p>服务器处理: 需要在服务器做一些流处理工作, 让推送上来的流适配各个平台各种不同的协议, 比如:RTMP,HLS,FLV…</p>\n<p>解码和渲染: 也就即音视频的播放. 解码毫无疑问也必须要硬解码. iOS端兼容较好, Android依然大坑.这块的难点在于音画同步, 目前很多直播平台这块是硬伤.国内比较好的开源项目应该是B站开源的ijkplayer . 斗鱼就是基于ijkplayer 的, 本项目也是基于ijkplayer 的.</p>\n<p>技术坑 : 降噪, 音频解码器, 蓝牙适配, 回声消除, 信令控制, 登录, 鉴权, 权限管理, 状态管理, 应用消息, 消息推送, 礼物系统, 即时聊天, 支付系统, 统计系统, 数据库, 缓存, 分布式文件存储, 消息队列, 运维系统等等大小不一的坑等你来填!!!</p>","more":"<p>资金坑 : 以带宽为例, 2万人同时在线, 手机码率在600KB, 每个月的带宽费用至少在30万左右. 根据欢聚时代(YY)15年四季度财务报, 他们的带宽成本为人民币1.611亿元, 折合每月5000万+. 人力成本+渠道支出和其他支出就不详谈了.</p>\n<p>社会坑: 还得每时每刻与各种黑暗势力斗争, 包括色情, 广告, 刷小号, 刷充值, 告侵权, DDos…</p>\n<p>前期准备<br>项目主要是基于ijkplayer 的. 最好是打包成framework. 原本我准备写一个打包教程, 不过后来在简书上发现了一篇特别详细的打包blog, 分享给大家: <a href=\"http://\">http://www.jianshu.com/p/1f06b27b3ac0</a></p>\n<p>Profile : 个人中心, 这里面只有一个ProfileController. 因为总写重复代码, 都写吐了, 这儿有兴趣的自己写一下吧, So easy…</p>\n<p>Network : 关于网络连接的工具类. 关于网络的实时监控, 网络状态的切换, 网络请求的工具类都在这里面.</p>\n<p>Other : 全局的常量. 当然你也可以在里面将文件结构更加细化.</p>\n<p>Home : 包含最新主播, 最热直播, 关注的直播, 礼物排行榜等模块. 还有最重要的视频直播也在这里面了.</p>\n<p>ShowTime :见名知意. 视频直播的前处理, 智能美颜和H264硬编码等都在这里面.</p>\n<p>Main : UITabBarController和UINavigationController的配置</p>\n<p>Toos : 这儿命名有点不规范, 这里面放置的都是项目用到的分类</p>\n<p>Login : 登录模块</p>\n<p>Resource : 项目用到的资源文件</p>\n<p>项目详解<br>tip1: 判读网络类型.</p>\n<p>在观看直播的时候, 我们通常都是用WiFi或者3/4G(土豪级别的), 一般用户在进行网络切换的时候, 我们都要给出友善的提示, 告诉TA: 您的网络状态切换到了XX状态. 假设用户从WiFi切换到4G, 你的应用也没个提醒, 导致TA的流量归零甚至欠了运营商一屁股的钱, 我想你的APP的用户体验也就归零或者为负了.<br>我们可以使用苹果的Reachability结合下面的代码实时监听网络状态的改变<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\">typedef NS_ENUM(NSUInteger, NetworkStates) &#123;</div><div class=\"line\">    NetworkStatesNone, // 没有网络</div><div class=\"line\">    NetworkStates2G, // 2G</div><div class=\"line\">    NetworkStates3G, // 3G</div><div class=\"line\">    NetworkStates4G, // 4G</div><div class=\"line\">    NetworkStatesWIFI // WIFI</div><div class=\"line\">&#125;;</div><div class=\"line\">// 判断网络类型</div><div class=\"line\">+ (NetworkStates)getNetworkStates</div><div class=\"line\">  &#123;</div><div class=\"line\">    NSArray *subviews = [[[[UIApplication sharedApplication] valueForKeyPath:@&quot;statusBar&quot;] valueForKeyPath:@&quot;foregroundView&quot;] subviews];</div><div class=\"line\">    // 保存网络状态</div><div class=\"line\">    NetworkStates states = NetworkStatesNone;</div><div class=\"line\">    for (id child in subviews) &#123;</div><div class=\"line\">        if ([child isKindOfClass:NSClassFromString(@&quot;UIStatusBarDataNetworkItemView&quot;)]) &#123;</div><div class=\"line\">            //获取到状态栏码</div><div class=\"line\">            int networkType = [[child valueForKeyPath:@&quot;dataNetworkType&quot;] intValue];</div><div class=\"line\">            switch (networkType) &#123;</div><div class=\"line\">                case 0:</div><div class=\"line\">                   //无网模式</div><div class=\"line\">                    states = NetworkStatesNone;</div><div class=\"line\">                    break;</div><div class=\"line\">                case 1:</div><div class=\"line\">                    states = NetworkStates2G;</div><div class=\"line\">                    break;</div><div class=\"line\">                case 2:</div><div class=\"line\">                    states = NetworkStates3G;</div><div class=\"line\">                    break;</div><div class=\"line\">                case 3:</div><div class=\"line\">                    states = NetworkStates4G;</div><div class=\"line\">                    break;</div><div class=\"line\">                case 5:</div><div class=\"line\">                &#123;</div><div class=\"line\">                    states = NetworkStatesWIFI;</div><div class=\"line\">                &#125;</div><div class=\"line\">                    break;</div><div class=\"line\">                default:</div><div class=\"line\">                    break;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    //根据状态选择</div><div class=\"line\">    return states;</div><div class=\"line\">  &#125;</div><div class=\"line\">  tip2: 登录模块</div></pre></td></tr></table></figure></p>\n<p>如果你多运行几次就会发现, 登录模块背景中播放的视频是2个视频每次随机播放一个的.并且是无限重复的, 也就是说只要你一直呆着登录界面, 就会单视频循环播放当前的视频. 这儿的登录只是几个按钮, 没有具体的登录逻辑, 随便点哪一个按钮都可以进入首页.<br>我们需要监听视频, 是否播放完成.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 监听视频是否播放完成</div><div class=\"line\">  [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(didFinish) name:IJKMPMoviePlayerPlaybackDidFinishNotification object:nil];</div><div class=\"line\">如果播放完成了, 让IJKFFMoviePlayerController再次play即可</div><div class=\"line\"></div><div class=\"line\">- (void)didFinish</div><div class=\"line\">  &#123;</div><div class=\"line\">    // 播放完之后, 继续重播</div><div class=\"line\">    [self.player play];</div><div class=\"line\">  &#125;</div><div class=\"line\">  tip3: 首页</div></pre></td></tr></table></figure></p>\n<p>首页</p>\n<p>这种效果相信很多人都看到过或者做过.我简单说一下我的做法(不一定是最佳的, 只是提供一个思路)</p>\n<p>一个父控制器HomeViewController+三个子控制器(最热/最新/关注. 每个控制器各自管理自己的业务逻辑, 高内聚低耦合). 重写HomeViewController的loadView, 将self.view替换成UIScrollView. 将三个子控制器的view添加到UIScrollView上即可. 其他的效果实现, 请参照我的代码, 都有详细的中文注释.<br>tip4: 直播(面向观众端)<br>这个是整个项目的重点之一了.这种直播的布局, 应该是比较主流的了. 我下载的好多直播类APP都是这个项目布局, 包括YY也是这种界面布局.这个里面涉及的东西比较多了, 三言两语真说不清.</p>\n<p>简单说一下已经实现的效果:<br>A: 主播的直播<br>B: 关联主播的视频直播, 默认是只有界面, 没有声音的. 点击该视图可以切换到此主播<br>C: 下拉切换另一个主播, 这个功能是很常见的. 做法是直播控制器是一个UICollectionViewController, 只有一个cell, 且cell.frame就是self.collectionViewb.bounds. 我们进入直播控制器的时候, 其实是传进去一个关联主播数组, 每次下拉的时候, 就加载数组里面的主播<br>D. 查看观众席的观众详情<br>E. 查看主播详情<br>F. 足迹: 粒子动画, 后面详解<br>G. 弹幕: 点击最下方的工具栏第一个按钮可以开启/关闭弹幕, 后面详解<br>…<br>tip5: 粒子动画实现游客足迹<br>粒子动画的layer是添加到播放器的view上面的. 下面代码有详细的注释<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div></pre></td><td class=\"code\"><pre><div class=\"line\">CAEmitterLayer *emitterLayer = [CAEmitterLayer layer];</div><div class=\"line\">// 发射器在xy平面的中心位置</div><div class=\"line\">emitterLayer.emitterPosition = CGPointMake(self.moviePlayer.view.frame.size.width-50,self.moviePlayer.view.frame.size.height-50);</div><div class=\"line\">// 发射器的尺寸大小</div><div class=\"line\">emitterLayer.emitterSize = CGSizeMake(20, 20);</div><div class=\"line\">// 渲染模式</div><div class=\"line\">emitterLayer.renderMode = kCAEmitterLayerUnordered;</div><div class=\"line\">// 开启三维效果</div><div class=\"line\">//    _emitterLayer.preservesDepth = YES;</div><div class=\"line\">NSMutableArray *array = [NSMutableArray array];</div><div class=\"line\">// 创建粒子</div><div class=\"line\">for (int i = 0; i&lt;10; i++) &#123;</div><div class=\"line\">    // 发射单元</div><div class=\"line\">    CAEmitterCell *stepCell = [CAEmitterCell emitterCell];</div><div class=\"line\">    // 粒子的创建速率，默认为1/s</div><div class=\"line\">    stepCell.birthRate = 1;</div><div class=\"line\">    // 粒子存活时间</div><div class=\"line\">    stepCell.lifetime = arc4random_uniform(4) + 1;</div><div class=\"line\">    // 粒子的生存时间容差</div><div class=\"line\">    stepCell.lifetimeRange = 1.5;</div><div class=\"line\">    // 颜色</div><div class=\"line\">    // fire.color=[[UIColor colorWithRed:0.8 green:0.4 blue:0.2 alpha:0.1]CGColor];</div><div class=\"line\">    UIImage *image = [UIImage imageNamed:[NSString stringWithFormat:@&quot;good%d_30x30&quot;, i]];</div><div class=\"line\">    // 粒子显示的内容</div><div class=\"line\">    stepCell.contents = (id)[image CGImage];</div><div class=\"line\">    // 粒子的名字</div><div class=\"line\">    //            [fire setName:@&quot;step%d&quot;, i];</div><div class=\"line\">    // 粒子的运动速度</div><div class=\"line\">    stepCell.velocity = arc4random_uniform(100) + 100;</div><div class=\"line\">    // 粒子速度的容差</div><div class=\"line\">    stepCell.velocityRange = 80;</div><div class=\"line\">    // 粒子在xy平面的发射角度</div><div class=\"line\">    stepCell.emissionLongitude = M_PI+M_PI_2;;</div><div class=\"line\">    // 粒子发射角度的容差</div><div class=\"line\">    stepCell.emissionRange = M_PI_2/6;</div><div class=\"line\">    // 缩放比例</div><div class=\"line\">    stepCell.scale = 0.3;</div><div class=\"line\">    [array addObject:stepCell];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">emitterLayer.emitterCells = array;</div><div class=\"line\">[self.moviePlayer.view.layer insertSublayer:emitterLayer below:self.catEarView.layer];</div><div class=\"line\">tip6: 弹幕</div><div class=\"line\">弹幕使用的也是一个第三方轮子BarrageRenderer . 这个开源项目的文档都是中文的, 用法也是很简单的.</div><div class=\"line\"></div><div class=\"line\">基本配置</div><div class=\"line\"></div><div class=\"line\">_renderer = [[BarrageRenderer alloc] init];</div><div class=\"line\">// 设置弹幕的显示区域. 基于父控件的.</div><div class=\"line\">_renderer.canvasMargin = UIEdgeInsetsMake(ALinScreenHeight * 0.3, 10, 10, 10);</div><div class=\"line\">[self.contentView addSubview:_renderer.view];</div><div class=\"line\">弹幕配置</div><div class=\"line\"></div><div class=\"line\">#pragma mark - 弹幕描述符生产方法</div><div class=\"line\">/// 生成精灵描述 - 过场文字弹幕</div><div class=\"line\">- (BarrageDescriptor *)walkTextSpriteDescriptorWithDirection:(NSInteger)direction</div><div class=\"line\">  &#123;</div><div class=\"line\">    BarrageDescriptor * descriptor = [[BarrageDescriptor alloc]init];</div><div class=\"line\">    descriptor.spriteName = NSStringFromClass([BarrageWalkTextSprite class]);</div><div class=\"line\">    descriptor.params[@&quot;text&quot;] = self.danMuText[arc4random_uniform((uint32_t)self.danMuText.count)];</div><div class=\"line\">    descriptor.params[@&quot;textColor&quot;] = Color(arc4random_uniform(256), arc4random_uniform(256), arc4random_uniform(256));</div><div class=\"line\">    descriptor.params[@&quot;speed&quot;] = @(100 * (double)random()/RAND_MAX+50);</div><div class=\"line\">    descriptor.params[@&quot;direction&quot;] = @(direction);</div><div class=\"line\">    descriptor.params[@&quot;clickAction&quot;] = ^&#123;</div><div class=\"line\">        UIAlertView *alertView = [[UIAlertView alloc]initWithTitle:@&quot;提示&quot; message:@&quot;弹幕被点击&quot; delegate:nil cancelButtonTitle:@&quot;取消&quot; otherButtonTitles:nil];</div><div class=\"line\">        [alertView show];</div><div class=\"line\">    &#125;;</div><div class=\"line\">    return descriptor;</div><div class=\"line\">  &#125;</div><div class=\"line\">  最后一步, 千万要记得start</div><div class=\"line\"></div><div class=\"line\">[_renderer start];</div></pre></td></tr></table></figure></p>\n<p>tip7: 智能美颜效果<br>现在的直播平台, 美颜是标配. 不然绝大多数的主播都是没法看的.美颜算法需要用到GPU编程, 需要懂图像处理的人. 图像处理这一块我不是很熟悉, 相关的文献也是看得云里雾里的. 所以, 依然使用开源的轮子: GPUImage . 这个开源框架有近1.3W+star(7月5日数据), 真不是盖的, 内置125种滤镜效果, 没有你想不到, 只有你不会用. 我的项目中都有详细的用法, 还是很简单的. 在这里摘抄一份其.h文件的注释. 一方面方便大家修改我项目中的美颜效果, 另一方面也是做个备份.(具体出处我真忘了, 如果有人找到了源地址链接, 可以联系我加上)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &quot;GLProgram.h&quot;</div><div class=\"line\"></div><div class=\"line\">// Base classes</div><div class=\"line\">#import &quot;GPUImageOpenGLESContext.h&quot;</div><div class=\"line\">#import &quot;GPUImageOutput.h&quot;</div><div class=\"line\">#import &quot;GPUImageView.h&quot;</div><div class=\"line\">#import &quot;GPUImageVideoCamera.h&quot;</div><div class=\"line\">#import &quot;GPUImageStillCamera.h&quot;</div><div class=\"line\">#import &quot;GPUImageMovie.h&quot;</div><div class=\"line\">#import &quot;GPUImagePicture.h&quot;</div><div class=\"line\">#import &quot;GPUImageRawDataInput.h&quot;</div><div class=\"line\">#import &quot;GPUImageRawDataOutput.h&quot;</div><div class=\"line\">#import &quot;GPUImageMovieWriter.h&quot;</div><div class=\"line\">#import &quot;GPUImageFilterPipeline.h&quot;</div><div class=\"line\">#import &quot;GPUImageTextureOutput.h&quot;</div><div class=\"line\">#import &quot;GPUImageFilterGroup.h&quot;</div><div class=\"line\">#import &quot;GPUImageTextureInput.h&quot;</div><div class=\"line\">#import &quot;GPUImageUIElement.h&quot;</div><div class=\"line\">#import &quot;GPUImageBuffer.h&quot;</div><div class=\"line\"></div><div class=\"line\">// Filters</div><div class=\"line\">#import &quot;GPUImageFilter.h&quot;</div><div class=\"line\">#import &quot;GPUImageTwoInputFilter.h&quot;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">#pragma mark - 调整颜色 Handle Color</div><div class=\"line\"></div><div class=\"line\">#import &quot;GPUImageBrightnessFilter.h&quot;                //亮度</div><div class=\"line\">#import &quot;GPUImageExposureFilter.h&quot;                  //曝光</div><div class=\"line\">#import &quot;GPUImageContrastFilter.h&quot;                  //对比度</div><div class=\"line\">#import &quot;GPUImageSaturationFilter.h&quot;                //饱和度</div><div class=\"line\">#import &quot;GPUImageGammaFilter.h&quot;                     //伽马线</div><div class=\"line\">#import &quot;GPUImageColorInvertFilter.h&quot;               //反色</div><div class=\"line\">#import &quot;GPUImageSepiaFilter.h&quot;                     //褐色（怀旧）</div><div class=\"line\">#import &quot;GPUImageLevelsFilter.h&quot;                    //色阶</div><div class=\"line\">#import &quot;GPUImageGrayscaleFilter.h&quot;                 //灰度</div><div class=\"line\">#import &quot;GPUImageHistogramFilter.h&quot;                 //色彩直方图，显示在图片上</div><div class=\"line\">#import &quot;GPUImageHistogramGenerator.h&quot;              //色彩直方图</div><div class=\"line\">#import &quot;GPUImageRGBFilter.h&quot;                       //RGB</div><div class=\"line\">#import &quot;GPUImageToneCurveFilter.h&quot;                 //色调曲线</div><div class=\"line\">#import &quot;GPUImageMonochromeFilter.h&quot;                //单色</div><div class=\"line\">#import &quot;GPUImageOpacityFilter.h&quot;                   //不透明度</div><div class=\"line\">#import &quot;GPUImageHighlightShadowFilter.h&quot;           //提亮阴影</div><div class=\"line\">#import &quot;GPUImageFalseColorFilter.h&quot;                //色彩替换（替换亮部和暗部色彩）</div><div class=\"line\">#import &quot;GPUImageHueFilter.h&quot;                       //色度</div><div class=\"line\">#import &quot;GPUImageChromaKeyFilter.h&quot;                 //色度键</div><div class=\"line\">#import &quot;GPUImageWhiteBalanceFilter.h&quot;              //白平横</div><div class=\"line\">#import &quot;GPUImageAverageColor.h&quot;                    //像素平均色值</div><div class=\"line\">#import &quot;GPUImageSolidColorGenerator.h&quot;             //纯色</div><div class=\"line\">#import &quot;GPUImageLuminosity.h&quot;                      //亮度平均</div><div class=\"line\">#import &quot;GPUImageAverageLuminanceThresholdFilter.h&quot; //像素色值亮度平均，图像黑白（有类似漫画效果）</div><div class=\"line\"></div><div class=\"line\">#import &quot;GPUImageLookupFilter.h&quot;                    //lookup 色彩调整</div><div class=\"line\">#import &quot;GPUImageAmatorkaFilter.h&quot;                  //Amatorka lookup</div><div class=\"line\">#import &quot;GPUImageMissEtikateFilter.h&quot;               //MissEtikate lookup</div><div class=\"line\">#import &quot;GPUImageSoftEleganceFilter.h&quot;              //SoftElegance lookup</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">#pragma mark - 图像处理 Handle Image</div><div class=\"line\"></div><div class=\"line\">#import &quot;GPUImageCrosshairGenerator.h&quot;              //十字</div><div class=\"line\">#import &quot;GPUImageLineGenerator.h&quot;                   //线条</div><div class=\"line\"></div><div class=\"line\">#import &quot;GPUImageTransformFilter.h&quot;                 //形状变化</div><div class=\"line\">#import &quot;GPUImageCropFilter.h&quot;                      //剪裁</div><div class=\"line\">#import &quot;GPUImageSharpenFilter.h&quot;                   //锐化</div><div class=\"line\">#import &quot;GPUImageUnsharpMaskFilter.h&quot;               //反遮罩锐化</div><div class=\"line\"></div><div class=\"line\">#import &quot;GPUImageFastBlurFilter.h&quot;                  //模糊</div><div class=\"line\">#import &quot;GPUImageGaussianBlurFilter.h&quot;              //高斯模糊</div><div class=\"line\">#import &quot;GPUImageGaussianSelectiveBlurFilter.h&quot;     //高斯模糊，选择部分清晰</div><div class=\"line\">#import &quot;GPUImageBoxBlurFilter.h&quot;                   //盒状模糊</div><div class=\"line\">#import &quot;GPUImageTiltShiftFilter.h&quot;                 //条纹模糊，中间清晰，上下两端模糊</div><div class=\"line\">#import &quot;GPUImageMedianFilter.h&quot;                    //中间值，有种稍微模糊边缘的效果</div><div class=\"line\">#import &quot;GPUImageBilateralFilter.h&quot;                 //双边模糊</div><div class=\"line\">#import &quot;GPUImageErosionFilter.h&quot;                   //侵蚀边缘模糊，变黑白</div><div class=\"line\">#import &quot;GPUImageRGBErosionFilter.h&quot;                //RGB侵蚀边缘模糊，有色彩</div><div class=\"line\">#import &quot;GPUImageDilationFilter.h&quot;                  //扩展边缘模糊，变黑白</div><div class=\"line\">#import &quot;GPUImageRGBDilationFilter.h&quot;               //RGB扩展边缘模糊，有色彩</div><div class=\"line\">#import &quot;GPUImageOpeningFilter.h&quot;                   //黑白色调模糊</div><div class=\"line\">#import &quot;GPUImageRGBOpeningFilter.h&quot;                //彩色模糊</div><div class=\"line\">#import &quot;GPUImageClosingFilter.h&quot;                   //黑白色调模糊，暗色会被提亮</div><div class=\"line\">#import &quot;GPUImageRGBClosingFilter.h&quot;                //彩色模糊，暗色会被提亮</div><div class=\"line\">#import &quot;GPUImageLanczosResamplingFilter.h&quot;         //Lanczos重取样，模糊效果</div><div class=\"line\">#import &quot;GPUImageNonMaximumSuppressionFilter.h&quot;     //非最大抑制，只显示亮度最高的像素，其他为黑</div><div class=\"line\">#import &quot;GPUImageThresholdedNonMaximumSuppressionFilter.h&quot; //与上相比，像素丢失更多</div><div class=\"line\"></div><div class=\"line\">#import &quot;GPUImageSobelEdgeDetectionFilter.h&quot;        //Sobel边缘检测算法(白边，黑内容，有点漫画的反色效果)</div><div class=\"line\">#import &quot;GPUImageCannyEdgeDetectionFilter.h&quot;        //Canny边缘检测算法（比上更强烈的黑白对比度）</div><div class=\"line\">#import &quot;GPUImageThresholdEdgeDetectionFilter.h&quot;    //阈值边缘检测（效果与上差别不大）</div><div class=\"line\">#import &quot;GPUImagePrewittEdgeDetectionFilter.h&quot;      //普瑞维特(Prewitt)边缘检测(效果与Sobel差不多，貌似更平滑)</div><div class=\"line\">#import &quot;GPUImageXYDerivativeFilter.h&quot;              //XYDerivative边缘检测，画面以蓝色为主，绿色为边缘，带彩色</div><div class=\"line\">#import &quot;GPUImageHarrisCornerDetectionFilter.h&quot;     //Harris角点检测，会有绿色小十字显示在图片角点处</div><div class=\"line\">#import &quot;GPUImageNobleCornerDetectionFilter.h&quot;      //Noble角点检测，检测点更多</div><div class=\"line\">#import &quot;GPUImageShiTomasiFeatureDetectionFilter.h&quot; //ShiTomasi角点检测，与上差别不大</div><div class=\"line\">#import &quot;GPUImageMotionDetector.h&quot;                  //动作检测</div><div class=\"line\">#import &quot;GPUImageHoughTransformLineDetector.h&quot;      //线条检测</div><div class=\"line\">#import &quot;GPUImageParallelCoordinateLineTransformFilter.h&quot; //平行线检测</div><div class=\"line\"></div><div class=\"line\">#import &quot;GPUImageLocalBinaryPatternFilter.h&quot;        //图像黑白化，并有大量噪点</div><div class=\"line\"></div><div class=\"line\">#import &quot;GPUImageLowPassFilter.h&quot;                   //用于图像加亮</div><div class=\"line\">#import &quot;GPUImageHighPassFilter.h&quot;                  //图像低于某值时显示为黑</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">#pragma mark - 视觉效果 Visual Effect</div><div class=\"line\"></div><div class=\"line\">#import &quot;GPUImageSketchFilter.h&quot;                    //素描</div><div class=\"line\">#import &quot;GPUImageThresholdSketchFilter.h&quot;           //阀值素描，形成有噪点的素描</div><div class=\"line\">#import &quot;GPUImageToonFilter.h&quot;                      //卡通效果（黑色粗线描边）</div><div class=\"line\">#import &quot;GPUImageSmoothToonFilter.h&quot;                //相比上面的效果更细腻，上面是粗旷的画风</div><div class=\"line\">#import &quot;GPUImageKuwaharaFilter.h&quot;                  //桑原(Kuwahara)滤波,水粉画的模糊效果；处理时间比较长，慎用</div><div class=\"line\"></div><div class=\"line\">#import &quot;GPUImageMosaicFilter.h&quot;                    //黑白马赛克</div><div class=\"line\">#import &quot;GPUImagePixellateFilter.h&quot;                 //像素化</div><div class=\"line\">#import &quot;GPUImagePolarPixellateFilter.h&quot;            //同心圆像素化</div><div class=\"line\">#import &quot;GPUImageCrosshatchFilter.h&quot;                //交叉线阴影，形成黑白网状画面</div><div class=\"line\">#import &quot;GPUImageColorPackingFilter.h&quot;              //色彩丢失，模糊（类似监控摄像效果）</div><div class=\"line\"></div><div class=\"line\">#import &quot;GPUImageVignetteFilter.h&quot;                  //晕影，形成黑色圆形边缘，突出中间图像的效果</div><div class=\"line\">#import &quot;GPUImageSwirlFilter.h&quot;                     //漩涡，中间形成卷曲的画面</div><div class=\"line\">#import &quot;GPUImageBulgeDistortionFilter.h&quot;           //凸起失真，鱼眼效果</div><div class=\"line\">#import &quot;GPUImagePinchDistortionFilter.h&quot;           //收缩失真，凹面镜</div><div class=\"line\">#import &quot;GPUImageStretchDistortionFilter.h&quot;         //伸展失真，哈哈镜</div><div class=\"line\">#import &quot;GPUImageGlassSphereFilter.h&quot;               //水晶球效果</div><div class=\"line\">#import &quot;GPUImageSphereRefractionFilter.h&quot;          //球形折射，图形倒立</div><div class=\"line\"></div><div class=\"line\">#import &quot;GPUImagePosterizeFilter.h&quot;                 //色调分离，形成噪点效果</div><div class=\"line\">#import &quot;GPUImageCGAColorspaceFilter.h&quot;             //CGA色彩滤镜，形成黑、浅蓝、紫色块的画面</div><div class=\"line\">#import &quot;GPUImagePerlinNoiseFilter.h&quot;               //柏林噪点，花边噪点</div><div class=\"line\">#import &quot;GPUImage3x3ConvolutionFilter.h&quot;            //3x3卷积，高亮大色块变黑，加亮边缘、线条等</div><div class=\"line\">#import &quot;GPUImageEmbossFilter.h&quot;                    //浮雕效果，带有点3d的感觉</div><div class=\"line\">#import &quot;GPUImagePolkaDotFilter.h&quot;                  //像素圆点花样</div><div class=\"line\">#import &quot;GPUImageHalftoneFilter.h&quot;                  //点染,图像黑白化，由黑点构成原图的大致图形</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">#pragma mark - 混合模式 Blend</div><div class=\"line\"></div><div class=\"line\">#import &quot;GPUImageMultiplyBlendFilter.h&quot;             //通常用于创建阴影和深度效果</div><div class=\"line\">#import &quot;GPUImageNormalBlendFilter.h&quot;               //正常</div><div class=\"line\">#import &quot;GPUImageAlphaBlendFilter.h&quot;                //透明混合,通常用于在背景上应用前景的透明度</div><div class=\"line\">#import &quot;GPUImageDissolveBlendFilter.h&quot;             //溶解</div><div class=\"line\">#import &quot;GPUImageOverlayBlendFilter.h&quot;              //叠加,通常用于创建阴影效果</div><div class=\"line\">#import &quot;GPUImageDarkenBlendFilter.h&quot;               //加深混合,通常用于重叠类型</div><div class=\"line\">#import &quot;GPUImageLightenBlendFilter.h&quot;              //减淡混合,通常用于重叠类型</div><div class=\"line\">#import &quot;GPUImageSourceOverBlendFilter.h&quot;           //源混合</div><div class=\"line\">#import &quot;GPUImageColorBurnBlendFilter.h&quot;            //色彩加深混合</div><div class=\"line\">#import &quot;GPUImageColorDodgeBlendFilter.h&quot;           //色彩减淡混合</div><div class=\"line\">#import &quot;GPUImageScreenBlendFilter.h&quot;               //屏幕包裹,通常用于创建亮点和镜头眩光</div><div class=\"line\">#import &quot;GPUImageExclusionBlendFilter.h&quot;            //排除混合</div><div class=\"line\">#import &quot;GPUImageDifferenceBlendFilter.h&quot;           //差异混合,通常用于创建更多变动的颜色</div><div class=\"line\">#import &quot;GPUImageSubtractBlendFilter.h&quot;             //差值混合,通常用于创建两个图像之间的动画变暗模糊效果</div><div class=\"line\">#import &quot;GPUImageHardLightBlendFilter.h&quot;            //强光混合,通常用于创建阴影效果</div><div class=\"line\">#import &quot;GPUImageSoftLightBlendFilter.h&quot;            //柔光混合</div><div class=\"line\">#import &quot;GPUImageChromaKeyBlendFilter.h&quot;            //色度键混合</div><div class=\"line\">#import &quot;GPUImageMaskFilter.h&quot;                      //遮罩混合</div><div class=\"line\">#import &quot;GPUImageHazeFilter.h&quot;                      //朦胧加暗</div><div class=\"line\">#import &quot;GPUImageLuminanceThresholdFilter.h&quot;        //亮度阈</div><div class=\"line\">#import &quot;GPUImageAdaptiveThresholdFilter.h&quot;         //自适应阈值</div><div class=\"line\">#import &quot;GPUImageAddBlendFilter.h&quot;                  //通常用于创建两个图像之间的动画变亮模糊效果</div><div class=\"line\">#import &quot;GPUImageDivideBlendFilter.h&quot;               //通常用于创建两个图像之间的动画变暗模糊效果</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">#pragma mark - 尚不清楚</div><div class=\"line\">#import &quot;GPUImageJFAVoroniFilter.h&quot;</div><div class=\"line\">#import &quot;GPUImageVoroniConsumerFilter.h&quot;</div><div class=\"line\">tip8: H264硬编码</div><div class=\"line\">如果使用ijkplayer 使用硬解码, 一句代码即可.</div><div class=\"line\"></div><div class=\"line\">// 开启硬解码</div><div class=\"line\">[option setPlayerOptionValue:@&quot;1&quot; forKey:@&quot;videotoolbox&quot;];</div></pre></td></tr></table></figure>\n<p>硬编码的应用场景: 我们要将主播的视频数据传送给服务器</p>\n<p>通过摄像头来采集图像，然后将采集到的图像，通过硬编码的方式进行编码，最后编码后的数据将其组合成H264的码流通过网络传播。<br>摄像头采集图像, iOS系统提供了AVCaptureSession来采集摄像头的图像数据. 项目中我是直接使用 GPUImage 中的GPUImageVideoCamera, 直接设置GPUImageVideoCamera的代理即可, 在其代理方法- (void)willOutputSampleBuffer:(CMSampleBufferRef)sampleBuffer;进行数据编码即可.</p>\n<p>切记一点: 不管是系统自带的AVCaptureSession还是GPUImageVideoCamera采集到的数据都是未经过编码的CMSampleBuffer.<br>然后将采集到的数据, 用iOS开放的VideoToolbox进行硬编码. 关于VideoToolbox硬编解码网上很多教程, 当然最好是看Apple的官方文档, 如果只是硬编码, 看我的项目即可.</p>\n<p>关键的编码函数(来自YOLO直播负责人的开源项目 BeautifyFaceDemo )</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">void didCompressH264(void *outputCallbackRefCon, void *sourceFrameRefCon, OSStatus status, VTEncodeInfoFlags infoFlags,</div><div class=\"line\">                     CMSampleBufferRef sampleBuffer )</div><div class=\"line\">&#123;</div><div class=\"line\">    if (status != 0) return;</div><div class=\"line\">    // 采集的未编码数据是否准备好</div><div class=\"line\">    if (!CMSampleBufferDataIsReady(sampleBuffer))</div><div class=\"line\">    &#123;</div><div class=\"line\">        NSLog(@&quot;didCompressH264 data is not ready &quot;);</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    ALinH264Encoder* encoder = (__bridge ALinH264Encoder*)outputCallbackRefCon;</div><div class=\"line\">    </div><div class=\"line\">    bool keyframe = !CFDictionaryContainsKey((CFArrayGetValueAtIndex(CMSampleBufferGetSampleAttachmentsArray(sampleBuffer, true), 0)), kCMSampleAttachmentKey_NotSync);</div><div class=\"line\">    </div><div class=\"line\">    if (keyframe) // 关键帧</div><div class=\"line\">    &#123;</div><div class=\"line\">        CMFormatDescriptionRef format = CMSampleBufferGetFormatDescription(sampleBuffer);</div><div class=\"line\">        size_t sparameterSetSize, sparameterSetCount;</div><div class=\"line\">        const uint8_t *sparameterSet;</div><div class=\"line\">        OSStatus statusCode = CMVideoFormatDescriptionGetH264ParameterSetAtIndex(format, 0, &amp;sparameterSet, &amp;sparameterSetSize, &amp;sparameterSetCount, 0 );</div><div class=\"line\">        if (statusCode == noErr)</div><div class=\"line\">        &#123;</div><div class=\"line\">            size_t pparameterSetSize, pparameterSetCount;</div><div class=\"line\">            const uint8_t *pparameterSet;</div><div class=\"line\">            OSStatus statusCode = CMVideoFormatDescriptionGetH264ParameterSetAtIndex(format, 1, &amp;pparameterSet, &amp;pparameterSetSize, &amp;pparameterSetCount, 0 );</div><div class=\"line\">            if (statusCode == noErr)</div><div class=\"line\">            &#123;</div><div class=\"line\">                encoder-&gt;sps = [NSData dataWithBytes:sparameterSet length:sparameterSetSize];</div><div class=\"line\">                encoder-&gt;pps = [NSData dataWithBytes:pparameterSet length:pparameterSetSize];</div><div class=\"line\">                NSLog(@&quot;sps:%@ , pps:%@&quot;, encoder-&gt;sps, encoder-&gt;pps);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    CMBlockBufferRef dataBuffer = CMSampleBufferGetDataBuffer(sampleBuffer);</div><div class=\"line\">    size_t length, totalLength;</div><div class=\"line\">    char *dataPointer;</div><div class=\"line\">    OSStatus statusCodeRet = CMBlockBufferGetDataPointer(dataBuffer, 0, &amp;length, &amp;totalLength, &amp;dataPointer);</div><div class=\"line\">    if (statusCodeRet == noErr) &#123;</div><div class=\"line\">    </div><div class=\"line\">        size_t bufferOffset = 0;</div><div class=\"line\">        static const int AVCCHeaderLength = 4;</div><div class=\"line\">        while (bufferOffset &lt; totalLength - AVCCHeaderLength)</div><div class=\"line\">        &#123;</div><div class=\"line\">            uint32_t NALUnitLength = 0;</div><div class=\"line\">            memcpy(&amp;NALUnitLength, dataPointer + bufferOffset, AVCCHeaderLength);</div><div class=\"line\">            NALUnitLength = CFSwapInt32BigToHost(NALUnitLength);</div><div class=\"line\">            NSData *data = [[NSData alloc] initWithBytes:(dataPointer + bufferOffset + AVCCHeaderLength) length:NALUnitLength];</div><div class=\"line\">            bufferOffset += AVCCHeaderLength + NALUnitLength;</div><div class=\"line\">            NSLog(@&quot;sendData--&gt;&gt; %@ %lu&quot;, data, bufferOffset);</div><div class=\"line\">        &#125;</div><div class=\"line\">    </div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>"},{"title":"早该知道的生活小经验","date":"2016-12-29T01:52:38.000Z","_content":"\n\n恋爱要趁早，学习要搞好。\n在不了解之前，先别急着说不感兴趣。\n别为自己是个凡人而负疚。\n坚持不是没有中断，而是现在还在做。\n如果袜子买同样的颜色款式，早上拿的时候会容易很多。\n别为太久以后的事情发愁。\n自己的事情，要自己做决定。\n没有选择的时候，就只能前行。\n如果橘子很酸，换个角度吃，可能会觉得甜。\n早睡。\n多学几种运动。\n人生没有成功，只有顿挫和偶胜。\n要对得起别人，更要对得起自己。\n牙痛的时候，含两粒花椒，可以消肿止痛。\n没有过去和将来，只有现在。\n同一天，过的高兴，就赚了，过的郁闷，就亏了，过的浑浑噩噩，就没了。\n有所不为。\n在为浪费时间而后悔和自责时，你依然在浪费时间。\n逛街逛累了，可以去看电影。\n只试不买，心情不好，边逛边吃，才是王道。\n学会做饭。晚上少吃点，心情会很好。\n学个新东西，心情会很好。\n去跑两圈步，心情会很好。\n蛙泳游太久，小腿上的韧带可能受伤。\n技不压身。\n免费的东西，不一定便宜。\n对于没用的东西，最好的收纳方法，就是扔。\n学习资料找太多，就会有已经学了的错觉。\n运动装备买太好，就会有已经瘦了的错觉。\n如果吃点油腻的东西，就会拉肚子，可能减肥会有帮助。\n减肥的时候，要假设所有人都不想你成功，所有人都想破坏你的计划，包括爹妈。\n面试是低成本，高回报的事。\n低成本的事情谈不上失败，只有成功或不成功。\n没有万事俱备的时候，只有做，或者不做。\n不试，就不会有结果。\n一辈子，大概是三万天。\n\n","source":"_posts/早该知道的生活小经验 .md","raw":"---\ntitle: 早该知道的生活小经验\npermalink: LifeExp\ndate: 2016-12-29 09:52:38\ntags: 生活\ncategories: 生活\n---\n\n\n恋爱要趁早，学习要搞好。\n在不了解之前，先别急着说不感兴趣。\n别为自己是个凡人而负疚。\n坚持不是没有中断，而是现在还在做。\n如果袜子买同样的颜色款式，早上拿的时候会容易很多。\n别为太久以后的事情发愁。\n自己的事情，要自己做决定。\n没有选择的时候，就只能前行。\n如果橘子很酸，换个角度吃，可能会觉得甜。\n早睡。\n多学几种运动。\n人生没有成功，只有顿挫和偶胜。\n要对得起别人，更要对得起自己。\n牙痛的时候，含两粒花椒，可以消肿止痛。\n没有过去和将来，只有现在。\n同一天，过的高兴，就赚了，过的郁闷，就亏了，过的浑浑噩噩，就没了。\n有所不为。\n在为浪费时间而后悔和自责时，你依然在浪费时间。\n逛街逛累了，可以去看电影。\n只试不买，心情不好，边逛边吃，才是王道。\n学会做饭。晚上少吃点，心情会很好。\n学个新东西，心情会很好。\n去跑两圈步，心情会很好。\n蛙泳游太久，小腿上的韧带可能受伤。\n技不压身。\n免费的东西，不一定便宜。\n对于没用的东西，最好的收纳方法，就是扔。\n学习资料找太多，就会有已经学了的错觉。\n运动装备买太好，就会有已经瘦了的错觉。\n如果吃点油腻的东西，就会拉肚子，可能减肥会有帮助。\n减肥的时候，要假设所有人都不想你成功，所有人都想破坏你的计划，包括爹妈。\n面试是低成本，高回报的事。\n低成本的事情谈不上失败，只有成功或不成功。\n没有万事俱备的时候，只有做，或者不做。\n不试，就不会有结果。\n一辈子，大概是三万天。\n\n","slug":"LifeExp","published":1,"updated":"2017-01-05T02:14:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj04pzyyi001fs04esmyy9462","content":"<p>恋爱要趁早，学习要搞好。<br>在不了解之前，先别急着说不感兴趣。<br>别为自己是个凡人而负疚。<br>坚持不是没有中断，而是现在还在做。<br>如果袜子买同样的颜色款式，早上拿的时候会容易很多。<br>别为太久以后的事情发愁。<br>自己的事情，要自己做决定。<br>没有选择的时候，就只能前行。<br>如果橘子很酸，换个角度吃，可能会觉得甜。<br>早睡。<br>多学几种运动。<br>人生没有成功，只有顿挫和偶胜。<br>要对得起别人，更要对得起自己。<br>牙痛的时候，含两粒花椒，可以消肿止痛。<br>没有过去和将来，只有现在。<br>同一天，过的高兴，就赚了，过的郁闷，就亏了，过的浑浑噩噩，就没了。<br>有所不为。<br>在为浪费时间而后悔和自责时，你依然在浪费时间。<br>逛街逛累了，可以去看电影。<br>只试不买，心情不好，边逛边吃，才是王道。<br>学会做饭。晚上少吃点，心情会很好。<br>学个新东西，心情会很好。<br>去跑两圈步，心情会很好。<br>蛙泳游太久，小腿上的韧带可能受伤。<br>技不压身。<br>免费的东西，不一定便宜。<br>对于没用的东西，最好的收纳方法，就是扔。<br>学习资料找太多，就会有已经学了的错觉。<br>运动装备买太好，就会有已经瘦了的错觉。<br>如果吃点油腻的东西，就会拉肚子，可能减肥会有帮助。<br>减肥的时候，要假设所有人都不想你成功，所有人都想破坏你的计划，包括爹妈。<br>面试是低成本，高回报的事。<br>低成本的事情谈不上失败，只有成功或不成功。<br>没有万事俱备的时候，只有做，或者不做。<br>不试，就不会有结果。<br>一辈子，大概是三万天。</p>\n","excerpt":"","more":"<p>恋爱要趁早，学习要搞好。<br>在不了解之前，先别急着说不感兴趣。<br>别为自己是个凡人而负疚。<br>坚持不是没有中断，而是现在还在做。<br>如果袜子买同样的颜色款式，早上拿的时候会容易很多。<br>别为太久以后的事情发愁。<br>自己的事情，要自己做决定。<br>没有选择的时候，就只能前行。<br>如果橘子很酸，换个角度吃，可能会觉得甜。<br>早睡。<br>多学几种运动。<br>人生没有成功，只有顿挫和偶胜。<br>要对得起别人，更要对得起自己。<br>牙痛的时候，含两粒花椒，可以消肿止痛。<br>没有过去和将来，只有现在。<br>同一天，过的高兴，就赚了，过的郁闷，就亏了，过的浑浑噩噩，就没了。<br>有所不为。<br>在为浪费时间而后悔和自责时，你依然在浪费时间。<br>逛街逛累了，可以去看电影。<br>只试不买，心情不好，边逛边吃，才是王道。<br>学会做饭。晚上少吃点，心情会很好。<br>学个新东西，心情会很好。<br>去跑两圈步，心情会很好。<br>蛙泳游太久，小腿上的韧带可能受伤。<br>技不压身。<br>免费的东西，不一定便宜。<br>对于没用的东西，最好的收纳方法，就是扔。<br>学习资料找太多，就会有已经学了的错觉。<br>运动装备买太好，就会有已经瘦了的错觉。<br>如果吃点油腻的东西，就会拉肚子，可能减肥会有帮助。<br>减肥的时候，要假设所有人都不想你成功，所有人都想破坏你的计划，包括爹妈。<br>面试是低成本，高回报的事。<br>低成本的事情谈不上失败，只有成功或不成功。<br>没有万事俱备的时候，只有做，或者不做。<br>不试，就不会有结果。<br>一辈子，大概是三万天。</p>\n"},{"title":"来自 Linkedin 的 Swift 编程风格指南","id":"25","updated":"2016-07-03T09:36:24.000Z","date":"2016-07-03T01:37:29.000Z","_content":"\n\n\n\n![](https://ooo.0o0.ooo/2016/07/03/5778dc0ab45a1.jpg)\n##1. Code Formatting:代码格式化\n\n- **1.1** 使用4个空格来代替Tabs\n- **1.2** 避免过长的行，可以在XCode中进行设置单行最大长度：(Xcode->Preferences->Text Editing->Page guide at column: 160 is helpful for this)\n- **1.3** 保证每个文件结尾都存在一个新行 Ensure that there is a newline at the end of every file.\n- **1.4** 避免无意义的尾随空格: (Xcode->Preferences->Text Editing->Automatically trim trailing whitespace + Including whitespace-only lines).\n- **1.5** 避免将单独的左花括号放置到一行，我们参考了：[1TBS style](https://en.m.wikipedia.org/wiki/Indent_style#Variant:_1TBS).\n\n```\nclass SomeClass {\n    func someMethod() {\n        if x == y {\n            /* ... */\n        } else if x == z {\n            /* ... */\n        } else {\n            /* ... */\n        }\n    }\n\n    /* ... */\n}\n```\n\n- **1.6** 在写变量的类型声明、字典类型的键、函数参数、协议的声明或者父类的时候，不要在冒号前添加空格。\n\n```\n// specifying type\nlet pirateViewController: PirateViewController\n\n// dictionary syntax (note that we left-align as opposed to aligning colons)\nlet ninjaDictionary: [String: AnyObject] = [\n    \"fightLikeDairyFarmer\": false,\n    \"disgusting\": true\n]\n\n// declaring a function\nfunc myFunction<T, U: SomeProtocol where T.RelatedType == U>(firstArgument: U, secondArgument: T) {\n    /* ... */\n}\n\n// calling a function\nsomeFunction(someArgument: \"Kitten\")\n\n// superclasses\nclass PirateViewController: UIViewController {\n    /* ... */\n}\n\n// protocols\nextension PirateViewController: UITableViewDataSource {\n    /* ... */\n}\n```\n\n- **1.7** 一般来说，逗号后面都要跟随一个空格。\n\n```\nlet myArray = [1, 2, 3, 4, 5]\n```\n\n- **1.8** 在二元操作符譬如`+`, `==`, 或者 `->`的前后需要加上空格，但是对于`(` 、`)的前后不需要加空格。\n\n\n- **1.9** 我们默认使用Xcode推荐的格式化风格(CTRL-I) ，在声明某个函数的时候会多行排布参数。\n\n\n- **1.10** 在调用多参数函数的时候，会把多个参数放置到单独的行中：\n\n\n\n- **1.11** 对于大型的数组或者字典类型，应该将其分割到多行内，`[` 与 `]`类比于花括号进行处理。对于闭包而言也应该同样适合于该规则。\n\n\n\n- **1.12** 尽可能地使用本地变量的方式来避免多行的判断语句。\n\n\n##2. Naming:命名\n\n- **2.1** Swift中不需要再使用Objective-C那样的前缀，譬如使用 `GuybrushThreepwood` 而不是`LIGuybrushThreepwood`。\n- **2.2** 对于类型名即`struct`, `enum`, `class`, `typedef`, `associatedtype`等等使用 `PascalCase` 。\n- **2.3** 对于函数名、方法名、变量名、常量、参数名等使用`camelCase`。\n- **2.4** 在使用首字母缩写的时候尽可能地全部大写，并且注意保证全部代码中的统一。不过如果缩写被用于命名的起始，那么就全部小写。\n\n```\n// \"HTML\" is at the start of a variable name, so we use lowercase \"html\"\nlet htmlBodyContent: String = \"<p>Hello, World!</p>\"\n// Prefer using ID to Id\nlet profileID: Int = 1\n// Prefer URLFinder to UrlFinder\nclass URLFinder {\n    /* ... */\n}\n```\n\n- **2.5** 对于静态常量使用 `k` 前缀 + PascalCase。\n\n```\nclass MyClassName {\n    // use `k` prefix for constant primitives\n    static let kSomeConstantHeight: CGFloat = 80.0\n\n    // use `k` prefix for non-primitives as well\n    static let kDeleteButtonColor = UIColor.redColor()\n\n    // don't use `k` prefix for singletons\n    static let sharedInstance = MyClassName()\n\n    /* ... */\n}\n```\n\n- **2.6** 对于泛型或者关联类型，使用`PascalCase`描述泛型，如果泛型名与其他重复，那么可以添加一个`Type`后缀名到泛型名上。\n\n```\nclass SomeClass<T> { /* ... */ }\nclass SomeClass<Model> { /* ... */ }\nprotocol Modelable {\n    associatedtype Model\n}\nprotocol Sequence {\n    associatedtype IteratorType: Iterator\n}\n```\n\n- **2.7** 命名必须要是不模糊的并且方便表述的\n\n```\n// PREFERRED\nclass RoundAnimatingButton: UIButton { /* ... */ }\n\n// NOT PREFERRED\nclass CustomButton: UIButton { /* ... */ }\n```\n\n- **2.8** 不要使用缩写，可以选择较为简短的单词。\n\n```\n// PREFERRED\nclass RoundAnimatingButton: UIButton {\n    let animationDuration: NSTimeInterval\n\n    func startAnimating() {\n        let firstSubview = subviews.first\n    }\n\n}\n\n// NOT PREFERRED\nclass RoundAnimating: UIButton {\n    let aniDur: NSTimeInterval\n\n    func srtAnmating() {\n        let v = subviews.first\n    }\n}\n```\n\n- **2.9** 对于不是很明显的类型需要将类型信息包含在属性名中。\n\n```\n// PREFERRED\nclass ConnectionTableViewCell: UITableViewCell {\n    let personImageView: UIImageView\n\n    let animationDuration: NSTimeInterval\n\n    // it is ok not to include string in the ivar name here because it's obvious\n    // that it's a string from the property name\n    let firstName: String\n\n    // though not preferred, it is OK to use `Controller` instead of `ViewController`\n    let popupController: UIViewController\n    let popupViewController: UIViewController\n\n    // when working with a subclass of `UIViewController` such as a table view\n    // controller, collection view controller, split view controller, etc.,\n    // fully indicate the type in the name.\n    let popupTableViewController: UITableViewController\n\n    // when working with outlets, make sure to specify the outlet type in the\n    // variable name.\n    @IBOutlet weak var submitButton: UIButton!\n    @IBOutlet weak var emailTextField: UITextField!\n    @IBOutlet weak var nameLabel: UILabel!\n\n}\n\n// NOT PREFERRED\nclass ConnectionTableViewCell: UITableViewCell {\n    // this isn't a `UIImage`, so shouldn't be called image\n    // use personImageView instead\n    let personImage: UIImageView\n\n    // this isn't a `String`, so it should be `textLabel`\n    let text: UILabel\n\n    // `animation` is not clearly a time interval\n    // use `animationDuration` or `animationTimeInterval` instead\n    let animation: NSTimeInterval\n\n    // this is not obviously a `String`\n    // use `transitionText` or `transitionString` instead\n    let transition: String\n\n    // this is a view controller - not a view\n    let popupView: UIViewController\n\n    // as mentioned previously, we don't want to use abbreviations, so don't use\n    // `VC` instead of `ViewController`\n    let popupVC: UIViewController\n\n    // even though this is still technically a `UIViewController`, this variable\n    // should indicate that we are working with a *Table* View Controller\n    let popupViewController: UITableViewController\n\n    // for the sake of consistency, we should put the type name at the end of the\n    // variable name and not at the start\n    @IBOutlet weak var btnSubmit: UIButton!\n    @IBOutlet weak var buttonSubmit: UIButton!\n\n    // we should always have a type in the variable name when dealing with outlets\n    // for example, here, we should have `firstNameLabel` instead\n    @IBOutlet weak var firstName: UILabel!\n}\n```\n\n- **2.10** 在编写函数参数的时候，要保证每个参数都易于理解其功能。\n- **2.11** 根据 [Apple's API Design Guidelines](https://swift.org/documentation/api-design-guidelines/), 对于`protocol`，如果其描述的是正在做的事情，譬如`Collection`，那么应该命名为名词。而如果是用于描述某种能力，譬如`Equatable`, `ProgressReporting`，那么应该添加 `able`, `ible`, 或者 `ing` 这样的后缀。如果你的协议并不符合上述两种情形，那么应该直接添加一个`Protocol`后缀，譬如：\n\n```\n// here, the name is a noun that describes what the protocol does\nprotocol TableViewSectionProvider {\n    func rowHeight(atRow row: Int) -> CGFloat\n    var numberOfRows: Int { get }\n    /* ... */\n}\n\n// here, the protocol is a capability, and we name it appropriately\nprotocol Loggable {\n    func logCurrentState()\n    /* ... */\n}\n\n// suppose we have an `InputTextView` class, but we also want a protocol\n// to generalize some of the functionality - it might be appropriate to\n// use the `Protocol` suffix here\nprotocol InputTextViewProtocol {\n    func sendTrackingEvent()\n    func inputText() -> String\n    /* ... */\n}\n```\n\n## 3. Coding Style\n\n###3.1 General\n\n- **3.1.1** 尽可能地使用`let`来代替`var`。\n- **3.1.2** 尽可能地使用 `map`, `filter`, `reduce`的组合来进行集合的转换等操作，并且尽可能地避免使用带有副作用的闭包。\n\n```\n// PREFERRED\nlet stringOfInts = [1, 2, 3].flatMap { String($0) }\n// [\"1\", \"2\", \"3\"]\n\n// NOT PREFERRED\nvar stringOfInts: [String] = []\nfor integer in [1, 2, 3] {\n    stringOfInts.append(String(integer))\n}\n\n// PREFERRED\nlet evenNumbers = [4, 8, 15, 16, 23, 42].filter { $0 % 2 == 0 }\n// [4, 8, 16, 42]\n\n// NOT PREFERRED\nvar evenNumbers: [Int] = []\nfor integer in [4, 8, 15, 16, 23, 42] {\n    if integer % 2 == 0 {\n        evenNumbers(integer)\n    }\n}\n```\n\n- **3.1.3** 尽可能地显式声明不方便进行类型推测的变量或者常量的类型名。\n- **3.1.4** 如果你的函数需要返回多个参数，那么尽可能地使用`Tuple`来代替`inout`参数。如果你会多次使用某个元组，那么应该使用`typealias`设置别名。如果返回的参数超过三个，那么应该使用结构体或者类来替代。\n\n```\nfunc pirateName() -> (firstName: String, lastName: String) {\n    return (\"Guybrush\", \"Threepwood\")\n}\n\nlet name = pirateName()\nlet firstName = name.firstName\nlet lastName = name.lastName\n```\n\n- **3.1.5** 在创建delegates/protocols的时候需要小心所谓的保留环(retain cycles)，这些属性需要被声明为`weak`。\n- **3.1.6** 在闭包中直接调用`self`可能会导致保留环，可以使用[capture list](https://developer.apple.com/library/ios/documentation/swift/conceptual/Swift_Programming_Language/Closures.html#//apple_ref/doc/uid/TP40014097-CH11-XID_163) 在这种情况下:\n\n```\nmyFunctionWithClosure() { [weak self] (error) -> Void in\n    // you can do this\n\n    self?.doSomething()\n\n    // or you can do this\n\n    guard let strongSelf = self else {\n        return\n    }\n\n    strongSelf.doSomething()\n}\n```\n\n- **3.1.7** 不要使用 labeled breaks。\n- **3.1.8** 不要在控制流逻辑判断的时候加上圆括号\n\n```\n// PREFERRED\nif x == y {\n    /* ... */\n}\n\n// NOT PREFERRED\nif (x == y) {\n    /* ... */\n}\n```\n\n- **3.1.9** 避免在使用enum的时候写出全名\n\n```\n// PREFERRED\nimageView.setImageWithURL(url, type: .person)\n\n// NOT PREFERRED\nimageView.setImageWithURL(url, type: AsyncImageView.Type.person)\n```\n\n- **3.1.10** 在写类方法的时候不能用简短写法，应该使用类名.方法名，这样能够保证代码的可读性\n\n```\n// PREFERRED\nimageView.backgroundColor = UIColor.whiteColor()\n\n// NOT PREFERRED\nimageView.backgroundColor = .whiteColor()\n```\n\n- **3.1.11** 在非必要的时候不要写`self.`。\n- **3.1.12** 在编写某个方法的时候注意考虑下这个方法是否有可能被复写，如果不可能被复写那么应该使用`final`修饰符。还要注意加上final之后也会导致无法在测试的时候进行复写，所以还是需要综合考虑。一般而言，加上`final`修饰符后会提高编译的效率，所以应该尽可能地使用该修饰符。\n- **3.1.13** 在使用譬如`else`, `catch`等等类似的语句的时候，将关键字与花括号放在一行，同样遵循[1TBS style](https://en.m.wikipedia.org/wiki/Indent_style#Variant:_1TBS)规范，这边列出了常见的`if`/`else` 以及 `do`/`catch` 示范代码。\n\n```\nif someBoolean {\n    // do something\n} else {\n    // do something else\n}\n\ndo {\n    let fileContents = try readFile(\"filename.txt\")\n} catch {\n    print(error)\n}\n```\n\n###3.2 Access Modifiers\n\n- **3.2.1** 在需要的时候应该将访问修饰符放在关键字的第一位。\n\n```\n// PREFERRED\nprivate static let kMyPrivateNumber: Int\n\n// NOT PREFERRED\nstatic private let kMyPrivateNumber: Int\n```\n\n- **3.2.2** 访问修饰符不应该单独放一行：\n\n```\n// PREFERRED\npublic class Pirate {\n    /* ... */\n}\n\n// NOT PREFERRED\npublic\nclass Pirate {\n    /* ... */\n}\n```\n\n- **3.2.3** 一般来说，不要显式地写默认的 `internal`访问修饰符。\n- **3.2.4** 如果某个变量需要在测试的时候被使用到，那么应该标识为`internal`来保证`@testable import ModuleName`。这里需要注意的是，对于某些应该被声明为`private`的变量因为测试用途而声明为了`internal`，那么应该在注释里特别地注明。\n\n```\n/**\n This variable defines the pirate's name.\n - warning: Not `private` for `@testable`.\n */\nlet pirateName = \"LeChuck\"\n```\n\n### [](https://github.com/wxyyxc1992/iOS-Boilerplate/blob/master/Doc/language/swift/advanced/bestpractices/styleguide/linkedin-swift-style-guide.md#33-custom-operators自定义操作符)3.3 Custom Operators:自定义操作符\n\n尽可能地选用命名函数来代替自定义操作符。如果你打算引入一个自定义的操作符，那么一定要有非常充分的理由来说明为啥要讲一个新的操作符引入到全局作用域，而不是使用其他一些可替代的方式。你也可以选择去复写一些现有的操作符，譬如`==`来适应一些新的类型，不过要保证你添加的用法一定要与语义相符。譬如`==` 应该只能用于表示相等性测试并且返回一个布尔值。\n\n###3.4 Switch Statements and `enum`s\n\n- **3.4.1** 在使用枚举类型作为switch的参数的时候，避免引入`default`关键字，而应该将没有使用的情形放到下面然后使用break关键字来避免被执行。\n- **3.4.2** Swift中默认会在每个case的结尾进行break，因此没必要的时候不需要显式地声明`break`关键字。\n- **3.4.3** The `case` statements should line up with the `switch` statement itself as per default Swift standards.\n- **3.4.4** When defining a case that has an associated value, make sure that this value is appropriately labeled as opposed to just types (e.g. `case Hunger(hungerLevel: Int)` instead of `case Hunger(Int)`).\n\n```\nenum Problem {\n    case attitude\n    case hair\n    case hunger(hungerLevel: Int)\n}\n\nfunc handleProblem(problem: Problem) {\n    switch problem {\n    case .attitude:\n        print(\"At least I don't have a hair problem.\")\n    case .hair:\n        print(\"Your barber didn't know when to stop.\")\n    case .hunger(let hungerLevel):\n        print(\"The hunger level is \\(hungerLevel).\")\n    }\n}\n```\n\n- **3.4.5** 优先使用譬如`case 1, 2, 3:`这样的列表表达式而不是使用`fallthrough`关键字。\n- **3.4.6** 如果你添加了一个默认的case并且该case不应该被使用，那么应该在default情形下抛出异常。\n\n```\nfunc handleDigit(digit: Int) throws {\n    case 0, 1, 2, 3, 4, 5, 6, 7, 8, 9:\n        print(\"Yes, \\(digit) is a digit!\")\n    default:\n        throw Error(message: \"The given number was not a digit.\")\n}\n```\n\n###3.5 Optionals\n\n- **3.5.1** 只应该在 `@IBOutlet`中使用隐式地未包裹的Options。否则其他情况下就应该使用Non-Optional或者正常的Optional的变量。虽然有时候你能保证某个变量肯定非`nil`，不过这样用的话还是比较安全并且能保证上下一致性。\n\nThe only time you should be using implicitly unwrapped optionals is withs. In every other case, it is better to use a non-optional or regular optional variable. Yes, there are cases in which you can probably \"guarantee\" that the variable will never be `nil` when used, but it is better to be safe and consistent.\n\n- **3.5.2** 不要使用 `as!` 或者 `try!`.\n- **3.5.3** 如果你只是打算判断存放在Optional中的值是否为空，那么你应该直接与`nil`进行判断而不是使用`if let`语句将值取出来。\n\n```\n// PREFERERED\nif someOptional != nil {\n    // do something\n}\n\n// NOT PREFERRED\nif let _ = someOptional {\n    // do something\n}\n```\n\n- **3.5.4** 不要使用 `unowned`。你可以将`unowned`当做对于`weak`变量的隐式解包，虽然有时候`unowned`与`weak`相比有小小地性能提升，不过还是不建议进行使用。\n\n```\n// PREFERRED\nweak var parentViewController: UIViewController?\n\n// NOT PREFERRED\nweak var parentViewController: UIViewController!\nunowned var parentViewController: UIViewController\n```\n\n- **3.5.5** 当对Optionals进行解包的时候，使用与Optionals变量一致的变量名\n\n```\nguard let myVariable = myVariable else {\n    return\n}\n\n```\n\n### 3.6 Protocols\n\n在实现协议的时候，大体上有两种代码组织方式：\n\n1. 使用 `// MARK:` 来注释你的专门用于实现协议中规定的方法\n2. 在你的类或者结构体实现之外使用一个扩展来存放实现代码，不过要保证在一个源文件中\n\n不过需要注意的是，如果你是使用了Extension方式，那么定义在Extension中的方法是无法被子类复写的，这样可能会无法进行测试。\n\n### [](https://github.com/wxyyxc1992/iOS-Boilerplate/blob/master/Doc/language/swift/advanced/bestpractices/styleguide/linkedin-swift-style-guide.md#37-properties)3.7 Properties\n\n- **3.7.1** 如果是定义一个只读的需要经过计算的属性，那么不需要声明 `get {}`\n\n```\nvar computedProperty: String {\n    if someBool {\n        return \"I'm a mighty pirate!\"\n    }\n    return \"I'm selling these fine leather jackets.\"\n}\n```\n\n- **3.7.2** 在使用 `get {}`, `set {}`, `willSet`, 以及 `didSet`, 注意块的缩进\n- **3.7.3** 尽管你可以在`willSet`/`didSet`以及 `set`方法中使用自定义的名称，不过建议还是使用默认的`newValue`/`oldValue`变量名\n\n```\nvar computedProperty: String {\n    get {\n        if someBool {\n            return \"I'm a mighty pirate!\"\n        }\n        return \"I'm selling these fine leather jackets.\"\n    }\n    set {\n        computedProperty = newValue\n    }\n    willSet {\n        print(\"will set to \\(newValue)\")\n    }\n    didSet {\n        print(\"did set from \\(oldValue) to \\(newValue)\")\n    }\n}\n```\n\n- **3.7.4** 将任何类常量设置为`static`\n\n```\nclass MyTableViewCell: UITableViewCell {\n    static let kReuseIdentifier = String(MyTableViewCell)\n    static let kCellHeight: CGFloat = 80.0\n}\n```\n\n- **3.7.5** 可以使用如下方式便捷地声明一个单例变量：\n\n```\nclass PirateManager {\n    static let sharedInstance = PirateManager()\n\n    /* ... */\n}\n```\n\n### 3.8 Closures:闭包\n\n- **3.8.1** 如果闭包中的某个参数的类型是显而易见的，那么可以避免声明类型。不过有时候为了保证可读性与一致性，还是会显示声明参数类型。\n\n```\n// omitting the type\ndoSomethingWithClosure() { response in\n    print(response)\n}\n\n// explicit type\ndoSomethingWithClosure() { response: NSURLResponse in\n    print(response)\n}\n\n// using shorthand in a map statement\n[1, 2, 3].flatMap { String($0) }\n```\n\n- **3.8.2** 在参数列表中，如果是使用了捕获变量或者声明了非Void的返回值，那么应该将参数列表写在一个圆括号里，其他情况下则可以省略圆括号。\n\n```\n// parentheses due to capture list\ndoSomethingWithClosure() { [weak self] (response: NSURLResponse) in\n    self?.handleResponse(response)\n}\n\n// parentheses due to return type\ndoSomethingWithClosure() { (response: NSURLResponse) -> String in\n    return String(response)\n}\n```\n\n- **3.8.3** 如果你是将闭包声明为一个类型，那么除非该类型为Optional或者该闭包是另一个闭包的参数，否则不需要使用圆括号进行包裹。不过需要用圆括号来标注参数列表，并且使用`Void`来指明没有任何结果返回。\n\n```\nlet completionBlock: (success: Bool) -> Void = {\n    print(\"Success? \\(success)\")\n}\n\nlet completionBlock: () -> Void = {\n    print(\"Completed!\")\n}\n\nlet completionBlock: (() -> Void)? = nil\n```\n\n- **3.8.4** 尽可能地将参数名与左括号放在一行，不过要避免打破每行最长160个字符的限制。\n\nKeep parameter names on same line as the opening brace for closures when possible without too much horizontal overflow (i.e. ensure lines are less than 160 characters).\n\n- **3.8.5** 尽可能地使用 trailing closure表达式，除非需要显示地声明闭包参数的外部参数名。\n\n```\n// trailing closure\ndoSomething(1.0) { parameter1 in\n    print(\"Parameter 1 is \\(parameter1)\")\n}\n\n// no trailing closure\ndoSomething(1.0, success: { parameter1 in\n    print(\"Success with \\(parameter1)\")\n}, failure: { parameter1 in\n    print(\"Failure with \\(parameter1)\")\n})\n```\n\n###3.9 Arrays\n\n- **3.9.1** 一般来说，避免使用下标直接访问某个数组，而应该使用类似于`.first`、`.last`这样的访问器进行访问。另外，应该优先使用`for item in items`语法来替代`for i in 0..。如果你打算用下标遍历数组，那么一定保证不能越界。\n- **3.9.2** 永远不要使用`+=` 或者 `+`运算符来增加或者连接数组，应该使用`.append()` 或者 `.appendContentsOf()` 方法。如果你想定义一个从其他数组生成的不可变数组，那么应该使用`let`关键字，即： `let myNewArray = arr1 + arr2`, 或者 `let myNewArray = [arr1, arr2].flatten()`。\n\n### [](https://github.com/wxyyxc1992/iOS-Boilerplate/blob/master/Doc/language/swift/advanced/bestpractices/styleguide/linkedin-swift-style-guide.md#310-error-handling)3.10 Error Handling\n\n假设某个函数 `myFunction` 需要去返回一个`String`类型，不过有可能会在某个点抛出异常，一般来说会将该函数的返回值设置为`String?`：\n\nExample:\n\n```\nfunc readFile(withFilename filename: String) -> String? {\n    guard let file = openFile(filename) else {\n        return nil\n    }\n\n    let fileContents = file.read()\n    file.close()\n    return fileContents\n}\n\nfunc printSomeFile() {\n    let filename = \"somefile.txt\"\n    guard let fileContents = readFile(filename) else {\n        print(\"Unable to open file \\(filename).\")\n        return\n    }\n    print(fileContents)\n}\n```\n\n不过作为异常处理的角度，我们应该使用Swift的`try-catch`表达式，这样能显式地知道错误点：\n\n```\nstruct Error: ErrorType {\n    public let file: StaticString\n    public let function: StaticString\n    public let line: UInt\n    public let message: String\n\n    public init(message: String, file: StaticString = #file, function: StaticString = #function, line: UInt = #line) {\n        self.file = file\n        self.function = function\n        self.line = line\n        self.message = message\n    }\n}\n```\n\nExample usage:\n\n```\nfunc readFile(withFilename filename: String) throws -> String {\n    guard let file = openFile(filename) else {\n        throw Error(message: \"Unable to open file named \\(filename).\")\n    }\n\n    let fileContents = file.read()\n    file.close()\n    return fileContents\n}\n\nfunc printSomeFile() {\n    do {\n        let fileContents = try readFile(filename)\n        print(fileContents)\n    } catch {\n        print(error)\n    }\n}\n```\n\n总而言之，如果某个函数可能会出错，并且出错的原因不能显式地观测到，那么应该优先抛出异常而不是使用一个Optional作为返回值。\n\n###3.11 Using `guard` Statements\n\n- **3.11.1** 一般来说，我们会优先使用所谓的\"early return\"策略来避免`if`表达式中的多层嵌套的代码。在这种情况下使用`guard`语句能够有效地提升代码的可读性。\n\n```\n// PREFERRED\nfunc eatDoughnut(atIndex index: Int) {\n    guard index >= 0 && index < doughnuts else {\n        // return early because the index is out of bounds\n        return\n    }\n\n    let doughnut = doughnuts[index]\n    eat(doughnut)\n}\n\n// NOT PREFERRED\nfunc eatDoughnuts(atIndex index: Int) {\n    if index >= 0 && index < donuts.count {\n        let doughnut = doughnuts[index]\n        eat(doughnut)\n    }\n}\n```\n\n- **3.11.2** 在对Optional类型进行解包的时候，优先使用 `guard` 语句来避免`if`语句中较多的缩进。\n\n```\n// PREFERRED\nguard let monkeyIsland = monkeyIsland else {\n    return\n}\nbookVacation(onIsland: monkeyIsland)\nbragAboutVacation(onIsland: monkeyIsland)\n\n// NOT PREFERRED\nif let monkeyIsland = monkeyIsland {\n    bookVacation(onIsland: monkeyIsland)\n    bragAboutVacation(onIsland: monkeyIsland)\n}\n\n// EVEN LESS PREFERRED\nif monkeyIsland == nil {\n    return\n}\nbookVacation(onIsland: monkeyIsland!)\nbragAboutVacation(onIsland: monkeyIsland!)\n```\n\n- **3.11.3** 在决定是要用`if`表达式还是`guard`表达式进行Optional类型解包的时候，最重要的点就是要保证代码的可读性。很多时候要注意因时而变，因地制宜：\n\n```\n// an `if` statement is readable here\nif operationFailed {\n    return\n}\n\n// a `guard` statement is readable here\nguard isSuccessful else {\n    return\n}\n\n// double negative logic like this can get hard to read - i.e. don't do this\nguard !operationFailed else {\n    return\n}\n```\n\n- **3.11.4** 当需要进行多可能性处理的时候，应该优先使用`if`表达式而不是`guard`表达式。\n\n```\n// PREFERRED\nif isFriendly {\n    print(\"Hello, nice to meet you!\")\n} else {\n    print(\"You have the manners of a beggar.\")\n}\n\n// NOT PREFERRED\nguard isFriendly else {\n    print(\"You have the manners of a beggar.\")\n    return\n}\n\nprint(\"Hello, nice to meet you!\")\n```\n\n- **3.11.5** 一般来说，`guard`应该被用于需要直接退出当前上下文的情形。而对于下面这种两个条件互不干扰的情况，应该使用两个`if`而不是两个`guard`。\n\n```\nif let monkeyIsland = monkeyIsland {\n    bookVacation(onIsland: monkeyIsland)\n}\n\nif let woodchuck = woodchuck where canChuckWood(woodchuck) {\n    woodchuck.chuckWood()\n}\n```\n\n- **3.11.6** 有时候我们会碰到要用`guard`语句进行多个optionals解包的情况，一般而言，对于复杂的错误处理的Optional类型需要将其拆分到多个单个表达式中。\n\n```\n// combined because we just return\nguard let thingOne = thingOne,\n    let thingTwo = thingTwo,\n    let thingThree = thingThree else {\n    return\n}\n\n// separate statements because we handle a specific error in each case\nguard let thingOne = thingOne else {\n    throw Error(message: \"Unwrapping thingOne failed.\")\n}\n\nguard let thingTwo = thingTwo else {\n    throw Error(message: \"Unwrapping thingTwo failed.\")\n}\n\nguard let thingThree = thingThree else {\n    throw Error(message: \"Unwrapping thingThree failed.\")\n}\n```\n\n- **3.11.7** 不要将`guard`表达式强行缩写到一行内。\n\n```\n// PREFERRED\nguard let thingOne = thingOne else {\n    return\n}\n\n// NOT PREFERRED\nguard let thingOne = thingOne else { return }\n```\n\n## 4. Documentation/Comments\n\n### [](https://github.com/wxyyxc1992/iOS-Boilerplate/blob/master/Doc/language/swift/advanced/bestpractices/styleguide/linkedin-swift-style-guide.md#41-documentation)4.1 Documentation\n\n如果某个函数不是简单地`O(1)`操作，那么最好就是为该函数添加一些注释文档，这样能有效地提高代码的可读性与可维护性。之前有个非常不错的文档工具[VVDocumenter](https://github.com/onevcat/VVDocumenter-Xcode)。推荐阅读Apple的官方指南中的描述：[described in Apple's Documentation](https://developer.apple.com/library/tvos/documentation/Xcode/Reference/xcode_markup_formatting_ref/Attention.html#//apple_ref/doc/uid/TP40016497-CH29-SW1).\n\nGuidelines:\n\n- **4.1.1** 每行不应超过160个字符\n- **4.1.2** 即使某些注释只有一行，也应该使用块注释符： (`/** */`).\n- **4.1.3** 不用给每行的开头都加上： `*`.\n- **4.1.4** 使用新的 `- parameter` 标识符来代替老的`:param:` syntax (注意这边是小写的 `parameter` 而不是`Parameter`).\n- **4.1.5** 如果你准备对参数/返回值/异常值来写注释，那么注意要一个不落的全局加上，尽管有时候会让文档显得重复冗余。有时候，如果只需要对单个参数进行注释，那么还不如直接放在描述里进行声明，而不需要专门的为参数写一个注释。\n- **4.1.6** 对于复杂的使用类，应该添加一些具体的使用用例来描述类的用法。注意Swift的注释文档中是支持MarkDown语法的，这是一个很好的特性。\n\n```\n/**\n ## Feature Support\n\n This class does some awesome things. It supports:\n\n - Feature 1\n - Feature 2\n - Feature 3\n\n ## Examples\n\n Here is an example use case indented by four spaces because that indicates a\n code block:\n\n     let myAwesomeThing = MyAwesomeClass()\n     myAwesomeThing.makeMoney()\n\n ## Warnings:告警\n\n There are some things you should be careful of:\n\n 1. Thing one\n 2. Thing two\n 3. Thing three\n */\nclass MyAwesomeClass {\n    /* ... */\n}\n```\n\n- **4.1.7** 使用 - ` 在注释中著名引用的代码\n\n```\n/**\n This does something with a `UIViewController`, perchance.\n - warning: Make sure that `someValue` is `true` before running this function.\n */\nfunc myFunction() {\n    /* ... */\n}\n```\n\n- **4.1.8** 保证文档的注释尽可能的简洁\n\n### 4.2 Other Commenting Guidelines:其他的注释规则\n\n- **4.2.1** `//`后面总是要跟上一个空格\n- **4.2.2** 注释永远要放在单独的行中\n- **4.2.3** 在使用`// MARK: - whatever`的时候，注意MARK与代码之间保留一个空行\n\n```\nclass Pirate {\n\n    // MARK: - instance properties\n\n    private let pirateName: String\n\n    // MARK: - initialization\n\n    init() {\n        /* ... */\n    }\n\n}\n```\n\n\n\n原文链接:[github:Swift Style Guide](https://github.com/wxyyxc1992/iOS-Boilerplate/blob/master/Doc/language/swift/advanced/bestpractices/styleguide/linkedin-swift-style-guide.md#1-code-formatting)\n\n\n","source":"_posts/来自-Linkedin-的-Swift-编程风格指南.md","raw":"---\ntitle: 来自 Linkedin 的 Swift 编程风格指南\ntags: '转载'\npermalink: lai-zi-linkedin-de-swift-bian-cheng-feng-ge-zhi-nan\nid: 25\nupdated: '2016-07-03 17:36:24'\ndate: 2016-07-03 09:37:29\n---\n\n\n\n\n![](https://ooo.0o0.ooo/2016/07/03/5778dc0ab45a1.jpg)\n##1. Code Formatting:代码格式化\n\n- **1.1** 使用4个空格来代替Tabs\n- **1.2** 避免过长的行，可以在XCode中进行设置单行最大长度：(Xcode->Preferences->Text Editing->Page guide at column: 160 is helpful for this)\n- **1.3** 保证每个文件结尾都存在一个新行 Ensure that there is a newline at the end of every file.\n- **1.4** 避免无意义的尾随空格: (Xcode->Preferences->Text Editing->Automatically trim trailing whitespace + Including whitespace-only lines).\n- **1.5** 避免将单独的左花括号放置到一行，我们参考了：[1TBS style](https://en.m.wikipedia.org/wiki/Indent_style#Variant:_1TBS).\n\n```\nclass SomeClass {\n    func someMethod() {\n        if x == y {\n            /* ... */\n        } else if x == z {\n            /* ... */\n        } else {\n            /* ... */\n        }\n    }\n\n    /* ... */\n}\n```\n\n- **1.6** 在写变量的类型声明、字典类型的键、函数参数、协议的声明或者父类的时候，不要在冒号前添加空格。\n\n```\n// specifying type\nlet pirateViewController: PirateViewController\n\n// dictionary syntax (note that we left-align as opposed to aligning colons)\nlet ninjaDictionary: [String: AnyObject] = [\n    \"fightLikeDairyFarmer\": false,\n    \"disgusting\": true\n]\n\n// declaring a function\nfunc myFunction<T, U: SomeProtocol where T.RelatedType == U>(firstArgument: U, secondArgument: T) {\n    /* ... */\n}\n\n// calling a function\nsomeFunction(someArgument: \"Kitten\")\n\n// superclasses\nclass PirateViewController: UIViewController {\n    /* ... */\n}\n\n// protocols\nextension PirateViewController: UITableViewDataSource {\n    /* ... */\n}\n```\n\n- **1.7** 一般来说，逗号后面都要跟随一个空格。\n\n```\nlet myArray = [1, 2, 3, 4, 5]\n```\n\n- **1.8** 在二元操作符譬如`+`, `==`, 或者 `->`的前后需要加上空格，但是对于`(` 、`)的前后不需要加空格。\n\n\n- **1.9** 我们默认使用Xcode推荐的格式化风格(CTRL-I) ，在声明某个函数的时候会多行排布参数。\n\n\n- **1.10** 在调用多参数函数的时候，会把多个参数放置到单独的行中：\n\n\n\n- **1.11** 对于大型的数组或者字典类型，应该将其分割到多行内，`[` 与 `]`类比于花括号进行处理。对于闭包而言也应该同样适合于该规则。\n\n\n\n- **1.12** 尽可能地使用本地变量的方式来避免多行的判断语句。\n\n\n##2. Naming:命名\n\n- **2.1** Swift中不需要再使用Objective-C那样的前缀，譬如使用 `GuybrushThreepwood` 而不是`LIGuybrushThreepwood`。\n- **2.2** 对于类型名即`struct`, `enum`, `class`, `typedef`, `associatedtype`等等使用 `PascalCase` 。\n- **2.3** 对于函数名、方法名、变量名、常量、参数名等使用`camelCase`。\n- **2.4** 在使用首字母缩写的时候尽可能地全部大写，并且注意保证全部代码中的统一。不过如果缩写被用于命名的起始，那么就全部小写。\n\n```\n// \"HTML\" is at the start of a variable name, so we use lowercase \"html\"\nlet htmlBodyContent: String = \"<p>Hello, World!</p>\"\n// Prefer using ID to Id\nlet profileID: Int = 1\n// Prefer URLFinder to UrlFinder\nclass URLFinder {\n    /* ... */\n}\n```\n\n- **2.5** 对于静态常量使用 `k` 前缀 + PascalCase。\n\n```\nclass MyClassName {\n    // use `k` prefix for constant primitives\n    static let kSomeConstantHeight: CGFloat = 80.0\n\n    // use `k` prefix for non-primitives as well\n    static let kDeleteButtonColor = UIColor.redColor()\n\n    // don't use `k` prefix for singletons\n    static let sharedInstance = MyClassName()\n\n    /* ... */\n}\n```\n\n- **2.6** 对于泛型或者关联类型，使用`PascalCase`描述泛型，如果泛型名与其他重复，那么可以添加一个`Type`后缀名到泛型名上。\n\n```\nclass SomeClass<T> { /* ... */ }\nclass SomeClass<Model> { /* ... */ }\nprotocol Modelable {\n    associatedtype Model\n}\nprotocol Sequence {\n    associatedtype IteratorType: Iterator\n}\n```\n\n- **2.7** 命名必须要是不模糊的并且方便表述的\n\n```\n// PREFERRED\nclass RoundAnimatingButton: UIButton { /* ... */ }\n\n// NOT PREFERRED\nclass CustomButton: UIButton { /* ... */ }\n```\n\n- **2.8** 不要使用缩写，可以选择较为简短的单词。\n\n```\n// PREFERRED\nclass RoundAnimatingButton: UIButton {\n    let animationDuration: NSTimeInterval\n\n    func startAnimating() {\n        let firstSubview = subviews.first\n    }\n\n}\n\n// NOT PREFERRED\nclass RoundAnimating: UIButton {\n    let aniDur: NSTimeInterval\n\n    func srtAnmating() {\n        let v = subviews.first\n    }\n}\n```\n\n- **2.9** 对于不是很明显的类型需要将类型信息包含在属性名中。\n\n```\n// PREFERRED\nclass ConnectionTableViewCell: UITableViewCell {\n    let personImageView: UIImageView\n\n    let animationDuration: NSTimeInterval\n\n    // it is ok not to include string in the ivar name here because it's obvious\n    // that it's a string from the property name\n    let firstName: String\n\n    // though not preferred, it is OK to use `Controller` instead of `ViewController`\n    let popupController: UIViewController\n    let popupViewController: UIViewController\n\n    // when working with a subclass of `UIViewController` such as a table view\n    // controller, collection view controller, split view controller, etc.,\n    // fully indicate the type in the name.\n    let popupTableViewController: UITableViewController\n\n    // when working with outlets, make sure to specify the outlet type in the\n    // variable name.\n    @IBOutlet weak var submitButton: UIButton!\n    @IBOutlet weak var emailTextField: UITextField!\n    @IBOutlet weak var nameLabel: UILabel!\n\n}\n\n// NOT PREFERRED\nclass ConnectionTableViewCell: UITableViewCell {\n    // this isn't a `UIImage`, so shouldn't be called image\n    // use personImageView instead\n    let personImage: UIImageView\n\n    // this isn't a `String`, so it should be `textLabel`\n    let text: UILabel\n\n    // `animation` is not clearly a time interval\n    // use `animationDuration` or `animationTimeInterval` instead\n    let animation: NSTimeInterval\n\n    // this is not obviously a `String`\n    // use `transitionText` or `transitionString` instead\n    let transition: String\n\n    // this is a view controller - not a view\n    let popupView: UIViewController\n\n    // as mentioned previously, we don't want to use abbreviations, so don't use\n    // `VC` instead of `ViewController`\n    let popupVC: UIViewController\n\n    // even though this is still technically a `UIViewController`, this variable\n    // should indicate that we are working with a *Table* View Controller\n    let popupViewController: UITableViewController\n\n    // for the sake of consistency, we should put the type name at the end of the\n    // variable name and not at the start\n    @IBOutlet weak var btnSubmit: UIButton!\n    @IBOutlet weak var buttonSubmit: UIButton!\n\n    // we should always have a type in the variable name when dealing with outlets\n    // for example, here, we should have `firstNameLabel` instead\n    @IBOutlet weak var firstName: UILabel!\n}\n```\n\n- **2.10** 在编写函数参数的时候，要保证每个参数都易于理解其功能。\n- **2.11** 根据 [Apple's API Design Guidelines](https://swift.org/documentation/api-design-guidelines/), 对于`protocol`，如果其描述的是正在做的事情，譬如`Collection`，那么应该命名为名词。而如果是用于描述某种能力，譬如`Equatable`, `ProgressReporting`，那么应该添加 `able`, `ible`, 或者 `ing` 这样的后缀。如果你的协议并不符合上述两种情形，那么应该直接添加一个`Protocol`后缀，譬如：\n\n```\n// here, the name is a noun that describes what the protocol does\nprotocol TableViewSectionProvider {\n    func rowHeight(atRow row: Int) -> CGFloat\n    var numberOfRows: Int { get }\n    /* ... */\n}\n\n// here, the protocol is a capability, and we name it appropriately\nprotocol Loggable {\n    func logCurrentState()\n    /* ... */\n}\n\n// suppose we have an `InputTextView` class, but we also want a protocol\n// to generalize some of the functionality - it might be appropriate to\n// use the `Protocol` suffix here\nprotocol InputTextViewProtocol {\n    func sendTrackingEvent()\n    func inputText() -> String\n    /* ... */\n}\n```\n\n## 3. Coding Style\n\n###3.1 General\n\n- **3.1.1** 尽可能地使用`let`来代替`var`。\n- **3.1.2** 尽可能地使用 `map`, `filter`, `reduce`的组合来进行集合的转换等操作，并且尽可能地避免使用带有副作用的闭包。\n\n```\n// PREFERRED\nlet stringOfInts = [1, 2, 3].flatMap { String($0) }\n// [\"1\", \"2\", \"3\"]\n\n// NOT PREFERRED\nvar stringOfInts: [String] = []\nfor integer in [1, 2, 3] {\n    stringOfInts.append(String(integer))\n}\n\n// PREFERRED\nlet evenNumbers = [4, 8, 15, 16, 23, 42].filter { $0 % 2 == 0 }\n// [4, 8, 16, 42]\n\n// NOT PREFERRED\nvar evenNumbers: [Int] = []\nfor integer in [4, 8, 15, 16, 23, 42] {\n    if integer % 2 == 0 {\n        evenNumbers(integer)\n    }\n}\n```\n\n- **3.1.3** 尽可能地显式声明不方便进行类型推测的变量或者常量的类型名。\n- **3.1.4** 如果你的函数需要返回多个参数，那么尽可能地使用`Tuple`来代替`inout`参数。如果你会多次使用某个元组，那么应该使用`typealias`设置别名。如果返回的参数超过三个，那么应该使用结构体或者类来替代。\n\n```\nfunc pirateName() -> (firstName: String, lastName: String) {\n    return (\"Guybrush\", \"Threepwood\")\n}\n\nlet name = pirateName()\nlet firstName = name.firstName\nlet lastName = name.lastName\n```\n\n- **3.1.5** 在创建delegates/protocols的时候需要小心所谓的保留环(retain cycles)，这些属性需要被声明为`weak`。\n- **3.1.6** 在闭包中直接调用`self`可能会导致保留环，可以使用[capture list](https://developer.apple.com/library/ios/documentation/swift/conceptual/Swift_Programming_Language/Closures.html#//apple_ref/doc/uid/TP40014097-CH11-XID_163) 在这种情况下:\n\n```\nmyFunctionWithClosure() { [weak self] (error) -> Void in\n    // you can do this\n\n    self?.doSomething()\n\n    // or you can do this\n\n    guard let strongSelf = self else {\n        return\n    }\n\n    strongSelf.doSomething()\n}\n```\n\n- **3.1.7** 不要使用 labeled breaks。\n- **3.1.8** 不要在控制流逻辑判断的时候加上圆括号\n\n```\n// PREFERRED\nif x == y {\n    /* ... */\n}\n\n// NOT PREFERRED\nif (x == y) {\n    /* ... */\n}\n```\n\n- **3.1.9** 避免在使用enum的时候写出全名\n\n```\n// PREFERRED\nimageView.setImageWithURL(url, type: .person)\n\n// NOT PREFERRED\nimageView.setImageWithURL(url, type: AsyncImageView.Type.person)\n```\n\n- **3.1.10** 在写类方法的时候不能用简短写法，应该使用类名.方法名，这样能够保证代码的可读性\n\n```\n// PREFERRED\nimageView.backgroundColor = UIColor.whiteColor()\n\n// NOT PREFERRED\nimageView.backgroundColor = .whiteColor()\n```\n\n- **3.1.11** 在非必要的时候不要写`self.`。\n- **3.1.12** 在编写某个方法的时候注意考虑下这个方法是否有可能被复写，如果不可能被复写那么应该使用`final`修饰符。还要注意加上final之后也会导致无法在测试的时候进行复写，所以还是需要综合考虑。一般而言，加上`final`修饰符后会提高编译的效率，所以应该尽可能地使用该修饰符。\n- **3.1.13** 在使用譬如`else`, `catch`等等类似的语句的时候，将关键字与花括号放在一行，同样遵循[1TBS style](https://en.m.wikipedia.org/wiki/Indent_style#Variant:_1TBS)规范，这边列出了常见的`if`/`else` 以及 `do`/`catch` 示范代码。\n\n```\nif someBoolean {\n    // do something\n} else {\n    // do something else\n}\n\ndo {\n    let fileContents = try readFile(\"filename.txt\")\n} catch {\n    print(error)\n}\n```\n\n###3.2 Access Modifiers\n\n- **3.2.1** 在需要的时候应该将访问修饰符放在关键字的第一位。\n\n```\n// PREFERRED\nprivate static let kMyPrivateNumber: Int\n\n// NOT PREFERRED\nstatic private let kMyPrivateNumber: Int\n```\n\n- **3.2.2** 访问修饰符不应该单独放一行：\n\n```\n// PREFERRED\npublic class Pirate {\n    /* ... */\n}\n\n// NOT PREFERRED\npublic\nclass Pirate {\n    /* ... */\n}\n```\n\n- **3.2.3** 一般来说，不要显式地写默认的 `internal`访问修饰符。\n- **3.2.4** 如果某个变量需要在测试的时候被使用到，那么应该标识为`internal`来保证`@testable import ModuleName`。这里需要注意的是，对于某些应该被声明为`private`的变量因为测试用途而声明为了`internal`，那么应该在注释里特别地注明。\n\n```\n/**\n This variable defines the pirate's name.\n - warning: Not `private` for `@testable`.\n */\nlet pirateName = \"LeChuck\"\n```\n\n### [](https://github.com/wxyyxc1992/iOS-Boilerplate/blob/master/Doc/language/swift/advanced/bestpractices/styleguide/linkedin-swift-style-guide.md#33-custom-operators自定义操作符)3.3 Custom Operators:自定义操作符\n\n尽可能地选用命名函数来代替自定义操作符。如果你打算引入一个自定义的操作符，那么一定要有非常充分的理由来说明为啥要讲一个新的操作符引入到全局作用域，而不是使用其他一些可替代的方式。你也可以选择去复写一些现有的操作符，譬如`==`来适应一些新的类型，不过要保证你添加的用法一定要与语义相符。譬如`==` 应该只能用于表示相等性测试并且返回一个布尔值。\n\n###3.4 Switch Statements and `enum`s\n\n- **3.4.1** 在使用枚举类型作为switch的参数的时候，避免引入`default`关键字，而应该将没有使用的情形放到下面然后使用break关键字来避免被执行。\n- **3.4.2** Swift中默认会在每个case的结尾进行break，因此没必要的时候不需要显式地声明`break`关键字。\n- **3.4.3** The `case` statements should line up with the `switch` statement itself as per default Swift standards.\n- **3.4.4** When defining a case that has an associated value, make sure that this value is appropriately labeled as opposed to just types (e.g. `case Hunger(hungerLevel: Int)` instead of `case Hunger(Int)`).\n\n```\nenum Problem {\n    case attitude\n    case hair\n    case hunger(hungerLevel: Int)\n}\n\nfunc handleProblem(problem: Problem) {\n    switch problem {\n    case .attitude:\n        print(\"At least I don't have a hair problem.\")\n    case .hair:\n        print(\"Your barber didn't know when to stop.\")\n    case .hunger(let hungerLevel):\n        print(\"The hunger level is \\(hungerLevel).\")\n    }\n}\n```\n\n- **3.4.5** 优先使用譬如`case 1, 2, 3:`这样的列表表达式而不是使用`fallthrough`关键字。\n- **3.4.6** 如果你添加了一个默认的case并且该case不应该被使用，那么应该在default情形下抛出异常。\n\n```\nfunc handleDigit(digit: Int) throws {\n    case 0, 1, 2, 3, 4, 5, 6, 7, 8, 9:\n        print(\"Yes, \\(digit) is a digit!\")\n    default:\n        throw Error(message: \"The given number was not a digit.\")\n}\n```\n\n###3.5 Optionals\n\n- **3.5.1** 只应该在 `@IBOutlet`中使用隐式地未包裹的Options。否则其他情况下就应该使用Non-Optional或者正常的Optional的变量。虽然有时候你能保证某个变量肯定非`nil`，不过这样用的话还是比较安全并且能保证上下一致性。\n\nThe only time you should be using implicitly unwrapped optionals is withs. In every other case, it is better to use a non-optional or regular optional variable. Yes, there are cases in which you can probably \"guarantee\" that the variable will never be `nil` when used, but it is better to be safe and consistent.\n\n- **3.5.2** 不要使用 `as!` 或者 `try!`.\n- **3.5.3** 如果你只是打算判断存放在Optional中的值是否为空，那么你应该直接与`nil`进行判断而不是使用`if let`语句将值取出来。\n\n```\n// PREFERERED\nif someOptional != nil {\n    // do something\n}\n\n// NOT PREFERRED\nif let _ = someOptional {\n    // do something\n}\n```\n\n- **3.5.4** 不要使用 `unowned`。你可以将`unowned`当做对于`weak`变量的隐式解包，虽然有时候`unowned`与`weak`相比有小小地性能提升，不过还是不建议进行使用。\n\n```\n// PREFERRED\nweak var parentViewController: UIViewController?\n\n// NOT PREFERRED\nweak var parentViewController: UIViewController!\nunowned var parentViewController: UIViewController\n```\n\n- **3.5.5** 当对Optionals进行解包的时候，使用与Optionals变量一致的变量名\n\n```\nguard let myVariable = myVariable else {\n    return\n}\n\n```\n\n### 3.6 Protocols\n\n在实现协议的时候，大体上有两种代码组织方式：\n\n1. 使用 `// MARK:` 来注释你的专门用于实现协议中规定的方法\n2. 在你的类或者结构体实现之外使用一个扩展来存放实现代码，不过要保证在一个源文件中\n\n不过需要注意的是，如果你是使用了Extension方式，那么定义在Extension中的方法是无法被子类复写的，这样可能会无法进行测试。\n\n### [](https://github.com/wxyyxc1992/iOS-Boilerplate/blob/master/Doc/language/swift/advanced/bestpractices/styleguide/linkedin-swift-style-guide.md#37-properties)3.7 Properties\n\n- **3.7.1** 如果是定义一个只读的需要经过计算的属性，那么不需要声明 `get {}`\n\n```\nvar computedProperty: String {\n    if someBool {\n        return \"I'm a mighty pirate!\"\n    }\n    return \"I'm selling these fine leather jackets.\"\n}\n```\n\n- **3.7.2** 在使用 `get {}`, `set {}`, `willSet`, 以及 `didSet`, 注意块的缩进\n- **3.7.3** 尽管你可以在`willSet`/`didSet`以及 `set`方法中使用自定义的名称，不过建议还是使用默认的`newValue`/`oldValue`变量名\n\n```\nvar computedProperty: String {\n    get {\n        if someBool {\n            return \"I'm a mighty pirate!\"\n        }\n        return \"I'm selling these fine leather jackets.\"\n    }\n    set {\n        computedProperty = newValue\n    }\n    willSet {\n        print(\"will set to \\(newValue)\")\n    }\n    didSet {\n        print(\"did set from \\(oldValue) to \\(newValue)\")\n    }\n}\n```\n\n- **3.7.4** 将任何类常量设置为`static`\n\n```\nclass MyTableViewCell: UITableViewCell {\n    static let kReuseIdentifier = String(MyTableViewCell)\n    static let kCellHeight: CGFloat = 80.0\n}\n```\n\n- **3.7.5** 可以使用如下方式便捷地声明一个单例变量：\n\n```\nclass PirateManager {\n    static let sharedInstance = PirateManager()\n\n    /* ... */\n}\n```\n\n### 3.8 Closures:闭包\n\n- **3.8.1** 如果闭包中的某个参数的类型是显而易见的，那么可以避免声明类型。不过有时候为了保证可读性与一致性，还是会显示声明参数类型。\n\n```\n// omitting the type\ndoSomethingWithClosure() { response in\n    print(response)\n}\n\n// explicit type\ndoSomethingWithClosure() { response: NSURLResponse in\n    print(response)\n}\n\n// using shorthand in a map statement\n[1, 2, 3].flatMap { String($0) }\n```\n\n- **3.8.2** 在参数列表中，如果是使用了捕获变量或者声明了非Void的返回值，那么应该将参数列表写在一个圆括号里，其他情况下则可以省略圆括号。\n\n```\n// parentheses due to capture list\ndoSomethingWithClosure() { [weak self] (response: NSURLResponse) in\n    self?.handleResponse(response)\n}\n\n// parentheses due to return type\ndoSomethingWithClosure() { (response: NSURLResponse) -> String in\n    return String(response)\n}\n```\n\n- **3.8.3** 如果你是将闭包声明为一个类型，那么除非该类型为Optional或者该闭包是另一个闭包的参数，否则不需要使用圆括号进行包裹。不过需要用圆括号来标注参数列表，并且使用`Void`来指明没有任何结果返回。\n\n```\nlet completionBlock: (success: Bool) -> Void = {\n    print(\"Success? \\(success)\")\n}\n\nlet completionBlock: () -> Void = {\n    print(\"Completed!\")\n}\n\nlet completionBlock: (() -> Void)? = nil\n```\n\n- **3.8.4** 尽可能地将参数名与左括号放在一行，不过要避免打破每行最长160个字符的限制。\n\nKeep parameter names on same line as the opening brace for closures when possible without too much horizontal overflow (i.e. ensure lines are less than 160 characters).\n\n- **3.8.5** 尽可能地使用 trailing closure表达式，除非需要显示地声明闭包参数的外部参数名。\n\n```\n// trailing closure\ndoSomething(1.0) { parameter1 in\n    print(\"Parameter 1 is \\(parameter1)\")\n}\n\n// no trailing closure\ndoSomething(1.0, success: { parameter1 in\n    print(\"Success with \\(parameter1)\")\n}, failure: { parameter1 in\n    print(\"Failure with \\(parameter1)\")\n})\n```\n\n###3.9 Arrays\n\n- **3.9.1** 一般来说，避免使用下标直接访问某个数组，而应该使用类似于`.first`、`.last`这样的访问器进行访问。另外，应该优先使用`for item in items`语法来替代`for i in 0..。如果你打算用下标遍历数组，那么一定保证不能越界。\n- **3.9.2** 永远不要使用`+=` 或者 `+`运算符来增加或者连接数组，应该使用`.append()` 或者 `.appendContentsOf()` 方法。如果你想定义一个从其他数组生成的不可变数组，那么应该使用`let`关键字，即： `let myNewArray = arr1 + arr2`, 或者 `let myNewArray = [arr1, arr2].flatten()`。\n\n### [](https://github.com/wxyyxc1992/iOS-Boilerplate/blob/master/Doc/language/swift/advanced/bestpractices/styleguide/linkedin-swift-style-guide.md#310-error-handling)3.10 Error Handling\n\n假设某个函数 `myFunction` 需要去返回一个`String`类型，不过有可能会在某个点抛出异常，一般来说会将该函数的返回值设置为`String?`：\n\nExample:\n\n```\nfunc readFile(withFilename filename: String) -> String? {\n    guard let file = openFile(filename) else {\n        return nil\n    }\n\n    let fileContents = file.read()\n    file.close()\n    return fileContents\n}\n\nfunc printSomeFile() {\n    let filename = \"somefile.txt\"\n    guard let fileContents = readFile(filename) else {\n        print(\"Unable to open file \\(filename).\")\n        return\n    }\n    print(fileContents)\n}\n```\n\n不过作为异常处理的角度，我们应该使用Swift的`try-catch`表达式，这样能显式地知道错误点：\n\n```\nstruct Error: ErrorType {\n    public let file: StaticString\n    public let function: StaticString\n    public let line: UInt\n    public let message: String\n\n    public init(message: String, file: StaticString = #file, function: StaticString = #function, line: UInt = #line) {\n        self.file = file\n        self.function = function\n        self.line = line\n        self.message = message\n    }\n}\n```\n\nExample usage:\n\n```\nfunc readFile(withFilename filename: String) throws -> String {\n    guard let file = openFile(filename) else {\n        throw Error(message: \"Unable to open file named \\(filename).\")\n    }\n\n    let fileContents = file.read()\n    file.close()\n    return fileContents\n}\n\nfunc printSomeFile() {\n    do {\n        let fileContents = try readFile(filename)\n        print(fileContents)\n    } catch {\n        print(error)\n    }\n}\n```\n\n总而言之，如果某个函数可能会出错，并且出错的原因不能显式地观测到，那么应该优先抛出异常而不是使用一个Optional作为返回值。\n\n###3.11 Using `guard` Statements\n\n- **3.11.1** 一般来说，我们会优先使用所谓的\"early return\"策略来避免`if`表达式中的多层嵌套的代码。在这种情况下使用`guard`语句能够有效地提升代码的可读性。\n\n```\n// PREFERRED\nfunc eatDoughnut(atIndex index: Int) {\n    guard index >= 0 && index < doughnuts else {\n        // return early because the index is out of bounds\n        return\n    }\n\n    let doughnut = doughnuts[index]\n    eat(doughnut)\n}\n\n// NOT PREFERRED\nfunc eatDoughnuts(atIndex index: Int) {\n    if index >= 0 && index < donuts.count {\n        let doughnut = doughnuts[index]\n        eat(doughnut)\n    }\n}\n```\n\n- **3.11.2** 在对Optional类型进行解包的时候，优先使用 `guard` 语句来避免`if`语句中较多的缩进。\n\n```\n// PREFERRED\nguard let monkeyIsland = monkeyIsland else {\n    return\n}\nbookVacation(onIsland: monkeyIsland)\nbragAboutVacation(onIsland: monkeyIsland)\n\n// NOT PREFERRED\nif let monkeyIsland = monkeyIsland {\n    bookVacation(onIsland: monkeyIsland)\n    bragAboutVacation(onIsland: monkeyIsland)\n}\n\n// EVEN LESS PREFERRED\nif monkeyIsland == nil {\n    return\n}\nbookVacation(onIsland: monkeyIsland!)\nbragAboutVacation(onIsland: monkeyIsland!)\n```\n\n- **3.11.3** 在决定是要用`if`表达式还是`guard`表达式进行Optional类型解包的时候，最重要的点就是要保证代码的可读性。很多时候要注意因时而变，因地制宜：\n\n```\n// an `if` statement is readable here\nif operationFailed {\n    return\n}\n\n// a `guard` statement is readable here\nguard isSuccessful else {\n    return\n}\n\n// double negative logic like this can get hard to read - i.e. don't do this\nguard !operationFailed else {\n    return\n}\n```\n\n- **3.11.4** 当需要进行多可能性处理的时候，应该优先使用`if`表达式而不是`guard`表达式。\n\n```\n// PREFERRED\nif isFriendly {\n    print(\"Hello, nice to meet you!\")\n} else {\n    print(\"You have the manners of a beggar.\")\n}\n\n// NOT PREFERRED\nguard isFriendly else {\n    print(\"You have the manners of a beggar.\")\n    return\n}\n\nprint(\"Hello, nice to meet you!\")\n```\n\n- **3.11.5** 一般来说，`guard`应该被用于需要直接退出当前上下文的情形。而对于下面这种两个条件互不干扰的情况，应该使用两个`if`而不是两个`guard`。\n\n```\nif let monkeyIsland = monkeyIsland {\n    bookVacation(onIsland: monkeyIsland)\n}\n\nif let woodchuck = woodchuck where canChuckWood(woodchuck) {\n    woodchuck.chuckWood()\n}\n```\n\n- **3.11.6** 有时候我们会碰到要用`guard`语句进行多个optionals解包的情况，一般而言，对于复杂的错误处理的Optional类型需要将其拆分到多个单个表达式中。\n\n```\n// combined because we just return\nguard let thingOne = thingOne,\n    let thingTwo = thingTwo,\n    let thingThree = thingThree else {\n    return\n}\n\n// separate statements because we handle a specific error in each case\nguard let thingOne = thingOne else {\n    throw Error(message: \"Unwrapping thingOne failed.\")\n}\n\nguard let thingTwo = thingTwo else {\n    throw Error(message: \"Unwrapping thingTwo failed.\")\n}\n\nguard let thingThree = thingThree else {\n    throw Error(message: \"Unwrapping thingThree failed.\")\n}\n```\n\n- **3.11.7** 不要将`guard`表达式强行缩写到一行内。\n\n```\n// PREFERRED\nguard let thingOne = thingOne else {\n    return\n}\n\n// NOT PREFERRED\nguard let thingOne = thingOne else { return }\n```\n\n## 4. Documentation/Comments\n\n### [](https://github.com/wxyyxc1992/iOS-Boilerplate/blob/master/Doc/language/swift/advanced/bestpractices/styleguide/linkedin-swift-style-guide.md#41-documentation)4.1 Documentation\n\n如果某个函数不是简单地`O(1)`操作，那么最好就是为该函数添加一些注释文档，这样能有效地提高代码的可读性与可维护性。之前有个非常不错的文档工具[VVDocumenter](https://github.com/onevcat/VVDocumenter-Xcode)。推荐阅读Apple的官方指南中的描述：[described in Apple's Documentation](https://developer.apple.com/library/tvos/documentation/Xcode/Reference/xcode_markup_formatting_ref/Attention.html#//apple_ref/doc/uid/TP40016497-CH29-SW1).\n\nGuidelines:\n\n- **4.1.1** 每行不应超过160个字符\n- **4.1.2** 即使某些注释只有一行，也应该使用块注释符： (`/** */`).\n- **4.1.3** 不用给每行的开头都加上： `*`.\n- **4.1.4** 使用新的 `- parameter` 标识符来代替老的`:param:` syntax (注意这边是小写的 `parameter` 而不是`Parameter`).\n- **4.1.5** 如果你准备对参数/返回值/异常值来写注释，那么注意要一个不落的全局加上，尽管有时候会让文档显得重复冗余。有时候，如果只需要对单个参数进行注释，那么还不如直接放在描述里进行声明，而不需要专门的为参数写一个注释。\n- **4.1.6** 对于复杂的使用类，应该添加一些具体的使用用例来描述类的用法。注意Swift的注释文档中是支持MarkDown语法的，这是一个很好的特性。\n\n```\n/**\n ## Feature Support\n\n This class does some awesome things. It supports:\n\n - Feature 1\n - Feature 2\n - Feature 3\n\n ## Examples\n\n Here is an example use case indented by four spaces because that indicates a\n code block:\n\n     let myAwesomeThing = MyAwesomeClass()\n     myAwesomeThing.makeMoney()\n\n ## Warnings:告警\n\n There are some things you should be careful of:\n\n 1. Thing one\n 2. Thing two\n 3. Thing three\n */\nclass MyAwesomeClass {\n    /* ... */\n}\n```\n\n- **4.1.7** 使用 - ` 在注释中著名引用的代码\n\n```\n/**\n This does something with a `UIViewController`, perchance.\n - warning: Make sure that `someValue` is `true` before running this function.\n */\nfunc myFunction() {\n    /* ... */\n}\n```\n\n- **4.1.8** 保证文档的注释尽可能的简洁\n\n### 4.2 Other Commenting Guidelines:其他的注释规则\n\n- **4.2.1** `//`后面总是要跟上一个空格\n- **4.2.2** 注释永远要放在单独的行中\n- **4.2.3** 在使用`// MARK: - whatever`的时候，注意MARK与代码之间保留一个空行\n\n```\nclass Pirate {\n\n    // MARK: - instance properties\n\n    private let pirateName: String\n\n    // MARK: - initialization\n\n    init() {\n        /* ... */\n    }\n\n}\n```\n\n\n\n原文链接:[github:Swift Style Guide](https://github.com/wxyyxc1992/iOS-Boilerplate/blob/master/Doc/language/swift/advanced/bestpractices/styleguide/linkedin-swift-style-guide.md#1-code-formatting)\n\n\n","slug":"lai-zi-linkedin-de-swift-bian-cheng-feng-ge-zhi-nan","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cj04pzyym001hs04ehleuzl6m","content":"<p><img src=\"https://ooo.0o0.ooo/2016/07/03/5778dc0ab45a1.jpg\" alt=\"\"></p>\n<p>##1. Code Formatting:代码格式化</p>\n<ul>\n<li><strong>1.1</strong> 使用4个空格来代替Tabs</li>\n<li><strong>1.2</strong> 避免过长的行，可以在XCode中进行设置单行最大长度：(Xcode-&gt;Preferences-&gt;Text Editing-&gt;Page guide at column: 160 is helpful for this)</li>\n<li><strong>1.3</strong> 保证每个文件结尾都存在一个新行 Ensure that there is a newline at the end of every file.</li>\n<li><strong>1.4</strong> 避免无意义的尾随空格: (Xcode-&gt;Preferences-&gt;Text Editing-&gt;Automatically trim trailing whitespace + Including whitespace-only lines).</li>\n<li><strong>1.5</strong> 避免将单独的左花括号放置到一行，我们参考了：<a href=\"https://en.m.wikipedia.org/wiki/Indent_style#Variant:_1TBS\" target=\"_blank\" rel=\"external\">1TBS style</a>.</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">class SomeClass &#123;</div><div class=\"line\">    func someMethod() &#123;</div><div class=\"line\">        if x == y &#123;</div><div class=\"line\">            /* ... */</div><div class=\"line\">        &#125; else if x == z &#123;</div><div class=\"line\">            /* ... */</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            /* ... */</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /* ... */</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>1.6</strong> 在写变量的类型声明、字典类型的键、函数参数、协议的声明或者父类的时候，不要在冒号前添加空格。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">// specifying type</div><div class=\"line\">let pirateViewController: PirateViewController</div><div class=\"line\"></div><div class=\"line\">// dictionary syntax (note that we left-align as opposed to aligning colons)</div><div class=\"line\">let ninjaDictionary: [String: AnyObject] = [</div><div class=\"line\">    &quot;fightLikeDairyFarmer&quot;: false,</div><div class=\"line\">    &quot;disgusting&quot;: true</div><div class=\"line\">]</div><div class=\"line\"></div><div class=\"line\">// declaring a function</div><div class=\"line\">func myFunction&lt;T, U: SomeProtocol where T.RelatedType == U&gt;(firstArgument: U, secondArgument: T) &#123;</div><div class=\"line\">    /* ... */</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// calling a function</div><div class=\"line\">someFunction(someArgument: &quot;Kitten&quot;)</div><div class=\"line\"></div><div class=\"line\">// superclasses</div><div class=\"line\">class PirateViewController: UIViewController &#123;</div><div class=\"line\">    /* ... */</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// protocols</div><div class=\"line\">extension PirateViewController: UITableViewDataSource &#123;</div><div class=\"line\">    /* ... */</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>1.7</strong> 一般来说，逗号后面都要跟随一个空格。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">let myArray = [1, 2, 3, 4, 5]</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>1.8</strong> 在二元操作符譬如<code>+</code>, <code>==</code>, 或者 <code>-&gt;</code>的前后需要加上空格，但是对于<code>(</code> 、`)的前后不需要加空格。</li>\n</ul>\n<ul>\n<li><strong>1.9</strong> 我们默认使用Xcode推荐的格式化风格(CTRL-I) ，在声明某个函数的时候会多行排布参数。</li>\n</ul>\n<ul>\n<li><strong>1.10</strong> 在调用多参数函数的时候，会把多个参数放置到单独的行中：</li>\n</ul>\n<ul>\n<li><strong>1.11</strong> 对于大型的数组或者字典类型，应该将其分割到多行内，<code>[</code> 与 <code>]</code>类比于花括号进行处理。对于闭包而言也应该同样适合于该规则。</li>\n</ul>\n<ul>\n<li><strong>1.12</strong> 尽可能地使用本地变量的方式来避免多行的判断语句。</li>\n</ul>\n<p>##2. Naming:命名</p>\n<ul>\n<li><strong>2.1</strong> Swift中不需要再使用Objective-C那样的前缀，譬如使用 <code>GuybrushThreepwood</code> 而不是<code>LIGuybrushThreepwood</code>。</li>\n<li><strong>2.2</strong> 对于类型名即<code>struct</code>, <code>enum</code>, <code>class</code>, <code>typedef</code>, <code>associatedtype</code>等等使用 <code>PascalCase</code> 。</li>\n<li><strong>2.3</strong> 对于函数名、方法名、变量名、常量、参数名等使用<code>camelCase</code>。</li>\n<li><strong>2.4</strong> 在使用首字母缩写的时候尽可能地全部大写，并且注意保证全部代码中的统一。不过如果缩写被用于命名的起始，那么就全部小写。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">// &quot;HTML&quot; is at the start of a variable name, so we use lowercase &quot;html&quot;</div><div class=\"line\">let htmlBodyContent: String = &quot;&lt;p&gt;Hello, World!&lt;/p&gt;&quot;</div><div class=\"line\">// Prefer using ID to Id</div><div class=\"line\">let profileID: Int = 1</div><div class=\"line\">// Prefer URLFinder to UrlFinder</div><div class=\"line\">class URLFinder &#123;</div><div class=\"line\">    /* ... */</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>2.5</strong> 对于静态常量使用 <code>k</code> 前缀 + PascalCase。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">class MyClassName &#123;</div><div class=\"line\">    // use `k` prefix for constant primitives</div><div class=\"line\">    static let kSomeConstantHeight: CGFloat = 80.0</div><div class=\"line\"></div><div class=\"line\">    // use `k` prefix for non-primitives as well</div><div class=\"line\">    static let kDeleteButtonColor = UIColor.redColor()</div><div class=\"line\"></div><div class=\"line\">    // don&apos;t use `k` prefix for singletons</div><div class=\"line\">    static let sharedInstance = MyClassName()</div><div class=\"line\"></div><div class=\"line\">    /* ... */</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>2.6</strong> 对于泛型或者关联类型，使用<code>PascalCase</code>描述泛型，如果泛型名与其他重复，那么可以添加一个<code>Type</code>后缀名到泛型名上。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">class SomeClass&lt;T&gt; &#123; /* ... */ &#125;</div><div class=\"line\">class SomeClass&lt;Model&gt; &#123; /* ... */ &#125;</div><div class=\"line\">protocol Modelable &#123;</div><div class=\"line\">    associatedtype Model</div><div class=\"line\">&#125;</div><div class=\"line\">protocol Sequence &#123;</div><div class=\"line\">    associatedtype IteratorType: Iterator</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>2.7</strong> 命名必须要是不模糊的并且方便表述的</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">// PREFERRED</div><div class=\"line\">class RoundAnimatingButton: UIButton &#123; /* ... */ &#125;</div><div class=\"line\"></div><div class=\"line\">// NOT PREFERRED</div><div class=\"line\">class CustomButton: UIButton &#123; /* ... */ &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>2.8</strong> 不要使用缩写，可以选择较为简短的单词。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">// PREFERRED</div><div class=\"line\">class RoundAnimatingButton: UIButton &#123;</div><div class=\"line\">    let animationDuration: NSTimeInterval</div><div class=\"line\"></div><div class=\"line\">    func startAnimating() &#123;</div><div class=\"line\">        let firstSubview = subviews.first</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// NOT PREFERRED</div><div class=\"line\">class RoundAnimating: UIButton &#123;</div><div class=\"line\">    let aniDur: NSTimeInterval</div><div class=\"line\"></div><div class=\"line\">    func srtAnmating() &#123;</div><div class=\"line\">        let v = subviews.first</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>2.9</strong> 对于不是很明显的类型需要将类型信息包含在属性名中。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div></pre></td><td class=\"code\"><pre><div class=\"line\">// PREFERRED</div><div class=\"line\">class ConnectionTableViewCell: UITableViewCell &#123;</div><div class=\"line\">    let personImageView: UIImageView</div><div class=\"line\"></div><div class=\"line\">    let animationDuration: NSTimeInterval</div><div class=\"line\"></div><div class=\"line\">    // it is ok not to include string in the ivar name here because it&apos;s obvious</div><div class=\"line\">    // that it&apos;s a string from the property name</div><div class=\"line\">    let firstName: String</div><div class=\"line\"></div><div class=\"line\">    // though not preferred, it is OK to use `Controller` instead of `ViewController`</div><div class=\"line\">    let popupController: UIViewController</div><div class=\"line\">    let popupViewController: UIViewController</div><div class=\"line\"></div><div class=\"line\">    // when working with a subclass of `UIViewController` such as a table view</div><div class=\"line\">    // controller, collection view controller, split view controller, etc.,</div><div class=\"line\">    // fully indicate the type in the name.</div><div class=\"line\">    let popupTableViewController: UITableViewController</div><div class=\"line\"></div><div class=\"line\">    // when working with outlets, make sure to specify the outlet type in the</div><div class=\"line\">    // variable name.</div><div class=\"line\">    @IBOutlet weak var submitButton: UIButton!</div><div class=\"line\">    @IBOutlet weak var emailTextField: UITextField!</div><div class=\"line\">    @IBOutlet weak var nameLabel: UILabel!</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// NOT PREFERRED</div><div class=\"line\">class ConnectionTableViewCell: UITableViewCell &#123;</div><div class=\"line\">    // this isn&apos;t a `UIImage`, so shouldn&apos;t be called image</div><div class=\"line\">    // use personImageView instead</div><div class=\"line\">    let personImage: UIImageView</div><div class=\"line\"></div><div class=\"line\">    // this isn&apos;t a `String`, so it should be `textLabel`</div><div class=\"line\">    let text: UILabel</div><div class=\"line\"></div><div class=\"line\">    // `animation` is not clearly a time interval</div><div class=\"line\">    // use `animationDuration` or `animationTimeInterval` instead</div><div class=\"line\">    let animation: NSTimeInterval</div><div class=\"line\"></div><div class=\"line\">    // this is not obviously a `String`</div><div class=\"line\">    // use `transitionText` or `transitionString` instead</div><div class=\"line\">    let transition: String</div><div class=\"line\"></div><div class=\"line\">    // this is a view controller - not a view</div><div class=\"line\">    let popupView: UIViewController</div><div class=\"line\"></div><div class=\"line\">    // as mentioned previously, we don&apos;t want to use abbreviations, so don&apos;t use</div><div class=\"line\">    // `VC` instead of `ViewController`</div><div class=\"line\">    let popupVC: UIViewController</div><div class=\"line\"></div><div class=\"line\">    // even though this is still technically a `UIViewController`, this variable</div><div class=\"line\">    // should indicate that we are working with a *Table* View Controller</div><div class=\"line\">    let popupViewController: UITableViewController</div><div class=\"line\"></div><div class=\"line\">    // for the sake of consistency, we should put the type name at the end of the</div><div class=\"line\">    // variable name and not at the start</div><div class=\"line\">    @IBOutlet weak var btnSubmit: UIButton!</div><div class=\"line\">    @IBOutlet weak var buttonSubmit: UIButton!</div><div class=\"line\"></div><div class=\"line\">    // we should always have a type in the variable name when dealing with outlets</div><div class=\"line\">    // for example, here, we should have `firstNameLabel` instead</div><div class=\"line\">    @IBOutlet weak var firstName: UILabel!</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>2.10</strong> 在编写函数参数的时候，要保证每个参数都易于理解其功能。</li>\n<li><strong>2.11</strong> 根据 <a href=\"https://swift.org/documentation/api-design-guidelines/\" target=\"_blank\" rel=\"external\">Apple’s API Design Guidelines</a>, 对于<code>protocol</code>，如果其描述的是正在做的事情，譬如<code>Collection</code>，那么应该命名为名词。而如果是用于描述某种能力，譬如<code>Equatable</code>, <code>ProgressReporting</code>，那么应该添加 <code>able</code>, <code>ible</code>, 或者 <code>ing</code> 这样的后缀。如果你的协议并不符合上述两种情形，那么应该直接添加一个<code>Protocol</code>后缀，譬如：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">// here, the name is a noun that describes what the protocol does</div><div class=\"line\">protocol TableViewSectionProvider &#123;</div><div class=\"line\">    func rowHeight(atRow row: Int) -&gt; CGFloat</div><div class=\"line\">    var numberOfRows: Int &#123; get &#125;</div><div class=\"line\">    /* ... */</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// here, the protocol is a capability, and we name it appropriately</div><div class=\"line\">protocol Loggable &#123;</div><div class=\"line\">    func logCurrentState()</div><div class=\"line\">    /* ... */</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// suppose we have an `InputTextView` class, but we also want a protocol</div><div class=\"line\">// to generalize some of the functionality - it might be appropriate to</div><div class=\"line\">// use the `Protocol` suffix here</div><div class=\"line\">protocol InputTextViewProtocol &#123;</div><div class=\"line\">    func sendTrackingEvent()</div><div class=\"line\">    func inputText() -&gt; String</div><div class=\"line\">    /* ... */</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"3-Coding-Style\"><a href=\"#3-Coding-Style\" class=\"headerlink\" title=\"3. Coding Style\"></a>3. Coding Style</h2><p>###3.1 General</p>\n<ul>\n<li><strong>3.1.1</strong> 尽可能地使用<code>let</code>来代替<code>var</code>。</li>\n<li><strong>3.1.2</strong> 尽可能地使用 <code>map</code>, <code>filter</code>, <code>reduce</code>的组合来进行集合的转换等操作，并且尽可能地避免使用带有副作用的闭包。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">// PREFERRED</div><div class=\"line\">let stringOfInts = [1, 2, 3].flatMap &#123; String($0) &#125;</div><div class=\"line\">// [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]</div><div class=\"line\"></div><div class=\"line\">// NOT PREFERRED</div><div class=\"line\">var stringOfInts: [String] = []</div><div class=\"line\">for integer in [1, 2, 3] &#123;</div><div class=\"line\">    stringOfInts.append(String(integer))</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// PREFERRED</div><div class=\"line\">let evenNumbers = [4, 8, 15, 16, 23, 42].filter &#123; $0 % 2 == 0 &#125;</div><div class=\"line\">// [4, 8, 16, 42]</div><div class=\"line\"></div><div class=\"line\">// NOT PREFERRED</div><div class=\"line\">var evenNumbers: [Int] = []</div><div class=\"line\">for integer in [4, 8, 15, 16, 23, 42] &#123;</div><div class=\"line\">    if integer % 2 == 0 &#123;</div><div class=\"line\">        evenNumbers(integer)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>3.1.3</strong> 尽可能地显式声明不方便进行类型推测的变量或者常量的类型名。</li>\n<li><strong>3.1.4</strong> 如果你的函数需要返回多个参数，那么尽可能地使用<code>Tuple</code>来代替<code>inout</code>参数。如果你会多次使用某个元组，那么应该使用<code>typealias</code>设置别名。如果返回的参数超过三个，那么应该使用结构体或者类来替代。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">func pirateName() -&gt; (firstName: String, lastName: String) &#123;</div><div class=\"line\">    return (&quot;Guybrush&quot;, &quot;Threepwood&quot;)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">let name = pirateName()</div><div class=\"line\">let firstName = name.firstName</div><div class=\"line\">let lastName = name.lastName</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>3.1.5</strong> 在创建delegates/protocols的时候需要小心所谓的保留环(retain cycles)，这些属性需要被声明为<code>weak</code>。</li>\n<li><strong>3.1.6</strong> 在闭包中直接调用<code>self</code>可能会导致保留环，可以使用<a href=\"https://developer.apple.com/library/ios/documentation/swift/conceptual/Swift_Programming_Language/Closures.html#//apple_ref/doc/uid/TP40014097-CH11-XID_163\" target=\"_blank\" rel=\"external\">capture list</a> 在这种情况下:</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">myFunctionWithClosure() &#123; [weak self] (error) -&gt; Void in</div><div class=\"line\">    // you can do this</div><div class=\"line\"></div><div class=\"line\">    self?.doSomething()</div><div class=\"line\"></div><div class=\"line\">    // or you can do this</div><div class=\"line\"></div><div class=\"line\">    guard let strongSelf = self else &#123;</div><div class=\"line\">        return</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    strongSelf.doSomething()</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>3.1.7</strong> 不要使用 labeled breaks。</li>\n<li><strong>3.1.8</strong> 不要在控制流逻辑判断的时候加上圆括号</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">// PREFERRED</div><div class=\"line\">if x == y &#123;</div><div class=\"line\">    /* ... */</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// NOT PREFERRED</div><div class=\"line\">if (x == y) &#123;</div><div class=\"line\">    /* ... */</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>3.1.9</strong> 避免在使用enum的时候写出全名</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">// PREFERRED</div><div class=\"line\">imageView.setImageWithURL(url, type: .person)</div><div class=\"line\"></div><div class=\"line\">// NOT PREFERRED</div><div class=\"line\">imageView.setImageWithURL(url, type: AsyncImageView.Type.person)</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>3.1.10</strong> 在写类方法的时候不能用简短写法，应该使用类名.方法名，这样能够保证代码的可读性</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">// PREFERRED</div><div class=\"line\">imageView.backgroundColor = UIColor.whiteColor()</div><div class=\"line\"></div><div class=\"line\">// NOT PREFERRED</div><div class=\"line\">imageView.backgroundColor = .whiteColor()</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>3.1.11</strong> 在非必要的时候不要写<code>self.</code>。</li>\n<li><strong>3.1.12</strong> 在编写某个方法的时候注意考虑下这个方法是否有可能被复写，如果不可能被复写那么应该使用<code>final</code>修饰符。还要注意加上final之后也会导致无法在测试的时候进行复写，所以还是需要综合考虑。一般而言，加上<code>final</code>修饰符后会提高编译的效率，所以应该尽可能地使用该修饰符。</li>\n<li><strong>3.1.13</strong> 在使用譬如<code>else</code>, <code>catch</code>等等类似的语句的时候，将关键字与花括号放在一行，同样遵循<a href=\"https://en.m.wikipedia.org/wiki/Indent_style#Variant:_1TBS\" target=\"_blank\" rel=\"external\">1TBS style</a>规范，这边列出了常见的<code>if</code>/<code>else</code> 以及 <code>do</code>/<code>catch</code> 示范代码。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">if someBoolean &#123;</div><div class=\"line\">    // do something</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">    // do something else</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">do &#123;</div><div class=\"line\">    let fileContents = try readFile(&quot;filename.txt&quot;)</div><div class=\"line\">&#125; catch &#123;</div><div class=\"line\">    print(error)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>###3.2 Access Modifiers</p>\n<ul>\n<li><strong>3.2.1</strong> 在需要的时候应该将访问修饰符放在关键字的第一位。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">// PREFERRED</div><div class=\"line\">private static let kMyPrivateNumber: Int</div><div class=\"line\"></div><div class=\"line\">// NOT PREFERRED</div><div class=\"line\">static private let kMyPrivateNumber: Int</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>3.2.2</strong> 访问修饰符不应该单独放一行：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">// PREFERRED</div><div class=\"line\">public class Pirate &#123;</div><div class=\"line\">    /* ... */</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// NOT PREFERRED</div><div class=\"line\">public</div><div class=\"line\">class Pirate &#123;</div><div class=\"line\">    /* ... */</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>3.2.3</strong> 一般来说，不要显式地写默认的 <code>internal</code>访问修饰符。</li>\n<li><strong>3.2.4</strong> 如果某个变量需要在测试的时候被使用到，那么应该标识为<code>internal</code>来保证<code>@testable import ModuleName</code>。这里需要注意的是，对于某些应该被声明为<code>private</code>的变量因为测试用途而声明为了<code>internal</code>，那么应该在注释里特别地注明。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> This variable defines the pirate&apos;s name.</div><div class=\"line\"> - warning: Not `private` for `@testable`.</div><div class=\"line\"> */</div><div class=\"line\">let pirateName = &quot;LeChuck&quot;</div></pre></td></tr></table></figure>\n<h3 id=\"3-3-Custom-Operators-自定义操作符\"><a href=\"#3-3-Custom-Operators-自定义操作符\" class=\"headerlink\" title=\"3.3 Custom Operators:自定义操作符\"></a><a href=\"https://github.com/wxyyxc1992/iOS-Boilerplate/blob/master/Doc/language/swift/advanced/bestpractices/styleguide/linkedin-swift-style-guide.md#33-custom-operators自定义操作符\" target=\"_blank\" rel=\"external\"></a>3.3 Custom Operators:自定义操作符</h3><p>尽可能地选用命名函数来代替自定义操作符。如果你打算引入一个自定义的操作符，那么一定要有非常充分的理由来说明为啥要讲一个新的操作符引入到全局作用域，而不是使用其他一些可替代的方式。你也可以选择去复写一些现有的操作符，譬如<code>==</code>来适应一些新的类型，不过要保证你添加的用法一定要与语义相符。譬如<code>==</code> 应该只能用于表示相等性测试并且返回一个布尔值。</p>\n<p>###3.4 Switch Statements and <code>enum</code>s</p>\n<ul>\n<li><strong>3.4.1</strong> 在使用枚举类型作为switch的参数的时候，避免引入<code>default</code>关键字，而应该将没有使用的情形放到下面然后使用break关键字来避免被执行。</li>\n<li><strong>3.4.2</strong> Swift中默认会在每个case的结尾进行break，因此没必要的时候不需要显式地声明<code>break</code>关键字。</li>\n<li><strong>3.4.3</strong> The <code>case</code> statements should line up with the <code>switch</code> statement itself as per default Swift standards.</li>\n<li><strong>3.4.4</strong> When defining a case that has an associated value, make sure that this value is appropriately labeled as opposed to just types (e.g. <code>case Hunger(hungerLevel: Int)</code> instead of <code>case Hunger(Int)</code>).</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">enum Problem &#123;</div><div class=\"line\">    case attitude</div><div class=\"line\">    case hair</div><div class=\"line\">    case hunger(hungerLevel: Int)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">func handleProblem(problem: Problem) &#123;</div><div class=\"line\">    switch problem &#123;</div><div class=\"line\">    case .attitude:</div><div class=\"line\">        print(&quot;At least I don&apos;t have a hair problem.&quot;)</div><div class=\"line\">    case .hair:</div><div class=\"line\">        print(&quot;Your barber didn&apos;t know when to stop.&quot;)</div><div class=\"line\">    case .hunger(let hungerLevel):</div><div class=\"line\">        print(&quot;The hunger level is \\(hungerLevel).&quot;)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>3.4.5</strong> 优先使用譬如<code>case 1, 2, 3:</code>这样的列表表达式而不是使用<code>fallthrough</code>关键字。</li>\n<li><strong>3.4.6</strong> 如果你添加了一个默认的case并且该case不应该被使用，那么应该在default情形下抛出异常。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">func handleDigit(digit: Int) throws &#123;</div><div class=\"line\">    case 0, 1, 2, 3, 4, 5, 6, 7, 8, 9:</div><div class=\"line\">        print(&quot;Yes, \\(digit) is a digit!&quot;)</div><div class=\"line\">    default:</div><div class=\"line\">        throw Error(message: &quot;The given number was not a digit.&quot;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>###3.5 Optionals</p>\n<ul>\n<li><strong>3.5.1</strong> 只应该在 <code>@IBOutlet</code>中使用隐式地未包裹的Options。否则其他情况下就应该使用Non-Optional或者正常的Optional的变量。虽然有时候你能保证某个变量肯定非<code>nil</code>，不过这样用的话还是比较安全并且能保证上下一致性。</li>\n</ul>\n<p>The only time you should be using implicitly unwrapped optionals is withs. In every other case, it is better to use a non-optional or regular optional variable. Yes, there are cases in which you can probably “guarantee” that the variable will never be <code>nil</code> when used, but it is better to be safe and consistent.</p>\n<ul>\n<li><strong>3.5.2</strong> 不要使用 <code>as!</code> 或者 <code>try!</code>.</li>\n<li><strong>3.5.3</strong> 如果你只是打算判断存放在Optional中的值是否为空，那么你应该直接与<code>nil</code>进行判断而不是使用<code>if let</code>语句将值取出来。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">// PREFERERED</div><div class=\"line\">if someOptional != nil &#123;</div><div class=\"line\">    // do something</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// NOT PREFERRED</div><div class=\"line\">if let _ = someOptional &#123;</div><div class=\"line\">    // do something</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>3.5.4</strong> 不要使用 <code>unowned</code>。你可以将<code>unowned</code>当做对于<code>weak</code>变量的隐式解包，虽然有时候<code>unowned</code>与<code>weak</code>相比有小小地性能提升，不过还是不建议进行使用。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">// PREFERRED</div><div class=\"line\">weak var parentViewController: UIViewController?</div><div class=\"line\"></div><div class=\"line\">// NOT PREFERRED</div><div class=\"line\">weak var parentViewController: UIViewController!</div><div class=\"line\">unowned var parentViewController: UIViewController</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>3.5.5</strong> 当对Optionals进行解包的时候，使用与Optionals变量一致的变量名</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">guard let myVariable = myVariable else &#123;</div><div class=\"line\">    return</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"3-6-Protocols\"><a href=\"#3-6-Protocols\" class=\"headerlink\" title=\"3.6 Protocols\"></a>3.6 Protocols</h3><p>在实现协议的时候，大体上有两种代码组织方式：</p>\n<ol>\n<li>使用 <code>// MARK:</code> 来注释你的专门用于实现协议中规定的方法</li>\n<li>在你的类或者结构体实现之外使用一个扩展来存放实现代码，不过要保证在一个源文件中</li>\n</ol>\n<p>不过需要注意的是，如果你是使用了Extension方式，那么定义在Extension中的方法是无法被子类复写的，这样可能会无法进行测试。</p>\n<h3 id=\"3-7-Properties\"><a href=\"#3-7-Properties\" class=\"headerlink\" title=\"3.7 Properties\"></a><a href=\"https://github.com/wxyyxc1992/iOS-Boilerplate/blob/master/Doc/language/swift/advanced/bestpractices/styleguide/linkedin-swift-style-guide.md#37-properties\" target=\"_blank\" rel=\"external\"></a>3.7 Properties</h3><ul>\n<li><strong>3.7.1</strong> 如果是定义一个只读的需要经过计算的属性，那么不需要声明 <code>get {}</code></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">var computedProperty: String &#123;</div><div class=\"line\">    if someBool &#123;</div><div class=\"line\">        return &quot;I&apos;m a mighty pirate!&quot;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return &quot;I&apos;m selling these fine leather jackets.&quot;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>3.7.2</strong> 在使用 <code>get {}</code>, <code>set {}</code>, <code>willSet</code>, 以及 <code>didSet</code>, 注意块的缩进</li>\n<li><strong>3.7.3</strong> 尽管你可以在<code>willSet</code>/<code>didSet</code>以及 <code>set</code>方法中使用自定义的名称，不过建议还是使用默认的<code>newValue</code>/<code>oldValue</code>变量名</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">var computedProperty: String &#123;</div><div class=\"line\">    get &#123;</div><div class=\"line\">        if someBool &#123;</div><div class=\"line\">            return &quot;I&apos;m a mighty pirate!&quot;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return &quot;I&apos;m selling these fine leather jackets.&quot;</div><div class=\"line\">    &#125;</div><div class=\"line\">    set &#123;</div><div class=\"line\">        computedProperty = newValue</div><div class=\"line\">    &#125;</div><div class=\"line\">    willSet &#123;</div><div class=\"line\">        print(&quot;will set to \\(newValue)&quot;)</div><div class=\"line\">    &#125;</div><div class=\"line\">    didSet &#123;</div><div class=\"line\">        print(&quot;did set from \\(oldValue) to \\(newValue)&quot;)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>3.7.4</strong> 将任何类常量设置为<code>static</code></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">class MyTableViewCell: UITableViewCell &#123;</div><div class=\"line\">    static let kReuseIdentifier = String(MyTableViewCell)</div><div class=\"line\">    static let kCellHeight: CGFloat = 80.0</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>3.7.5</strong> 可以使用如下方式便捷地声明一个单例变量：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">class PirateManager &#123;</div><div class=\"line\">    static let sharedInstance = PirateManager()</div><div class=\"line\"></div><div class=\"line\">    /* ... */</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"3-8-Closures-闭包\"><a href=\"#3-8-Closures-闭包\" class=\"headerlink\" title=\"3.8 Closures:闭包\"></a>3.8 Closures:闭包</h3><ul>\n<li><strong>3.8.1</strong> 如果闭包中的某个参数的类型是显而易见的，那么可以避免声明类型。不过有时候为了保证可读性与一致性，还是会显示声明参数类型。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">// omitting the type</div><div class=\"line\">doSomethingWithClosure() &#123; response in</div><div class=\"line\">    print(response)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// explicit type</div><div class=\"line\">doSomethingWithClosure() &#123; response: NSURLResponse in</div><div class=\"line\">    print(response)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// using shorthand in a map statement</div><div class=\"line\">[1, 2, 3].flatMap &#123; String($0) &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>3.8.2</strong> 在参数列表中，如果是使用了捕获变量或者声明了非Void的返回值，那么应该将参数列表写在一个圆括号里，其他情况下则可以省略圆括号。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">// parentheses due to capture list</div><div class=\"line\">doSomethingWithClosure() &#123; [weak self] (response: NSURLResponse) in</div><div class=\"line\">    self?.handleResponse(response)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// parentheses due to return type</div><div class=\"line\">doSomethingWithClosure() &#123; (response: NSURLResponse) -&gt; String in</div><div class=\"line\">    return String(response)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>3.8.3</strong> 如果你是将闭包声明为一个类型，那么除非该类型为Optional或者该闭包是另一个闭包的参数，否则不需要使用圆括号进行包裹。不过需要用圆括号来标注参数列表，并且使用<code>Void</code>来指明没有任何结果返回。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">let completionBlock: (success: Bool) -&gt; Void = &#123;</div><div class=\"line\">    print(&quot;Success? \\(success)&quot;)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">let completionBlock: () -&gt; Void = &#123;</div><div class=\"line\">    print(&quot;Completed!&quot;)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">let completionBlock: (() -&gt; Void)? = nil</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>3.8.4</strong> 尽可能地将参数名与左括号放在一行，不过要避免打破每行最长160个字符的限制。</li>\n</ul>\n<p>Keep parameter names on same line as the opening brace for closures when possible without too much horizontal overflow (i.e. ensure lines are less than 160 characters).</p>\n<ul>\n<li><strong>3.8.5</strong> 尽可能地使用 trailing closure表达式，除非需要显示地声明闭包参数的外部参数名。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">// trailing closure</div><div class=\"line\">doSomething(1.0) &#123; parameter1 in</div><div class=\"line\">    print(&quot;Parameter 1 is \\(parameter1)&quot;)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// no trailing closure</div><div class=\"line\">doSomething(1.0, success: &#123; parameter1 in</div><div class=\"line\">    print(&quot;Success with \\(parameter1)&quot;)</div><div class=\"line\">&#125;, failure: &#123; parameter1 in</div><div class=\"line\">    print(&quot;Failure with \\(parameter1)&quot;)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>###3.9 Arrays</p>\n<ul>\n<li><strong>3.9.1</strong> 一般来说，避免使用下标直接访问某个数组，而应该使用类似于<code>.first</code>、<code>.last</code>这样的访问器进行访问。另外，应该优先使用<code>for item in items</code>语法来替代`for i in 0..。如果你打算用下标遍历数组，那么一定保证不能越界。</li>\n<li><strong>3.9.2</strong> 永远不要使用<code>+=</code> 或者 <code>+</code>运算符来增加或者连接数组，应该使用<code>.append()</code> 或者 <code>.appendContentsOf()</code> 方法。如果你想定义一个从其他数组生成的不可变数组，那么应该使用<code>let</code>关键字，即： <code>let myNewArray = arr1 + arr2</code>, 或者 <code>let myNewArray = [arr1, arr2].flatten()</code>。</li>\n</ul>\n<h3 id=\"3-10-Error-Handling\"><a href=\"#3-10-Error-Handling\" class=\"headerlink\" title=\"3.10 Error Handling\"></a><a href=\"https://github.com/wxyyxc1992/iOS-Boilerplate/blob/master/Doc/language/swift/advanced/bestpractices/styleguide/linkedin-swift-style-guide.md#310-error-handling\" target=\"_blank\" rel=\"external\"></a>3.10 Error Handling</h3><p>假设某个函数 <code>myFunction</code> 需要去返回一个<code>String</code>类型，不过有可能会在某个点抛出异常，一般来说会将该函数的返回值设置为<code>String?</code>：</p>\n<p>Example:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">func readFile(withFilename filename: String) -&gt; String? &#123;</div><div class=\"line\">    guard let file = openFile(filename) else &#123;</div><div class=\"line\">        return nil</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    let fileContents = file.read()</div><div class=\"line\">    file.close()</div><div class=\"line\">    return fileContents</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">func printSomeFile() &#123;</div><div class=\"line\">    let filename = &quot;somefile.txt&quot;</div><div class=\"line\">    guard let fileContents = readFile(filename) else &#123;</div><div class=\"line\">        print(&quot;Unable to open file \\(filename).&quot;)</div><div class=\"line\">        return</div><div class=\"line\">    &#125;</div><div class=\"line\">    print(fileContents)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>不过作为异常处理的角度，我们应该使用Swift的<code>try-catch</code>表达式，这样能显式地知道错误点：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct Error: ErrorType &#123;</div><div class=\"line\">    public let file: StaticString</div><div class=\"line\">    public let function: StaticString</div><div class=\"line\">    public let line: UInt</div><div class=\"line\">    public let message: String</div><div class=\"line\"></div><div class=\"line\">    public init(message: String, file: StaticString = #file, function: StaticString = #function, line: UInt = #line) &#123;</div><div class=\"line\">        self.file = file</div><div class=\"line\">        self.function = function</div><div class=\"line\">        self.line = line</div><div class=\"line\">        self.message = message</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Example usage:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">func readFile(withFilename filename: String) throws -&gt; String &#123;</div><div class=\"line\">    guard let file = openFile(filename) else &#123;</div><div class=\"line\">        throw Error(message: &quot;Unable to open file named \\(filename).&quot;)</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    let fileContents = file.read()</div><div class=\"line\">    file.close()</div><div class=\"line\">    return fileContents</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">func printSomeFile() &#123;</div><div class=\"line\">    do &#123;</div><div class=\"line\">        let fileContents = try readFile(filename)</div><div class=\"line\">        print(fileContents)</div><div class=\"line\">    &#125; catch &#123;</div><div class=\"line\">        print(error)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>总而言之，如果某个函数可能会出错，并且出错的原因不能显式地观测到，那么应该优先抛出异常而不是使用一个Optional作为返回值。</p>\n<p>###3.11 Using <code>guard</code> Statements</p>\n<ul>\n<li><strong>3.11.1</strong> 一般来说，我们会优先使用所谓的”early return”策略来避免<code>if</code>表达式中的多层嵌套的代码。在这种情况下使用<code>guard</code>语句能够有效地提升代码的可读性。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">// PREFERRED</div><div class=\"line\">func eatDoughnut(atIndex index: Int) &#123;</div><div class=\"line\">    guard index &gt;= 0 &amp;&amp; index &lt; doughnuts else &#123;</div><div class=\"line\">        // return early because the index is out of bounds</div><div class=\"line\">        return</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    let doughnut = doughnuts[index]</div><div class=\"line\">    eat(doughnut)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// NOT PREFERRED</div><div class=\"line\">func eatDoughnuts(atIndex index: Int) &#123;</div><div class=\"line\">    if index &gt;= 0 &amp;&amp; index &lt; donuts.count &#123;</div><div class=\"line\">        let doughnut = doughnuts[index]</div><div class=\"line\">        eat(doughnut)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>3.11.2</strong> 在对Optional类型进行解包的时候，优先使用 <code>guard</code> 语句来避免<code>if</code>语句中较多的缩进。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">// PREFERRED</div><div class=\"line\">guard let monkeyIsland = monkeyIsland else &#123;</div><div class=\"line\">    return</div><div class=\"line\">&#125;</div><div class=\"line\">bookVacation(onIsland: monkeyIsland)</div><div class=\"line\">bragAboutVacation(onIsland: monkeyIsland)</div><div class=\"line\"></div><div class=\"line\">// NOT PREFERRED</div><div class=\"line\">if let monkeyIsland = monkeyIsland &#123;</div><div class=\"line\">    bookVacation(onIsland: monkeyIsland)</div><div class=\"line\">    bragAboutVacation(onIsland: monkeyIsland)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// EVEN LESS PREFERRED</div><div class=\"line\">if monkeyIsland == nil &#123;</div><div class=\"line\">    return</div><div class=\"line\">&#125;</div><div class=\"line\">bookVacation(onIsland: monkeyIsland!)</div><div class=\"line\">bragAboutVacation(onIsland: monkeyIsland!)</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>3.11.3</strong> 在决定是要用<code>if</code>表达式还是<code>guard</code>表达式进行Optional类型解包的时候，最重要的点就是要保证代码的可读性。很多时候要注意因时而变，因地制宜：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">// an `if` statement is readable here</div><div class=\"line\">if operationFailed &#123;</div><div class=\"line\">    return</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// a `guard` statement is readable here</div><div class=\"line\">guard isSuccessful else &#123;</div><div class=\"line\">    return</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// double negative logic like this can get hard to read - i.e. don&apos;t do this</div><div class=\"line\">guard !operationFailed else &#123;</div><div class=\"line\">    return</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>3.11.4</strong> 当需要进行多可能性处理的时候，应该优先使用<code>if</code>表达式而不是<code>guard</code>表达式。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">// PREFERRED</div><div class=\"line\">if isFriendly &#123;</div><div class=\"line\">    print(&quot;Hello, nice to meet you!&quot;)</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">    print(&quot;You have the manners of a beggar.&quot;)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// NOT PREFERRED</div><div class=\"line\">guard isFriendly else &#123;</div><div class=\"line\">    print(&quot;You have the manners of a beggar.&quot;)</div><div class=\"line\">    return</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">print(&quot;Hello, nice to meet you!&quot;)</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>3.11.5</strong> 一般来说，<code>guard</code>应该被用于需要直接退出当前上下文的情形。而对于下面这种两个条件互不干扰的情况，应该使用两个<code>if</code>而不是两个<code>guard</code>。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">if let monkeyIsland = monkeyIsland &#123;</div><div class=\"line\">    bookVacation(onIsland: monkeyIsland)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">if let woodchuck = woodchuck where canChuckWood(woodchuck) &#123;</div><div class=\"line\">    woodchuck.chuckWood()</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>3.11.6</strong> 有时候我们会碰到要用<code>guard</code>语句进行多个optionals解包的情况，一般而言，对于复杂的错误处理的Optional类型需要将其拆分到多个单个表达式中。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">// combined because we just return</div><div class=\"line\">guard let thingOne = thingOne,</div><div class=\"line\">    let thingTwo = thingTwo,</div><div class=\"line\">    let thingThree = thingThree else &#123;</div><div class=\"line\">    return</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// separate statements because we handle a specific error in each case</div><div class=\"line\">guard let thingOne = thingOne else &#123;</div><div class=\"line\">    throw Error(message: &quot;Unwrapping thingOne failed.&quot;)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">guard let thingTwo = thingTwo else &#123;</div><div class=\"line\">    throw Error(message: &quot;Unwrapping thingTwo failed.&quot;)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">guard let thingThree = thingThree else &#123;</div><div class=\"line\">    throw Error(message: &quot;Unwrapping thingThree failed.&quot;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>3.11.7</strong> 不要将<code>guard</code>表达式强行缩写到一行内。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">// PREFERRED</div><div class=\"line\">guard let thingOne = thingOne else &#123;</div><div class=\"line\">    return</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// NOT PREFERRED</div><div class=\"line\">guard let thingOne = thingOne else &#123; return &#125;</div></pre></td></tr></table></figure>\n<h2 id=\"4-Documentation-Comments\"><a href=\"#4-Documentation-Comments\" class=\"headerlink\" title=\"4. Documentation/Comments\"></a>4. Documentation/Comments</h2><h3 id=\"4-1-Documentation\"><a href=\"#4-1-Documentation\" class=\"headerlink\" title=\"4.1 Documentation\"></a><a href=\"https://github.com/wxyyxc1992/iOS-Boilerplate/blob/master/Doc/language/swift/advanced/bestpractices/styleguide/linkedin-swift-style-guide.md#41-documentation\" target=\"_blank\" rel=\"external\"></a>4.1 Documentation</h3><p>如果某个函数不是简单地<code>O(1)</code>操作，那么最好就是为该函数添加一些注释文档，这样能有效地提高代码的可读性与可维护性。之前有个非常不错的文档工具<a href=\"https://github.com/onevcat/VVDocumenter-Xcode\" target=\"_blank\" rel=\"external\">VVDocumenter</a>。推荐阅读Apple的官方指南中的描述：<a href=\"https://developer.apple.com/library/tvos/documentation/Xcode/Reference/xcode_markup_formatting_ref/Attention.html#//apple_ref/doc/uid/TP40016497-CH29-SW1\" target=\"_blank\" rel=\"external\">described in Apple’s Documentation</a>.</p>\n<p>Guidelines:</p>\n<ul>\n<li><strong>4.1.1</strong> 每行不应超过160个字符</li>\n<li><strong>4.1.2</strong> 即使某些注释只有一行，也应该使用块注释符： (<code>/** */</code>).</li>\n<li><strong>4.1.3</strong> 不用给每行的开头都加上： <code>*</code>.</li>\n<li><strong>4.1.4</strong> 使用新的 <code>- parameter</code> 标识符来代替老的<code>:param:</code> syntax (注意这边是小写的 <code>parameter</code> 而不是<code>Parameter</code>).</li>\n<li><strong>4.1.5</strong> 如果你准备对参数/返回值/异常值来写注释，那么注意要一个不落的全局加上，尽管有时候会让文档显得重复冗余。有时候，如果只需要对单个参数进行注释，那么还不如直接放在描述里进行声明，而不需要专门的为参数写一个注释。</li>\n<li><strong>4.1.6</strong> 对于复杂的使用类，应该添加一些具体的使用用例来描述类的用法。注意Swift的注释文档中是支持MarkDown语法的，这是一个很好的特性。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> ## Feature Support</div><div class=\"line\"></div><div class=\"line\"> This class does some awesome things. It supports:</div><div class=\"line\"></div><div class=\"line\"> - Feature 1</div><div class=\"line\"> - Feature 2</div><div class=\"line\"> - Feature 3</div><div class=\"line\"></div><div class=\"line\"> ## Examples</div><div class=\"line\"></div><div class=\"line\"> Here is an example use case indented by four spaces because that indicates a</div><div class=\"line\"> code block:</div><div class=\"line\"></div><div class=\"line\">     let myAwesomeThing = MyAwesomeClass()</div><div class=\"line\">     myAwesomeThing.makeMoney()</div><div class=\"line\"></div><div class=\"line\"> ## Warnings:告警</div><div class=\"line\"></div><div class=\"line\"> There are some things you should be careful of:</div><div class=\"line\"></div><div class=\"line\"> 1. Thing one</div><div class=\"line\"> 2. Thing two</div><div class=\"line\"> 3. Thing three</div><div class=\"line\"> */</div><div class=\"line\">class MyAwesomeClass &#123;</div><div class=\"line\">    /* ... */</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>4.1.7</strong> 使用 - ` 在注释中著名引用的代码</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> This does something with a `UIViewController`, perchance.</div><div class=\"line\"> - warning: Make sure that `someValue` is `true` before running this function.</div><div class=\"line\"> */</div><div class=\"line\">func myFunction() &#123;</div><div class=\"line\">    /* ... */</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>4.1.8</strong> 保证文档的注释尽可能的简洁</li>\n</ul>\n<h3 id=\"4-2-Other-Commenting-Guidelines-其他的注释规则\"><a href=\"#4-2-Other-Commenting-Guidelines-其他的注释规则\" class=\"headerlink\" title=\"4.2 Other Commenting Guidelines:其他的注释规则\"></a>4.2 Other Commenting Guidelines:其他的注释规则</h3><ul>\n<li><strong>4.2.1</strong> <code>//</code>后面总是要跟上一个空格</li>\n<li><strong>4.2.2</strong> 注释永远要放在单独的行中</li>\n<li><strong>4.2.3</strong> 在使用<code>// MARK: - whatever</code>的时候，注意MARK与代码之间保留一个空行</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Pirate &#123;</div><div class=\"line\"></div><div class=\"line\">    // MARK: - instance properties</div><div class=\"line\"></div><div class=\"line\">    private let pirateName: String</div><div class=\"line\"></div><div class=\"line\">    // MARK: - initialization</div><div class=\"line\"></div><div class=\"line\">    init() &#123;</div><div class=\"line\">        /* ... */</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>原文链接:<a href=\"https://github.com/wxyyxc1992/iOS-Boilerplate/blob/master/Doc/language/swift/advanced/bestpractices/styleguide/linkedin-swift-style-guide.md#1-code-formatting\" target=\"_blank\" rel=\"external\">github:Swift Style Guide</a></p>\n","excerpt":"","more":"<p><img src=\"https://ooo.0o0.ooo/2016/07/03/5778dc0ab45a1.jpg\" alt=\"\"></p>\n<p>##1. Code Formatting:代码格式化</p>\n<ul>\n<li><strong>1.1</strong> 使用4个空格来代替Tabs</li>\n<li><strong>1.2</strong> 避免过长的行，可以在XCode中进行设置单行最大长度：(Xcode-&gt;Preferences-&gt;Text Editing-&gt;Page guide at column: 160 is helpful for this)</li>\n<li><strong>1.3</strong> 保证每个文件结尾都存在一个新行 Ensure that there is a newline at the end of every file.</li>\n<li><strong>1.4</strong> 避免无意义的尾随空格: (Xcode-&gt;Preferences-&gt;Text Editing-&gt;Automatically trim trailing whitespace + Including whitespace-only lines).</li>\n<li><strong>1.5</strong> 避免将单独的左花括号放置到一行，我们参考了：<a href=\"https://en.m.wikipedia.org/wiki/Indent_style#Variant:_1TBS\">1TBS style</a>.</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">class SomeClass &#123;</div><div class=\"line\">    func someMethod() &#123;</div><div class=\"line\">        if x == y &#123;</div><div class=\"line\">            /* ... */</div><div class=\"line\">        &#125; else if x == z &#123;</div><div class=\"line\">            /* ... */</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            /* ... */</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /* ... */</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>1.6</strong> 在写变量的类型声明、字典类型的键、函数参数、协议的声明或者父类的时候，不要在冒号前添加空格。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">// specifying type</div><div class=\"line\">let pirateViewController: PirateViewController</div><div class=\"line\"></div><div class=\"line\">// dictionary syntax (note that we left-align as opposed to aligning colons)</div><div class=\"line\">let ninjaDictionary: [String: AnyObject] = [</div><div class=\"line\">    &quot;fightLikeDairyFarmer&quot;: false,</div><div class=\"line\">    &quot;disgusting&quot;: true</div><div class=\"line\">]</div><div class=\"line\"></div><div class=\"line\">// declaring a function</div><div class=\"line\">func myFunction&lt;T, U: SomeProtocol where T.RelatedType == U&gt;(firstArgument: U, secondArgument: T) &#123;</div><div class=\"line\">    /* ... */</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// calling a function</div><div class=\"line\">someFunction(someArgument: &quot;Kitten&quot;)</div><div class=\"line\"></div><div class=\"line\">// superclasses</div><div class=\"line\">class PirateViewController: UIViewController &#123;</div><div class=\"line\">    /* ... */</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// protocols</div><div class=\"line\">extension PirateViewController: UITableViewDataSource &#123;</div><div class=\"line\">    /* ... */</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>1.7</strong> 一般来说，逗号后面都要跟随一个空格。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">let myArray = [1, 2, 3, 4, 5]</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>1.8</strong> 在二元操作符譬如<code>+</code>, <code>==</code>, 或者 <code>-&gt;</code>的前后需要加上空格，但是对于<code>(</code> 、`)的前后不需要加空格。</li>\n</ul>\n<ul>\n<li><strong>1.9</strong> 我们默认使用Xcode推荐的格式化风格(CTRL-I) ，在声明某个函数的时候会多行排布参数。</li>\n</ul>\n<ul>\n<li><strong>1.10</strong> 在调用多参数函数的时候，会把多个参数放置到单独的行中：</li>\n</ul>\n<ul>\n<li><strong>1.11</strong> 对于大型的数组或者字典类型，应该将其分割到多行内，<code>[</code> 与 <code>]</code>类比于花括号进行处理。对于闭包而言也应该同样适合于该规则。</li>\n</ul>\n<ul>\n<li><strong>1.12</strong> 尽可能地使用本地变量的方式来避免多行的判断语句。</li>\n</ul>\n<p>##2. Naming:命名</p>\n<ul>\n<li><strong>2.1</strong> Swift中不需要再使用Objective-C那样的前缀，譬如使用 <code>GuybrushThreepwood</code> 而不是<code>LIGuybrushThreepwood</code>。</li>\n<li><strong>2.2</strong> 对于类型名即<code>struct</code>, <code>enum</code>, <code>class</code>, <code>typedef</code>, <code>associatedtype</code>等等使用 <code>PascalCase</code> 。</li>\n<li><strong>2.3</strong> 对于函数名、方法名、变量名、常量、参数名等使用<code>camelCase</code>。</li>\n<li><strong>2.4</strong> 在使用首字母缩写的时候尽可能地全部大写，并且注意保证全部代码中的统一。不过如果缩写被用于命名的起始，那么就全部小写。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">// &quot;HTML&quot; is at the start of a variable name, so we use lowercase &quot;html&quot;</div><div class=\"line\">let htmlBodyContent: String = &quot;&lt;p&gt;Hello, World!&lt;/p&gt;&quot;</div><div class=\"line\">// Prefer using ID to Id</div><div class=\"line\">let profileID: Int = 1</div><div class=\"line\">// Prefer URLFinder to UrlFinder</div><div class=\"line\">class URLFinder &#123;</div><div class=\"line\">    /* ... */</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>2.5</strong> 对于静态常量使用 <code>k</code> 前缀 + PascalCase。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">class MyClassName &#123;</div><div class=\"line\">    // use `k` prefix for constant primitives</div><div class=\"line\">    static let kSomeConstantHeight: CGFloat = 80.0</div><div class=\"line\"></div><div class=\"line\">    // use `k` prefix for non-primitives as well</div><div class=\"line\">    static let kDeleteButtonColor = UIColor.redColor()</div><div class=\"line\"></div><div class=\"line\">    // don&apos;t use `k` prefix for singletons</div><div class=\"line\">    static let sharedInstance = MyClassName()</div><div class=\"line\"></div><div class=\"line\">    /* ... */</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>2.6</strong> 对于泛型或者关联类型，使用<code>PascalCase</code>描述泛型，如果泛型名与其他重复，那么可以添加一个<code>Type</code>后缀名到泛型名上。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">class SomeClass&lt;T&gt; &#123; /* ... */ &#125;</div><div class=\"line\">class SomeClass&lt;Model&gt; &#123; /* ... */ &#125;</div><div class=\"line\">protocol Modelable &#123;</div><div class=\"line\">    associatedtype Model</div><div class=\"line\">&#125;</div><div class=\"line\">protocol Sequence &#123;</div><div class=\"line\">    associatedtype IteratorType: Iterator</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>2.7</strong> 命名必须要是不模糊的并且方便表述的</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">// PREFERRED</div><div class=\"line\">class RoundAnimatingButton: UIButton &#123; /* ... */ &#125;</div><div class=\"line\"></div><div class=\"line\">// NOT PREFERRED</div><div class=\"line\">class CustomButton: UIButton &#123; /* ... */ &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>2.8</strong> 不要使用缩写，可以选择较为简短的单词。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">// PREFERRED</div><div class=\"line\">class RoundAnimatingButton: UIButton &#123;</div><div class=\"line\">    let animationDuration: NSTimeInterval</div><div class=\"line\"></div><div class=\"line\">    func startAnimating() &#123;</div><div class=\"line\">        let firstSubview = subviews.first</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// NOT PREFERRED</div><div class=\"line\">class RoundAnimating: UIButton &#123;</div><div class=\"line\">    let aniDur: NSTimeInterval</div><div class=\"line\"></div><div class=\"line\">    func srtAnmating() &#123;</div><div class=\"line\">        let v = subviews.first</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>2.9</strong> 对于不是很明显的类型需要将类型信息包含在属性名中。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div></pre></td><td class=\"code\"><pre><div class=\"line\">// PREFERRED</div><div class=\"line\">class ConnectionTableViewCell: UITableViewCell &#123;</div><div class=\"line\">    let personImageView: UIImageView</div><div class=\"line\"></div><div class=\"line\">    let animationDuration: NSTimeInterval</div><div class=\"line\"></div><div class=\"line\">    // it is ok not to include string in the ivar name here because it&apos;s obvious</div><div class=\"line\">    // that it&apos;s a string from the property name</div><div class=\"line\">    let firstName: String</div><div class=\"line\"></div><div class=\"line\">    // though not preferred, it is OK to use `Controller` instead of `ViewController`</div><div class=\"line\">    let popupController: UIViewController</div><div class=\"line\">    let popupViewController: UIViewController</div><div class=\"line\"></div><div class=\"line\">    // when working with a subclass of `UIViewController` such as a table view</div><div class=\"line\">    // controller, collection view controller, split view controller, etc.,</div><div class=\"line\">    // fully indicate the type in the name.</div><div class=\"line\">    let popupTableViewController: UITableViewController</div><div class=\"line\"></div><div class=\"line\">    // when working with outlets, make sure to specify the outlet type in the</div><div class=\"line\">    // variable name.</div><div class=\"line\">    @IBOutlet weak var submitButton: UIButton!</div><div class=\"line\">    @IBOutlet weak var emailTextField: UITextField!</div><div class=\"line\">    @IBOutlet weak var nameLabel: UILabel!</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// NOT PREFERRED</div><div class=\"line\">class ConnectionTableViewCell: UITableViewCell &#123;</div><div class=\"line\">    // this isn&apos;t a `UIImage`, so shouldn&apos;t be called image</div><div class=\"line\">    // use personImageView instead</div><div class=\"line\">    let personImage: UIImageView</div><div class=\"line\"></div><div class=\"line\">    // this isn&apos;t a `String`, so it should be `textLabel`</div><div class=\"line\">    let text: UILabel</div><div class=\"line\"></div><div class=\"line\">    // `animation` is not clearly a time interval</div><div class=\"line\">    // use `animationDuration` or `animationTimeInterval` instead</div><div class=\"line\">    let animation: NSTimeInterval</div><div class=\"line\"></div><div class=\"line\">    // this is not obviously a `String`</div><div class=\"line\">    // use `transitionText` or `transitionString` instead</div><div class=\"line\">    let transition: String</div><div class=\"line\"></div><div class=\"line\">    // this is a view controller - not a view</div><div class=\"line\">    let popupView: UIViewController</div><div class=\"line\"></div><div class=\"line\">    // as mentioned previously, we don&apos;t want to use abbreviations, so don&apos;t use</div><div class=\"line\">    // `VC` instead of `ViewController`</div><div class=\"line\">    let popupVC: UIViewController</div><div class=\"line\"></div><div class=\"line\">    // even though this is still technically a `UIViewController`, this variable</div><div class=\"line\">    // should indicate that we are working with a *Table* View Controller</div><div class=\"line\">    let popupViewController: UITableViewController</div><div class=\"line\"></div><div class=\"line\">    // for the sake of consistency, we should put the type name at the end of the</div><div class=\"line\">    // variable name and not at the start</div><div class=\"line\">    @IBOutlet weak var btnSubmit: UIButton!</div><div class=\"line\">    @IBOutlet weak var buttonSubmit: UIButton!</div><div class=\"line\"></div><div class=\"line\">    // we should always have a type in the variable name when dealing with outlets</div><div class=\"line\">    // for example, here, we should have `firstNameLabel` instead</div><div class=\"line\">    @IBOutlet weak var firstName: UILabel!</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>2.10</strong> 在编写函数参数的时候，要保证每个参数都易于理解其功能。</li>\n<li><strong>2.11</strong> 根据 <a href=\"https://swift.org/documentation/api-design-guidelines/\">Apple’s API Design Guidelines</a>, 对于<code>protocol</code>，如果其描述的是正在做的事情，譬如<code>Collection</code>，那么应该命名为名词。而如果是用于描述某种能力，譬如<code>Equatable</code>, <code>ProgressReporting</code>，那么应该添加 <code>able</code>, <code>ible</code>, 或者 <code>ing</code> 这样的后缀。如果你的协议并不符合上述两种情形，那么应该直接添加一个<code>Protocol</code>后缀，譬如：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">// here, the name is a noun that describes what the protocol does</div><div class=\"line\">protocol TableViewSectionProvider &#123;</div><div class=\"line\">    func rowHeight(atRow row: Int) -&gt; CGFloat</div><div class=\"line\">    var numberOfRows: Int &#123; get &#125;</div><div class=\"line\">    /* ... */</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// here, the protocol is a capability, and we name it appropriately</div><div class=\"line\">protocol Loggable &#123;</div><div class=\"line\">    func logCurrentState()</div><div class=\"line\">    /* ... */</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// suppose we have an `InputTextView` class, but we also want a protocol</div><div class=\"line\">// to generalize some of the functionality - it might be appropriate to</div><div class=\"line\">// use the `Protocol` suffix here</div><div class=\"line\">protocol InputTextViewProtocol &#123;</div><div class=\"line\">    func sendTrackingEvent()</div><div class=\"line\">    func inputText() -&gt; String</div><div class=\"line\">    /* ... */</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"3-Coding-Style\"><a href=\"#3-Coding-Style\" class=\"headerlink\" title=\"3. Coding Style\"></a>3. Coding Style</h2><p>###3.1 General</p>\n<ul>\n<li><strong>3.1.1</strong> 尽可能地使用<code>let</code>来代替<code>var</code>。</li>\n<li><strong>3.1.2</strong> 尽可能地使用 <code>map</code>, <code>filter</code>, <code>reduce</code>的组合来进行集合的转换等操作，并且尽可能地避免使用带有副作用的闭包。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">// PREFERRED</div><div class=\"line\">let stringOfInts = [1, 2, 3].flatMap &#123; String($0) &#125;</div><div class=\"line\">// [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]</div><div class=\"line\"></div><div class=\"line\">// NOT PREFERRED</div><div class=\"line\">var stringOfInts: [String] = []</div><div class=\"line\">for integer in [1, 2, 3] &#123;</div><div class=\"line\">    stringOfInts.append(String(integer))</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// PREFERRED</div><div class=\"line\">let evenNumbers = [4, 8, 15, 16, 23, 42].filter &#123; $0 % 2 == 0 &#125;</div><div class=\"line\">// [4, 8, 16, 42]</div><div class=\"line\"></div><div class=\"line\">// NOT PREFERRED</div><div class=\"line\">var evenNumbers: [Int] = []</div><div class=\"line\">for integer in [4, 8, 15, 16, 23, 42] &#123;</div><div class=\"line\">    if integer % 2 == 0 &#123;</div><div class=\"line\">        evenNumbers(integer)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>3.1.3</strong> 尽可能地显式声明不方便进行类型推测的变量或者常量的类型名。</li>\n<li><strong>3.1.4</strong> 如果你的函数需要返回多个参数，那么尽可能地使用<code>Tuple</code>来代替<code>inout</code>参数。如果你会多次使用某个元组，那么应该使用<code>typealias</code>设置别名。如果返回的参数超过三个，那么应该使用结构体或者类来替代。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">func pirateName() -&gt; (firstName: String, lastName: String) &#123;</div><div class=\"line\">    return (&quot;Guybrush&quot;, &quot;Threepwood&quot;)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">let name = pirateName()</div><div class=\"line\">let firstName = name.firstName</div><div class=\"line\">let lastName = name.lastName</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>3.1.5</strong> 在创建delegates/protocols的时候需要小心所谓的保留环(retain cycles)，这些属性需要被声明为<code>weak</code>。</li>\n<li><strong>3.1.6</strong> 在闭包中直接调用<code>self</code>可能会导致保留环，可以使用<a href=\"https://developer.apple.com/library/ios/documentation/swift/conceptual/Swift_Programming_Language/Closures.html#//apple_ref/doc/uid/TP40014097-CH11-XID_163\">capture list</a> 在这种情况下:</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">myFunctionWithClosure() &#123; [weak self] (error) -&gt; Void in</div><div class=\"line\">    // you can do this</div><div class=\"line\"></div><div class=\"line\">    self?.doSomething()</div><div class=\"line\"></div><div class=\"line\">    // or you can do this</div><div class=\"line\"></div><div class=\"line\">    guard let strongSelf = self else &#123;</div><div class=\"line\">        return</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    strongSelf.doSomething()</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>3.1.7</strong> 不要使用 labeled breaks。</li>\n<li><strong>3.1.8</strong> 不要在控制流逻辑判断的时候加上圆括号</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">// PREFERRED</div><div class=\"line\">if x == y &#123;</div><div class=\"line\">    /* ... */</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// NOT PREFERRED</div><div class=\"line\">if (x == y) &#123;</div><div class=\"line\">    /* ... */</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>3.1.9</strong> 避免在使用enum的时候写出全名</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">// PREFERRED</div><div class=\"line\">imageView.setImageWithURL(url, type: .person)</div><div class=\"line\"></div><div class=\"line\">// NOT PREFERRED</div><div class=\"line\">imageView.setImageWithURL(url, type: AsyncImageView.Type.person)</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>3.1.10</strong> 在写类方法的时候不能用简短写法，应该使用类名.方法名，这样能够保证代码的可读性</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">// PREFERRED</div><div class=\"line\">imageView.backgroundColor = UIColor.whiteColor()</div><div class=\"line\"></div><div class=\"line\">// NOT PREFERRED</div><div class=\"line\">imageView.backgroundColor = .whiteColor()</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>3.1.11</strong> 在非必要的时候不要写<code>self.</code>。</li>\n<li><strong>3.1.12</strong> 在编写某个方法的时候注意考虑下这个方法是否有可能被复写，如果不可能被复写那么应该使用<code>final</code>修饰符。还要注意加上final之后也会导致无法在测试的时候进行复写，所以还是需要综合考虑。一般而言，加上<code>final</code>修饰符后会提高编译的效率，所以应该尽可能地使用该修饰符。</li>\n<li><strong>3.1.13</strong> 在使用譬如<code>else</code>, <code>catch</code>等等类似的语句的时候，将关键字与花括号放在一行，同样遵循<a href=\"https://en.m.wikipedia.org/wiki/Indent_style#Variant:_1TBS\">1TBS style</a>规范，这边列出了常见的<code>if</code>/<code>else</code> 以及 <code>do</code>/<code>catch</code> 示范代码。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">if someBoolean &#123;</div><div class=\"line\">    // do something</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">    // do something else</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">do &#123;</div><div class=\"line\">    let fileContents = try readFile(&quot;filename.txt&quot;)</div><div class=\"line\">&#125; catch &#123;</div><div class=\"line\">    print(error)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>###3.2 Access Modifiers</p>\n<ul>\n<li><strong>3.2.1</strong> 在需要的时候应该将访问修饰符放在关键字的第一位。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">// PREFERRED</div><div class=\"line\">private static let kMyPrivateNumber: Int</div><div class=\"line\"></div><div class=\"line\">// NOT PREFERRED</div><div class=\"line\">static private let kMyPrivateNumber: Int</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>3.2.2</strong> 访问修饰符不应该单独放一行：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">// PREFERRED</div><div class=\"line\">public class Pirate &#123;</div><div class=\"line\">    /* ... */</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// NOT PREFERRED</div><div class=\"line\">public</div><div class=\"line\">class Pirate &#123;</div><div class=\"line\">    /* ... */</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>3.2.3</strong> 一般来说，不要显式地写默认的 <code>internal</code>访问修饰符。</li>\n<li><strong>3.2.4</strong> 如果某个变量需要在测试的时候被使用到，那么应该标识为<code>internal</code>来保证<code>@testable import ModuleName</code>。这里需要注意的是，对于某些应该被声明为<code>private</code>的变量因为测试用途而声明为了<code>internal</code>，那么应该在注释里特别地注明。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> This variable defines the pirate&apos;s name.</div><div class=\"line\"> - warning: Not `private` for `@testable`.</div><div class=\"line\"> */</div><div class=\"line\">let pirateName = &quot;LeChuck&quot;</div></pre></td></tr></table></figure>\n<h3 id=\"3-3-Custom-Operators-自定义操作符\"><a href=\"#3-3-Custom-Operators-自定义操作符\" class=\"headerlink\" title=\"3.3 Custom Operators:自定义操作符\"></a><a href=\"https://github.com/wxyyxc1992/iOS-Boilerplate/blob/master/Doc/language/swift/advanced/bestpractices/styleguide/linkedin-swift-style-guide.md#33-custom-operators自定义操作符\"></a>3.3 Custom Operators:自定义操作符</h3><p>尽可能地选用命名函数来代替自定义操作符。如果你打算引入一个自定义的操作符，那么一定要有非常充分的理由来说明为啥要讲一个新的操作符引入到全局作用域，而不是使用其他一些可替代的方式。你也可以选择去复写一些现有的操作符，譬如<code>==</code>来适应一些新的类型，不过要保证你添加的用法一定要与语义相符。譬如<code>==</code> 应该只能用于表示相等性测试并且返回一个布尔值。</p>\n<p>###3.4 Switch Statements and <code>enum</code>s</p>\n<ul>\n<li><strong>3.4.1</strong> 在使用枚举类型作为switch的参数的时候，避免引入<code>default</code>关键字，而应该将没有使用的情形放到下面然后使用break关键字来避免被执行。</li>\n<li><strong>3.4.2</strong> Swift中默认会在每个case的结尾进行break，因此没必要的时候不需要显式地声明<code>break</code>关键字。</li>\n<li><strong>3.4.3</strong> The <code>case</code> statements should line up with the <code>switch</code> statement itself as per default Swift standards.</li>\n<li><strong>3.4.4</strong> When defining a case that has an associated value, make sure that this value is appropriately labeled as opposed to just types (e.g. <code>case Hunger(hungerLevel: Int)</code> instead of <code>case Hunger(Int)</code>).</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">enum Problem &#123;</div><div class=\"line\">    case attitude</div><div class=\"line\">    case hair</div><div class=\"line\">    case hunger(hungerLevel: Int)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">func handleProblem(problem: Problem) &#123;</div><div class=\"line\">    switch problem &#123;</div><div class=\"line\">    case .attitude:</div><div class=\"line\">        print(&quot;At least I don&apos;t have a hair problem.&quot;)</div><div class=\"line\">    case .hair:</div><div class=\"line\">        print(&quot;Your barber didn&apos;t know when to stop.&quot;)</div><div class=\"line\">    case .hunger(let hungerLevel):</div><div class=\"line\">        print(&quot;The hunger level is \\(hungerLevel).&quot;)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>3.4.5</strong> 优先使用譬如<code>case 1, 2, 3:</code>这样的列表表达式而不是使用<code>fallthrough</code>关键字。</li>\n<li><strong>3.4.6</strong> 如果你添加了一个默认的case并且该case不应该被使用，那么应该在default情形下抛出异常。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">func handleDigit(digit: Int) throws &#123;</div><div class=\"line\">    case 0, 1, 2, 3, 4, 5, 6, 7, 8, 9:</div><div class=\"line\">        print(&quot;Yes, \\(digit) is a digit!&quot;)</div><div class=\"line\">    default:</div><div class=\"line\">        throw Error(message: &quot;The given number was not a digit.&quot;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>###3.5 Optionals</p>\n<ul>\n<li><strong>3.5.1</strong> 只应该在 <code>@IBOutlet</code>中使用隐式地未包裹的Options。否则其他情况下就应该使用Non-Optional或者正常的Optional的变量。虽然有时候你能保证某个变量肯定非<code>nil</code>，不过这样用的话还是比较安全并且能保证上下一致性。</li>\n</ul>\n<p>The only time you should be using implicitly unwrapped optionals is withs. In every other case, it is better to use a non-optional or regular optional variable. Yes, there are cases in which you can probably “guarantee” that the variable will never be <code>nil</code> when used, but it is better to be safe and consistent.</p>\n<ul>\n<li><strong>3.5.2</strong> 不要使用 <code>as!</code> 或者 <code>try!</code>.</li>\n<li><strong>3.5.3</strong> 如果你只是打算判断存放在Optional中的值是否为空，那么你应该直接与<code>nil</code>进行判断而不是使用<code>if let</code>语句将值取出来。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">// PREFERERED</div><div class=\"line\">if someOptional != nil &#123;</div><div class=\"line\">    // do something</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// NOT PREFERRED</div><div class=\"line\">if let _ = someOptional &#123;</div><div class=\"line\">    // do something</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>3.5.4</strong> 不要使用 <code>unowned</code>。你可以将<code>unowned</code>当做对于<code>weak</code>变量的隐式解包，虽然有时候<code>unowned</code>与<code>weak</code>相比有小小地性能提升，不过还是不建议进行使用。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">// PREFERRED</div><div class=\"line\">weak var parentViewController: UIViewController?</div><div class=\"line\"></div><div class=\"line\">// NOT PREFERRED</div><div class=\"line\">weak var parentViewController: UIViewController!</div><div class=\"line\">unowned var parentViewController: UIViewController</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>3.5.5</strong> 当对Optionals进行解包的时候，使用与Optionals变量一致的变量名</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">guard let myVariable = myVariable else &#123;</div><div class=\"line\">    return</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"3-6-Protocols\"><a href=\"#3-6-Protocols\" class=\"headerlink\" title=\"3.6 Protocols\"></a>3.6 Protocols</h3><p>在实现协议的时候，大体上有两种代码组织方式：</p>\n<ol>\n<li>使用 <code>// MARK:</code> 来注释你的专门用于实现协议中规定的方法</li>\n<li>在你的类或者结构体实现之外使用一个扩展来存放实现代码，不过要保证在一个源文件中</li>\n</ol>\n<p>不过需要注意的是，如果你是使用了Extension方式，那么定义在Extension中的方法是无法被子类复写的，这样可能会无法进行测试。</p>\n<h3 id=\"3-7-Properties\"><a href=\"#3-7-Properties\" class=\"headerlink\" title=\"3.7 Properties\"></a><a href=\"https://github.com/wxyyxc1992/iOS-Boilerplate/blob/master/Doc/language/swift/advanced/bestpractices/styleguide/linkedin-swift-style-guide.md#37-properties\"></a>3.7 Properties</h3><ul>\n<li><strong>3.7.1</strong> 如果是定义一个只读的需要经过计算的属性，那么不需要声明 <code>get {}</code></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">var computedProperty: String &#123;</div><div class=\"line\">    if someBool &#123;</div><div class=\"line\">        return &quot;I&apos;m a mighty pirate!&quot;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return &quot;I&apos;m selling these fine leather jackets.&quot;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>3.7.2</strong> 在使用 <code>get {}</code>, <code>set {}</code>, <code>willSet</code>, 以及 <code>didSet</code>, 注意块的缩进</li>\n<li><strong>3.7.3</strong> 尽管你可以在<code>willSet</code>/<code>didSet</code>以及 <code>set</code>方法中使用自定义的名称，不过建议还是使用默认的<code>newValue</code>/<code>oldValue</code>变量名</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">var computedProperty: String &#123;</div><div class=\"line\">    get &#123;</div><div class=\"line\">        if someBool &#123;</div><div class=\"line\">            return &quot;I&apos;m a mighty pirate!&quot;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return &quot;I&apos;m selling these fine leather jackets.&quot;</div><div class=\"line\">    &#125;</div><div class=\"line\">    set &#123;</div><div class=\"line\">        computedProperty = newValue</div><div class=\"line\">    &#125;</div><div class=\"line\">    willSet &#123;</div><div class=\"line\">        print(&quot;will set to \\(newValue)&quot;)</div><div class=\"line\">    &#125;</div><div class=\"line\">    didSet &#123;</div><div class=\"line\">        print(&quot;did set from \\(oldValue) to \\(newValue)&quot;)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>3.7.4</strong> 将任何类常量设置为<code>static</code></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">class MyTableViewCell: UITableViewCell &#123;</div><div class=\"line\">    static let kReuseIdentifier = String(MyTableViewCell)</div><div class=\"line\">    static let kCellHeight: CGFloat = 80.0</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>3.7.5</strong> 可以使用如下方式便捷地声明一个单例变量：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">class PirateManager &#123;</div><div class=\"line\">    static let sharedInstance = PirateManager()</div><div class=\"line\"></div><div class=\"line\">    /* ... */</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"3-8-Closures-闭包\"><a href=\"#3-8-Closures-闭包\" class=\"headerlink\" title=\"3.8 Closures:闭包\"></a>3.8 Closures:闭包</h3><ul>\n<li><strong>3.8.1</strong> 如果闭包中的某个参数的类型是显而易见的，那么可以避免声明类型。不过有时候为了保证可读性与一致性，还是会显示声明参数类型。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">// omitting the type</div><div class=\"line\">doSomethingWithClosure() &#123; response in</div><div class=\"line\">    print(response)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// explicit type</div><div class=\"line\">doSomethingWithClosure() &#123; response: NSURLResponse in</div><div class=\"line\">    print(response)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// using shorthand in a map statement</div><div class=\"line\">[1, 2, 3].flatMap &#123; String($0) &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>3.8.2</strong> 在参数列表中，如果是使用了捕获变量或者声明了非Void的返回值，那么应该将参数列表写在一个圆括号里，其他情况下则可以省略圆括号。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">// parentheses due to capture list</div><div class=\"line\">doSomethingWithClosure() &#123; [weak self] (response: NSURLResponse) in</div><div class=\"line\">    self?.handleResponse(response)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// parentheses due to return type</div><div class=\"line\">doSomethingWithClosure() &#123; (response: NSURLResponse) -&gt; String in</div><div class=\"line\">    return String(response)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>3.8.3</strong> 如果你是将闭包声明为一个类型，那么除非该类型为Optional或者该闭包是另一个闭包的参数，否则不需要使用圆括号进行包裹。不过需要用圆括号来标注参数列表，并且使用<code>Void</code>来指明没有任何结果返回。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">let completionBlock: (success: Bool) -&gt; Void = &#123;</div><div class=\"line\">    print(&quot;Success? \\(success)&quot;)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">let completionBlock: () -&gt; Void = &#123;</div><div class=\"line\">    print(&quot;Completed!&quot;)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">let completionBlock: (() -&gt; Void)? = nil</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>3.8.4</strong> 尽可能地将参数名与左括号放在一行，不过要避免打破每行最长160个字符的限制。</li>\n</ul>\n<p>Keep parameter names on same line as the opening brace for closures when possible without too much horizontal overflow (i.e. ensure lines are less than 160 characters).</p>\n<ul>\n<li><strong>3.8.5</strong> 尽可能地使用 trailing closure表达式，除非需要显示地声明闭包参数的外部参数名。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">// trailing closure</div><div class=\"line\">doSomething(1.0) &#123; parameter1 in</div><div class=\"line\">    print(&quot;Parameter 1 is \\(parameter1)&quot;)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// no trailing closure</div><div class=\"line\">doSomething(1.0, success: &#123; parameter1 in</div><div class=\"line\">    print(&quot;Success with \\(parameter1)&quot;)</div><div class=\"line\">&#125;, failure: &#123; parameter1 in</div><div class=\"line\">    print(&quot;Failure with \\(parameter1)&quot;)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>###3.9 Arrays</p>\n<ul>\n<li><strong>3.9.1</strong> 一般来说，避免使用下标直接访问某个数组，而应该使用类似于<code>.first</code>、<code>.last</code>这样的访问器进行访问。另外，应该优先使用<code>for item in items</code>语法来替代`for i in 0..。如果你打算用下标遍历数组，那么一定保证不能越界。</li>\n<li><strong>3.9.2</strong> 永远不要使用<code>+=</code> 或者 <code>+</code>运算符来增加或者连接数组，应该使用<code>.append()</code> 或者 <code>.appendContentsOf()</code> 方法。如果你想定义一个从其他数组生成的不可变数组，那么应该使用<code>let</code>关键字，即： <code>let myNewArray = arr1 + arr2</code>, 或者 <code>let myNewArray = [arr1, arr2].flatten()</code>。</li>\n</ul>\n<h3 id=\"3-10-Error-Handling\"><a href=\"#3-10-Error-Handling\" class=\"headerlink\" title=\"3.10 Error Handling\"></a><a href=\"https://github.com/wxyyxc1992/iOS-Boilerplate/blob/master/Doc/language/swift/advanced/bestpractices/styleguide/linkedin-swift-style-guide.md#310-error-handling\"></a>3.10 Error Handling</h3><p>假设某个函数 <code>myFunction</code> 需要去返回一个<code>String</code>类型，不过有可能会在某个点抛出异常，一般来说会将该函数的返回值设置为<code>String?</code>：</p>\n<p>Example:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">func readFile(withFilename filename: String) -&gt; String? &#123;</div><div class=\"line\">    guard let file = openFile(filename) else &#123;</div><div class=\"line\">        return nil</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    let fileContents = file.read()</div><div class=\"line\">    file.close()</div><div class=\"line\">    return fileContents</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">func printSomeFile() &#123;</div><div class=\"line\">    let filename = &quot;somefile.txt&quot;</div><div class=\"line\">    guard let fileContents = readFile(filename) else &#123;</div><div class=\"line\">        print(&quot;Unable to open file \\(filename).&quot;)</div><div class=\"line\">        return</div><div class=\"line\">    &#125;</div><div class=\"line\">    print(fileContents)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>不过作为异常处理的角度，我们应该使用Swift的<code>try-catch</code>表达式，这样能显式地知道错误点：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct Error: ErrorType &#123;</div><div class=\"line\">    public let file: StaticString</div><div class=\"line\">    public let function: StaticString</div><div class=\"line\">    public let line: UInt</div><div class=\"line\">    public let message: String</div><div class=\"line\"></div><div class=\"line\">    public init(message: String, file: StaticString = #file, function: StaticString = #function, line: UInt = #line) &#123;</div><div class=\"line\">        self.file = file</div><div class=\"line\">        self.function = function</div><div class=\"line\">        self.line = line</div><div class=\"line\">        self.message = message</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Example usage:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">func readFile(withFilename filename: String) throws -&gt; String &#123;</div><div class=\"line\">    guard let file = openFile(filename) else &#123;</div><div class=\"line\">        throw Error(message: &quot;Unable to open file named \\(filename).&quot;)</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    let fileContents = file.read()</div><div class=\"line\">    file.close()</div><div class=\"line\">    return fileContents</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">func printSomeFile() &#123;</div><div class=\"line\">    do &#123;</div><div class=\"line\">        let fileContents = try readFile(filename)</div><div class=\"line\">        print(fileContents)</div><div class=\"line\">    &#125; catch &#123;</div><div class=\"line\">        print(error)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>总而言之，如果某个函数可能会出错，并且出错的原因不能显式地观测到，那么应该优先抛出异常而不是使用一个Optional作为返回值。</p>\n<p>###3.11 Using <code>guard</code> Statements</p>\n<ul>\n<li><strong>3.11.1</strong> 一般来说，我们会优先使用所谓的”early return”策略来避免<code>if</code>表达式中的多层嵌套的代码。在这种情况下使用<code>guard</code>语句能够有效地提升代码的可读性。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">// PREFERRED</div><div class=\"line\">func eatDoughnut(atIndex index: Int) &#123;</div><div class=\"line\">    guard index &gt;= 0 &amp;&amp; index &lt; doughnuts else &#123;</div><div class=\"line\">        // return early because the index is out of bounds</div><div class=\"line\">        return</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    let doughnut = doughnuts[index]</div><div class=\"line\">    eat(doughnut)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// NOT PREFERRED</div><div class=\"line\">func eatDoughnuts(atIndex index: Int) &#123;</div><div class=\"line\">    if index &gt;= 0 &amp;&amp; index &lt; donuts.count &#123;</div><div class=\"line\">        let doughnut = doughnuts[index]</div><div class=\"line\">        eat(doughnut)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>3.11.2</strong> 在对Optional类型进行解包的时候，优先使用 <code>guard</code> 语句来避免<code>if</code>语句中较多的缩进。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">// PREFERRED</div><div class=\"line\">guard let monkeyIsland = monkeyIsland else &#123;</div><div class=\"line\">    return</div><div class=\"line\">&#125;</div><div class=\"line\">bookVacation(onIsland: monkeyIsland)</div><div class=\"line\">bragAboutVacation(onIsland: monkeyIsland)</div><div class=\"line\"></div><div class=\"line\">// NOT PREFERRED</div><div class=\"line\">if let monkeyIsland = monkeyIsland &#123;</div><div class=\"line\">    bookVacation(onIsland: monkeyIsland)</div><div class=\"line\">    bragAboutVacation(onIsland: monkeyIsland)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// EVEN LESS PREFERRED</div><div class=\"line\">if monkeyIsland == nil &#123;</div><div class=\"line\">    return</div><div class=\"line\">&#125;</div><div class=\"line\">bookVacation(onIsland: monkeyIsland!)</div><div class=\"line\">bragAboutVacation(onIsland: monkeyIsland!)</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>3.11.3</strong> 在决定是要用<code>if</code>表达式还是<code>guard</code>表达式进行Optional类型解包的时候，最重要的点就是要保证代码的可读性。很多时候要注意因时而变，因地制宜：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">// an `if` statement is readable here</div><div class=\"line\">if operationFailed &#123;</div><div class=\"line\">    return</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// a `guard` statement is readable here</div><div class=\"line\">guard isSuccessful else &#123;</div><div class=\"line\">    return</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// double negative logic like this can get hard to read - i.e. don&apos;t do this</div><div class=\"line\">guard !operationFailed else &#123;</div><div class=\"line\">    return</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>3.11.4</strong> 当需要进行多可能性处理的时候，应该优先使用<code>if</code>表达式而不是<code>guard</code>表达式。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">// PREFERRED</div><div class=\"line\">if isFriendly &#123;</div><div class=\"line\">    print(&quot;Hello, nice to meet you!&quot;)</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">    print(&quot;You have the manners of a beggar.&quot;)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// NOT PREFERRED</div><div class=\"line\">guard isFriendly else &#123;</div><div class=\"line\">    print(&quot;You have the manners of a beggar.&quot;)</div><div class=\"line\">    return</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">print(&quot;Hello, nice to meet you!&quot;)</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>3.11.5</strong> 一般来说，<code>guard</code>应该被用于需要直接退出当前上下文的情形。而对于下面这种两个条件互不干扰的情况，应该使用两个<code>if</code>而不是两个<code>guard</code>。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">if let monkeyIsland = monkeyIsland &#123;</div><div class=\"line\">    bookVacation(onIsland: monkeyIsland)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">if let woodchuck = woodchuck where canChuckWood(woodchuck) &#123;</div><div class=\"line\">    woodchuck.chuckWood()</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>3.11.6</strong> 有时候我们会碰到要用<code>guard</code>语句进行多个optionals解包的情况，一般而言，对于复杂的错误处理的Optional类型需要将其拆分到多个单个表达式中。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">// combined because we just return</div><div class=\"line\">guard let thingOne = thingOne,</div><div class=\"line\">    let thingTwo = thingTwo,</div><div class=\"line\">    let thingThree = thingThree else &#123;</div><div class=\"line\">    return</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// separate statements because we handle a specific error in each case</div><div class=\"line\">guard let thingOne = thingOne else &#123;</div><div class=\"line\">    throw Error(message: &quot;Unwrapping thingOne failed.&quot;)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">guard let thingTwo = thingTwo else &#123;</div><div class=\"line\">    throw Error(message: &quot;Unwrapping thingTwo failed.&quot;)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">guard let thingThree = thingThree else &#123;</div><div class=\"line\">    throw Error(message: &quot;Unwrapping thingThree failed.&quot;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>3.11.7</strong> 不要将<code>guard</code>表达式强行缩写到一行内。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">// PREFERRED</div><div class=\"line\">guard let thingOne = thingOne else &#123;</div><div class=\"line\">    return</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// NOT PREFERRED</div><div class=\"line\">guard let thingOne = thingOne else &#123; return &#125;</div></pre></td></tr></table></figure>\n<h2 id=\"4-Documentation-Comments\"><a href=\"#4-Documentation-Comments\" class=\"headerlink\" title=\"4. Documentation/Comments\"></a>4. Documentation/Comments</h2><h3 id=\"4-1-Documentation\"><a href=\"#4-1-Documentation\" class=\"headerlink\" title=\"4.1 Documentation\"></a><a href=\"https://github.com/wxyyxc1992/iOS-Boilerplate/blob/master/Doc/language/swift/advanced/bestpractices/styleguide/linkedin-swift-style-guide.md#41-documentation\"></a>4.1 Documentation</h3><p>如果某个函数不是简单地<code>O(1)</code>操作，那么最好就是为该函数添加一些注释文档，这样能有效地提高代码的可读性与可维护性。之前有个非常不错的文档工具<a href=\"https://github.com/onevcat/VVDocumenter-Xcode\">VVDocumenter</a>。推荐阅读Apple的官方指南中的描述：<a href=\"https://developer.apple.com/library/tvos/documentation/Xcode/Reference/xcode_markup_formatting_ref/Attention.html#//apple_ref/doc/uid/TP40016497-CH29-SW1\">described in Apple’s Documentation</a>.</p>\n<p>Guidelines:</p>\n<ul>\n<li><strong>4.1.1</strong> 每行不应超过160个字符</li>\n<li><strong>4.1.2</strong> 即使某些注释只有一行，也应该使用块注释符： (<code>/** */</code>).</li>\n<li><strong>4.1.3</strong> 不用给每行的开头都加上： <code>*</code>.</li>\n<li><strong>4.1.4</strong> 使用新的 <code>- parameter</code> 标识符来代替老的<code>:param:</code> syntax (注意这边是小写的 <code>parameter</code> 而不是<code>Parameter</code>).</li>\n<li><strong>4.1.5</strong> 如果你准备对参数/返回值/异常值来写注释，那么注意要一个不落的全局加上，尽管有时候会让文档显得重复冗余。有时候，如果只需要对单个参数进行注释，那么还不如直接放在描述里进行声明，而不需要专门的为参数写一个注释。</li>\n<li><strong>4.1.6</strong> 对于复杂的使用类，应该添加一些具体的使用用例来描述类的用法。注意Swift的注释文档中是支持MarkDown语法的，这是一个很好的特性。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> ## Feature Support</div><div class=\"line\"></div><div class=\"line\"> This class does some awesome things. It supports:</div><div class=\"line\"></div><div class=\"line\"> - Feature 1</div><div class=\"line\"> - Feature 2</div><div class=\"line\"> - Feature 3</div><div class=\"line\"></div><div class=\"line\"> ## Examples</div><div class=\"line\"></div><div class=\"line\"> Here is an example use case indented by four spaces because that indicates a</div><div class=\"line\"> code block:</div><div class=\"line\"></div><div class=\"line\">     let myAwesomeThing = MyAwesomeClass()</div><div class=\"line\">     myAwesomeThing.makeMoney()</div><div class=\"line\"></div><div class=\"line\"> ## Warnings:告警</div><div class=\"line\"></div><div class=\"line\"> There are some things you should be careful of:</div><div class=\"line\"></div><div class=\"line\"> 1. Thing one</div><div class=\"line\"> 2. Thing two</div><div class=\"line\"> 3. Thing three</div><div class=\"line\"> */</div><div class=\"line\">class MyAwesomeClass &#123;</div><div class=\"line\">    /* ... */</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>4.1.7</strong> 使用 - ` 在注释中著名引用的代码</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> This does something with a `UIViewController`, perchance.</div><div class=\"line\"> - warning: Make sure that `someValue` is `true` before running this function.</div><div class=\"line\"> */</div><div class=\"line\">func myFunction() &#123;</div><div class=\"line\">    /* ... */</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>4.1.8</strong> 保证文档的注释尽可能的简洁</li>\n</ul>\n<h3 id=\"4-2-Other-Commenting-Guidelines-其他的注释规则\"><a href=\"#4-2-Other-Commenting-Guidelines-其他的注释规则\" class=\"headerlink\" title=\"4.2 Other Commenting Guidelines:其他的注释规则\"></a>4.2 Other Commenting Guidelines:其他的注释规则</h3><ul>\n<li><strong>4.2.1</strong> <code>//</code>后面总是要跟上一个空格</li>\n<li><strong>4.2.2</strong> 注释永远要放在单独的行中</li>\n<li><strong>4.2.3</strong> 在使用<code>// MARK: - whatever</code>的时候，注意MARK与代码之间保留一个空行</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Pirate &#123;</div><div class=\"line\"></div><div class=\"line\">    // MARK: - instance properties</div><div class=\"line\"></div><div class=\"line\">    private let pirateName: String</div><div class=\"line\"></div><div class=\"line\">    // MARK: - initialization</div><div class=\"line\"></div><div class=\"line\">    init() &#123;</div><div class=\"line\">        /* ... */</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>原文链接:<a href=\"https://github.com/wxyyxc1992/iOS-Boilerplate/blob/master/Doc/language/swift/advanced/bestpractices/styleguide/linkedin-swift-style-guide.md#1-code-formatting\">github:Swift Style Guide</a></p>\n"},{"title":"比特币及区块链","id":"34","updated":"2016-09-10T03:46:54.000Z","date":"2016-09-09T03:13:43.000Z","_content":"\n\n\n\n\n---\n\n####[Bitcoin是什么](http://http://v.youku.com/v_show/id_XMjY4MTA3NDky.html)\n\n####[一分钟了解比特币](http://v.youku.com/v_show/id_XNjY1NTQzMDYw.html?beta&from=s1.8-1-1.2&spm=0.0.0.0.Xy0KUn)\n\n####[NHK纪录片《比特币最前线》中英字幕版](http://v.youku.com/v_show/id_XNzk0MzgwNTU2.html?beta&from=s1.8-1-1.2&spm=0.0.0.0.nfpGov)\n\n---\n\n####[Bitcoin是什么](http://v.youku.com/v_show/id_XMTYyNTc1OTAwNA==.html?beta&from=s1.8-1-1.2&spm=0.0.0.0.vDyGgJ)\n\n","source":"_posts/比特币及区块链.md","raw":"---\ntitle: 比特币及区块链\npermalink: bi-te-bi-ji-qu-kuai-lian\nid: 34\nupdated: '2016-09-10 11:46:54'\ndate: 2016-09-09 11:13:43\ntags:\n---\n\n\n\n\n\n---\n\n####[Bitcoin是什么](http://http://v.youku.com/v_show/id_XMjY4MTA3NDky.html)\n\n####[一分钟了解比特币](http://v.youku.com/v_show/id_XNjY1NTQzMDYw.html?beta&from=s1.8-1-1.2&spm=0.0.0.0.Xy0KUn)\n\n####[NHK纪录片《比特币最前线》中英字幕版](http://v.youku.com/v_show/id_XNzk0MzgwNTU2.html?beta&from=s1.8-1-1.2&spm=0.0.0.0.nfpGov)\n\n---\n\n####[Bitcoin是什么](http://v.youku.com/v_show/id_XMTYyNTc1OTAwNA==.html?beta&from=s1.8-1-1.2&spm=0.0.0.0.vDyGgJ)\n\n","slug":"bi-te-bi-ji-qu-kuai-lian","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cj04pzyys001ls04ed2mllrlj","content":"<hr>\n<p>####<a href=\"http://http://v.youku.com/v_show/id_XMjY4MTA3NDky.html\" target=\"_blank\" rel=\"external\">Bitcoin是什么</a></p>\n<p>####<a href=\"http://v.youku.com/v_show/id_XNjY1NTQzMDYw.html?beta&amp;from=s1.8-1-1.2&amp;spm=0.0.0.0.Xy0KUn\" target=\"_blank\" rel=\"external\">一分钟了解比特币</a></p>\n<p>####<a href=\"http://v.youku.com/v_show/id_XNzk0MzgwNTU2.html?beta&amp;from=s1.8-1-1.2&amp;spm=0.0.0.0.nfpGov\" target=\"_blank\" rel=\"external\">NHK纪录片《比特币最前线》中英字幕版</a></p>\n<hr>\n<p>####<a href=\"http://v.youku.com/v_show/id_XMTYyNTc1OTAwNA==.html?beta&amp;from=s1.8-1-1.2&amp;spm=0.0.0.0.vDyGgJ\" target=\"_blank\" rel=\"external\">Bitcoin是什么</a></p>\n","excerpt":"","more":"<hr>\n<p>####<a href=\"http://http://v.youku.com/v_show/id_XMjY4MTA3NDky.html\">Bitcoin是什么</a></p>\n<p>####<a href=\"http://v.youku.com/v_show/id_XNjY1NTQzMDYw.html?beta&amp;from=s1.8-1-1.2&amp;spm=0.0.0.0.Xy0KUn\">一分钟了解比特币</a></p>\n<p>####<a href=\"http://v.youku.com/v_show/id_XNzk0MzgwNTU2.html?beta&amp;from=s1.8-1-1.2&amp;spm=0.0.0.0.nfpGov\">NHK纪录片《比特币最前线》中英字幕版</a></p>\n<hr>\n<p>####<a href=\"http://v.youku.com/v_show/id_XMTYyNTc1OTAwNA==.html?beta&amp;from=s1.8-1-1.2&amp;spm=0.0.0.0.vDyGgJ\">Bitcoin是什么</a></p>\n"},{"title":"逆向工程 - Reveal、IDA、Hopper、https抓包","id":"16","updated":"2016-07-13T07:00:10.000Z","date":"2016-06-23T03:21:14.000Z","_content":"\n\n\n*iOS应用的安全性 常常被大家忽视*\n\n##**一、iOS 如何做才安全:**\n\n**详见《iOS如何做才安全》**\n\n \n\n##**二、ipa文件**\n\n1、AppStore里的ipa包 可以通过 iTunes 下载到电脑。iOS8.3以下系统的非越狱的手机上，可以用MAC上的PP助手等软件，直接把手机上的ipa文件(包含沙盒里的存储文件)拷贝到电脑。\n\n如果是越狱手机，都可以用PP助手、itools直接把ipa导出到电脑，并且可以用PP助手、iExplorer、itools这些工具 查看 iOS的系统目录。\n\n \n\nMAC上安装 iExplorer软件，用iExplorer 可以看到 手机（非越狱也可以） 在 iTunes上备份的内容。\n\n如果你在帮测试美女的手机 调试问题的时候， 在 iTunes上设置 “连接次iPhone时自动同步”(或者点击 备份到本地电脑),默认该手机上的照片、短信等内容都会备份到你的电脑上，用 iExplorer 就可以看到 这位 美女的隐私。\n\n曾经有次不小心看到同事的隐私信息，所以现在都比较注意这块，避免引发误会。\n\n \n\n2、拿到ipa文件后，解压缩，得到.app文件，右键显示包内容，可以看到里面的app中的图片、js、plist、静态H5页 等资源。\n\n比如 你要 用微信里的默认表情包，解压微信的ipa包就可以获取到。\n\n \n\n3、iOS的系统目录和MAC上的都类似（类unix系统）。iOS系统的目录图：\n\n ![img](http://images2015.cnblogs.com/blog/859442/201606/859442-20160603113527508-253137717.png)\n\n <!------MORE------->\n\n##**三、沙盒 中的数据**\n\niPhone上 计算器的沙盒：\n\n![img](http://images2015.cnblogs.com/blog/859442/201606/859442-20160602201509805-146936001.png)\n\n.app文件:应用程序本身的数据，打包时候的一些资源文件（如：图片、plist等文件）、可执行文件。这个目录不会被iTunes同步。\n\nDocuments ：存储不可再生 的关键数据。不会被iTunes同步\n\nLibrary：保存配置文件和其他一些文件。NSUserDefault 会存储到 Library下的Preferences中 的 plist文件中。可以直接打开，所以 也不要在 NSUserDefault 中存一些 关键数据，或者 存储的时候 进行 AES等方式的加密。\n\nLibrary/Caches可以用来保存可再生的数据，比如网络请求，用户需要负责删除对应文件。 \n\n这个目录（除了Library/Caches外）会被iTunes同步\n\ntmp：临时文件。不需要的时候，手动将其内文件删除。（当应用不再运行的时候，系统可能会将此目录清空。） \n\ntmp：临时文件。不需要的时候，手动将其内文件删除。（当应用不再运行的时候，系统可能会将此目录清空。） \n这个目录不会被iTunes同步\n\n存到沙盒的数据都是不安全的，关键数据一定 要做加密存储。\n\n \n\n##**四、Reveal 工具：查看 任何APP 的UI结构**\n\n1、不越狱的手机 可以用 Reveal 来查看自己APP的UI结构。不能查看其他APP的UI结构。这里就不再描述了。\n\n \n\n 2、越狱手机 上可以查看 任何APP的UI结构。\n\n在越狱的手机上，在 Cydia 搜索并安装 Reveal Loader，如果搜索不到。就 点下面的“软件源”，选择“BigBoss”,选择“全部软件包”，点右边R的字母，去一个个找到 Reveal Loader，放心吧，你一定能找到的，我用的iOS7.1的系统测试的，没问题。\n\n安装完成后，打开“设置”页面，下拉到最底部，点击“Reveal”\n\n![img](http://images2015.cnblogs.com/blog/859442/201606/859442-20160602192309977-1694804093.png)\n\n \n\n3、点击 Enabled Applictions 。然后选中 你想分析的APP。\n\n4、确保iOS和OSX在同一个IP网段内。打开想分析的 APP，如果该APP已经启动，则关闭后再次启动\n\n5、打开MAC上的 Reveal，选中 左上方列表里的 APP，**比如QQ：**\n\n![img](http://images2015.cnblogs.com/blog/859442/201606/859442-20160602193213742-452768022.png)\n\n \n\n6、如果 Reveal 左上方 一直显示：No Connection。说明iPhone上的 Reveal Loader 没安装成功，需要配置一下。\n\n首先从MAC上 用PP助手或 iTools 查看“文件系统（系统）”--》Library文件夹，看 Library文件夹下面有没有 RHRevealLoader 文件夹，如果没有，就 右键 新建文件夹，并修改名字为：RHRevealLoader。\n\n在Mac 下打开已经安装的Reveal，选择标题栏**Help**下的**Show Reveal Library in Finder  下的 iOS library  **选项，将会显示如下界面：\n\n![img](http://images2015.cnblogs.com/blog/859442/201606/859442-20160602194122961-7619153.png)\n\n将**libReveal.dylib **文件通过**PP助手**拷贝到刚才创建的`RHRevealLoader`文件夹下，就可以了。\n\n \n\n然后 从手机上打开APP， 再 打开 MAC上的 Reveal 软件，左上方 就会出来 相关APP的选项。\n\n再发个 **淘宝中的天猫模块**吧：\n\n![img](http://images2015.cnblogs.com/blog/859442/201606/859442-20160602195031367-1190080065.png) \n\n \n\n##**五、反编译工具：IDA**\n\n从AppStore下载的ipa都是加壳的(苹果 把开发者上传的ipa进行了加壳再放到AppStore中)，加壳的ipa要先去壳，可以用clutch、dumpdecrypted、使用gdb调试 等解密去壳工具，这个我们后面再说。\n\n如果你有越狱手机，可以直接 从 PP助手上下载ipa包，这个就是 脱壳后的。。\n\n现在 我们先反编译 自己的APP，通过Xcode打包的APP 都是没加壳的，可以直接用来反编译。\n\n \n\n新建一个项目，在 ViewController 的 viewDidLoad 方法里 加 几句代码。\n\n[![复制代码](http://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)\n\n```\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    UILabel *label = [[UILabel alloc] initWithFrame:CGRectMake(50, 70, 200, 100)];\n    label.text = @\"CeShiLabel007\";\n    label.backgroundColor = [UIColor redColor];\n    [self.view addSubview:label];\n}\n```\n\n[![复制代码](http://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)\n\n将项目 打包，生成 ipa文件，下面我们就用IDA分析一下 ipa。\n\n将ipa文件 解压后 得到.app文件：\n\n![img](http://images2015.cnblogs.com/blog/859442/201606/859442-20160602200635492-1438112164.png)\n\n \n\n下载IDA，并打开：\n\n![img](http://images2015.cnblogs.com/blog/859442/201606/859442-20160602200012914-225461018.png)\n\n点击“New”按钮，选择刚才 解压的 .app文件。一路 点击“OK”或者“YES” 就可以了。\n\n打开界面后，双击左侧的 viewDidLoad：\n\n![img](http://images2015.cnblogs.com/blog/859442/201606/859442-20160602201058242-1824337591.png)\n\n可以看出：代码中的  \"CeShiLabel007\" 字符串 完全可以反编译出来。所以尽量不要在代码里放一些 关键 的数据。可以通过接口来获取。或者 把 数据进行加密。\n\n从上面的界面中 ，按下键盘的F5，可以 把汇编转成C语言代码。可读性很高。。\n\n你如果试了 就发现你的F5不管用啊，那是因为 F5是一个插件Hex-Rays.Decompiler 的快捷键，这个插件是收费的、收费的。\n\n \n\n##**六、反编译工具：Hopper Disassembler**\n\n下载 Hopper Disassembler软件。打开ipa解压的.app。 或者直接 把.app拖进去。\n\n双击“viewDidLoad”： 可以看到 汇编代码， \"CeShiLabel007\" 字符串、setText方法 等。\n\n \n\n![img](http://images2015.cnblogs.com/blog/859442/201606/859442-20160602204404555-1739403755.png)\n\n点击右上角的 if(a) f(x)图标：\n\n![img](http://images2015.cnblogs.com/blog/859442/201606/859442-20160602204528664-464088547.png)\n\n会弹出 类似源代码的 伪编码：\n\n \n\n![img](http://images2015.cnblogs.com/blog/859442/201606/859442-20160602204639992-255404740.png)\n\n \n\n代码中可以清楚的看到 处理的逻辑。简单易懂，和看源代码没太大区别。。\n\n下面 是我从越狱手机的PP助手上下载的 微信 的ipa  进行反编译,看下里面的 QQContactInfoViewController 页面 的 viewDidLoad方法里的代码 怎么写的，\n\n截图：\n\n![img](http://images2015.cnblogs.com/blog/859442/201606/859442-20160603132557742-293853908.png)\n\n \n\n如果 你把从 AppStore下载的 ipa包直接拖到 IDA或Hopper里，看到的就是乱码，刚才已经说过了。AppStore的ipa是加过壳的 。如图：\n\n ![img](http://images2015.cnblogs.com/blog/859442/201606/859442-20160603131037805-1919649565.png)\n\n \n\n##**七、抓包-https**\n\nCharles 老版本和 新版本 抓取https 的配置 不一样。。\n\n先看HTTP抓包：\n\n1. 打开Charles程序\n2. 查看Mac电脑的IP地址，如192.168.1.7\n3. 打开iOS设置，进入当前wifi连接，设置HTTP代理Group，将服务器填为上一步中获得的IP，即192.168.1.7，端口填8888\n4. iOS设备打开你要抓包的app进行网络操作\n5. Charles弹出确认框，点击Allow按钮即可\n\nHTTPS 老版本抓包：\n\n1. 下载Charles证书http://www.charlesproxy.com/ssl.zip，解压后导入到iOS设备中（将crt文件作为邮件附件发给自己，再在iOS设备中点击附件即可安装；也可上传至dropbox之类的网盘，通过safari下载安装）\n2. 在Charles的工具栏上点击设置按钮，选择Proxy Settings…\n3. 切换到SSL选项卡，选中Enable SSL Proxying\n4. 这一步跟Fiddler不同，Fiddler安装证书后就可以抓HTTPS网址的包了，Charles 还 需要在上一步的SSL选项卡的Locations表单填写要抓包的域名和端口，点击Add按钮，在弹出的表单中Host填写域名，比如填api.instagram.com，Port填443\n\nHTTPS 新版本抓包：\n\n　　Charles新版本 的 Proxy Settings 选项里是没有 SSL选项卡的。在左侧的域名上点右键：Enable SSL Proxying，就可以用了。\n\n![img](http://images2015.cnblogs.com/blog/859442/201606/859442-20160603130151602-184733403.png)\n\n \n\n然后 点击APP，会看到HTTPS解密的json数据。如果接口返回的数据 本身进行了加密，那你看到的还是乱码。\n\n \n\n##**七、https - iOS 的代码如何写**\n\n2015年4月末，网爆流行IOS网络通信库`AFNetworking SSL`漏洞，影响银联、中国银行、交通银行在内的2.5万个IOS应用，我来看下 各种网络写法对应的问题。\n\n1、信任任何证书。在 AFNetworking 中 定义 allowInvalidCertificates 为true，表示 忽略所有证书。\n\n```\nAFHTTPRequestOperationManager * manager = [AFHTTPRequestOperationManager manager];\n\nmanager.securityPolicy.allowInvalidCertificates = YES;\n```\n\n \n\n这种情况下 用我们上面讲的方法，用Charles很容易 破解HTTPS加密的数据。\n\n这种情况，一般是 因为 测试环境 用的不是 CA发的证书，需要忽略掉证书，所以把 allowInvalidCertificates 设为了 true。这个可以用 #ifdef DEBUG 来进行设置。\n\n```\n    #ifdef DEBUG\n    manager.securityPolicy.allowInvalidCertificates = YES;\n    #endif\n```\n\n \n\n2、信任证书管理机构（CA）颁发的证书。\n\nCA颁发的证书，据说这类的证书只需50美元就能买到。此类问题出在`AFNetworking 2.5.2`及之前的版本，是AF的漏洞（[详见新闻](http://www.freebuf.com/news/65744.html)）。如果某IOS APP使用了此版本的开源通信库，在不安全Wifi网络中的，黑客 只要使用CA颁发的证书就可以对该APP的HTTPS加密数据进行监听或者篡改。\n\n这个需要升级到 AFNetworking 最新版本，正好最新版本也声明兼容IPv6。\n\n \n\n3、信任合法的证书、服务器和客户端双向认证。\n\n这两种也都有办法破解，详见：[Bypassing OpenSSL Certificate Pinning in iOS Apps](https://www.nccgroup.trust/us/about-us/newsroom-and-events/blog/2015/january/bypassing-openssl-certificate-pinning-in-ios-apps/)、[http://drops.wooyun.org/tips/7838](http://drops.wooyun.org/tips/7838)\n\n \n\n要正确的使用HTTPS才不会出现上面的问题。接口也一定要用自己的方式进行加密 才真正的放心，把小命完全放到对方(HTTPS)手里，命运就只能靠别人来摆布。。\n\n","source":"_posts/逆向工程-Reveal、IDA、Hopper、https抓包.md","raw":"---\ntitle: 逆向工程 - Reveal、IDA、Hopper、https抓包\ntags: [iOS, 转载]\npermalink: ni-xiang-gong-cheng-reveal-ida-hopper-httpszhua-bao\nid: 16\nupdated: '2016-07-13 15:00:10'\ndate: 2016-06-23 11:21:14\n---\n\n\n\n*iOS应用的安全性 常常被大家忽视*\n\n##**一、iOS 如何做才安全:**\n\n**详见《iOS如何做才安全》**\n\n \n\n##**二、ipa文件**\n\n1、AppStore里的ipa包 可以通过 iTunes 下载到电脑。iOS8.3以下系统的非越狱的手机上，可以用MAC上的PP助手等软件，直接把手机上的ipa文件(包含沙盒里的存储文件)拷贝到电脑。\n\n如果是越狱手机，都可以用PP助手、itools直接把ipa导出到电脑，并且可以用PP助手、iExplorer、itools这些工具 查看 iOS的系统目录。\n\n \n\nMAC上安装 iExplorer软件，用iExplorer 可以看到 手机（非越狱也可以） 在 iTunes上备份的内容。\n\n如果你在帮测试美女的手机 调试问题的时候， 在 iTunes上设置 “连接次iPhone时自动同步”(或者点击 备份到本地电脑),默认该手机上的照片、短信等内容都会备份到你的电脑上，用 iExplorer 就可以看到 这位 美女的隐私。\n\n曾经有次不小心看到同事的隐私信息，所以现在都比较注意这块，避免引发误会。\n\n \n\n2、拿到ipa文件后，解压缩，得到.app文件，右键显示包内容，可以看到里面的app中的图片、js、plist、静态H5页 等资源。\n\n比如 你要 用微信里的默认表情包，解压微信的ipa包就可以获取到。\n\n \n\n3、iOS的系统目录和MAC上的都类似（类unix系统）。iOS系统的目录图：\n\n ![img](http://images2015.cnblogs.com/blog/859442/201606/859442-20160603113527508-253137717.png)\n\n <!------MORE------->\n\n##**三、沙盒 中的数据**\n\niPhone上 计算器的沙盒：\n\n![img](http://images2015.cnblogs.com/blog/859442/201606/859442-20160602201509805-146936001.png)\n\n.app文件:应用程序本身的数据，打包时候的一些资源文件（如：图片、plist等文件）、可执行文件。这个目录不会被iTunes同步。\n\nDocuments ：存储不可再生 的关键数据。不会被iTunes同步\n\nLibrary：保存配置文件和其他一些文件。NSUserDefault 会存储到 Library下的Preferences中 的 plist文件中。可以直接打开，所以 也不要在 NSUserDefault 中存一些 关键数据，或者 存储的时候 进行 AES等方式的加密。\n\nLibrary/Caches可以用来保存可再生的数据，比如网络请求，用户需要负责删除对应文件。 \n\n这个目录（除了Library/Caches外）会被iTunes同步\n\ntmp：临时文件。不需要的时候，手动将其内文件删除。（当应用不再运行的时候，系统可能会将此目录清空。） \n\ntmp：临时文件。不需要的时候，手动将其内文件删除。（当应用不再运行的时候，系统可能会将此目录清空。） \n这个目录不会被iTunes同步\n\n存到沙盒的数据都是不安全的，关键数据一定 要做加密存储。\n\n \n\n##**四、Reveal 工具：查看 任何APP 的UI结构**\n\n1、不越狱的手机 可以用 Reveal 来查看自己APP的UI结构。不能查看其他APP的UI结构。这里就不再描述了。\n\n \n\n 2、越狱手机 上可以查看 任何APP的UI结构。\n\n在越狱的手机上，在 Cydia 搜索并安装 Reveal Loader，如果搜索不到。就 点下面的“软件源”，选择“BigBoss”,选择“全部软件包”，点右边R的字母，去一个个找到 Reveal Loader，放心吧，你一定能找到的，我用的iOS7.1的系统测试的，没问题。\n\n安装完成后，打开“设置”页面，下拉到最底部，点击“Reveal”\n\n![img](http://images2015.cnblogs.com/blog/859442/201606/859442-20160602192309977-1694804093.png)\n\n \n\n3、点击 Enabled Applictions 。然后选中 你想分析的APP。\n\n4、确保iOS和OSX在同一个IP网段内。打开想分析的 APP，如果该APP已经启动，则关闭后再次启动\n\n5、打开MAC上的 Reveal，选中 左上方列表里的 APP，**比如QQ：**\n\n![img](http://images2015.cnblogs.com/blog/859442/201606/859442-20160602193213742-452768022.png)\n\n \n\n6、如果 Reveal 左上方 一直显示：No Connection。说明iPhone上的 Reveal Loader 没安装成功，需要配置一下。\n\n首先从MAC上 用PP助手或 iTools 查看“文件系统（系统）”--》Library文件夹，看 Library文件夹下面有没有 RHRevealLoader 文件夹，如果没有，就 右键 新建文件夹，并修改名字为：RHRevealLoader。\n\n在Mac 下打开已经安装的Reveal，选择标题栏**Help**下的**Show Reveal Library in Finder  下的 iOS library  **选项，将会显示如下界面：\n\n![img](http://images2015.cnblogs.com/blog/859442/201606/859442-20160602194122961-7619153.png)\n\n将**libReveal.dylib **文件通过**PP助手**拷贝到刚才创建的`RHRevealLoader`文件夹下，就可以了。\n\n \n\n然后 从手机上打开APP， 再 打开 MAC上的 Reveal 软件，左上方 就会出来 相关APP的选项。\n\n再发个 **淘宝中的天猫模块**吧：\n\n![img](http://images2015.cnblogs.com/blog/859442/201606/859442-20160602195031367-1190080065.png) \n\n \n\n##**五、反编译工具：IDA**\n\n从AppStore下载的ipa都是加壳的(苹果 把开发者上传的ipa进行了加壳再放到AppStore中)，加壳的ipa要先去壳，可以用clutch、dumpdecrypted、使用gdb调试 等解密去壳工具，这个我们后面再说。\n\n如果你有越狱手机，可以直接 从 PP助手上下载ipa包，这个就是 脱壳后的。。\n\n现在 我们先反编译 自己的APP，通过Xcode打包的APP 都是没加壳的，可以直接用来反编译。\n\n \n\n新建一个项目，在 ViewController 的 viewDidLoad 方法里 加 几句代码。\n\n[![复制代码](http://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)\n\n```\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    UILabel *label = [[UILabel alloc] initWithFrame:CGRectMake(50, 70, 200, 100)];\n    label.text = @\"CeShiLabel007\";\n    label.backgroundColor = [UIColor redColor];\n    [self.view addSubview:label];\n}\n```\n\n[![复制代码](http://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)\n\n将项目 打包，生成 ipa文件，下面我们就用IDA分析一下 ipa。\n\n将ipa文件 解压后 得到.app文件：\n\n![img](http://images2015.cnblogs.com/blog/859442/201606/859442-20160602200635492-1438112164.png)\n\n \n\n下载IDA，并打开：\n\n![img](http://images2015.cnblogs.com/blog/859442/201606/859442-20160602200012914-225461018.png)\n\n点击“New”按钮，选择刚才 解压的 .app文件。一路 点击“OK”或者“YES” 就可以了。\n\n打开界面后，双击左侧的 viewDidLoad：\n\n![img](http://images2015.cnblogs.com/blog/859442/201606/859442-20160602201058242-1824337591.png)\n\n可以看出：代码中的  \"CeShiLabel007\" 字符串 完全可以反编译出来。所以尽量不要在代码里放一些 关键 的数据。可以通过接口来获取。或者 把 数据进行加密。\n\n从上面的界面中 ，按下键盘的F5，可以 把汇编转成C语言代码。可读性很高。。\n\n你如果试了 就发现你的F5不管用啊，那是因为 F5是一个插件Hex-Rays.Decompiler 的快捷键，这个插件是收费的、收费的。\n\n \n\n##**六、反编译工具：Hopper Disassembler**\n\n下载 Hopper Disassembler软件。打开ipa解压的.app。 或者直接 把.app拖进去。\n\n双击“viewDidLoad”： 可以看到 汇编代码， \"CeShiLabel007\" 字符串、setText方法 等。\n\n \n\n![img](http://images2015.cnblogs.com/blog/859442/201606/859442-20160602204404555-1739403755.png)\n\n点击右上角的 if(a) f(x)图标：\n\n![img](http://images2015.cnblogs.com/blog/859442/201606/859442-20160602204528664-464088547.png)\n\n会弹出 类似源代码的 伪编码：\n\n \n\n![img](http://images2015.cnblogs.com/blog/859442/201606/859442-20160602204639992-255404740.png)\n\n \n\n代码中可以清楚的看到 处理的逻辑。简单易懂，和看源代码没太大区别。。\n\n下面 是我从越狱手机的PP助手上下载的 微信 的ipa  进行反编译,看下里面的 QQContactInfoViewController 页面 的 viewDidLoad方法里的代码 怎么写的，\n\n截图：\n\n![img](http://images2015.cnblogs.com/blog/859442/201606/859442-20160603132557742-293853908.png)\n\n \n\n如果 你把从 AppStore下载的 ipa包直接拖到 IDA或Hopper里，看到的就是乱码，刚才已经说过了。AppStore的ipa是加过壳的 。如图：\n\n ![img](http://images2015.cnblogs.com/blog/859442/201606/859442-20160603131037805-1919649565.png)\n\n \n\n##**七、抓包-https**\n\nCharles 老版本和 新版本 抓取https 的配置 不一样。。\n\n先看HTTP抓包：\n\n1. 打开Charles程序\n2. 查看Mac电脑的IP地址，如192.168.1.7\n3. 打开iOS设置，进入当前wifi连接，设置HTTP代理Group，将服务器填为上一步中获得的IP，即192.168.1.7，端口填8888\n4. iOS设备打开你要抓包的app进行网络操作\n5. Charles弹出确认框，点击Allow按钮即可\n\nHTTPS 老版本抓包：\n\n1. 下载Charles证书http://www.charlesproxy.com/ssl.zip，解压后导入到iOS设备中（将crt文件作为邮件附件发给自己，再在iOS设备中点击附件即可安装；也可上传至dropbox之类的网盘，通过safari下载安装）\n2. 在Charles的工具栏上点击设置按钮，选择Proxy Settings…\n3. 切换到SSL选项卡，选中Enable SSL Proxying\n4. 这一步跟Fiddler不同，Fiddler安装证书后就可以抓HTTPS网址的包了，Charles 还 需要在上一步的SSL选项卡的Locations表单填写要抓包的域名和端口，点击Add按钮，在弹出的表单中Host填写域名，比如填api.instagram.com，Port填443\n\nHTTPS 新版本抓包：\n\n　　Charles新版本 的 Proxy Settings 选项里是没有 SSL选项卡的。在左侧的域名上点右键：Enable SSL Proxying，就可以用了。\n\n![img](http://images2015.cnblogs.com/blog/859442/201606/859442-20160603130151602-184733403.png)\n\n \n\n然后 点击APP，会看到HTTPS解密的json数据。如果接口返回的数据 本身进行了加密，那你看到的还是乱码。\n\n \n\n##**七、https - iOS 的代码如何写**\n\n2015年4月末，网爆流行IOS网络通信库`AFNetworking SSL`漏洞，影响银联、中国银行、交通银行在内的2.5万个IOS应用，我来看下 各种网络写法对应的问题。\n\n1、信任任何证书。在 AFNetworking 中 定义 allowInvalidCertificates 为true，表示 忽略所有证书。\n\n```\nAFHTTPRequestOperationManager * manager = [AFHTTPRequestOperationManager manager];\n\nmanager.securityPolicy.allowInvalidCertificates = YES;\n```\n\n \n\n这种情况下 用我们上面讲的方法，用Charles很容易 破解HTTPS加密的数据。\n\n这种情况，一般是 因为 测试环境 用的不是 CA发的证书，需要忽略掉证书，所以把 allowInvalidCertificates 设为了 true。这个可以用 #ifdef DEBUG 来进行设置。\n\n```\n    #ifdef DEBUG\n    manager.securityPolicy.allowInvalidCertificates = YES;\n    #endif\n```\n\n \n\n2、信任证书管理机构（CA）颁发的证书。\n\nCA颁发的证书，据说这类的证书只需50美元就能买到。此类问题出在`AFNetworking 2.5.2`及之前的版本，是AF的漏洞（[详见新闻](http://www.freebuf.com/news/65744.html)）。如果某IOS APP使用了此版本的开源通信库，在不安全Wifi网络中的，黑客 只要使用CA颁发的证书就可以对该APP的HTTPS加密数据进行监听或者篡改。\n\n这个需要升级到 AFNetworking 最新版本，正好最新版本也声明兼容IPv6。\n\n \n\n3、信任合法的证书、服务器和客户端双向认证。\n\n这两种也都有办法破解，详见：[Bypassing OpenSSL Certificate Pinning in iOS Apps](https://www.nccgroup.trust/us/about-us/newsroom-and-events/blog/2015/january/bypassing-openssl-certificate-pinning-in-ios-apps/)、[http://drops.wooyun.org/tips/7838](http://drops.wooyun.org/tips/7838)\n\n \n\n要正确的使用HTTPS才不会出现上面的问题。接口也一定要用自己的方式进行加密 才真正的放心，把小命完全放到对方(HTTPS)手里，命运就只能靠别人来摆布。。\n\n","slug":"ni-xiang-gong-cheng-reveal-ida-hopper-httpszhua-bao","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cj04pzyz0001ns04evct1fij4","content":"<p><em>iOS应用的安全性 常常被大家忽视</em></p>\n<p>##<strong>一、iOS 如何做才安全:</strong></p>\n<p><strong>详见《iOS如何做才安全》</strong></p>\n<p>##<strong>二、ipa文件</strong></p>\n<p>1、AppStore里的ipa包 可以通过 iTunes 下载到电脑。iOS8.3以下系统的非越狱的手机上，可以用MAC上的PP助手等软件，直接把手机上的ipa文件(包含沙盒里的存储文件)拷贝到电脑。</p>\n<p>如果是越狱手机，都可以用PP助手、itools直接把ipa导出到电脑，并且可以用PP助手、iExplorer、itools这些工具 查看 iOS的系统目录。</p>\n<p>MAC上安装 iExplorer软件，用iExplorer 可以看到 手机（非越狱也可以） 在 iTunes上备份的内容。</p>\n<p>如果你在帮测试美女的手机 调试问题的时候， 在 iTunes上设置 “连接次iPhone时自动同步”(或者点击 备份到本地电脑),默认该手机上的照片、短信等内容都会备份到你的电脑上，用 iExplorer 就可以看到 这位 美女的隐私。</p>\n<p>曾经有次不小心看到同事的隐私信息，所以现在都比较注意这块，避免引发误会。</p>\n<p>2、拿到ipa文件后，解压缩，得到.app文件，右键显示包内容，可以看到里面的app中的图片、js、plist、静态H5页 等资源。</p>\n<p>比如 你要 用微信里的默认表情包，解压微信的ipa包就可以获取到。</p>\n<p>3、iOS的系统目录和MAC上的都类似（类unix系统）。iOS系统的目录图：</p>\n<p> <img src=\"http://images2015.cnblogs.com/blog/859442/201606/859442-20160603113527508-253137717.png\" alt=\"img\"></p>\n <a id=\"more\"></a>\n<p>##<strong>三、沙盒 中的数据</strong></p>\n<p>iPhone上 计算器的沙盒：</p>\n<p><img src=\"http://images2015.cnblogs.com/blog/859442/201606/859442-20160602201509805-146936001.png\" alt=\"img\"></p>\n<p>.app文件:应用程序本身的数据，打包时候的一些资源文件（如：图片、plist等文件）、可执行文件。这个目录不会被iTunes同步。</p>\n<p>Documents ：存储不可再生 的关键数据。不会被iTunes同步</p>\n<p>Library：保存配置文件和其他一些文件。NSUserDefault 会存储到 Library下的Preferences中 的 plist文件中。可以直接打开，所以 也不要在 NSUserDefault 中存一些 关键数据，或者 存储的时候 进行 AES等方式的加密。</p>\n<p>Library/Caches可以用来保存可再生的数据，比如网络请求，用户需要负责删除对应文件。 </p>\n<p>这个目录（除了Library/Caches外）会被iTunes同步</p>\n<p>tmp：临时文件。不需要的时候，手动将其内文件删除。（当应用不再运行的时候，系统可能会将此目录清空。） </p>\n<p>tmp：临时文件。不需要的时候，手动将其内文件删除。（当应用不再运行的时候，系统可能会将此目录清空。）<br>这个目录不会被iTunes同步</p>\n<p>存到沙盒的数据都是不安全的，关键数据一定 要做加密存储。</p>\n<p>##<strong>四、Reveal 工具：查看 任何APP 的UI结构</strong></p>\n<p>1、不越狱的手机 可以用 Reveal 来查看自己APP的UI结构。不能查看其他APP的UI结构。这里就不再描述了。</p>\n<p> 2、越狱手机 上可以查看 任何APP的UI结构。</p>\n<p>在越狱的手机上，在 Cydia 搜索并安装 Reveal Loader，如果搜索不到。就 点下面的“软件源”，选择“BigBoss”,选择“全部软件包”，点右边R的字母，去一个个找到 Reveal Loader，放心吧，你一定能找到的，我用的iOS7.1的系统测试的，没问题。</p>\n<p>安装完成后，打开“设置”页面，下拉到最底部，点击“Reveal”</p>\n<p><img src=\"http://images2015.cnblogs.com/blog/859442/201606/859442-20160602192309977-1694804093.png\" alt=\"img\"></p>\n<p>3、点击 Enabled Applictions 。然后选中 你想分析的APP。</p>\n<p>4、确保iOS和OSX在同一个IP网段内。打开想分析的 APP，如果该APP已经启动，则关闭后再次启动</p>\n<p>5、打开MAC上的 Reveal，选中 左上方列表里的 APP，<strong>比如QQ：</strong></p>\n<p><img src=\"http://images2015.cnblogs.com/blog/859442/201606/859442-20160602193213742-452768022.png\" alt=\"img\"></p>\n<p>6、如果 Reveal 左上方 一直显示：No Connection。说明iPhone上的 Reveal Loader 没安装成功，需要配置一下。</p>\n<p>首先从MAC上 用PP助手或 iTools 查看“文件系统（系统）”–》Library文件夹，看 Library文件夹下面有没有 RHRevealLoader 文件夹，如果没有，就 右键 新建文件夹，并修改名字为：RHRevealLoader。</p>\n<p>在Mac 下打开已经安装的Reveal，选择标题栏<strong>Help</strong>下的<strong>Show Reveal Library in Finder  下的 iOS library  </strong>选项，将会显示如下界面：</p>\n<p><img src=\"http://images2015.cnblogs.com/blog/859442/201606/859442-20160602194122961-7619153.png\" alt=\"img\"></p>\n<p>将<strong>libReveal.dylib </strong>文件通过<strong>PP助手</strong>拷贝到刚才创建的<code>RHRevealLoader</code>文件夹下，就可以了。</p>\n<p>然后 从手机上打开APP， 再 打开 MAC上的 Reveal 软件，左上方 就会出来 相关APP的选项。</p>\n<p>再发个 <strong>淘宝中的天猫模块</strong>吧：</p>\n<p><img src=\"http://images2015.cnblogs.com/blog/859442/201606/859442-20160602195031367-1190080065.png\" alt=\"img\"> </p>\n<p>##<strong>五、反编译工具：IDA</strong></p>\n<p>从AppStore下载的ipa都是加壳的(苹果 把开发者上传的ipa进行了加壳再放到AppStore中)，加壳的ipa要先去壳，可以用clutch、dumpdecrypted、使用gdb调试 等解密去壳工具，这个我们后面再说。</p>\n<p>如果你有越狱手机，可以直接 从 PP助手上下载ipa包，这个就是 脱壳后的。。</p>\n<p>现在 我们先反编译 自己的APP，通过Xcode打包的APP 都是没加壳的，可以直接用来反编译。</p>\n<p>新建一个项目，在 ViewController 的 viewDidLoad 方法里 加 几句代码。</p>\n<p><a href=\"javascript:void(0\" target=\"_blank\" rel=\"external\"><img src=\"http://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a>;)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)viewDidLoad &#123;</div><div class=\"line\">    [super viewDidLoad];</div><div class=\"line\">    </div><div class=\"line\">    UILabel *label = [[UILabel alloc] initWithFrame:CGRectMake(50, 70, 200, 100)];</div><div class=\"line\">    label.text = @&quot;CeShiLabel007&quot;;</div><div class=\"line\">    label.backgroundColor = [UIColor redColor];</div><div class=\"line\">    [self.view addSubview:label];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><a href=\"javascript:void(0\" target=\"_blank\" rel=\"external\"><img src=\"http://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a>;)</p>\n<p>将项目 打包，生成 ipa文件，下面我们就用IDA分析一下 ipa。</p>\n<p>将ipa文件 解压后 得到.app文件：</p>\n<p><img src=\"http://images2015.cnblogs.com/blog/859442/201606/859442-20160602200635492-1438112164.png\" alt=\"img\"></p>\n<p>下载IDA，并打开：</p>\n<p><img src=\"http://images2015.cnblogs.com/blog/859442/201606/859442-20160602200012914-225461018.png\" alt=\"img\"></p>\n<p>点击“New”按钮，选择刚才 解压的 .app文件。一路 点击“OK”或者“YES” 就可以了。</p>\n<p>打开界面后，双击左侧的 viewDidLoad：</p>\n<p><img src=\"http://images2015.cnblogs.com/blog/859442/201606/859442-20160602201058242-1824337591.png\" alt=\"img\"></p>\n<p>可以看出：代码中的  “CeShiLabel007” 字符串 完全可以反编译出来。所以尽量不要在代码里放一些 关键 的数据。可以通过接口来获取。或者 把 数据进行加密。</p>\n<p>从上面的界面中 ，按下键盘的F5，可以 把汇编转成C语言代码。可读性很高。。</p>\n<p>你如果试了 就发现你的F5不管用啊，那是因为 F5是一个插件Hex-Rays.Decompiler 的快捷键，这个插件是收费的、收费的。</p>\n<p>##<strong>六、反编译工具：Hopper Disassembler</strong></p>\n<p>下载 Hopper Disassembler软件。打开ipa解压的.app。 或者直接 把.app拖进去。</p>\n<p>双击“viewDidLoad”： 可以看到 汇编代码， “CeShiLabel007” 字符串、setText方法 等。</p>\n<p><img src=\"http://images2015.cnblogs.com/blog/859442/201606/859442-20160602204404555-1739403755.png\" alt=\"img\"></p>\n<p>点击右上角的 if(a) f(x)图标：</p>\n<p><img src=\"http://images2015.cnblogs.com/blog/859442/201606/859442-20160602204528664-464088547.png\" alt=\"img\"></p>\n<p>会弹出 类似源代码的 伪编码：</p>\n<p><img src=\"http://images2015.cnblogs.com/blog/859442/201606/859442-20160602204639992-255404740.png\" alt=\"img\"></p>\n<p>代码中可以清楚的看到 处理的逻辑。简单易懂，和看源代码没太大区别。。</p>\n<p>下面 是我从越狱手机的PP助手上下载的 微信 的ipa  进行反编译,看下里面的 QQContactInfoViewController 页面 的 viewDidLoad方法里的代码 怎么写的，</p>\n<p>截图：</p>\n<p><img src=\"http://images2015.cnblogs.com/blog/859442/201606/859442-20160603132557742-293853908.png\" alt=\"img\"></p>\n<p>如果 你把从 AppStore下载的 ipa包直接拖到 IDA或Hopper里，看到的就是乱码，刚才已经说过了。AppStore的ipa是加过壳的 。如图：</p>\n<p> <img src=\"http://images2015.cnblogs.com/blog/859442/201606/859442-20160603131037805-1919649565.png\" alt=\"img\"></p>\n<p>##<strong>七、抓包-https</strong></p>\n<p>Charles 老版本和 新版本 抓取https 的配置 不一样。。</p>\n<p>先看HTTP抓包：</p>\n<ol>\n<li>打开Charles程序</li>\n<li>查看Mac电脑的IP地址，如192.168.1.7</li>\n<li>打开iOS设置，进入当前wifi连接，设置HTTP代理Group，将服务器填为上一步中获得的IP，即192.168.1.7，端口填8888</li>\n<li>iOS设备打开你要抓包的app进行网络操作</li>\n<li>Charles弹出确认框，点击Allow按钮即可</li>\n</ol>\n<p>HTTPS 老版本抓包：</p>\n<ol>\n<li>下载Charles证书<a href=\"http://www.charlesproxy.com/ssl.zip，解压后导入到iOS设备中（将crt文件作为邮件附件发给自己，再在iOS设备中点击附件即可安装；也可上传至dropbox之类的网盘，通过safari下载安装）\" target=\"_blank\" rel=\"external\">http://www.charlesproxy.com/ssl.zip，解压后导入到iOS设备中（将crt文件作为邮件附件发给自己，再在iOS设备中点击附件即可安装；也可上传至dropbox之类的网盘，通过safari下载安装）</a></li>\n<li>在Charles的工具栏上点击设置按钮，选择Proxy Settings…</li>\n<li>切换到SSL选项卡，选中Enable SSL Proxying</li>\n<li>这一步跟Fiddler不同，Fiddler安装证书后就可以抓HTTPS网址的包了，Charles 还 需要在上一步的SSL选项卡的Locations表单填写要抓包的域名和端口，点击Add按钮，在弹出的表单中Host填写域名，比如填api.instagram.com，Port填443</li>\n</ol>\n<p>HTTPS 新版本抓包：</p>\n<p>　　Charles新版本 的 Proxy Settings 选项里是没有 SSL选项卡的。在左侧的域名上点右键：Enable SSL Proxying，就可以用了。</p>\n<p><img src=\"http://images2015.cnblogs.com/blog/859442/201606/859442-20160603130151602-184733403.png\" alt=\"img\"></p>\n<p>然后 点击APP，会看到HTTPS解密的json数据。如果接口返回的数据 本身进行了加密，那你看到的还是乱码。</p>\n<p>##<strong>七、https - iOS 的代码如何写</strong></p>\n<p>2015年4月末，网爆流行IOS网络通信库<code>AFNetworking SSL</code>漏洞，影响银联、中国银行、交通银行在内的2.5万个IOS应用，我来看下 各种网络写法对应的问题。</p>\n<p>1、信任任何证书。在 AFNetworking 中 定义 allowInvalidCertificates 为true，表示 忽略所有证书。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">AFHTTPRequestOperationManager * manager = [AFHTTPRequestOperationManager manager];</div><div class=\"line\"></div><div class=\"line\">manager.securityPolicy.allowInvalidCertificates = YES;</div></pre></td></tr></table></figure>\n<p>这种情况下 用我们上面讲的方法，用Charles很容易 破解HTTPS加密的数据。</p>\n<p>这种情况，一般是 因为 测试环境 用的不是 CA发的证书，需要忽略掉证书，所以把 allowInvalidCertificates 设为了 true。这个可以用 #ifdef DEBUG 来进行设置。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">#ifdef DEBUG</div><div class=\"line\">manager.securityPolicy.allowInvalidCertificates = YES;</div><div class=\"line\">#endif</div></pre></td></tr></table></figure>\n<p>2、信任证书管理机构（CA）颁发的证书。</p>\n<p>CA颁发的证书，据说这类的证书只需50美元就能买到。此类问题出在<code>AFNetworking 2.5.2</code>及之前的版本，是AF的漏洞（<a href=\"http://www.freebuf.com/news/65744.html\" target=\"_blank\" rel=\"external\">详见新闻</a>）。如果某IOS APP使用了此版本的开源通信库，在不安全Wifi网络中的，黑客 只要使用CA颁发的证书就可以对该APP的HTTPS加密数据进行监听或者篡改。</p>\n<p>这个需要升级到 AFNetworking 最新版本，正好最新版本也声明兼容IPv6。</p>\n<p>3、信任合法的证书、服务器和客户端双向认证。</p>\n<p>这两种也都有办法破解，详见：<a href=\"https://www.nccgroup.trust/us/about-us/newsroom-and-events/blog/2015/january/bypassing-openssl-certificate-pinning-in-ios-apps/\" target=\"_blank\" rel=\"external\">Bypassing OpenSSL Certificate Pinning in iOS Apps</a>、<a href=\"http://drops.wooyun.org/tips/7838\" target=\"_blank\" rel=\"external\">http://drops.wooyun.org/tips/7838</a></p>\n<p>要正确的使用HTTPS才不会出现上面的问题。接口也一定要用自己的方式进行加密 才真正的放心，把小命完全放到对方(HTTPS)手里，命运就只能靠别人来摆布。。</p>\n","excerpt":"<p><em>iOS应用的安全性 常常被大家忽视</em></p>\n<p>##<strong>一、iOS 如何做才安全:</strong></p>\n<p><strong>详见《iOS如何做才安全》</strong></p>\n<p>##<strong>二、ipa文件</strong></p>\n<p>1、AppStore里的ipa包 可以通过 iTunes 下载到电脑。iOS8.3以下系统的非越狱的手机上，可以用MAC上的PP助手等软件，直接把手机上的ipa文件(包含沙盒里的存储文件)拷贝到电脑。</p>\n<p>如果是越狱手机，都可以用PP助手、itools直接把ipa导出到电脑，并且可以用PP助手、iExplorer、itools这些工具 查看 iOS的系统目录。</p>\n<p>MAC上安装 iExplorer软件，用iExplorer 可以看到 手机（非越狱也可以） 在 iTunes上备份的内容。</p>\n<p>如果你在帮测试美女的手机 调试问题的时候， 在 iTunes上设置 “连接次iPhone时自动同步”(或者点击 备份到本地电脑),默认该手机上的照片、短信等内容都会备份到你的电脑上，用 iExplorer 就可以看到 这位 美女的隐私。</p>\n<p>曾经有次不小心看到同事的隐私信息，所以现在都比较注意这块，避免引发误会。</p>\n<p>2、拿到ipa文件后，解压缩，得到.app文件，右键显示包内容，可以看到里面的app中的图片、js、plist、静态H5页 等资源。</p>\n<p>比如 你要 用微信里的默认表情包，解压微信的ipa包就可以获取到。</p>\n<p>3、iOS的系统目录和MAC上的都类似（类unix系统）。iOS系统的目录图：</p>\n<p> <img src=\"http://images2015.cnblogs.com/blog/859442/201606/859442-20160603113527508-253137717.png\" alt=\"img\"></p>","more":"<p>##<strong>三、沙盒 中的数据</strong></p>\n<p>iPhone上 计算器的沙盒：</p>\n<p><img src=\"http://images2015.cnblogs.com/blog/859442/201606/859442-20160602201509805-146936001.png\" alt=\"img\"></p>\n<p>.app文件:应用程序本身的数据，打包时候的一些资源文件（如：图片、plist等文件）、可执行文件。这个目录不会被iTunes同步。</p>\n<p>Documents ：存储不可再生 的关键数据。不会被iTunes同步</p>\n<p>Library：保存配置文件和其他一些文件。NSUserDefault 会存储到 Library下的Preferences中 的 plist文件中。可以直接打开，所以 也不要在 NSUserDefault 中存一些 关键数据，或者 存储的时候 进行 AES等方式的加密。</p>\n<p>Library/Caches可以用来保存可再生的数据，比如网络请求，用户需要负责删除对应文件。 </p>\n<p>这个目录（除了Library/Caches外）会被iTunes同步</p>\n<p>tmp：临时文件。不需要的时候，手动将其内文件删除。（当应用不再运行的时候，系统可能会将此目录清空。） </p>\n<p>tmp：临时文件。不需要的时候，手动将其内文件删除。（当应用不再运行的时候，系统可能会将此目录清空。）<br>这个目录不会被iTunes同步</p>\n<p>存到沙盒的数据都是不安全的，关键数据一定 要做加密存储。</p>\n<p>##<strong>四、Reveal 工具：查看 任何APP 的UI结构</strong></p>\n<p>1、不越狱的手机 可以用 Reveal 来查看自己APP的UI结构。不能查看其他APP的UI结构。这里就不再描述了。</p>\n<p> 2、越狱手机 上可以查看 任何APP的UI结构。</p>\n<p>在越狱的手机上，在 Cydia 搜索并安装 Reveal Loader，如果搜索不到。就 点下面的“软件源”，选择“BigBoss”,选择“全部软件包”，点右边R的字母，去一个个找到 Reveal Loader，放心吧，你一定能找到的，我用的iOS7.1的系统测试的，没问题。</p>\n<p>安装完成后，打开“设置”页面，下拉到最底部，点击“Reveal”</p>\n<p><img src=\"http://images2015.cnblogs.com/blog/859442/201606/859442-20160602192309977-1694804093.png\" alt=\"img\"></p>\n<p>3、点击 Enabled Applictions 。然后选中 你想分析的APP。</p>\n<p>4、确保iOS和OSX在同一个IP网段内。打开想分析的 APP，如果该APP已经启动，则关闭后再次启动</p>\n<p>5、打开MAC上的 Reveal，选中 左上方列表里的 APP，<strong>比如QQ：</strong></p>\n<p><img src=\"http://images2015.cnblogs.com/blog/859442/201606/859442-20160602193213742-452768022.png\" alt=\"img\"></p>\n<p>6、如果 Reveal 左上方 一直显示：No Connection。说明iPhone上的 Reveal Loader 没安装成功，需要配置一下。</p>\n<p>首先从MAC上 用PP助手或 iTools 查看“文件系统（系统）”–》Library文件夹，看 Library文件夹下面有没有 RHRevealLoader 文件夹，如果没有，就 右键 新建文件夹，并修改名字为：RHRevealLoader。</p>\n<p>在Mac 下打开已经安装的Reveal，选择标题栏<strong>Help</strong>下的<strong>Show Reveal Library in Finder  下的 iOS library  </strong>选项，将会显示如下界面：</p>\n<p><img src=\"http://images2015.cnblogs.com/blog/859442/201606/859442-20160602194122961-7619153.png\" alt=\"img\"></p>\n<p>将<strong>libReveal.dylib </strong>文件通过<strong>PP助手</strong>拷贝到刚才创建的<code>RHRevealLoader</code>文件夹下，就可以了。</p>\n<p>然后 从手机上打开APP， 再 打开 MAC上的 Reveal 软件，左上方 就会出来 相关APP的选项。</p>\n<p>再发个 <strong>淘宝中的天猫模块</strong>吧：</p>\n<p><img src=\"http://images2015.cnblogs.com/blog/859442/201606/859442-20160602195031367-1190080065.png\" alt=\"img\"> </p>\n<p>##<strong>五、反编译工具：IDA</strong></p>\n<p>从AppStore下载的ipa都是加壳的(苹果 把开发者上传的ipa进行了加壳再放到AppStore中)，加壳的ipa要先去壳，可以用clutch、dumpdecrypted、使用gdb调试 等解密去壳工具，这个我们后面再说。</p>\n<p>如果你有越狱手机，可以直接 从 PP助手上下载ipa包，这个就是 脱壳后的。。</p>\n<p>现在 我们先反编译 自己的APP，通过Xcode打包的APP 都是没加壳的，可以直接用来反编译。</p>\n<p>新建一个项目，在 ViewController 的 viewDidLoad 方法里 加 几句代码。</p>\n<p><a href=\"javascript:void(0\"><img src=\"http://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a>;)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)viewDidLoad &#123;</div><div class=\"line\">    [super viewDidLoad];</div><div class=\"line\">    </div><div class=\"line\">    UILabel *label = [[UILabel alloc] initWithFrame:CGRectMake(50, 70, 200, 100)];</div><div class=\"line\">    label.text = @&quot;CeShiLabel007&quot;;</div><div class=\"line\">    label.backgroundColor = [UIColor redColor];</div><div class=\"line\">    [self.view addSubview:label];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><a href=\"javascript:void(0\"><img src=\"http://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a>;)</p>\n<p>将项目 打包，生成 ipa文件，下面我们就用IDA分析一下 ipa。</p>\n<p>将ipa文件 解压后 得到.app文件：</p>\n<p><img src=\"http://images2015.cnblogs.com/blog/859442/201606/859442-20160602200635492-1438112164.png\" alt=\"img\"></p>\n<p>下载IDA，并打开：</p>\n<p><img src=\"http://images2015.cnblogs.com/blog/859442/201606/859442-20160602200012914-225461018.png\" alt=\"img\"></p>\n<p>点击“New”按钮，选择刚才 解压的 .app文件。一路 点击“OK”或者“YES” 就可以了。</p>\n<p>打开界面后，双击左侧的 viewDidLoad：</p>\n<p><img src=\"http://images2015.cnblogs.com/blog/859442/201606/859442-20160602201058242-1824337591.png\" alt=\"img\"></p>\n<p>可以看出：代码中的  “CeShiLabel007” 字符串 完全可以反编译出来。所以尽量不要在代码里放一些 关键 的数据。可以通过接口来获取。或者 把 数据进行加密。</p>\n<p>从上面的界面中 ，按下键盘的F5，可以 把汇编转成C语言代码。可读性很高。。</p>\n<p>你如果试了 就发现你的F5不管用啊，那是因为 F5是一个插件Hex-Rays.Decompiler 的快捷键，这个插件是收费的、收费的。</p>\n<p>##<strong>六、反编译工具：Hopper Disassembler</strong></p>\n<p>下载 Hopper Disassembler软件。打开ipa解压的.app。 或者直接 把.app拖进去。</p>\n<p>双击“viewDidLoad”： 可以看到 汇编代码， “CeShiLabel007” 字符串、setText方法 等。</p>\n<p><img src=\"http://images2015.cnblogs.com/blog/859442/201606/859442-20160602204404555-1739403755.png\" alt=\"img\"></p>\n<p>点击右上角的 if(a) f(x)图标：</p>\n<p><img src=\"http://images2015.cnblogs.com/blog/859442/201606/859442-20160602204528664-464088547.png\" alt=\"img\"></p>\n<p>会弹出 类似源代码的 伪编码：</p>\n<p><img src=\"http://images2015.cnblogs.com/blog/859442/201606/859442-20160602204639992-255404740.png\" alt=\"img\"></p>\n<p>代码中可以清楚的看到 处理的逻辑。简单易懂，和看源代码没太大区别。。</p>\n<p>下面 是我从越狱手机的PP助手上下载的 微信 的ipa  进行反编译,看下里面的 QQContactInfoViewController 页面 的 viewDidLoad方法里的代码 怎么写的，</p>\n<p>截图：</p>\n<p><img src=\"http://images2015.cnblogs.com/blog/859442/201606/859442-20160603132557742-293853908.png\" alt=\"img\"></p>\n<p>如果 你把从 AppStore下载的 ipa包直接拖到 IDA或Hopper里，看到的就是乱码，刚才已经说过了。AppStore的ipa是加过壳的 。如图：</p>\n<p> <img src=\"http://images2015.cnblogs.com/blog/859442/201606/859442-20160603131037805-1919649565.png\" alt=\"img\"></p>\n<p>##<strong>七、抓包-https</strong></p>\n<p>Charles 老版本和 新版本 抓取https 的配置 不一样。。</p>\n<p>先看HTTP抓包：</p>\n<ol>\n<li>打开Charles程序</li>\n<li>查看Mac电脑的IP地址，如192.168.1.7</li>\n<li>打开iOS设置，进入当前wifi连接，设置HTTP代理Group，将服务器填为上一步中获得的IP，即192.168.1.7，端口填8888</li>\n<li>iOS设备打开你要抓包的app进行网络操作</li>\n<li>Charles弹出确认框，点击Allow按钮即可</li>\n</ol>\n<p>HTTPS 老版本抓包：</p>\n<ol>\n<li>下载Charles证书<a href=\"http://www.charlesproxy.com/ssl.zip，解压后导入到iOS设备中（将crt文件作为邮件附件发给自己，再在iOS设备中点击附件即可安装；也可上传至dropbox之类的网盘，通过safari下载安装）\">http://www.charlesproxy.com/ssl.zip，解压后导入到iOS设备中（将crt文件作为邮件附件发给自己，再在iOS设备中点击附件即可安装；也可上传至dropbox之类的网盘，通过safari下载安装）</a></li>\n<li>在Charles的工具栏上点击设置按钮，选择Proxy Settings…</li>\n<li>切换到SSL选项卡，选中Enable SSL Proxying</li>\n<li>这一步跟Fiddler不同，Fiddler安装证书后就可以抓HTTPS网址的包了，Charles 还 需要在上一步的SSL选项卡的Locations表单填写要抓包的域名和端口，点击Add按钮，在弹出的表单中Host填写域名，比如填api.instagram.com，Port填443</li>\n</ol>\n<p>HTTPS 新版本抓包：</p>\n<p>　　Charles新版本 的 Proxy Settings 选项里是没有 SSL选项卡的。在左侧的域名上点右键：Enable SSL Proxying，就可以用了。</p>\n<p><img src=\"http://images2015.cnblogs.com/blog/859442/201606/859442-20160603130151602-184733403.png\" alt=\"img\"></p>\n<p>然后 点击APP，会看到HTTPS解密的json数据。如果接口返回的数据 本身进行了加密，那你看到的还是乱码。</p>\n<p>##<strong>七、https - iOS 的代码如何写</strong></p>\n<p>2015年4月末，网爆流行IOS网络通信库<code>AFNetworking SSL</code>漏洞，影响银联、中国银行、交通银行在内的2.5万个IOS应用，我来看下 各种网络写法对应的问题。</p>\n<p>1、信任任何证书。在 AFNetworking 中 定义 allowInvalidCertificates 为true，表示 忽略所有证书。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">AFHTTPRequestOperationManager * manager = [AFHTTPRequestOperationManager manager];</div><div class=\"line\"></div><div class=\"line\">manager.securityPolicy.allowInvalidCertificates = YES;</div></pre></td></tr></table></figure>\n<p>这种情况下 用我们上面讲的方法，用Charles很容易 破解HTTPS加密的数据。</p>\n<p>这种情况，一般是 因为 测试环境 用的不是 CA发的证书，需要忽略掉证书，所以把 allowInvalidCertificates 设为了 true。这个可以用 #ifdef DEBUG 来进行设置。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">#ifdef DEBUG</div><div class=\"line\">manager.securityPolicy.allowInvalidCertificates = YES;</div><div class=\"line\">#endif</div></pre></td></tr></table></figure>\n<p>2、信任证书管理机构（CA）颁发的证书。</p>\n<p>CA颁发的证书，据说这类的证书只需50美元就能买到。此类问题出在<code>AFNetworking 2.5.2</code>及之前的版本，是AF的漏洞（<a href=\"http://www.freebuf.com/news/65744.html\">详见新闻</a>）。如果某IOS APP使用了此版本的开源通信库，在不安全Wifi网络中的，黑客 只要使用CA颁发的证书就可以对该APP的HTTPS加密数据进行监听或者篡改。</p>\n<p>这个需要升级到 AFNetworking 最新版本，正好最新版本也声明兼容IPv6。</p>\n<p>3、信任合法的证书、服务器和客户端双向认证。</p>\n<p>这两种也都有办法破解，详见：<a href=\"https://www.nccgroup.trust/us/about-us/newsroom-and-events/blog/2015/january/bypassing-openssl-certificate-pinning-in-ios-apps/\">Bypassing OpenSSL Certificate Pinning in iOS Apps</a>、<a href=\"http://drops.wooyun.org/tips/7838\">http://drops.wooyun.org/tips/7838</a></p>\n<p>要正确的使用HTTPS才不会出现上面的问题。接口也一定要用自己的方式进行加密 才真正的放心，把小命完全放到对方(HTTPS)手里，命运就只能靠别人来摆布。。</p>"}],"PostAsset":[],"PostCategory":[{"post_id":"cj04pzyyi001fs04esmyy9462","category_id":"cj04pzyyr001ks04euxp667zs","_id":"cj04pzyz4001ss04ecmcqugjz"}],"PostTag":[{"post_id":"cj04pzywi0004s04e0rj9filv","tag_id":"cj04pzywo0006s04eaqyk9vc5","_id":"cj04pzyx1000bs04e4xg36cv8"},{"post_id":"cj04pzywk0005s04eb4z3vv29","tag_id":"cj04pzywz000as04eobn2jvvr","_id":"cj04pzyxc000gs04ea6hi5m3t"},{"post_id":"cj04pzyww0008s04el9yrqmlh","tag_id":"cj04pzywz000as04eobn2jvvr","_id":"cj04pzyxj000ks04e0y8yuebt"},{"post_id":"cj04pzyxd000hs04erzghhl0w","tag_id":"cj04pzywz000as04eobn2jvvr","_id":"cj04pzyxo000ms04e4qygdogi"},{"post_id":"cj04pzyxs000os04eaybphg0r","tag_id":"cj04pzywz000as04eobn2jvvr","_id":"cj04pzyxu000qs04e3pd3haw5"},{"post_id":"cj04pzywx0009s04equ9rylrf","tag_id":"cj04pzyxf000is04ef650gxg7","_id":"cj04pzyy0000ws04ebtchk4rs"},{"post_id":"cj04pzywx0009s04equ9rylrf","tag_id":"cj04pzyxr000ns04eg8slk4s6","_id":"cj04pzyy1000ys04e5549humn"},{"post_id":"cj04pzywx0009s04equ9rylrf","tag_id":"cj04pzyxv000rs04e0ac8x6s8","_id":"cj04pzyy30011s04e0c3jqrh5"},{"post_id":"cj04pzyx2000cs04e7tbltrsi","tag_id":"cj04pzyy0000vs04ei5elcbd2","_id":"cj04pzyy40013s04eh5iiq90u"},{"post_id":"cj04pzyy2000zs04e0d51detr","tag_id":"cj04pzywz000as04eobn2jvvr","_id":"cj04pzyy70016s04esfv8410k"},{"post_id":"cj04pzyx5000ds04ecljvcam6","tag_id":"cj04pzyy0000vs04ei5elcbd2","_id":"cj04pzyy80018s04egkgps3vy"},{"post_id":"cj04pzyy90019s04egf8a9h2t","tag_id":"cj04pzyxv000rs04e0ac8x6s8","_id":"cj04pzyyf001cs04e0fo9hcj6"},{"post_id":"cj04pzyxb000fs04ele7izsw7","tag_id":"cj04pzyxv000rs04e0ac8x6s8","_id":"cj04pzyyl001gs04esyxq5p1u"},{"post_id":"cj04pzyxb000fs04ele7izsw7","tag_id":"cj04pzyy0000vs04ei5elcbd2","_id":"cj04pzyyp001is04egckt977b"},{"post_id":"cj04pzyxk000ls04ej3ini6v8","tag_id":"cj04pzyyg001es04eckcywu9n","_id":"cj04pzyyz001ms04erlrxqfnx"},{"post_id":"cj04pzyym001hs04ehleuzl6m","tag_id":"cj04pzyxv000rs04e0ac8x6s8","_id":"cj04pzyz1001os04ethdt7ba5"},{"post_id":"cj04pzyxt000ps04eyvs0s890","tag_id":"cj04pzyyq001js04egw8iized","_id":"cj04pzyz3001qs04eydm6yyrx"},{"post_id":"cj04pzyz0001ns04evct1fij4","tag_id":"cj04pzywz000as04eobn2jvvr","_id":"cj04pzyz4001rs04ejf1j66sf"},{"post_id":"cj04pzyz0001ns04evct1fij4","tag_id":"cj04pzyxv000rs04e0ac8x6s8","_id":"cj04pzyz5001us04e1mo894c6"},{"post_id":"cj04pzyxw000ts04efhvejw46","tag_id":"cj04pzyz2001ps04e2bhyifkk","_id":"cj04pzyz5001ws04extbefib6"},{"post_id":"cj04pzyxw000ts04efhvejw46","tag_id":"cj04pzyz4001ts04eqqm54bep","_id":"cj04pzyz5001xs04e8o1crwhu"},{"post_id":"cj04pzyxx000us04e6c0yfcc1","tag_id":"cj04pzyz5001vs04emegjtpey","_id":"cj04pzyz6001zs04eob4ulsfa"},{"post_id":"cj04pzyy0000xs04eq47m7e7c","tag_id":"cj04pzyz6001ys04ehl144uwb","_id":"cj04pzyz70021s04esnuzx5kf"},{"post_id":"cj04pzyy70017s04ely8kbg6a","tag_id":"cj04pzyz2001ps04e2bhyifkk","_id":"cj04pzyzb0023s04e1usoe5op"},{"post_id":"cj04pzyyd001bs04e2vezxkz2","tag_id":"cj04pzyz80022s04ew6r1w0ed","_id":"cj04pzyzc0025s04etahhi1qc"},{"post_id":"cj04pzyyf001ds04euho7mpva","tag_id":"cj04pzyzb0024s04e6aq5g57v","_id":"cj04pzyzg0027s04eyxzdr94c"},{"post_id":"cj04pzyyi001fs04esmyy9462","tag_id":"cj04pzyzc0026s04eboopjys4","_id":"cj04pzyzg0028s04edjr1jmda"}],"Tag":[{"name":"git","_id":"cj04pzywo0006s04eaqyk9vc5"},{"name":"iOS","_id":"cj04pzywz000as04eobn2jvvr"},{"name":"前端","_id":"cj04pzyxf000is04ef650gxg7"},{"name":"React-Native","_id":"cj04pzyxr000ns04eg8slk4s6"},{"name":"转载","_id":"cj04pzyxv000rs04e0ac8x6s8"},{"name":"swift","_id":"cj04pzyy0000vs04ei5elcbd2"},{"name":"Apple.Inc","_id":"cj04pzyyg001es04eckcywu9n"},{"name":"职业规划","_id":"cj04pzyyq001js04egw8iized"},{"name":"学习笔记","_id":"cj04pzyz2001ps04e2bhyifkk"},{"name":"人脸识别","_id":"cj04pzyz4001ts04eqqm54bep"},{"name":"GPS","_id":"cj04pzyz5001vs04emegjtpey"},{"name":"bug归档","_id":"cj04pzyz6001ys04ehl144uwb"},{"name":"互联网","_id":"cj04pzyz80022s04ew6r1w0ed"},{"name":" - 转载","_id":"cj04pzyzb0024s04e6aq5g57v"},{"name":"生活","_id":"cj04pzyzc0026s04eboopjys4"}]}}